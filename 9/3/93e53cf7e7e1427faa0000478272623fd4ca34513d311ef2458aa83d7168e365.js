7 28.798 1.29427C30.3095 1.29427 31.7873 1.74342 33.0455 2.58521C34.3037 3.42701 35.286 4.62386 35.869 6.02523C36.2387 5.8994 36.6268 5.83678 37.0171 5.83997H37.1764C36.5402 4.12214 35.3964 2.64091 33.8984 1.595C32.4004 0.549084 30.62 -0.0114746 28.7959 -0.0114746C26.9718 -0.0114746 25.1913 0.549084 23.6934 1.595C22.1954 2.64091 21.0516 4.12214 20.4154 5.83997H20.5746C20.9663 5.8378 21.3556 5.90039 21.7269 6.02523Z" fill="#68CB2B" data-v-35d238ac=""></path> <path d="M4.56332 6.68199H4.358C4.20381 6.45139 4.00414 6.25506 3.77137 6.10515C3.41205 5.9018 3.001 5.80953 2.58972 5.83989C2.13618 5.83848 1.69055 5.95915 1.29913 6.18936C0.899923 6.42022 0.574366 6.7605 0.360514 7.17041C0.108691 7.64069 -0.0155881 8.16925 0.000153877 8.70305V8.8841C-0.0157725 9.42144 0.106927 9.95377 0.356324 10.4294C0.576186 10.8363 0.902096 11.1754 1.29913 11.4104C1.69424 11.6287 2.13888 11.7404 2.58972 11.7346C2.88668 11.7431 3.18288 11.7003 3.46548 11.6083C3.66453 11.5439 3.85045 11.444 4.0144 11.3136C4.13651 11.2005 4.24482 11.0733 4.33705 10.9346H4.54237V12.4209C4.54237 12.6525 4.43342 12.7662 4.21972 12.7662H0.917816V14.0294H4.72674C4.89608 14.0373 5.06521 14.0096 5.22325 13.948C5.38129 13.8863 5.52475 13.7921 5.6444 13.6715C5.76123 13.5477 5.85191 13.4015 5.91097 13.2415C5.97002 13.0816 5.99622 12.9113 5.988 12.7409V6.0041H4.56332V6.68199ZM4.56332 8.83778C4.57831 9.05993 4.5465 9.28275 4.46996 9.49171C4.39343 9.70066 4.27389 9.89104 4.11916 10.0504C3.81698 10.3323 3.41667 10.4835 3.00455 10.4715C2.59357 10.4842 2.1943 10.3328 1.89414 10.0504C1.73964 9.89332 1.61984 9.70524 1.54259 9.49847C1.46533 9.29169 1.43234 9.07087 1.44579 8.85041V8.73673C1.42888 8.51405 1.4602 8.29034 1.5376 8.081C1.61501 7.87166 1.73664 7.68166 1.89414 7.5241C2.1943 7.24171 2.59357 7.09031 3.00455 7.10305C3.20884 7.09549 3.41258 7.12882 3.60393 7.2011C3.79528 7.27339 3.97042 7.38318 4.11916 7.5241C4.27356 7.68109 4.39301 7.86925 4.46959 8.07613C4.54616 8.28301 4.57811 8.50388 4.56332 8.7241V8.83778Z" fill="#152738" data-v-35d238ac=""></path> <path d="M13.4522 6.22364C13.0107 5.96337 12.5057 5.83213 11.994 5.8447C11.4734 5.83372 10.9591 5.96002 10.5022 6.21101C10.078 6.44939 9.73155 6.80625 9.50496 7.23838C9.25853 7.71961 9.13607 8.25523 9.14879 8.79628V8.93101C9.13715 9.47599 9.25949 10.0154 9.50496 10.5015C9.74266 10.93 10.0936 11.2841 10.519 11.5247C10.9821 11.7704 11.4998 11.8936 12.0233 11.8826C12.4631 11.8983 12.9009 11.8164 13.3055 11.6426C13.6106 11.4973 13.8841 11.2926 14.11 11.0405C14.2913 10.8406 14.4488 10.6202 14.5793 10.3836L13.3977 9.76049C13.3001 9.98399 13.1574 10.1847 12.9787 10.35C12.7247 10.5476 12.4062 10.6423 12.0861 10.6152C11.7148 10.6255 11.3537 10.4929 11.0763 10.2447C10.9427 10.1246 10.8361 9.97721 10.7639 9.81236C10.6916 9.64751 10.6553 9.46903 10.6573 9.28891H14.7972V8.78786C14.81 8.255 14.692 7.72718 14.4536 7.25101C14.2245 6.8193 13.877 6.46272 13.4522 6.22364ZM10.6321 8.2068C10.6698 7.89883 10.8189 7.61556 11.0512 7.41101C11.3144 7.19664 11.6471 7.08721 11.9856 7.10364C12.3135 7.08899 12.6354 7.19532 12.8907 7.40259C13.0104 7.49991 13.1092 7.6206 13.1813 7.75738C13.2533 7.89415 13.297 8.04417 13.3097 8.19838L10.6321 8.2068Z" fill="#152738" data-v-35d238ac=""></path> <path d="M23.181 7.19197C22.9283 6.76146 22.5573 6.41347 22.1125 6.18986C21.9877 6.12654 21.859 6.07168 21.727 6.02565C21.3556 5.90081 20.9663 5.83821 20.5746 5.84039H20.4028C19.9329 5.85367 19.4712 5.96855 19.0494 6.17723C18.6046 6.40084 18.2335 6.74883 17.9809 7.17933C17.7092 7.66996 17.5786 8.22685 17.6038 8.78776V8.97302C17.5879 9.5252 17.7226 10.0712 17.9935 10.552C18.2461 10.9825 18.6172 11.3305 19.062 11.5541C19.4544 11.7491 19.882 11.8622 20.319 11.8867C20.4112 11.8867 20.4992 11.8867 20.5914 11.8867C20.9462 11.8891 21.2993 11.838 21.639 11.7351C21.8011 11.6833 21.9593 11.62 22.1125 11.5456C22.5573 11.322 22.9283 10.974 23.181 10.5435C23.4518 10.0628 23.5866 9.51678 23.5707 8.9646V8.78776C23.5897 8.2299 23.4548 7.67762 23.181 7.19197ZM22.125 8.92249C22.1414 9.14717 22.1128 9.37286 22.0408 9.58621C21.9688 9.79957 21.855 9.99624 21.706 10.1646C21.5835 10.2822 21.4418 10.3776 21.287 10.4467C21.0727 10.5452 20.8396 10.5955 20.604 10.5941C20.3886 10.5943 20.1752 10.5529 19.9754 10.472C19.7919 10.4003 19.625 10.2913 19.4852 10.152C19.3362 9.98361 19.2224 9.78693 19.1504 9.57358C19.0784 9.36023 19.0498 9.13454 19.0662 8.90986V8.78776C19.0495 8.56434 19.078 8.33985 19.15 8.12782C19.222 7.91579 19.3361 7.72062 19.4852 7.55407C19.6356 7.40358 19.8173 7.28853 20.0173 7.21723C20.1969 7.15711 20.3854 7.12862 20.5746 7.13302C20.8312 7.13008 21.0845 7.19082 21.3121 7.30986C21.4464 7.37739 21.5693 7.46546 21.6767 7.57091C21.8258 7.73746 21.9398 7.93264 22.0118 8.14467C22.0838 8.3567 22.1124 8.58119 22.0957 8.8046L22.125 8.92249Z" fill="#152738" data-v-35d238ac=""></path> <path d="M28.017 10.3415L31.1346 7.73517V6.00464H26.5462V7.20464H29.5548V7.3899L26.4331 9.99201V11.7225H31.2267V10.5267H28.017V10.3415Z" fill="#152738" data-v-35d238ac=""></path> <path d="M39.6085 7.19172C39.3562 6.76242 38.9869 6.41468 38.5442 6.18962C38.119 5.97802 37.6526 5.86302 37.1782 5.85278H37.0189C36.6286 5.84959 36.2405 5.91221 35.8708 6.03804C35.7416 6.08266 35.6156 6.13612 35.4937 6.19804C35.0489 6.42165 34.6778 6.76964 34.4252 7.20015C34.1529 7.68334 34.0181 8.23249 34.0355 8.78751V8.97278C34.0196 9.52496 34.1544 10.071 34.4252 10.5517C34.6778 10.9822 35.0489 11.3302 35.4937 11.5538C35.6433 11.6286 35.7989 11.6905 35.9588 11.7391C36.3018 11.8473 36.6595 11.9013 37.0189 11.8991C37.1069 11.8991 37.1949 11.8991 37.2787 11.8991C37.7159 11.8749 38.1435 11.7618 38.5358 11.5665C38.9785 11.3414 39.3479 10.9937 39.6001 10.5644C39.871 10.0836 40.0057 9.53759 39.9898 8.98541V8.78751C40.0114 8.23045 39.8794 7.67823 39.6085 7.19172ZM38.5568 8.92225C38.5731 9.14693 38.5445 9.37262 38.4725 9.58597C38.4005 9.79932 38.2867 9.996 38.1377 10.1644C37.996 10.3053 37.826 10.4144 37.6391 10.4844C37.4464 10.5578 37.2418 10.5949 37.0357 10.5938C36.7956 10.5954 36.558 10.5436 36.3401 10.4422C36.1846 10.3763 36.0426 10.2821 35.9211 10.1644C35.7721 9.996 35.6583 9.79932 35.5863 9.58597C35.5144 9.37262 35.4857 9.14693 35.5021 8.92225V8.78751C35.4854 8.5641 35.5139 8.33961 35.5859 8.12758C35.658 7.91555 35.772 7.72038 35.9211 7.55383C36.2204 7.27545 36.6154 7.12452 37.0231 7.13278C37.2145 7.13133 37.4047 7.16412 37.5846 7.22962C37.7879 7.30129 37.9726 7.41783 38.1252 7.57067C38.2743 7.73722 38.3883 7.93239 38.4603 8.14442C38.5323 8.35645 38.5609 8.58094 38.5442 8.80436L38.5568 8.92225Z" fill="#152738" data-v-35d238ac=""></path></g> <defs data-v-35d238ac=""><clipPath id="clip0_2_1455" data-v-35d238ac=""><rect width="40" height="18" fill="white" data-v-35d238ac=""></rect></clipPath></defs></svg></a></div> <style data-v-35d238ac="">.block-he1hnd3ccusgz-info[data-v-35d238ac] {
        display: inline-flex !important;
        width: 56px !important;
        padding: 4px 6px !important;
        margin: 4px !important;
        align-items: center !important;
        box-sizing: border-box !important;
        background: transparent !important;
        transition: width 0.4s !important;
        line-height: 1 !important;
        font-size: 100% !important;
      }

      .block-he1hnd3ccusgz-info[data-v-35d238ac]:hover {
        width: 109px !important;
      }

      .block-he1hnd3ccusgz-info[data-v-35d238ac] a {
        border: none !important;
        margin: 0 !important;
        padding: 0 !important;
      }

      @media (max-width: 780px) { .block-he1hnd3ccusgz-info[data-v-35d238ac] {
          width: 109px !important;
        } }
</style></div></div> <div class="block-he1hnd3ccusgz-block" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-block__items" data-v-14c8c9d5="" data-v-1202af33=""><a data-v-1202af33="" data-id="5028f2cb-2eb8-21d1-d99d-3c791333063a" target="_blank" href="https://cdn.geozo.com/v4/click?media=96398&amp;c=fzIMa0IzK__XJJ17Fmj3ZhINrBeQGEAyYaxUoaU8yg9XS4QfagaJgePYO9oT3wADo-5keO4t8oi4PBndgafAwNPJfEP9jjGGapVYLyL6r80f3lFoqg1KhCjero4oylkI0K-wWS7hgQVrcBwVFq-Y0Gen9iq5AGOSdsuZ9zlJ7D5WYblu5Tii_U3abQfeq4w1yM4HIPYE7r7xG_uo5zG6mFE25BiWRXGXZ26divhxOB_vlzEBh814654ODkK1AyVxFentK-_9897NEDCSfPplK09-MRuEJyGuFcomUi1U9F8zLSyVXCWk4kW2lPw8OzF0M_o1w-ioM3sVSW_EG7IoTWgqAJSTmB9_4lzQv-I7C8HfNwrfBgFJYvO_Y2KrixhDUlDUJ6PCbKl6cJ9FGGzIg_hK658-hlvbsNRslckm6Gqs8_9GQmX93TnzQEx4gy6mnoflysbp9f8WyaY5nom22IIGiuRYPLk4oQdCaCqkguqEaqAcFyyiYnuPvU0QT9GCUY5Hkg2d1YqlvKwEv8pbMQwIY5wq0v4ehglT9EgltANs8hC-ibUC" rel="sponsored noindex nofollow" class="block-he1hnd3ccusgz-media block-he1hnd3ccusgz-block__item" data-v-14c8c9d5=""><div class="block-he1hnd3ccusgz-media__container" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-inner" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img" style="background-image:url(&#39;https://media.geozo.com/.cdn/5531a5/fad6f4/88100294083647a780d4031d81c493b3/d0364ecc5b10b9ed.webp&#39;) !important;" data-v-14c8c9d5="" data-v-1202af33=""></div></div></div> <div class="block-he1hnd3ccusgz-media__title" data-v-14c8c9d5="" data-v-1202af33="">
            Tristes noticias hoy sobre Julio Iglesias
          </div> <div class="block-he1hnd3ccusgz-media__btn-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><button class="block-he1hnd3ccusgz-media__btn" data-v-14c8c9d5="" data-v-1202af33="">
              More details
            </button></div></div></a><a data-v-1202af33="" data-id="5028f2cb-2eb8-21d1-d99d-3c791333063a" target="_blank" href="https://cdn.geozo.com/v4/click?media=96398&amp;c=fzIMa0IzK__XJJ17Fmj3ZhINrBeQGEAyYaxUoaU8yg9XS4QfagaJgePYO9oT3wADo-5keO4t8oi4PBndgafAwNPJfEP9jjGGapVYLyL6r80f3lFoqg1KhCjero4oylkI0K-wWS7hgQVrcBwVFq-Y0Gen9iq5AGOSdsuZ9zlJ7D5WYblu5Tii_U3abQfeq4w1yM4HIPYE7r7xG_uo5zG6mFE25BiWRXGXZ26divhxOB_vlzEBh814654ODkK1AyVxFentK-_9897NEDCSfPplK09-MRuEJyGuFcomUi1U9F8zLSyVXCWk4kW2lPw8OzF0M_o1w-ioM3sVSW_EG7IoTWgqAJSTmB9_4lzQv-I7C8HfNwrfBgFJYvO_Y2KrixhDUlDUJ6PCbKl6cJ9FGGzIg_hK658-hlvbsNRslckm6Gqs8_9GQmX93TnzQEx4gy6mnoflysbp9f8WyaY5nom22IIGiuRYPLk4oQdCaCqkguqEaqAcFyyiYnuPvU0QT9GCUY5Hkg2d1YqlvKwEv8pbMQwIY5wq0v4ehglT9EgltANs8hC-ibUC" rel="sponsored noindex nofollow" class="block-he1hnd3ccusgz-media block-he1hnd3ccusgz-block__item" data-v-14c8c9d5=""><div class="block-he1hnd3ccusgz-media__container" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-inner" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img" style="background-image:url(&#39;https://media.geozo.com/.cdn/5531a5/fad6f4/88100294083647a780d4031d81c493b3/d0364ecc5b10b9ed.webp&#39;) !important;" data-v-14c8c9d5="" data-v-1202af33=""></div></div></div> <div class="block-he1hnd3ccusgz-media__title" data-v-14c8c9d5="" data-v-1202af33="">
            Tristes noticias hoy sobre Julio Iglesias
          </div> <div class="block-he1hnd3ccusgz-media__btn-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><button class="block-he1hnd3ccusgz-media__btn" data-v-14c8c9d5="" data-v-1202af33="">
              More details
            </button></div></div></a><a data-v-1202af33="" data-id="5028f2cb-2eb8-21d1-d99d-3c791333063a" target="_blank" href="https://cdn.geozo.com/v4/click?media=96398&amp;c=fzIMa0IzK__XJJ17Fmj3ZhINrBeQGEAyYaxUoaU8yg9XS4QfagaJgePYO9oT3wADo-5keO4t8oi4PBndgafAwNPJfEP9jjGGapVYLyL6r80f3lFoqg1KhCjero4oylkI0K-wWS7hgQVrcBwVFq-Y0Gen9iq5AGOSdsuZ9zlJ7D5WYblu5Tii_U3abQfeq4w1yM4HIPYE7r7xG_uo5zG6mFE25BiWRXGXZ26divhxOB_vlzEBh814654ODkK1AyVxFentK-_9897NEDCSfPplK09-MRuEJyGuFcomUi1U9F8zLSyVXCWk4kW2lPw8OzF0M_o1w-ioM3sVSW_EG7IoTWgqAJSTmB9_4lzQv-I7C8HfNwrfBgFJYvO_Y2KrixhDUlDUJ6PCbKl6cJ9FGGzIg_hK658-hlvbsNRslckm6Gqs8_9GQmX93TnzQEx4gy6mnoflysbp9f8WyaY5nom22IIGiuRYPLk4oQdCaCqkguqEaqAcFyyiYnuPvU0QT9GCUY5Hkg2d1YqlvKwEv8pbMQwIY5wq0v4ehglT9EgltANs8hC-ibUC" rel="sponsored noindex nofollow" class="block-he1hnd3ccusgz-media block-he1hnd3ccusgz-block__item" data-v-14c8c9d5=""><div class="block-he1hnd3ccusgz-media__container" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-inner" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img" style="background-image:url(&#39;https://media.geozo.com/.cdn/5531a5/fad6f4/88100294083647a780d4031d81c493b3/d0364ecc5b10b9ed.webp&#39;) !important;" data-v-14c8c9d5="" data-v-1202af33=""></div></div></div> <div class="block-he1hnd3ccusgz-media__title" data-v-14c8c9d5="" data-v-1202af33="">
            Tristes noticias hoy sobre Julio Iglesias
          </div> <div class="block-he1hnd3ccusgz-media__btn-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><button class="block-he1hnd3ccusgz-media__btn" data-v-14c8c9d5="" data-v-1202af33="">
              More details
            </button></div></div></a><a data-v-1202af33="" data-id="5028f2cb-2eb8-21d1-d99d-3c791333063a" target="_blank" href="https://cdn.geozo.com/v4/click?media=96398&amp;c=fzIMa0IzK__XJJ17Fmj3ZhINrBeQGEAyYaxUoaU8yg9XS4QfagaJgePYO9oT3wADo-5keO4t8oi4PBndgafAwNPJfEP9jjGGapVYLyL6r80f3lFoqg1KhCjero4oylkI0K-wWS7hgQVrcBwVFq-Y0Gen9iq5AGOSdsuZ9zlJ7D5WYblu5Tii_U3abQfeq4w1yM4HIPYE7r7xG_uo5zG6mFE25BiWRXGXZ26divhxOB_vlzEBh814654ODkK1AyVxFentK-_9897NEDCSfPplK09-MRuEJyGuFcomUi1U9F8zLSyVXCWk4kW2lPw8OzF0M_o1w-ioM3sVSW_EG7IoTWgqAJSTmB9_4lzQv-I7C8HfNwrfBgFJYvO_Y2KrixhDUlDUJ6PCbKl6cJ9FGGzIg_hK658-hlvbsNRslckm6Gqs8_9GQmX93TnzQEx4gy6mnoflysbp9f8WyaY5nom22IIGiuRYPLk4oQdCaCqkguqEaqAcFyyiYnuPvU0QT9GCUY5Hkg2d1YqlvKwEv8pbMQwIY5wq0v4ehglT9EgltANs8hC-ibUC" rel="sponsored noindex nofollow" class="block-he1hnd3ccusgz-media block-he1hnd3ccusgz-block__item" data-v-14c8c9d5=""><div class="block-he1hnd3ccusgz-media__container" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-inner" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img" style="background-image:url(&#39;https://media.geozo.com/.cdn/5531a5/fad6f4/88100294083647a780d4031d81c493b3/d0364ecc5b10b9ed.webp&#39;) !important;" data-v-14c8c9d5="" data-v-1202af33=""></div></div></div> <div class="block-he1hnd3ccusgz-media__title" data-v-14c8c9d5="" data-v-1202af33="">
            Tristes noticias hoy sobre Julio Iglesias
          </div> <div class="block-he1hnd3ccusgz-media__btn-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><button class="block-he1hnd3ccusgz-media__btn" data-v-14c8c9d5="" data-v-1202af33="">
              More details
            </button></div></div></a><a data-v-1202af33="" data-id="5028f2cb-2eb8-21d1-d99d-3c791333063a" target="_blank" href="https://cdn.geozo.com/v4/click?media=96398&amp;c=fzIMa0IzK__XJJ17Fmj3ZhINrBeQGEAyYaxUoaU8yg9XS4QfagaJgePYO9oT3wADo-5keO4t8oi4PBndgafAwNPJfEP9jjGGapVYLyL6r80f3lFoqg1KhCjero4oylkI0K-wWS7hgQVrcBwVFq-Y0Gen9iq5AGOSdsuZ9zlJ7D5WYblu5Tii_U3abQfeq4w1yM4HIPYE7r7xG_uo5zG6mFE25BiWRXGXZ26divhxOB_vlzEBh814654ODkK1AyVxFentK-_9897NEDCSfPplK09-MRuEJyGuFcomUi1U9F8zLSyVXCWk4kW2lPw8OzF0M_o1w-ioM3sVSW_EG7IoTWgqAJSTmB9_4lzQv-I7C8HfNwrfBgFJYvO_Y2KrixhDUlDUJ6PCbKl6cJ9FGGzIg_hK658-hlvbsNRslckm6Gqs8_9GQmX93TnzQEx4gy6mnoflysbp9f8WyaY5nom22IIGiuRYPLk4oQdCaCqkguqEaqAcFyyiYnuPvU0QT9GCUY5Hkg2d1YqlvKwEv8pbMQwIY5wq0v4ehglT9EgltANs8hC-ibUC" rel="sponsored noindex nofollow" class="block-he1hnd3ccusgz-media block-he1hnd3ccusgz-block__item" data-v-14c8c9d5=""><div class="block-he1hnd3ccusgz-media__container" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-inner" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img" style="background-image:url(&#39;https://media.geozo.com/.cdn/5531a5/fad6f4/88100294083647a780d4031d81c493b3/d0364ecc5b10b9ed.webp&#39;) !important;" data-v-14c8c9d5="" data-v-1202af33=""></div></div></div> <div class="block-he1hnd3ccusgz-media__title" data-v-14c8c9d5="" data-v-1202af33="">
            Tristes noticias hoy sobre Julio Iglesias
          </div> <div class="block-he1hnd3ccusgz-media__btn-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><button class="block-he1hnd3ccusgz-media__btn" data-v-14c8c9d5="" data-v-1202af33="">
              More details
            </button></div></div></a><a data-v-1202af33="" data-id="5028f2cb-2eb8-21d1-d99d-3c791333063a" target="_blank" href="https://cdn.geozo.com/v4/click?media=96398&amp;c=fzIMa0IzK__XJJ17Fmj3ZhINrBeQGEAyYaxUoaU8yg9XS4QfagaJgePYO9oT3wADo-5keO4t8oi4PBndgafAwNPJfEP9jjGGapVYLyL6r80f3lFoqg1KhCjero4oylkI0K-wWS7hgQVrcBwVFq-Y0Gen9iq5AGOSdsuZ9zlJ7D5WYblu5Tii_U3abQfeq4w1yM4HIPYE7r7xG_uo5zG6mFE25BiWRXGXZ26divhxOB_vlzEBh814654ODkK1AyVxFentK-_9897NEDCSfPplK09-MRuEJyGuFcomUi1U9F8zLSyVXCWk4kW2lPw8OzF0M_o1w-ioM3sVSW_EG7IoTWgqAJSTmB9_4lzQv-I7C8HfNwrfBgFJYvO_Y2KrixhDUlDUJ6PCbKl6cJ9FGGzIg_hK658-hlvbsNRslckm6Gqs8_9GQmX93TnzQEx4gy6mnoflysbp9f8WyaY5nom22IIGiuRYPLk4oQdCaCqkguqEaqAcFyyiYnuPvU0QT9GCUY5Hkg2d1YqlvKwEv8pbMQwIY5wq0v4ehglT9EgltANs8hC-ibUC" rel="sponsored noindex nofollow" class="block-he1hnd3ccusgz-media block-he1hnd3ccusgz-block__item" data-v-14c8c9d5=""><div class="block-he1hnd3ccusgz-media__container" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img-inner" data-v-14c8c9d5="" data-v-1202af33=""><div class="block-he1hnd3ccusgz-media__img" style="background-image:url(&#39;https://media.geozo.com/.cdn/5531a5/fad6f4/88100294083647a780d4031d81c493b3/d0364ecc5b10b9ed.webp&#39;) !important;" data-v-14c8c9d5="" data-v-1202af33=""></div></div></div> <div class="block-he1hnd3ccusgz-media__title" data-v-14c8c9d5="" data-v-1202af33="">
            Tristes noticias hoy sobre Julio Iglesias
          </div> <div class="block-he1hnd3ccusgz-media__btn-wrapper" data-v-14c8c9d5="" data-v-1202af33=""><button class="block-he1hnd3ccusgz-media__btn" data-v-14c8c9d5="" data-v-1202af33="">
              More details
            </button></div></div></a></div></div></div> <style data-v-14c8c9d5="">.block-he1hnd3ccusgz-block[data-v-1202af33] {all: initial !important;}.block-he1hnd3ccusgz-block *[data-v-1202af33] {all: unset !important;display: block !important;overflow-wrap: break-word !important;word-wrap: break-word !important;-ms-word-break: break-all !important;word-break: break-all !important;word-break: break-word !important;-ms-hyphens: auto !important;-moz-hyphens: auto !important;-webkit-hyphens: auto !important;hyphens: auto !important;}.block-he1hnd3ccusgz-block script:nth-child(n),.block-he1hnd3ccusgz-block style:nth-child(n)[data-v-1202af33] {display: none !important;}.block-he1hnd3ccusgz-block-wrapper[data-v-1202af33] {text-align: center !important;}.block-he1hnd3ccusgz-block[data-v-1202af33] {display: inline-block !important;box-sizing: border-box !important;width: 100% !important;padding: 0px 0px !important;border-style: none !important;border-bottom: none !important;border-top: none !important;border-right: none !important;border-left: none !important;border-width: 7px !important;border-radius: 0px !important;border-color: #000000 !important;transition: background-color 0.3s cubic-bezier(0.215, 0.61, 0.355, 1), border-color 0.3s cubic-bezier(0.215, 0.61, 0.355, 1) !important;}.block-he1hnd3ccusgz-block[data-v-1202af33]:hover {border-color: #000000 !important;}.block-he1hnd3ccusgz-block__items[data-v-1202af33] {display: flex !important;justify-content: center !important;flex-wrap: wrap !important;margin: -3px -3px !important;}.block-he1hnd3ccusgz-block__item[data-v-1202af33] {box-sizing: border-box !important;width: calc(100% / 3 - 3px * 2) !important;max-width: 236.67px !important;min-width: 236.67px !important;margin: 3px 3px !important;}.block-he1hnd3ccusgz-media[data-v-1202af33] {overflow: hidden !important;box-sizing: border-box !important;font-family: Roboto !important;line-height: 1.1 !important;background-color: #ffffff !important;border-style: none !important;border-bottom: none !important;border-top: none !important;border-right: none !important;border-left: none !important;border-width: 10px !important;border-radius: 0px !important;border-color: #000000 !important;box-shadow: none !important;color: inherit !important;-webkit-text-fill-color: inherit !important;text-decoration: none !important;transition: background-color 0.3s cubic-bezier(0.215, 0.61, 0.355, 1), border-color 0.3s cubic-bezier(0.215, 0.61, 0.355, 1), box-shadow 0.3s cubic-bezier(0.215, 0.61, 0.355, 1) !important;}.block-he1hnd3ccusgz-media[data-v-1202af33]:hover {border-color: #000000 !important;cursor: pointer !important;}.block-he1hnd3ccusgz-media:hover .block-he1hnd3ccusgz-media__img-inner[data-v-1202af33] {border-color: #ffff00 !important;}.block-he1hnd3ccusgz-media:hover .block-he1hnd3ccusgz-media__img[data-v-1202af33] {transform: scale(1.05) !important;}.block-he1hnd3ccusgz-media:hover .block-he1hnd3ccusgz-media__title[data-v-1202af33] {color: rgba(1, 1, 1, 0.8) !important;-webkit-text-fill-color: rgba(1, 1, 1, 0.8) !important;}.block-he1hnd3ccusgz-media:hover .block-he1hnd3ccusgz-media__desc[data-v-1202af33] {color: rgba(1, 1, 1, 0.6) !important;-webkit-text-fill-color: rgba(1, 1, 1, 0.6) !important;}.block-he1hnd3ccusgz-media__container[data-v-1202af33] {display: flex !important;flex-direction: column !important;}.block-he1hnd3ccusgz-media__img-wrapper[data-v-1202af33] {padding: 0px !important;overflow: hidden !important;}.block-he1hnd3ccusgz-media__img-inner[data-v-1202af33] {overflow: hidden !important;border-style: none !important;border-bottom: none !important;border-top: none !important;border-right: none !important;border-left: none !important;border-width: 10px !important;border-radius: 0px !important;border-color: #ff0000 !important;transition: border-color 0.3s cubic-bezier(0.215, 0.61, 0.355, 1) !important;}.block-he1hnd3ccusgz-media__img[data-v-1202af33] {padding-bottom: 56.25% !important;background-position: center !important;background-size: cover !important;transition: transform 1.5s cubic-bezier(0.215, 0.61, 0.355, 1) !important;}.block-he1hnd3ccusgz-media__title[data-v-1202af33] {margin: 0 !important;margin-top: 12px !important;margin-bottom: 12px !important;padding-left: 0px !important;padding-right: 0px !important;font-size: 17px !important;font-weight: 700 !important;font-style: normal !important;text-decoration: none !important;color: rgba(1, 1, 1, 0.8) !important;-webkit-text-fill-color: rgba(1, 1, 1, 0.8) !important;text-align: left !important;transition: color 0.5s cubic-bezier(0.215, 0.61, 0.355, 1) !important;}.block-he1hnd3ccusgz-media__desc[data-v-1202af33] {display: block !important;margin: 0 !important;margin-top: 0px !important;margin-bottom: 16px !important;padding-left: 0px !important;padding-right: 0px !important;font-size: 14px !important;font-style: normal !important;text-decoration: none !important;color: rgba(1, 1, 1, 0.6) !important;-webkit-text-fill-color: rgba(1, 1, 1, 0.6) !important;text-align: left !important;transition: color 0.5s cubic-bezier(0.215, 0.61, 0.355, 1) !important;}.block-he1hnd3ccusgz-media__btn-wrapper[data-v-1202af33] {padding-left: 0px !important;padding-right: 0px !important;margin-top: auto !important;text-align: right !important;}.block-he1hnd3ccusgz-media__btn[data-v-1202af33] {display: none !important;margin-top: 20px !important;margin-bottom: 20px !important;padding: 0.5em 1em !important;font-size: 14px !important;font-weight: 700 !important;font-style: normal !important;line-height: 14px !important;color: #FFFFFF !important;-webkit-text-fill-color: #FFFFFF !important;text-decoration: none !important;background-color: #68CB2B !important;border-style: none !important;border-bottom: none !important;border-top: none !important;border-right: none !important;border-left: none !important;border-width: 4px !important;border-radius: 4px !important;border-color: #FFFFFF !important;transition: background-color 0.3s cubic-bezier(0.215, 0.61, 0.355, 1), color 0.3s cubic-bezier(0.215, 0.61, 0.355, 1), border-color 0.3s cubic-bezier(0.215, 0.61, 0.355, 1) !important;}.block-he1hnd3ccusgz-media__btn[data-v-1202af33]:hover {background-color: #4E9820 !important;cursor: pointer !important;}</style> <style id="block-he1hnd3ccusstyle" data-v-14c8c9d5=""></style> <script type="text/javascript" data-v-14c8c9d5="">(function () {var debounce = '';function onResize () {clearTimeout(debounce);debounce = setTimeout(function () {var el = document.getElementById('block-he1hnd3ccus');if (!el) return;var parent = getComputedStyle(el);var itemsContainerWidth = parseInt(parent.width, 10);var canContain = Math.floor((itemsContainerWidth + 6) / 243.67);canContain = Math.min(canContain, 3);canContain = Math.max(canContain, 1);var canContainMobile = Math.min(canContain, 1);document.getElementById('block-he1hnd3ccusstyle').innerHTML = "".concat(".block-he1hnd3ccusgz-media.block-he1hnd3ccusgz-block__item[data-v-1202af33]:nth-child(n+", canContain * 2 +1, ") { display: none !important; }.block-he1hnd3ccusgz-block__item[data-v-1202af33] {width: calc(100% / ", canContain, " - 3px * 2) !important;}.block-he1hnd3ccusgz-block[data-v-1202af33] {max-width: ", canContain * 242.67 +-6, "px !important;}@media (max-width: 650px) {.block-he1hnd3ccusgz-media.block-he1hnd3ccusgz-block__item[data-v-1202af33]:nth-child(n) { display: block !important; }.block-he1hnd3ccusgz-block__item[data-v-1202af33] {width: calc(100% / ", canContainMobile, " - 3px * 2) !important;}.block-he1hnd3ccusgz-block[data-v-1202af33] {max-width: ", canContainMobile * 242.67 +-6, "px !important;} }")}, 200);}onResize();window.addEventListener("resize", onResize);var link = document.querySelector('link[href="https://fonts.googleapis.com/css?family=Roboto:100,200,300,400,500,600,700,800,900"]');if (!link) {var resource = document.createElement('link');resource.setAttribute("rel", "stylesheet");resource.setAttribute("href", "https://fonts.googleapis.com/css?family=Roboto:100,200,300,400,500,600,700,800,900");resource.setAttribute("type", "text/css");var head = document.getElementsByTagName('head')[0];head.appendChild(resource);}undefined}(document, window));</script> <style data-v-14c8c9d5="">.block-he1hnd3ccusgz-block-wrapper[data-v-1202af33] {background: #fff}.block-he1hnd3ccusgz-block[data-v-1202af33]::before {content: "Konten di bawah ini disajikan oleh Geozo Jurnalis Okezone.com tidak terlibat dalam materi konten ini" !important;display: block !important;margin-bottom: 10px !important;color: red !important;font-size: 16px !important;border: 1px solid red !important;padding: 5px 7px !important;text-align: center !important;}</style></div></div> }
  };
  /*
  * This feature allows ad metadata tracks to be manipulated in ad implementations
  * @param player A reference to the player
  * @param cues The set of cues to work with
  * @param processCue A method that uses a cue to make some
  * ad request in the ad implementation
  * @param [cancelAdsHandler] A method that dynamically cancels ads in the ad implementation
  **/


  cueTextTracks.processAdTrack = function (player, cues, processCue, cancelAdsHandler) {
    player.ads.includedCues = {}; // loop over set of cues

    for (var i = 0; i < cues.length; i++) {
      var cue = cues[i];
      var cueData = this.getSupportedAdCue(player, cue); // Exit if this is not a supported cue

      if (!this.isSupportedAdCue(player, cue)) {
        videojs.log.warn('Skipping as this is not a supported ad cue.', cue);
        return;
      } // Continue processing supported cue


      var cueId = this.getCueId(player, cue);
      var startTime = cue.startTime; // Skip ad if cue was already used

      if (cueAlreadySeen(player, cueId)) {
        videojs.log('Skipping ad already seen with ID ' + cueId);
        return;
      } // Optional dynamic ad cancellation


      if (cancelAdsHandler) {
        cancelAdsHandler(player, cueData, cueId, startTime);
      } // Process cue as an ad cue


      processCue(player, cueData, cueId, startTime); // Indicate that this cue has been used

      setCueAlreadySeen(player, cueId);
    }
  };

  function initCancelContentPlay(player, debug) {
    if (debug) {
      videojs.log('Using cancelContentPlay to block content playback');
    } // Listen to play events to "cancel" them afterward


    player.on('play', cancelContentPlay);
  }
  /*
  This feature makes sure the player is paused during ad loading.

  It does this by pausing the player immediately after a "play" where ads will be requested,
  then signalling that we should play after the ad is done.
  */

  function cancelContentPlay() {
    // this function is in the player's context
    if (this.ads._shouldBlockPlay === false) {
      // Only block play if the ad plugin is in a state when content
      // playback should be blocked. This currently means during
      // BeforePrerollState and PrerollState.
      return;
    } // pause playback so ads can be handled.


    if (!this.paused()) {
      this.ads.debug('Playback was canceled by cancelContentPlay');
      this.pause();
    } // When the 'content-playback' state is entered, this will let us know to play.
    // This is needed if there is no preroll or if it errors, times out, etc.


    this.ads._cancelledPlay = true;
  }

  var obj = {}; // This reference allows videojs to be mocked in unit tests
  // while still using the available videojs import in the source code
  // @see obj.testHook

  var videojsReference = videojs;
  /**
   * Checks if middleware mediators are available and
   * can be used on this platform.
   * Currently we can only use mediators on desktop platforms.
   */

  obj.isMiddlewareMediatorSupported = function () {
    if (videojsReference.browser.IS_IOS || videojsReference.browser.IS_ANDROID) {
      return false;
    } else if ( // added when middleware was introduced in video.js
    videojsReference.use && // added when mediators were introduced in video.js
    videojsReference.middleware && videojsReference.middleware.TERMINATOR) {
      return true;
    }

    return false;
  };

  obj.playMiddleware = function (player) {
    return {
      setSource: function setSource(srcObj, next) {
        next(null, srcObj);
      },
      callPlay: function callPlay() {
        // Block play calls while waiting for an ad, only if this is an
        // ad supported player
        if (player.ads && player.ads._shouldBlockPlay === true) {
          player.ads.debug('Using playMiddleware to block content playback');
          player.ads._playBlocked = true;
          return videojsReference.middleware.TERMINATOR;
        }
      },
      play: function play(terminated, playPromise) {
        if (player.ads && player.ads._playBlocked && terminated) {
          player.ads.debug('Play call to Tech was terminated.'); // Trigger play event to match the user's intent to play.
          // The call to play on the Tech has been blocked, so triggering
          // the event on the Player will not affect the Tech's playback state.

          player.trigger('play'); // At this point the player has technically started

          player.addClass('vjs-has-started'); // Reset playBlocked

          player.ads._playBlocked = false; // Safari issues a pause event when autoplay is blocked but other browsers
          // do not, so we send a pause for consistency in those cases. This keeps the
          // play button in the correct state if play is rejected.
        } else if (playPromise && playPromise.catch) {
          playPromise.catch(function (e) {
            if (e.name === 'NotAllowedError' && !videojs.browser.IS_SAFARI) {
              player.trigger('pause');
            }
          });
        }
      }
    };
  };

  obj.testHook = function (testVjs) {
    videojsReference = testVjs;
  };

  var playMiddleware = obj.playMiddleware,
      isMiddlewareMediatorSupported = obj.isMiddlewareMediatorSupported;
  /**
   * Whether or not this copy of Video.js has the ads plugin.
   *
   * @return {boolean}
   *         If `true`, has the plugin. `false` otherwise.
   */

  var hasAdsPlugin = function hasAdsPlugin() {
    // Video.js 6 and 7 have a getPlugin method.
    if (videojs.getPlugin) {
      return Boolean(videojs.getPlugin('ads'));
    } // Video.js 5 does not have a getPlugin method, so check the player prototype.


    var Player = videojs.getComponent('Player');
    return Boolean(Player && Player.prototype.ads);
  };
  /**
   * Register contrib-ads with Video.js, but provide protection for duplicate
   * copies of the plugin. This could happen if, for example, a stitched ads
   * plugin and a client-side ads plugin are included simultaneously with their
   * own copies of contrib-ads.
   *
   * If contrib-ads detects a pre-existing duplicate, it will not register
   * itself.
   *
   * Ad plugins using contrib-ads and anticipating that this could come into
   * effect should verify that the contrib-ads they are using is of a compatible
   * version.
   *
   * @param  {Function} contribAdsPlugin
   *         The plugin function.
   *
   * @return {boolean}
   *         When `true`, the plugin was registered. When `false`, the plugin
   *         was not registered.
   */


  function register(contribAdsPlugin) {
    // If the ads plugin already exists, do not overwrite it.
    if (hasAdsPlugin(videojs)) {
      return false;
    } // Cross-compatibility with Video.js 6/7 and 5.


    var registerPlugin = videojs.registerPlugin || videojs.plugin; // Register this plugin with Video.js.

    registerPlugin('ads', contribAdsPlugin); // Register the play middleware with Video.js on script execution,
    // to avoid a new playMiddleware factory being added for each player.
    // The `usingContribAdsMiddleware_` flag is used to ensure that we only ever
    // register the middleware once - despite the ability to de-register and
    // re-register the plugin itself.

    if (isMiddlewareMediatorSupported() && !videojs.usingContribAdsMiddleware_) {
      // Register the play middleware
      videojs.use('*', playMiddleware);
      videojs.usingContribAdsMiddleware_ = true;
      videojs.log.debug('Play middleware has been registered with videojs');
    }

    return true;
  }

  var States =
  /*#__PURE__*/
  function () {
    function States() {}

    States.getState = function getState(name) {
      if (!name) {
        return;
      }

      if (States.states_ && States.states_[name]) {
        return States.states_[name];
      }
    };

    States.registerState = function registerState(name, StateToRegister) {
      if (typeof name !== 'string' || !name) {
        throw new Error("Illegal state name, \"" + name + "\"; must be a non-empty string.");
      }

      if (!States.states_) {
        States.states_ = {};
      }

      States.states_[name] = StateToRegister;
      return StateToRegister;
    };

    return States;
  }();

  var State =
  /*#__PURE__*/
  function () {
    State._getName = function _getName() {
      return 'Anonymous State';
    };

    function State(player) {
      this.player = player;
    }
    /*
     * This is the only allowed way to perform state transitions. State transitions usually
     * happen in player event handlers. They can also happen recursively in `init`. They
     * should _not_ happen in `cleanup`.
     */


    var _proto = State.prototype;

    _proto.transitionTo = function transitionTo(NewState) {
      var player = this.player; // Since State is an abstract class, this will refer to
      // the state that is extending this class

      this.cleanup(player);
      var newState = new NewState(player);
      player.ads._state = newState;
      player.ads.debug(this.constructor._getName() + ' -> ' + newState.constructor._getName());

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      newState.init.apply(newState, [player].concat(args));
    }
    /*
     * Implemented by subclasses to provide initialization logic when transitioning
     * to a new state.
     */
    ;

    _proto.init = function init() {}
    /*
     * Implemented by subclasses to provide cleanup logic when transitioning
     * to a new state.
     */
    ;

    _proto.cleanup = function cleanup() {}
    /*
     * Default event handlers. Different states can override these to provide behaviors.
     */
    ;

    _proto.onPlay = function onPlay() {};

    _proto.onPlaying = function onPlaying() {};

    _proto.onEnded = function onEnded() {};

    _proto.onAdEnded = function onAdEnded() {};

    _proto.onAdsReady = function onAdsReady() {
      videojs.log.warn('Unexpected adsready event');
    };

    _proto.onAdsError = function onAdsError() {};

    _proto.onAdsCanceled = function onAdsCanceled() {};

    _proto.onAdTimeout = function onAdTimeout() {};

    _proto.onAdStarted = function onAdStarted() {};

    _proto.onContentChanged = function onContentChanged() {};

    _proto.onContentResumed = function onContentResumed() {};

    _proto.onReadyForPostroll = function onReadyForPostroll() {
      videojs.log.warn('Unexpected readyforpostroll event');
    };

    _proto.onNoPreroll = function onNoPreroll() {};

    _proto.onNoPostroll = function onNoPostroll() {}
    /*
     * Method handlers. Different states can override these to provide behaviors.
     */
    ;

    _proto.startLinearAdMode = function startLinearAdMode() {
      videojs.log.warn('Unexpected startLinearAdMode invocation ' + '(State via ' + this.constructor._getName() + ')');
    };

    _proto.endLinearAdMode = function endLinearAdMode() {
      videojs.log.warn('Unexpected endLinearAdMode invocation ' + '(State via ' + this.constructor._getName() + ')');
    };

    _proto.skipLinearAdMode = function skipLinearAdMode() {
      videojs.log.warn('Unexpected skipLinearAdMode invocation ' + '(State via ' + this.constructor._getName() + ')');
    }
    /*
     * Overridden by ContentState and AdState. Should not be overriden elsewhere.
     */
    ;

    _proto.isAdState = function isAdState() {
      throw new Error('isAdState unimplemented for ' + this.constructor._getName());
    }
    /*
     * Overridden by Preroll and Postroll. Midrolls jump right into the ad break
     * so there is no "waiting" state for them.
     */
    ;

    _proto.isWaitingForAdBreak = function isWaitingForAdBreak() {
      return false;
    }
    /*
     * Overridden by Preroll, Midroll, and Postroll.
     */
    ;

    _proto.isContentResuming = function isContentResuming() {
      return false;
    };

    _proto.inAdBreak = function inAdBreak() {
      return false;
    }
    /*
     * Invoke event handler methods when events come in.
     */
    ;

    _proto.handleEvent = function handleEvent(type) {
      var player = this.player;

      if (type === 'play') {
        this.onPlay(player);
      } else if (type === 'adsready') {
        this.onAdsReady(player);
      } else if (type === 'adserror') {
        this.onAdsError(player);
      } else if (type === 'adscanceled') {
        this.onAdsCanceled(player);
      } else if (type === 'adtimeout') {
        this.onAdTimeout(player);
      } else if (type === 'ads-ad-started') {
        this.onAdStarted(player);
      } else if (type === 'contentchanged') {
        this.onContentChanged(player);
      } else if (type === 'contentresumed') {
        this.onContentResumed(player);
      } else if (type === 'readyforpostroll') {
        this.onReadyForPostroll(player);
      } else if (type === 'playing') {
        this.onPlaying(player);
      } else if (type === 'ended') {
        this.onEnded(player);
      } else if (type === 'nopreroll') {
        this.onNoPreroll(player);
      } else if (type === 'nopostroll') {
        this.onNoPostroll(player);
      } else if (type === 'adended') {
        this.onAdEnded(player);
      }
    };

    return State;
  }();

  States.registerState('State', State);

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }

  /*
   * This class contains logic for all ads, be they prerolls, midrolls, or postrolls.
   * Primarily, this involves handling startLinearAdMode and endLinearAdMode.
   * It also handles content resuming.
   */

  var AdState =
  /*#__PURE__*/
  function (_State) {
    _inheritsLoose(AdState, _State);

    function AdState(player) {
      var _this;

      _this = _State.call(this, player) || this;
      _this.contentResuming = false;
      _this.waitingForAdBreak = false;
      return _this;
    }
    /*
     * Overrides State.isAdState
     */


    var _proto = AdState.prototype;

    _proto.isAdState = function isAdState() {
      return true;
    }
    /*
     * We end the content-resuming process on the playing event because this is the exact
     * moment that content playback is no longer blocked by ads.
     */
    ;

    _proto.onPlaying = function onPlaying() {
      var ContentPlayback = States.getState('ContentPlayback');

      if (this.contentResuming) {
        this.transitionTo(ContentPlayback);
      }
    }
    /*
     * If the ad plugin does not result in a playing event when resuming content after an
     * ad, they should instead trigger a contentresumed event to signal that content should
     * resume. The main use case for this is when ads are stitched into the content video.
     */
    ;

    _proto.onContentResumed = function onContentResumed() {
      var ContentPlayback = States.getState('ContentPlayback');

      if (this.contentResuming) {
        this.transitionTo(ContentPlayback);
      }
    }
    /*
     * Check if we are in an ad state waiting for the ad plugin to start
     * an ad break.
     */
    ;

    _proto.isWaitingForAdBreak = function isWaitingForAdBreak() {
      return this.waitingForAdBreak;
    }
    /*
     * Allows you to check if content is currently resuming after an ad break.
     */
    ;

    _proto.isContentResuming = function isContentResuming() {
      return this.contentResuming;
    }
    /*
     * Allows you to check if an ad break is in progress.
     */
    ;

    _proto.inAdBreak = function inAdBreak() {
      return this.player.ads._inLinearAdMode === true;
    };

    return AdState;
  }(State);

  States.registerState('AdState', AdState);

  var ContentState =
  /*#__PURE__*/
  function (_State) {
    _inheritsLoose(ContentState, _State);

    function ContentState() {
      return _State.apply(this, arguments) || this;
    }

    var _proto = ContentState.prototype;

    /*
     * Overrides State.isAdState
     */
    _proto.isAdState = function isAdState() {
      return false;
    }
    /*
     * Source change sends you back to preroll checks. contentchanged does not
     * fire during ad breaks, so we don't need to worry about that.
     */
    ;

    _proto.onContentChanged = function onContentChanged(player) {
      var BeforePreroll = States.getState('BeforePreroll');
      var Preroll = States.getState('Preroll');
      player.ads.debug('Received contentchanged event (ContentState)');

      if (player.paused()) {
        this.transitionTo(BeforePreroll);
      } else {
        this.transitionTo(Preroll, false);
        player.pause();
        player.ads._pausedOnContentupdate = true;
      }
    };

    return ContentState;
  }(State);

  States.registerState('ContentState', ContentState);

  var ContentState$1 = States.getState('ContentState');

  var AdsDone =
  /*#__PURE__*/
  function (_ContentState) {
    _inheritsLoose(AdsDone, _ContentState);

    function AdsDone() {
      return _ContentState.apply(this, arguments) || this;
    }

    /*
     * Allows state name to be logged even after minification.
     */
    AdsDone._getName = function _getName() {
      return 'AdsDone';
    }
    /*
     * For state transitions to work correctly, initialization should
     * happen here, not in a constructor.
     */
    ;

    var _proto = AdsDone.prototype;

    _proto.init = function init(player) {
      // From now on, `ended` events won't be redispatched
      player.ads._contentHasEnded = true;
      player.trigger('ended');
    }
    /*
     * Midrolls do not play after ads are done.
     */
    ;

    _proto.startLinearAdMode = function startLinearAdMode() {
      videojs.log.warn('Unexpected startLinearAdMode invocation (AdsDone)');
    };

    return AdsDone;
  }(ContentState$1);

  States.registerState('AdsDone', AdsDone);

  /*
  The snapshot feature is responsible for saving the player state before an ad, then
  restoring the player state after an ad.
  */
  var tryToResumeTimeout_;
  /*
   * Returns an object that captures the portions of player state relevant to
   * video playback. The result of this function can be passed to
   * restorePlayerSnapshot with a player to return the player to the state it
   * was in when this function was invoked.
   * @param {Object} player The videojs player object
   */

  function getPlayerSnapshot(player) {
    var currentTime;

    if (videojs.browser.IS_IOS && player.ads.isLive(player)) {
      // Record how far behind live we are
      if (player.seekable().length > 0) {
        currentTime = player.currentTime() - player.seekable().end(0);
      } else {
        currentTime = player.currentTime();
      }
    } else {
      currentTime = player.currentTime();
    }

    var tech = player.$('.vjs-tech');
    var tracks = player.textTracks ? player.textTracks() : [];
    var suppressedTracks = [];
    var snapshotObject = {
      ended: player.ended(),
      currentSrc: player.currentSrc(),
      sources: player.currentSources(),
      src: player.tech_.src(),
      currentTime: currentTime,
      type: player.currentType()
    };

    if (tech) {
      snapshotObject.style = tech.getAttribute('style');
    }

    for (var i = 0; i < tracks.length; i++) {
      var track = tracks[i];
      suppressedTracks.push({
        track: track,
        mode: track.mode
      });
      track.mode = 'disabled';
    }

    snapshotObject.suppressedTracks = suppressedTracks;
    return snapshotObject;
  }
  /*
   * Attempts to modify the specified player so that its state is equivalent to
   * the state of the snapshot.
   * @param {Object} player - the videojs player object
   * @param {Object} snapshotObject - the player state to apply
   */

  function restorePlayerSnapshot(player, callback) {
    var snapshotObject = player.ads.snapshot;

    if (callback === undefined) {
      callback = function callback() {};
    }

    if (player.ads.disableNextSnapshotRestore === true) {
      player.ads.disableNextSnapshotRestore = false;
      delete player.ads.snapshot;
      callback();
      return;
    } // The playback tech


    var tech = player.$('.vjs-tech'); // the number of[ remaining attempts to restore the snapshot

    var attempts = 20;
    var suppressedTracks = snapshotObject.suppressedTracks;
    var trackSnapshot;

    var restoreTracks = function restoreTracks() {
      for (var i = 0; i < suppressedTracks.length; i++) {
        trackSnapshot = suppressedTracks[i];
        trackSnapshot.track.mode = trackSnapshot.mode;
      }
    }; // Finish restoring the playback state.
    // This only happens if the content video element was reused for ad playback.


    var resume = function resume() {
      var currentTime; // Live video on iOS has special logic to try to seek to the right place after
      // an ad.

      if (videojs.browser.IS_IOS && player.ads.isLive(player)) {
        if (snapshotObject.currentTime < 0) {
          // Playback was behind real time, so seek backwards to match
          if (player.seekable().length > 0) {
            currentTime = player.seekable().end(0) + snapshotObject.currentTime;
          } else {
            currentTime = player.currentTime();
          }

          player.currentTime(currentTime);
        } // iOS live play after restore if player was paused (would not be paused if
        // ad played muted behind ad)


        if (player.paused()) {
          var playPromise = player.play();

          if (playPromise && playPromise.catch) {
            playPromise.catch(function (error) {
              videojs.log.warn('Play promise rejected in IOS snapshot resume', error);
            });
          }
        } // Restore the video position after an ad.
        // We check snapshotObject.ended because the content starts at the beginning again
        // after being restored.

      } else if (snapshotObject.ended) {
        // For postrolls, seek to the player's current duration.
        // It could be different from the snapshot's currentTime due to
        // inaccuracy in HLS.
        player.currentTime(player.duration());
      } else {
        // Prerolls and midrolls, just seek to the player time before the ad.
        player.currentTime(snapshotObject.currentTime);

        var _playPromise = player.play();

        if (_playPromise && _playPromise.catch) {
          _playPromise.catch(function (error) {
            videojs.log.warn('Play promise rejected in snapshot resume', error);
          });
        }
      } // if we added autoplay to force content loading on iOS, remove it now
      // that it has served its purpose


      if (player.ads.shouldRemoveAutoplay_) {
        player.autoplay(false);
        player.ads.shouldRemoveAutoplay_ = false;
      }
    }; // Determine if the video element has loaded enough of the snapshot source
    // to be ready to apply the rest of the state.
    // This only happens if the content video element was reused for ad playback.


    var tryToResume = function tryToResume() {
      // tryToResume can either have been called through the `contentcanplay`
      // event or fired through setTimeout.
      // When tryToResume is called, we should make sure to clear out the other
      // way it could've been called by removing the listener and clearing out
      // the timeout.
      player.off('contentcanplay', tryToResume);

      if (tryToResumeTimeout_) {
        player.clearTimeout(tryToResumeTimeout_);
      } // Tech may have changed depending on the differences in sources of the
      // original video and that of the ad


      tech = player.el().querySelector('.vjs-tech');

      if (tech.readyState > 1) {
        // some browsers and media aren't "seekable".
        // readyState greater than 1 allows for seeking without exceptions
        return resume();
      }

      if (tech.seekable === undefined) {
        // if the tech doesn't expose the seekable time ranges, try to
        // resume playback immediately
        return resume();
      }

      if (tech.seekable.length > 0) {
        // if some period of the video is seekable, resume playback
        return resume();
      } // delay a bit and then check again unless we're out of attempts


      if (attempts--) {
        player.setTimeout(tryToResume, 50);
      } else {
        try {
          resume();
        } catch (e) {
          videojs.log.warn('Failed to resume the content after an advertisement', e);
        }
      }
    };

    if ('style' in snapshotObject) {
      // overwrite all css style properties to restore state precisely
      tech.setAttribute('style', snapshotObject.style || '');
    } // Determine whether the player needs to be restored to its state
    // before ad playback began. With a custom ad display or burned-in
    // ads, the content player state hasn't been modified and so no
    // restoration is required


    if (player.ads.videoElementRecycled()) {
      // Snapshot restore is done, so now we're really finished.
      player.one('resumeended', function () {
        delete player.ads.snapshot;
        callback();
      }); // on ios7, fiddling with textTracks too early will cause safari to crash

      player.one('contentloadedmetadata', restoreTracks); // adding autoplay guarantees that Safari will load the content so we can
      // seek back to the correct time after ads

      if (videojs.browser.IS_IOS && !player.autoplay()) {
        player.autoplay(true); // if we get here, the player was not originally configured to autoplay,
        // so we should remove it after it has served its purpose

        player.ads.shouldRemoveAutoplay_ = true;
      } // if the src changed for ad playback, reset it


      player.src(snapshotObject.sources); // and then resume from the snapshots time once the original src has loaded
      // in some browsers (firefox) `canplay` may not fire correctly.
      // Reace the `canplay` event with a timeout.

      player.one('contentcanplay', tryToResume);
      tryToResumeTimeout_ = player.setTimeout(tryToResume, 2000);
    } else {
      // if we didn't change the src, just restore the tracks
      restoreTracks(); // we don't need to check snapshotObject.ended here because the content video
      // element wasn't recycled

      if (!player.ended()) {
        // the src didn't change and this wasn't a postroll
        // just resume playback at the current time.
        var playPromise = player.play();

        if (playPromise && playPromise.catch) {
          playPromise.catch(function (error) {
            videojs.log.warn('Play promise rejected in snapshot restore', error);
          });
        }
      } // snapshot restore is complete


      delete player.ads.snapshot;
      callback();
    }
  }

  /*
   * Encapsulates logic for starting and ending ad breaks. An ad break
   * is the time between startLinearAdMode and endLinearAdMode. The ad
   * plugin may play 0 or more ads during this time.
   */

  function start(player) {
    player.ads.debug('Starting ad break');
    player.ads._inLinearAdMode = true; // No longer does anything, used to move us to ad-playback

    player.trigger('adstart'); // Capture current player state snapshot

    if (player.ads.shouldTakeSnapshots()) {
      player.ads.snapshot = getPlayerSnapshot(player);
    } // Mute the player behind the ad


    if (player.ads.shouldPlayContentBehindAd(player)) {
      player.ads.preAdVolume_ = player.volume();
      player.volume(0);
    } // Add css to the element to indicate and ad is playing.


    player.addClass('vjs-ad-playing'); // We should remove the vjs-live class if it has been added in order to
    // show the adprogress control bar on Android devices for falsely
    // determined LIVE videos due to the duration incorrectly reported as Infinity

    if (player.hasClass('vjs-live')) {
      player.removeClass('vjs-live');
    } // This removes the native poster so the ads don't show the content
    // poster if content element is reused for ad playback.


    player.ads.removeNativePoster();
  }

  function end(player, callback) {
    player.ads.debug('Ending ad break');

    if (callback === undefined) {
      callback = function callback() {};
    }

    player.ads.adType = null;
    player.ads._inLinearAdMode = false; // Signals the end of the ad break to anyone listening.

    player.trigger('adend');
    player.removeClass('vjs-ad-playing'); // We should add the vjs-live class back if the video is a LIVE video
    // If we dont do this, then for a LIVE Video, we will get an incorrect
    // styled control, which displays the time for the video

    if (player.ads.isLive(player)) {
      player.addClass('vjs-live');
    } // Restore snapshot


    if (player.ads.shouldTakeSnapshots()) {
      restorePlayerSnapshot(player, callback); // Reset the volume to pre-ad levels
    } else {
      player.volume(player.ads.preAdVolume_);
      callback();
    }
  }

  var obj$1 = {
    start: start,
    end: end
  };

  var AdState$1 = States.getState('AdState');
  /*
   * This state encapsulates waiting for prerolls, preroll playback, and
   * content restoration after a preroll.
   */

  var Preroll =
  /*#__PURE__*/
  function (_AdState) {
    _inheritsLoose(Preroll, _AdState);

    function Preroll() {
      return _AdState.apply(this, arguments) || this;
    }

    /*
     * Allows state name to be logged even after minification.
     */
    Preroll._getName = function _getName() {
      return 'Preroll';
    }
    /*
     * For state transitions to work correctly, initialization should
     * happen here, not in a constructor.
     */
    ;

    var _proto = Preroll.prototype;

    _proto.init = function init(player, adsReady, shouldResumeToContent) {
      this.waitingForAdBreak = true; // Loading spinner from now until ad start or end of ad break.

      player.addClass('vjs-ad-loading'); // If adserror, adscanceled, nopreroll or skipLinearAdMode already
      // ocurred, resume to content immediately

      if (shouldResumeToContent || player.ads.nopreroll_) {
        return this.resumeAfterNoPreroll(player);
      } // Determine preroll timeout based on plugin settings


      var timeout = player.ads.settings.timeout;

      if (typeof player.ads.settings.prerollTimeout === 'number') {
        timeout = player.ads.settings.prerollTimeout;
      } // Start the clock ticking for ad timeout


      this._timeout = player.setTimeout(function () {
        player.trigger('adtimeout');
      }, timeout); // If adsready already happened, lets get started. Otherwise,
      // wait until onAdsReady.

      if (adsReady) {
        this.handleAdsReady();
      } else {
        this.adsReady = false;
      }
    }
    /*
     * Adsready event after play event.
     */
    ;

    _proto.onAdsReady = function onAdsReady(player) {
      if (!player.ads.inAdBreak()) {
        player.ads.debug('Received adsready event (Preroll)');
        this.handleAdsReady();
      } else {
        videojs.log.warn('Unexpected adsready event (Preroll)');
      }
    }
    /*
     * Ad plugin is ready. Let's get started on this preroll.
     */
    ;

    _proto.handleAdsReady = function handleAdsReady() {
      this.adsReady = true;
      this.readyForPreroll();
    }
    /*
     * Helper to call a callback only after a loadstart event.
     * If we start content or ads before loadstart, loadstart
     * will not be prefixed correctly.
     */
    ;

    _proto.afterLoadStart = function afterLoadStart(callback) {
      var player = this.player;

      if (player.ads._hasThereBeenALoadStartDuringPlayerLife) {
        callback();
      } else {
        player.ads.debug('Waiting for loadstart...');
        player.one('loadstart', function () {
          player.ads.debug('Received loadstart event');
          callback();
        });
      }
    }
    /*
     * If there is no preroll, play content instead.
     */
    ;

    _proto.noPreroll = function noPreroll() {
      var _this = this;

      this.afterLoadStart(function () {
        _this.player.ads.debug('Skipping prerolls due to nopreroll event (Preroll)');

        _this.resumeAfterNoPreroll(_this.player);
      });
    }
    /*
     * Fire the readyforpreroll event. If loadstart hasn't happened yet,
     * wait until loadstart first.
     */
    ;

    _proto.readyForPreroll = function readyForPreroll() {
      var player = this.player;
      this.afterLoadStart(function () {
        player.ads.debug('Triggered readyforpreroll event (Preroll)');
        player.trigger('readyforpreroll');
      });
    }
    /*
     * adscanceled cancels all ads for the source. Play content now.
     */
    ;

    _proto.onAdsCanceled = function onAdsCanceled(player) {
      var _this2 = this;

      player.ads.debug('adscanceled (Preroll)');
      this.afterLoadStart(function () {
        _this2.resumeAfterNoPreroll(player);
      });
    }
    /*
     * An ad error occured. Play content instead.
     */
    ;

    _proto.onAdsError = function onAdsError(player) {
      var _this3 = this;

      videojs.log('adserror (Preroll)'); // In the future, we may not want to do this automatically.
      // Ad plugins should be able to choose to continue the ad break
      // if there was an error.

      if (this.inAdBreak()) {
        player.ads.endLinearAdMode();
      } else {
        this.afterLoadStart(function () {
          _this3.resumeAfterNoPreroll(player);
        });
      }
    }
    /*
     * Ad plugin invoked startLinearAdMode, the ad break starts now.
     */
    ;

    _proto.startLinearAdMode = function startLinearAdMode() {
      var player = this.player;

      if (this.adsReady && !player.ads.inAdBreak() && !this.isContentResuming()) {
        this.clearTimeout(player);
        player.ads.adType = 'preroll';
        this.waitingForAdBreak = false;
        obj$1.start(player); // We don't need to block play calls anymore

        player.ads._shouldBlockPlay = false;
      } else {
        videojs.log.warn('Unexpected startLinearAdMode invocation (Preroll)');
      }
    }
    /*
     * An ad has actually started playing.
     * Remove the loading spinner.
     */
    ;

    _proto.onAdStarted = function onAdStarted(player) {
      player.removeClass('vjs-ad-loading');
    }
    /*
     * Ad plugin invoked endLinearAdMode, the ad break ends now.
     */
    ;

    _proto.endLinearAdMode = function endLinearAdMode() {
      var player = this.player;

      if (this.inAdBreak()) {
        player.removeClass('vjs-ad-loading');
        player.addClass('vjs-ad-content-resuming');
        this.contentResuming = true;
        obj$1.end(player);
      }
    }
    /*
     * Ad skipped by ad plugin. Play content instead.
     */
    ;

    _proto.skipLinearAdMode = function skipLinearAdMode() {
      var _this4 = this;

      var player = this.player;

      if (player.ads.inAdBreak() || this.isContentResuming()) {
        videojs.log.warn('Unexpected skipLinearAdMode invocation');
      } else {
        this.afterLoadStart(function () {
          player.trigger('adskip');
          player.ads.debug('skipLinearAdMode (Preroll)');

          _this4.resumeAfterNoPreroll(player);
        });
      }
    }
    /*
     * Prerolls took too long! Play content instead.
     */
    ;

    _proto.onAdTimeout = function onAdTimeout(player) {
      var _this5 = this;

      this.afterLoadStart(function () {
        player.ads.debug('adtimeout (Preroll)');

        _this5.resumeAfterNoPreroll(player);
      });
    }
    /*
     * Check if nopreroll event was too late before handling it.
     */
    ;

    _proto.onNoPreroll = function onNoPreroll(player) {
      if (player.ads.inAdBreak() || this.isContentResuming()) {
        videojs.log.warn('Unexpected nopreroll event (Preroll)');
      } else {
        this.noPreroll();
      }
    };

    _proto.resumeAfterNoPreroll = function resumeAfterNoPreroll(player) {
      // Resume to content and unblock play as there is no preroll ad
      this.contentResuming = true;
      player.ads._shouldBlockPlay = false;
      this.cleanupPartial(player); // Play the content if we had requested play or we paused on 'contentupdate'
      // and we haven't played yet. This happens if there was no preroll or if it
      // errored, timed out, etc. Otherwise snapshot restore would play.

      if (player.ads._playRequested || player.ads._pausedOnContentupdate) {
        if (player.paused()) {
          player.ads.debug('resumeAfterNoPreroll: attempting to resume playback (Preroll)');
          var playPromise = player.play();

          if (playPromise && playPromise.then) {
            playPromise.then(null, function (e) {});
          }
        } else {
          player.ads.debug('resumeAfterNoPreroll: already playing (Preroll)');
          player.trigger('play');
          player.trigger('playing');
        }
      }
    }
    /*
     * Cleanup timeouts and spinner.
     */
    ;

    _proto.cleanup = function cleanup(player) {
      if (!player.ads._hasThereBeenALoadStartDuringPlayerLife) {
        videojs.log.warn('Leaving Preroll state before loadstart event can cause issues.');
      }

      this.cleanupPartial(player);
    }
    /*
     * Performs cleanup tasks without depending on a state transition. This is
     * used mainly in cases where a preroll failed.
     */
    ;

    _proto.cleanupPartial = function cleanupPartial(player) {
      player.removeClass('vjs-ad-loading');
      player.removeClass('vjs-ad-content-resuming');
      this.clearTimeout(player);
    }
    /*
     * Clear the preroll timeout and nulls out the pointer.
     */
    ;

    _proto.clearTimeout = function clearTimeout(player) {
      player.clearTimeout(this._timeout);
      this._timeout = null;
    };

    return Preroll;
  }(AdState$1);

  States.registerState('Preroll', Preroll);

  var ContentState$2 = States.getState('ContentState');
  /*
   * This is the initial state for a player with an ad plugin. Normally, it remains in this
   * state until a "play" event is seen. After that, we enter the Preroll state to check for
   * prerolls. This happens regardless of whether or not any prerolls ultimately will play.
   * Errors and other conditions may lead us directly from here to ContentPlayback.
   */

  var BeforePreroll =
  /*#__PURE__*/
  function (_ContentState) {
    _inheritsLoose(BeforePreroll, _ContentState);

    function BeforePreroll() {
      return _ContentState.apply(this, arguments) || this;
    }

    /*
     * Allows state name to be logged even after minification.
     */
    BeforePreroll._getName = function _getName() {
      return 'BeforePreroll';
    }
    /*
     * For state transitions to work correctly, initialization should
     * happen here, not in a constructor.
     */
    ;

    var _proto = BeforePreroll.prototype;

    _proto.init = function init(player) {
      this.adsReady = false;
      this.shouldResumeToContent = false; // Content playback should be blocked until we are done
      // playing ads or we know there are no ads to play

      player.ads._shouldBlockPlay = true;
    }
    /*
     * The ad plugin may trigger adsready before the play request. If so,
     * we record that adsready already happened so the Preroll state will know.
     */
    ;

    _proto.onAdsReady = function onAdsReady(player) {
      player.ads.debug('Received adsready event (BeforePreroll)');
      this.adsReady = true;
    }
    /*
     * Ad mode officially begins on the play request, because at this point
     * content playback is blocked by the ad plugin.
     */
    ;

    _proto.onPlay = function onPlay(player) {
      var Preroll = States.getState('Preroll');
      player.ads.debug('Received play event (BeforePreroll)'); // Check for prerolls

      this.transitionTo(Preroll, this.adsReady, this.shouldResumeToContent);
    }
    /*
     * All ads for the entire video are canceled.
     */
    ;

    _proto.onAdsCanceled = function onAdsCanceled(player) {
      player.ads.debug('adscanceled (BeforePreroll)');
      this.shouldResumeToContent = true;
    }
    /*
     * An ad error occured. Play content instead.
     */
    ;

    _proto.onAdsError = function onAdsError() {
      this.player.ads.debug('adserror (BeforePreroll)');
      this.shouldResumeToContent = true;
    }
    /*
     * If there is no preroll, don't wait for a play event to move forward.
     */
    ;

    _proto.onNoPreroll = function onNoPreroll() {
      this.player.ads.debug('Skipping prerolls due to nopreroll event (BeforePreroll)');
      this.shouldResumeToContent = true;
    }
    /*
     * Prerolls skipped by ad plugin. Play content instead.
     */
    ;

    _proto.skipLinearAdMode = function skipLinearAdMode() {
      var player = this.player;
      player.trigger('adskip');
      player.ads.debug('skipLinearAdMode (BeforePreroll)');
      this.shouldResumeToContent = true;
    };

    _proto.onContentChanged = function onContentChanged() {
      this.init(this.player);
    };

    return BeforePreroll;
  }(ContentState$2);

  States.registerState('BeforePreroll', BeforePreroll);

  var AdState$2 = States.getState('AdState');

  var Midroll =
  /*#__PURE__*/
  function (_AdState) {
    _inheritsLoose(Midroll, _AdState);

    function Midroll() {
      return _AdState.apply(this, arguments) || this;
    }

    /*
     * Allows state name to be logged even after minification.
     */
    Midroll._getName = function _getName() {
      return 'Midroll';
    }
    /*
     * Midroll breaks happen when the ad plugin calls startLinearAdMode,
     * which can happen at any time during content playback.
     */
    ;

    var _proto = Midroll.prototype;

    _proto.init = function init(player) {
      player.ads.adType = 'midroll';
      obj$1.start(player);
      player.addClass('vjs-ad-loading');
    }
    /*
     * An ad has actually started playing.
     * Remove the loading spinner.
     */
    ;

    _proto.onAdStarted = function onAdStarted(player) {
      player.removeClass('vjs-ad-loading');
    }
    /*
     * Midroll break is done.
     */
    ;

    _proto.endLinearAdMode = function endLinearAdMode() {
      var player = this.player;

      if (this.inAdBreak()) {
        this.contentResuming = true;
        player.addClass('vjs-ad-content-resuming');
        player.removeClass('vjs-ad-loading');
        obj$1.end(player);
      }
    }
    /*
     * End midroll break if there is an error.
     */
    ;

    _proto.onAdsError = function onAdsError(player) {
      // In the future, we may not want to do this automatically.
      // Ad plugins should be able to choose to continue the ad break
      // if there was an error.
      if (this.inAdBreak()) {
        player.ads.endLinearAdMode();
      }
    }
    /*
     * Cleanup CSS classes.
     */
    ;

    _proto.cleanup = function cleanup(player) {
      player.removeClass('vjs-ad-loading');
      player.removeClass('vjs-ad-content-resuming');
    };

    return Midroll;
  }(AdState$2);

  States.registerState('Midroll', Midroll);

  var AdState$3 = States.getState('AdState');

  var Postroll =
  /*#__PURE__*/
  function (_AdState) {
    _inheritsLoose(Postroll, _AdState);

    function Postroll() {
      return _AdState.apply(this, arguments) || this;
    }

    /*
     * Allows state name to be logged even after minification.
     */
    Postroll._getName = function _getName() {
      return 'Postroll';
    }
    /*
     * For state transitions to work correctly, initialization should
     * happen here, not in a constructor.
     */
    ;

    var _proto = Postroll.prototype;

    _proto.init = function init(player) {
      this.waitingForAdBreak = true; // Legacy name that now simply means "handling postrolls".

      player.ads._contentEnding = true; // Start postroll process.

      if (!player.ads.nopostroll_) {
        player.addClass('vjs-ad-loading'); // Determine postroll timeout based on plugin settings

        var timeout = player.ads.settings.timeout;

        if (typeof player.ads.settings.postrollTimeout === 'number') {
          timeout = player.ads.settings.postrollTimeout;
        }

        this._postrollTimeout = player.setTimeout(function () {
          player.trigger('adtimeout');
        }, timeout); // No postroll, ads are done
      } else {
        this.resumeContent(player);
        var AdsDone = States.getState('AdsDone');
        this.transitionTo(AdsDone);
      }
    }
    /*
     * Start the postroll if it's not too late.
     */
    ;

    _proto.startLinearAdMode = function startLinearAdMode() {
      var player = this.player;

      if (!player.ads.inAdBreak() && !this.isContentResuming()) {
        player.ads.adType = 'postroll';
        player.clearTimeout(this._postrollTimeout);
        this.waitingForAdBreak = false;
        obj$1.start(player);
      } else {
        videojs.log.warn('Unexpected startLinearAdMode invocation (Postroll)');
      }
    }
    /*
     * An ad has actually started playing.
     * Remove the loading spinner.
     */
    ;

    _proto.onAdStarted = function onAdStarted(player) {
      player.removeClass('vjs-ad-loading');
    }
    /*
     * Ending a postroll triggers the ended event.
     */
    ;

    _proto.endLinearAdMode = function endLinearAdMode() {
      var _this = this;

      var player = this.player;
      var AdsDone = States.getState('AdsDone');

      if (this.inAdBreak()) {
        player.removeClass('vjs-ad-loading');
        this.resumeContent(player);
        obj$1.end(player, function () {
          _this.transitionTo(AdsDone);
        });
      }
    }
    /*
     * Postroll skipped, time to clean up.
     */
    ;

    _proto.skipLinearAdMode = function skipLinearAdMode() {
      var player = this.player;

      if (player.ads.inAdBreak() || this.isContentResuming()) {
        videojs.log.warn('Unexpected skipLinearAdMode invocation');
      } else {
        player.ads.debug('Postroll abort (skipLinearAdMode)');
        player.trigger('adskip');
        this.abort(player);
      }
    }
    /*
     * Postroll timed out, time to clean up.
     */
    ;

    _proto.onAdTimeout = function onAdTimeout(player) {
      player.ads.debug('Postroll abort (adtimeout)');
      this.abort(player);
    }
    /*
     * Postroll errored out, time to clean up.
     */
    ;

    _proto.onAdsError = function onAdsError(player) {
      player.ads.debug('Postroll abort (adserror)'); // In the future, we may not want to do this automatically.
      // Ad plugins should be able to choose to continue the ad break
      // if there was an error.

      if (player.ads.inAdBreak()) {
        player.ads.endLinearAdMode();
      } else {
        this.abort(player);
      }
    }
    /*
     * Handle content change if we're not in an ad break.
     */
    ;

    _proto.onContentChanged = function onContentChanged(player) {
      // Content resuming after Postroll. Content is paused
      // at this point, since it is done playing.
      if (this.isContentResuming()) {
        var BeforePreroll = States.getState('BeforePreroll');
        this.transitionTo(BeforePreroll); // Waiting for postroll to start. Content is considered playing
        // at this point, since it had to be playing to start the postroll.
      } else if (!this.inAdBreak()) {
        var Preroll = States.getState('Preroll');
        this.transitionTo(Preroll);
      }
    }
    /*
     * Wrap up if there is no postroll.
     */
    ;

    _proto.onNoPostroll = function onNoPostroll(player) {
      if (!this.isContentResuming() && !this.inAdBreak()) {
        this.abort(player);
      } else {
        videojs.log.warn('Unexpected nopostroll event (Postroll)');
      }
    };

    _proto.resumeContent = function resumeContent(player) {
      this.contentResuming = true;
      player.addClass('vjs-ad-content-resuming');
    }
    /*
     * Helper for ending Postrolls. In the future we may want to
     * refactor this class so that `cleanup` handles all of this.
     */
    ;

    _proto.abort = function abort(player) {
      var AdsDone = States.getState('AdsDone');
      this.resumeContent(player);
      player.removeClass('vjs-ad-loading');
      this.transitionTo(AdsDone);
    }
    /*
     * Cleanup timeouts and state.
     */
    ;

    _proto.cleanup = function cleanup(player) {
      player.removeClass('vjs-ad-content-resuming');
      player.clearTimeout(this._postrollTimeout);
      player.ads._contentEnding = false;
    };

    return Postroll;
  }(AdState$3);

  States.registerState('Postroll', Postroll);

  var ContentState$3 = States.getState('ContentState');
  /*
   * This state represents content playback the first time through before
   * content ends. After content has ended once, we check for postrolls and
   * move on to the AdsDone state rather than returning here.
   */

  var ContentPlayback =
  /*#__PURE__*/
  function (_ContentState) {
    _inheritsLoose(ContentPlayback, _ContentState);

    function ContentPlayback() {
      return _ContentState.apply(this, arguments) || this;
    }

    /*
     * Allows state name to be logged even after minification.
     */
    ContentPlayback._getName = function _getName() {
      return 'ContentPlayback';
    }
    /*
     * For state transitions to work correctly, initialization should
     * happen here, not in a constructor.
     */
    ;

    var _proto = ContentPlayback.prototype;

    _proto.init = function init(player) {
      // Don't block calls to play in content playback
      player.ads._shouldBlockPlay = false;
    }
    /*
     * In the case of a timeout, adsready might come in late. This assumes the behavior
     * that if an ad times out, it could still interrupt the content and start playing.
     * An ad plugin could behave otherwise by ignoring this event.
     */
    ;

    _proto.onAdsReady = function onAdsReady(player) {
      player.ads.debug('Received adsready event (ContentPlayback)');

      if (!player.ads.nopreroll_) {
        player.ads.debug('Triggered readyforpreroll event (ContentPlayback)');
        player.trigger('readyforpreroll');
      }
    }
    /*
     * Content ended before postroll checks.
     */
    ;

    _proto.onReadyForPostroll = function onReadyForPostroll(player) {
      var Postroll = States.getState('Postroll');
      player.ads.debug('Received readyforpostroll event');
      this.transitionTo(Postroll);
    }
    /*
     * This is how midrolls start.
     */
    ;

    _proto.startLinearAdMode = function startLinearAdMode() {
      var Midroll = States.getState('Midroll');
      this.transitionTo(Midroll);
    };

    return ContentPlayback;
  }(ContentState$3);

  States.registerState('ContentPlayback', ContentPlayback);

  var ContentState$4 = States.getState('ContentState');
  /*
   * This state represents content playback when stitched ads are in play.
   */

  var StitchedContentPlayback =
  /*#__PURE__*/
  function (_ContentState) {
    _inheritsLoose(StitchedContentPlayback, _ContentState);

    function StitchedContentPlayback() {
      return _ContentState.apply(this, arguments) || this;
    }

    /*
     * Allows state name to be logged even after minification.
     */
    StitchedContentPlayback._getName = function _getName() {
      return 'StitchedContentPlayback';
    }
    /*
     * For state transitions to work correctly, initialization should
     * happen here, not in a constructor.
     */
    ;

    var _proto = StitchedContentPlayback.prototype;

    _proto.init = function init() {
      // Don't block calls to play in stitched ad players, ever.
      this.player.ads._shouldBlockPlay = false;
    }
    /*
     * Source change does not do anything for stitched ad players.
     * contentchanged does not fire during ad breaks, so we don't need to
     * worry about that.
     */
    ;

    _proto.onContentChanged = function onContentChanged() {
      this.player.ads.debug("Received contentchanged event (" + this.constructor._getName() + ")");
    }
    /*
     * This is how stitched ads start.
     */
    ;

    _proto.startLinearAdMode = function startLinearAdMode() {
      var StitchedAdRoll = States.getState('StitchedAdRoll');
      this.transitionTo(StitchedAdRoll);
    };

    return StitchedContentPlayback;
  }(ContentState$4);

  States.registerState('StitchedContentPlayback', StitchedContentPlayback);

  var AdState$4 = States.getState('AdState');

  var StitchedAdRoll =
  /*#__PURE__*/
  function (_AdState) {
    _inheritsLoose(StitchedAdRoll, _AdState);

    function StitchedAdRoll() {
      return _AdState.apply(this, arguments) || this;
    }

    /*
     * Allows state name to be logged even after minification.
     */
    StitchedAdRoll._getName = function _getName() {
      return 'StitchedAdRoll';
    }
    /*
     * StitchedAdRoll breaks happen when the ad plugin calls startLinearAdMode,
     * which can happen at any time during content playback.
     */
    ;

    var _proto = StitchedAdRoll.prototype;

    _proto.init = function init() {
      this.waitingForAdBreak = false;
      this.contentResuming = false;
      this.player.ads.adType = 'stitched';
      obj$1.start(this.player);
    }
    /*
     * For stitched ads, there is no "content resuming" scenario, so a "playing"
     * event is not relevant.
     */
    ;

    _proto.onPlaying = function onPlaying() {}
    /*
     * For stitched ads, there is no "content resuming" scenario, so a
     * "contentresumed" event is not relevant.
     */
    ;

    _proto.onContentResumed = function onContentResumed() {}
    /*
     * When we see an "adended" event, it means that we are in a postroll that
     * has ended (because the media ended and we are still in an ad state).
     *
     * In these cases, we transition back to content mode and fire ended.
     */
    ;

    _proto.onAdEnded = function onAdEnded() {
      this.endLinearAdMode();
      this.player.trigger('ended');
    }
    /*
     * StitchedAdRoll break is done.
     */
    ;

    _proto.endLinearAdMode = function endLinearAdMode() {
      var StitchedContentPlayback = States.getState('StitchedContentPlayback');
      obj$1.end(this.player);
      this.transitionTo(StitchedContentPlayback);
    };

    return StitchedAdRoll;
  }(AdState$4);

  States.registerState('StitchedAdRoll', StitchedAdRoll);

  /*
  This main plugin file is responsible for the public API and enabling the features
  that live in in separate files.
  */
  var isMiddlewareMediatorSupported$1 = obj.isMiddlewareMediatorSupported;
  var VIDEO_EVENTS = videojs.getTech('Html5').Events; // Default settings

  var defaults = {
    // Maximum amount of time in ms to wait to receive `adsready` from the ad
    // implementation after play has been requested. Ad implementations are
    // expected to load any dynamic libraries and make any requests to determine
    // ad policies for a video during this time.
    timeout: 5000,
    // Maximum amount of time in ms to wait for the ad implementation to start
    // linear ad mode after `readyforpreroll` has fired. This is in addition to
    // the standard timeout.
    prerollTimeout: undefined,
    // Maximum amount of time in ms to wait for the ad implementation to start
    // linear ad mode after `readyforpostroll` has fired.
    postrollTimeout: undefined,
    // When truthy, instructs the plugin to output additional information about
    // plugin state to the video.js log. On most devices, the video.js log is
    // the same as the developer console.
    debug: false,
    // Set this to true when using ads that are part of the content video
    stitchedAds: false,
    // Force content to be treated as live or not live
    // if not defined, the code will try to infer if content is live,
    // which can have limitations.
    contentIsLive: undefined,
    // If set to true, content will play muted behind ads on supported platforms. This is
    // to support ads on video metadata cuepoints during a live stream. It also results in
    // more precise resumes after ads during a live stream.
    liveCuePoints: true
  };

  var contribAdsPlugin = function contribAdsPlugin(options) {
    var player = this; // eslint-disable-line consistent-this

    var settings = videojs.mergeOptions(defaults, options); // Prefix all video element events during ad playback
    // if the video element emits ad-related events directly,
    // plugins that aren't ad-aware will break. prefixing allows
    // plugins that wish to handle ad events to do so while
    // avoiding the complexity for common usage

    var videoEvents = []; // dedupe event names

    VIDEO_EVENTS.concat(['firstplay', 'loadedalldata']).forEach(function (eventName) {
      if (videoEvents.indexOf(eventName) === -1) {
        videoEvents.push(eventName);
      }
    }); // Set up redispatching of player events

    player.on(videoEvents, redispatch); // Set up features to block content playback while waiting for ads.
    // Play middleware is only supported on later versions of video.js
    // and on desktop currently(as the user-gesture requirement on mobile
    // will disallow calling play once play blocking is lifted)
    // The middleware must also be registered outside of the plugin,
    // to avoid a middleware factory being created for each player

    if (!isMiddlewareMediatorSupported$1()) {
      initCancelContentPlay(player, settings.debug);
    } // If we haven't seen a loadstart after 5 seconds, the plugin was not initialized
    // correctly.


    player.setTimeout(function () {
      if (!player.ads._hasThereBeenALoadStartDuringPlayerLife && player.src() !== '') {
        videojs.log.error('videojs-contrib-ads has not seen a loadstart event 5 seconds ' + 'after being initialized, but a source is present. This indicates that ' + 'videojs-contrib-ads was initialized too late. It must be initialized ' + 'immediately after video.js in the same tick. As a result, some ads will not ' + 'play and some media events will be incorrect. For more information, see ' + 'http://videojs.github.io/videojs-contrib-ads/integrator/getting-started.html');
      }
    }, 5000); // "vjs-has-started" should be present at the end of a video. This makes sure it's
    // always there.

    player.on('ended', function () {
      if (!player.hasClass('vjs-has-started')) {
        player.addClass('vjs-has-started');
      }
    }); // video.js removes the vjs-waiting class on timeupdate. We want
    // to make sure this still happens during content restoration.

    player.on('contenttimeupdate', function () {
      player.removeClass('vjs-waiting');
    }); // We now auto-play when an ad gets loaded if we're playing ads in the same video
    // element as the content.
    // The problem is that in IE11, we cannot play in addurationchange but in iOS8, we
    // cannot play from adcanplay.
    // This will prevent ad plugins from needing to do this themselves.

    player.on(['addurationchange', 'adcanplay'], function () {
      // We don't need to handle this for stitched ads because
      // linear ads in such cases are stitched into the content.
      if (player.ads.settings.stitchedAds) {
        return;
      } // Some techs may retrigger canplay after playback has begun.
      // So we want to procceed only if playback hasn't started.


      if (player.hasStarted()) {
        return;
      }

      if (player.ads.snapshot && player.currentSrc() === player.ads.snapshot.currentSrc) {
        return;
      } // If an ad isn't playing, don't try to play an ad. This could result from prefixed
      // events when the player is blocked by a preroll check, but there is no preroll.


      if (!player.ads.inAdBreak()) {
        return;
      }

      var playPromise = player.play();

      if (playPromise && playPromise.catch) {
        playPromise.catch(function (error) {
          videojs.log.warn('Play promise rejected when playing ad', error);
        });
      }
    });
    player.on('nopreroll', function () {
      player.ads.debug('Received nopreroll event');
      player.ads.nopreroll_ = true;
    });
    player.on('nopostroll', function () {
      player.ads.debug('Received nopostroll event');
      player.ads.nopostroll_ = true;
    }); // Restart the cancelContentPlay process.

    player.on('playing', function () {
      player.ads._cancelledPlay = false;
      player.ads._pausedOnContentupdate = false;
    }); // Keep track of whether a play event has happened

    player.on('play', function () {
      player.ads._playRequested = true;
    });
    player.one('loadstart', function () {
      player.ads._hasThereBeenALoadStartDuringPlayerLife = true;
    });
    player.on('loadeddata', function () {
      player.ads._hasThereBeenALoadedData = true;
    });
    player.on('loadedmetadata', function () {
      player.ads._hasThereBeenALoadedMetaData = true;
    }); // Replace the plugin constructor with the ad namespace

    player.ads = getAds(player);
    player.ads.settings = settings; // Set the stitched ads state. This needs to happen before the `_state` is
    // initialized below - BeforePreroll needs to know whether contrib-ads is
    // playing stitched ads or not.
    // The setter is deprecated, so this does not use it.
    // But first, cast to boolean.

    settings.stitchedAds = !!settings.stitchedAds;

    if (settings.stitchedAds) {
      player.ads._state = new (States.getState('StitchedContentPlayback'))(player);
    } else {
      player.ads._state = new (States.getState('BeforePreroll'))(player);
    }

    player.ads._state.init(player);

    player.ads.cueTextTracks = cueTextTracks;
    player.ads.adMacroReplacement = adMacroReplacement.bind(player); // Start sending contentupdate and contentchanged events for this player

    initializeContentupdate(player); // Global contentchanged handler for resetting plugin state

    player.on('contentchanged', player.ads.reset); // A utility method for textTrackChangeHandler to define the conditions
    // when text tracks should be disabled.
    // Currently this includes:
    //  - on iOS with native text tracks, during an ad playing

    var shouldDisableTracks = function shouldDisableTracks() {
      // If the platform matches iOS with native text tracks
      // and this occurs during ad playback, we should disable tracks again.
      // If shouldPlayContentBehindAd, no special handling is needed.
      return !player.ads.shouldPlayContentBehindAd(player) && player.ads.inAdBreak() && player.tech_.featuresNativeTextTracks && videojs.browser.IS_IOS && // older versions of video.js did not use an emulated textTrackList
      !Array.isArray(player.textTracks());
    };
    /*
     * iOS Safari will change caption mode to 'showing' if a user previously
     * turned captions on manually for that video source, so this TextTrackList
     * 'change' event handler will re-disable them in case that occurs during ad playback
     */


    var textTrackChangeHandler = function textTrackChangeHandler() {
      var textTrackList = player.textTracks();

      if (shouldDisableTracks()) {
        // We must double check all tracks
        for (var i = 0; i < textTrackList.length; i++) {
          var track = textTrackList[i];

          if (track.mode === 'showing') {
            track.mode = 'disabled';
          }
        }
      }
    }; // Add the listener to the text track list


    player.ready(function () {
      player.textTracks().addEventListener('change', textTrackChangeHandler);
    }); // Event handling for the current state.

    player.on(['play', 'playing', 'ended', 'adsready', 'adscanceled', 'adskip', 'adserror', 'adtimeout', 'adended', 'ads-ad-started', 'contentchanged', 'dispose', 'contentresumed', 'readyforpostroll', 'nopreroll', 'nopostroll'], function (e) {
      player.ads._state.handleEvent(e.type);
    }); // Clear timeouts and handlers when player is disposed

    player.on('dispose', function () {
      player.ads.reset();
      player.textTracks().removeEventListener('change', textTrackChangeHandler);
    }); // Listen to TCF changes

    listenToTcf(); // Can be called for testing, or if the TCF CMP has loaded late

    player.ads.listenToTcf = listenToTcf;
  }; // Expose the contrib-ads version before it is initialized. Will be replaced
  // after initialization in ads.js


  contribAdsPlugin.VERSION = version; // Attempt to register the plugin, if we can.

  register(contribAdsPlugin);

  return contribAdsPlugin;

}));
