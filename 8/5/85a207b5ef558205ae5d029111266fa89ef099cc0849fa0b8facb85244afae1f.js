import{removeNodes as S}from"./dom.js";import{insertNodeIntoTemplate as h,removeNodesFromTemplate as u}from"./modify-template.js";import{parts as g,render as C}from"./render.js";import{templateCaches as l}from"./template-factory.js";import{TemplateInstance as j}from"./template-instance.js";import{marker,Template as m}from"./template.js";export{html,svg,TemplateResult}from"../lit-html.js";const p=let T=true;if(typeof window.ShadyCSS==="undefined"){T=false}else if(typeof window.ShadyCSS.prepareTemplateDom==="undefined"){console.warn(`Incompatible ShadyCSS version detected. `+`Please update to at least @webcomponents/webcomponentsjs@2.0.2 and `+`@webcomponents/shadycss@1.3.1.`);T=false}export const shadyTemplateFactory=scopeName=>result=>{const t=p(result.type,scopeName);let o=l.get(t);if(o===undefined){o={stringsArray:new WeakMap,keyString:new Map};l.set(t,o)}let i=o.stringsArray.get(result.strings);if(i!==undefined){return i}const key=result.strings.join(marker);i=o.keyString.get(key);if(i===undefined){const element=result.getTemplateElement();if(T){window.ShadyCSS.prepareTemplateDom(element,scopeName)}i=new m(result,element);o.keyString.set(key,i)}o.stringsArray.set(result.strings,i);return i};const t=["html","svg"];const v=scopeName=>{t.forEach(type=>{const t=l.get(p(type,scopeName));if(t!==undefined){t.keyString.forEach(t=>{const{element:{content}}=t;const o=new Set;Array.from(content.querySelectorAll("style")).forEach(;u(t,o)})}})};const A=new Set;const k=(scopeName,t,o)=>{A.add(scopeName);const i=!!o?o.element:document.createElement("template");const l=t.querySelectorAll("style");const{length}=l;if(length===0){window.ShadyCSS.prepareTemplateStyles(i,scopeName);return}const m=document.createElement("style");for(let p=0;p<length;p++){const style=l[p];style.parentNode.removeChild(style);m.textContent+=style.textContent}v(scopeName);const content=i.content;if(!!o){h(o,m,content.firstChild)}else{content.insertBefore(m,content.firstChild)}window.ShadyCSS.prepareTemplateStyles(i,scopeName);const style=content.querySelector("style");if(window.ShadyCSS.nativeShadow&&style!==null){t.insertBefore(style.cloneNode(true),t.firstChild)}else if(!!o){content.insertBefore(m,content.firstChild);const S=new Set;S.add(m);u(o,S)}};export const render=(result,t,options)=>{if(!options||typeof options!=="object"||!options.scopeName){throw new Error("The `scopeName` option is required.")}const scopeName=options.scopeName;const o=g.has(t);const i=T&&t.nodeType===11&&!!t.host;const l=i&&!A.has(scopeName);const m=l?document.createDocumentFragment():t;C(result,m,Object.assign({templateFactory:shadyTemplateFactory(scopeName)},options));if(l){const part=g.get(m);g.delete(m);const p=part.value instanceof j?part.value.template:undefined;k(scopeName,m,p);S(t,t.firstChild);t.appendChild(m);g.set(t,part)}if(!o&&i){window.ShadyCSS.styleElement(t.host)}};