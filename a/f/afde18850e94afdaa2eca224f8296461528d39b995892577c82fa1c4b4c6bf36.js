"use strict";(self.webpackChunk_respin_respin_app=self.webpackChunk_respin_respin_app||[]).push([[4439],{75759:(V,A,I)=>{I.d(A,{R:()=>B,A:);var S=I(50542),w=I(71783);class H{writeHandshakeRequestarseHandshakeResponse(n){let s,l;if((0,w.eP)(n)){const k=new Uint8Array(n),C=k.indexOf(S.d.RecordSeparatorCode);if(C===-1)throw new Error("Message is incomplete.");const $=C+1;s=String.fromCharCode.apply(null,Array.prototype.slice.call(k.slice(0,$))),l=k.byteLength>$?k.slice($).buffer:null}else{const k=n,C=k.indexOf(S.d.RecordSeparator);if(C===-1)throw new Error("Message is incomplete.");const $=C+1;s=k.substring(0,$),l=k.length>$?k.substring($):null}const u=S.d.parse(s),g=JSON.parse(u[0]);if(g.type)throw new Error("Expected a handshake response from the server.");return[l,g]}}var P=I(23011),v=I(51458);class K{ror(n){for(const s of this.observers)s.error&&s.error(n)}complete(){for(const n of this.observers)n.complete&&n.complete()}subscribevar L=const z=30*1e3,X=15*1e3;var T;((T||(T={}));class B{constructor(n,s,l,u){this._nextKeepAlive=0,this._freezeEventListener=()=>{this._logger.log(v.i.Warning,"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")},w.j7.isRequired(n,"connection"),w.j7.isRequired(s,"logger"),w.j7.isRequired(l,"protocol"),this.serverTimeoutInMilliseconds=z,this.keepAliveIntervalInMilliseconds=X,this._logger=s,this._protocol=l,this.connection=n,this._reconnectPolicy=u,this._handshakeProtocol=new H,this.connection.onreceive=g=>this._processIncomingData(g),this.connection.onclose=this._callbacks={},this._methods={},this._closedCallbacks=[],this._reconnectingCallbacks=[],this._reconnectedCallbacks=[],this._invocationId=0,this._receivedHandshakeResponse=!1,this._connectionState=T.Disconnected,this._connectionStarted=!1,this._cachedPingMessage=this._protocol.writeMessage({type:P.C.Ping})}baseUrltartWithStateTransitions(){return L(this,null,function*(){if(this._connectionState!==T.Disconnected)return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));this._connectionState=T.Connecting,this._logger.log(v.i.Debug,"Starting HubConnection.");try{yield this._startInternal(),w.t4.isBrowser&&window.document.addEventListener("freeze",this._freezeEventListener),this._connectionState=T.Connected,this._connectionStarted=!0,this._logger.log(v.i.Debug,"HubConnection connected successfully.")}catch(n){return this._connectionState=T.Disconnected,this._logger.log(v.i.Debug,`HubConnection failed to start successfully because of error '${n}'.`),Promise.reject(n)}})}_startInternal(){return L(this,null,function*(){this._stopDuringStartError=void 0,this._receivedHandshakeResponse=!1;const n=new Promise(;yield this.connection.start(this._protocol.transferFormat);try{const s={protocol:this._protocol.name,version:this._protocol.version};if(this._logger.log(v.i.Debug,"Sending handshake request."),yield this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(s)),this._logger.log(v.i.Information,`Using HubProtocol '${this._protocol.name}'.`),this._cleanupTimeout(),this._resetTimeoutPeriod(),this._resetKeepAliveInterval(),yield n,this._stopDuringStartError)throw this._stopDuringStartError}catch(s){throw this._logger.log(v.i.Debug,`Hub handshake failed with error '${s}' during start(). Stopping HubConnection.`),this._cleanupTimeout(),this._cleanupPingTimer(),yield this.connection.stop(s),s}})}stop(){return L(this,null,function*(){const n=this._startPromise;this._stopPromise=this._stopInternal(),yield this._stopPromise;try{yield n}catch(s){}})}_stopInternal(n){return this._connectionState===T.Disconnected?(this._logger.log(v.i.Debug,`Call to HubConnection.stop(${n}) ignored because it is already in the disconnected state.`),Promise.resolve()):this._connectionState===T.Disconnecting?(this._logger.log(v.i.Debug,`Call to HttpConnection.stop(${n}) ignored because the connection is already in the disconnecting state.`),this._stopPromise):(this._connectionState=T.Disconnecting,this._logger.log(v.i.Debug,"Stopping HubConnection."),this._reconnectDelayHandle?(this._logger.log(v.i.Debug,"Connection stopped during reconnect delay. Done reconnecting."),clearTimeout(this._reconnectDelayHandle),this._reconnectDelayHandle=void 0,this._completeClose(),Promise.resolve()):(this._cleanupTimeout(),this._cleanupPingTimer(),this._stopDuringStartError=n||new Error("The connection was stopped before the hub handshake could complete."),this.connection.stop(n)))}stream(n,...s){const[l,u]=this._replaceStreamingParams(s),g=this._createStreamInvocation(n,s,u);let E;const k=new K;return k.cancelCallback=()=>{const C=this._createCancelInvocation(g.invocationId);return delete this._callbacks[g.invocationId],E.then(},this._callbacks[g.invocationId]=(C,$)=>{if($){k.error($);return}else C&&(C.type===P.C.Completion?C.error?k.error(new Error(C.error)):k.complete():k.next(C.item))},E=this._sendWithProtocol(g).catch(C=>{k.error(C),delete this._callbacks[g.invocationId]}),this._launchStreams(l,E),k}nd(n,...s){const[l,u]=this._replaceStreamingParams(s),g=this._sendWithProtocol(this._createInvocation(n,s,!0,u));return this._launchStreams(l,g),g}invoke(n,...s){const[l,u]=this._replaceStreamingParams(s),g=this._createInvocation(n,s,!1,u);return new Promise((k,C)=>{this._callbacks[g.invocationId]=(c,m)=>{if(m){C(m);return}else c&&(c.type===P.C.Completion?c.error?C(new Error(c.error)):k(c.result):C(new Error(`Unexpected message type: ${c.type}`)))};const $=this._sendWithProtocol(g).catch(c=>{C(c),delete this._callbacks[g.invocationId]});this._launchStreams(l,$)})}on(n,s){!n||!s||(n=n.toLowerCase(),this._methods[n]||(this._methods[n]=[]),this._methods[n].indexOf(s)===-1&&this._methods[n].push(s))}off(n,s){if(!n)return;n=n.toLowerCase();const l=this._methods[n];if(l)if(s){const u=l.indexOf(s);u!==-1&&(l.splice(u,1),l.length===0&&delete this._methods[n])}else delete this._methods[n]}onclose(n){n&&this._closedCallbacks.push(n)}onreconnecting(n){n&&this._reconnectingCallbacks.push(n)}processIncomingData(n){if(this._cleanupTimeout(),this._receivedHandshakeResponse||(n=this._processHandshakeResponse(n),this._receivedHandshakeResponse=!0),n){const s=this._protocol.parseMessages(n,this._logger);for(const l of s)switch(l.type){case P.C.Invocation:this._invokeClientMethod(l);break;case P.C.StreamItem:case P.C.Completion:{const u=this._callbacks[l.invocationId];if(u){l.type===P.C.Completion&&delete this._callbacks[l.invocationId];try{u(l)}catch(g){this._logger.log(v.i.Error,`Stream callback threw error: ${(0,w.HH)(g)}`)}}break}case P.C.Ping:break;case P.C.Close:{this._logger.log(v.i.Information,"Close message received from server.");const u=l.error?new Error("Server returned an error on close: "+l.error):void 0;l.allowReconnect===!0?this.connection.stop(u):this._stopPromise=this._stopInternal(u);break}default:this._logger.log(v.i.Warning,`Invalid message type: ${l.type}.`);break}}this._resetTimeoutPeriod()}_processHandshakeResponse(n){let s,l;try{[l,s]=this._handshakeProtocol.parseHandshakeResponse(n)}catch(u){const g="Error parsing handshake response: "+u;this._logger.log(v.i.Error,g);const E=new Error(g);throw this._handshakeRejecter(E),E}if(s.error){const u="Server returned handshake error: "+s.error;this._logger.log(v.i.Error,u);const g=new Error(u);throw this._handshakeRejecter(g),g}else this._logger.log(v.i.Debug,"Server handshake complete.");return this._handshakeResolver(),l}_resetKeepAliveIntervalresetTimeoutPeriod(){if((!this.connection.features||!this.connection.features.inherentKeepAlive)&&(this._timeoutHandle=setTimeout(this.serverTimeoutInMilliseconds),this._pingServerHandle===void 0)){let n=this._nextKeepAlive-new Date().getTime();n<0&&(n=0),this._pingServerHandle=setTimeout(()=>L(this,null,function*(){if(this._connectionState===T.Connected)try{yield this._sendMessage(this._cachedPingMessage)}catch(s){this._cleanupPingTimer()}}),n)}}invokeClientMethod(n){const s=this._methods[n.target.toLowerCase()];if(s){try{s.forEach(l=>l.apply(this,n.arguments))}catch(l){this._logger.log(v.i.Error,`A callback for the method ${n.target.toLowerCase()} threw error '${l}'.`)}if(n.invocationId){const l="Server requested a response, which is not supported in this version of the client.";this._logger.log(v.i.Error,l),this._stopPromise=this._stopInternal(new Error(l))}}else this._logger.log(v.i.Warning,`No client method with the name '${n.target}' found.`)}_connectionClosed(n){this._logger.log(v.i.Debug,`HubConnection.connectionClosed(${n}) called while in state ${this._connectionState}.`),this._stopDuringStartError=this._stopDuringStartError||n||new Error("The underlying connection was closed before the hub handshake could complete."),this._handshakeResolver&&this._handshakeResolver(),this._cancelCallbacksWithError(n||new Error("Invocation canceled due to the underlying connection being closed.")),this._cleanupTimeout(),this._cleanupPingTimer(),this._connectionState===T.Disconnecting?this._completeClose(n):this._connectionState===T.Connected&&this._reconnectPolicy?this._reconnect(n):this._connectionState===T.Connected&&this._completeClose(n)}_completeClose(n){if(this._connectionStarted){this._connectionState=T.Disconnected,this._connectionStarted=!1,w.t4.isBrowser&&window.document.removeEventListener("freeze",this._freezeEventListener);try{this._closedCallbacks.forEach(s=>s.apply(this,[n]))}catch(s){this._logger.log(v.i.Error,`An onclose callback called with error '${n}' threw error '${s}'.`)}}}_reconnect(n){return L(this,null,function*(){const s=Date.now();let l=0,u=n!==void 0?n:new Error("Attempting to reconnect due to a unknown error."),g=this._getNextRetryDelay(l++,0,u);if(g===null){this._logger.log(v.i.Debug,"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."),this._completeClose(n);return}if(this._connectionState=T.Reconnecting,n?this._logger.log(v.i.Information,`Connection reconnecting because of error '${n}'.`):this._logger.log(v.i.Information,"Connection reconnecting."),this._reconnectingCallbacks.length!==0){try{this._reconnectingCallbacks.forEach(}catch(E){this._logger.log(v.i.Error,`An onreconnecting callback called with error '${n}' threw error '${E}'.`)}if(this._connectionState!==T.Reconnecting){this._logger.log(v.i.Debug,"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");return}}for(;g!==null;){if(this._logger.log(v.i.Information,`Reconnect attempt number ${l} will start in ${g} ms.`),yield new Promise(E=>{this._reconnectDelayHandle=setTimeout(E,g)}),this._reconnectDelayHandle=void 0,this._connectionState!==T.Reconnecting){this._logger.log(v.i.Debug,"Connection left the reconnecting state during reconnect delay. Done reconnecting.");return}try{if(yield this._startInternal(),this._connectionState=T.Connected,this._logger.log(v.i.Information,"HubConnection reconnected successfully."),this._reconnectedCallbacks.length!==0)try{this._reconnectedCallbacks.forEach(E=>E.apply(this,[this.connection.connectionId]))}catch(E){this._logger.log(v.i.Error,`An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${E}'.`)}return}catch(E){if(this._logger.log(v.i.Information,`Reconnect attempt failed because of error '${E}'.`),this._connectionState!==T.Reconnecting){this._logger.log(v.i.Debug,`Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`),this._connectionState===T.Disconnecting&&this._completeClose();return}u=E instanceof Error?E:new Error(E.toString()),g=this._getNextRetryDelay(l++,Date.now()-s,u)}}this._logger.log(v.i.Information,`Reconnect retries have been exhausted after ${Date.now()-s} ms and ${l} failed attempts. Connection disconnecting.`),this._completeClose()})}_getNextRetryDelay(n,s,l){try{return this._reconnectPolicy.nextRetryDelayInMilliseconds({elapsedMilliseconds:s,previousRetryCount:n,retryReason:l})}catch(u){return this._logger.log(v.i.Error,`IRetryPolicy.nextRetryDelayInMilliseconds(${n}, ${s}) threw error '${u}'.`),null}}_cancelCallbacksWithError(n){const s=this._callbacks;this._callbacks={},Object.keys(s).forEach(l=>{const u=s[l];try{u(null,n)}catch(g){this._logger.log(v.i.Error,`Stream 'error' callback called with '${n}' threw error: ${(0,w.HH)(g)}`)}})}reateInvocation(n,s,l,u){if(l)return u.length!==0?{arguments:s,streamIds:u,target:n,type:P.C.Invocation}:{arguments:s,target:n,type:P.C.Invocation};{const g=this._invocationId;return this._invocationId++,u.length!==0?{arguments:s,invocationId:g.toString(),streamIds:u,target:n,type:P.C.Invocation}:{arguments:s,invocationId:g.toString(),target:n,type:P.C.Invocation}}}_launchStreams(n,s){if(n.length!==0){s||(s=Promise.resolve());for(const l in n)n[l].subscribe({complete:()=>{s=s.then(},error:u=>{let g;u instanceof Error?g=u.message:u&&u.toString?g=u.toString():g="Unknown error",s=s.then(()=>this._sendWithProtocol(this._createCompletionMessage(l,g)))},next:u=>{s=s.then(()=>this._sendWithProtocol(this._createStreamItemMessage(l,u)))}})}}_replaceStreamingParams(n){const s=[],l=[];for(let u=0;u<n.length;u++){const g=n[u];if(this._isObservable(g)){const E=this._invocationId;this._invocationId++,s[E]=g,l.push(E.toString()),n.splice(u,1)}}return[s,l]}_isObservable(n){return n&&n.subscribe&&typeof n.subscribe=="function"}_createStreamInvocation(n,s,l){const u=this._invocationId;return this._invocationId++,l.length!==0?{arguments:s,invocationId:u.toString(),streamIds:l,target:n,type:P.C.StreamInvocation}:{arguments:s,invocationId:u.toString(),target:n,type:P.C.StreamInvocation}}_createCancelInvocationcreateStreamItemMessagecreateCompletionMessage},82629:(V,A,I)=>{I.d(A,{s:()=>qe});const S=[0,2e3,1e4,3e4,null];class w{constructor(e){this._retryDelays=e!==void 0?[...e,null]:S}class H extends Error{constructor(e,t){const i=new.target.prototype;super(`${e}: Status code '${t}'`),this.statusCode=t,this.__proto__=i}}class P extends Error{constructor(e="A timeout occurred."){const t=new.target.prototype;super(e),this.__proto__=t}}class v extends Error{constructor(e="An abort occurred."){const t=new.target.prototype;super(e),this.__proto__=t}}class K extends Error{constructor(e,t){const i=new.target.prototype;super(e),this.transport=t,this.errorType="UnsupportedTransportError",this.__proto__=i}}class L extends Error{constructor(e,t){const i=new.target.prototype;super(e),this.transport=t,this.errorType="DisabledTransportError",this.__proto__=i}}class z extends Error{constructor(e,t){const i=new.target.prototype;super(e),this.transport=t,this.errorType="FailedToStartTransportError",this.__proto__=i}}class X extends Error{constructor(e){const t=new.target.prototype;super(e),this.errorType="FailedToNegotiateWithServerError",this.__proto__=t}}class T extends Error{constructor(e,t){const i=new.target.prototype;super(e),this.innerErrors=t,this.__proto__=i}}var B=Object.defineProperty,W=Object.defineProperties,n=Object.getOwnPropertyDescriptors,s=Object.getOwnPropertySymbols,l=Object.prototype.hasOwnProperty,u=Object.prototype.propertyIsEnumerable,g=(o,e,t)=>e in o?B(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,E=(o,e)=>{for(var t in e||(e={}))l.call(e,t)&&g(o,t,e[t]);if(s)for(var t of s(e))u.call(e,t)&&g(o,t,e[t]);return o},k=(o,e)=>W(o,n(e));lass ${get(e,t){return this.send(k(E({},t),{method:"GET",url:e}))}post(e,t){return this.send(k(E({},t),{method:"POST",url:e}))}delete(e,t){return this.send(k(E({},t),{method:"DELETE",url:e}))}var c=I(51458),m=I(71783),ee=Object.defineProperty,Y=Object.getOwnPropertySymbols,te=Object.prototype.hasOwnProperty,ne=Object.prototype.propertyIsEnumerable,p=(o,e,t)=>e in o?ee(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,f=(o,e)=>{for(var t in e||(e={}))te.call(e,t)&&p(o,t,e[t]);if(Y)for(var t of Y(e))ne.call(e,t)&&p(o,t,e[t]);return o},y=(o,e,t)=>new Promise((i,r)=>{var h=a=>{try{_(t.next(a))}catch(b){r(b)}},d=a=>{try{_(t.throw(a))}catch(b){r(b)}},_=a=>a.done?i(a.value):Promise.resolve(a.value).then(h,d);_((t=t.apply(o,e)).next())});class x extends ${constructor(e){if(super(),this._logger=e,typeof fetch=="undefined"){const t=require;this._jar=new(t("tough-cookie")).CookieJar,this._fetchType=t("node-fetch"),this._fetchType=t("fetch-cookie")(this._fetchType,this._jar)}else this._fetchType=fetch.bind((0,m.E9)());if(typeof AbortController=="undefined"){const t=require;this._abortControllerType=t("abort-controller")}else this._abortControllerType=AbortController}send(e){return y(this,null,function*(){if(e.abortSignal&&e.abortSignal.aborted)throw new v;if(!e.method)throw new Error("No method defined.");if(!e.url)throw new Error("No url defined.");const t=new this._abortControllerType;let i;e.abortSignal&&(e.abortSignal.onabort=;let r=null;if(e.timeout){const a=e.timeout;r=setTimeout(()=>{t.abort(),this._logger.log(c.i.Warning,"Timeout from HTTP request."),i=new P},a)}let h;try{h=yield this._fetchType(e.url,{body:e.content,cache:"no-cache",credentials:e.withCredentials===!0?"include":"same-origin",headers:f({"Content-Type":"text/plain;charset=UTF-8","X-Requested-With":"XMLHttpRequest"},e.headers),method:e.method,mode:"cors",redirect:"follow",signal:t.signal})}catch(a){throw i||(this._logger.log(c.i.Warning,`Error from HTTP request. ${a}.`),a)}finally{r&&clearTimeout(r),e.abortSignal&&(e.abortSignal.onabort=null)}if(!h.ok){const a=yield R(h,"text");throw new H(a||h.statusText,h.status)}const _=yield R(h,e.responseType);return new C(h.status,h.statusText,_)})}getCookieString(e){let t="";return m.t4.isNode&&this._jar&&this._jar.getCookies(e,(i,r)=>t=r.join("; ")),t}}function R(o,e){let t;switch(e){case"arraybuffer":t=o.arrayBuffer();break;case"text":t=o.text();break;case"blob":case"document":case"json":throw new Error(`${e} is not supported.`);default:t=o.text();break}return t}class N extends ${end(e){return e.abortSignal&&e.abortSignal.aborted?Promise.reject(new v):e.method?e.url?new Promise((t,i)=>{const r=new XMLHttpRequest;r.open(e.method,e.url,!0),r.withCredentials=e.withCredentials===void 0?!0:e.withCredentials,r.setRequestHeader("X-Requested-With","XMLHttpRequest"),r.setRequestHeader("Content-Type","text/plain;charset=UTF-8");const h=e.headers;h&&Object.keys(h).forEach(,e.responseType&&(r.responseType=e.responseType),e.abortSignal&&(e.abortSignal.onabort=()=>{r.abort(),i(new v)}),e.timeout&&(r.timeout=e.timeout),r.onload=()=>{e.abortSignal&&(e.abortSignal.onabort=null),r.status>=200&&r.status<300?t(new C(r.status,r.statusText,r.response||r.responseText)):i(new H(r.response||r.responseText||r.statusText,r.status))},r.onerror=()=>{this._logger.log(c.i.Warning,`Error from HTTP request. ${r.status}: ${r.statusText}.`),i(new H(r.statusText,r.status))},r.ontimeout=()=>{this._logger.log(c.i.Warning,"Timeout from HTTP request."),i(new P)},r.send(e.content||"")}):Promise.reject(new Error("No url defined.")):Promise.reject(new Error("No method defined."))}}class M extends ${constructor(e){if(super(),typeof fetch!="undefined"||m.t4.isNode)this._httpClient=new x(e);else if(typeof XMLHttpRequest!="undefined")this._httpClient=new N(e);else throw new Error("No usable HttpClient found.")}sendAuthorization="Authorization",j.Cookie="Cookie";var D;((D||(D={}));var O;((O||(O={}));class oe{ aborted(){return this._isAborted}}var re=Object.defineProperty,J=Object.getOwnPropertySymbols,ke=Object.prototype.hasOwnProperty,Ie=Object.prototype.propertyIsEnumerable,ae=(o,e,t)=>e in o?re(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,ie=(o,e)=>{for(var t in e||(e={}))ke.call(e,t)&&ae(o,t,e[t]);if(J)for(var t of J(e))Ie.call(e,t)&&ae(o,t,e[t]);return o},G=(o,e,t)=>new Promise((i,r)=>{var h=a=>{try{_(t.next(a))}catch(b){r(b)}},d=a=>{try{_(t.throw(a))}catch(b){r(b)}},_=a=>a.done?i(a.value):Promise.resolve(a.value).then(h,d);_((t=t.apply(o,e)).next())});class le{constructor(e,t,i,r){this._httpClient=e,this._accessTokenFactory=t,this._logger=i,this._pollAbort=new oe,this._options=r,this._running=!1,this.onreceive=null,this.onclose=null}onnect(e,t){return G(this,null,function*(){if(m.j7.isRequired(e,"url"),m.j7.isRequired(t,"transferFormat"),m.j7.isIn(t,O,"transferFormat"),this._url=e,this._logger.log(c.i.Trace,"(LongPolling transport) Connecting."),t===O.Binary&&typeof XMLHttpRequest!="undefined"&&typeof new XMLHttpRequest().responseType!="string")throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");const[i,r]=(0,m.hS)(),h=ie({[i]:r},this._options.headers),d={abortSignal:this._pollAbort.signal,headers:h,timeout:1e5,withCredentials:this._options.withCredentials};t===O.Binary&&(d.responseType="arraybuffer");const _=yield this._getAccessToken();this._updateHeaderToken(d,_);const a=`${e}&_=${Date.now()}`;this._logger.log(c.i.Trace,`(LongPolling transport) polling: ${a}.`);const b=yield this._httpClient.get(a,d);b.statusCode!==200?(this._logger.log(c.i.Error,`(LongPolling transport) Unexpected response code: ${b.statusCode}.`),this._closeError=new H(b.statusText||"",b.statusCode),this._running=!1):this._running=!0,this._receiving=this._poll(this._url,d)})}_getAccessToken(){return G(this,null,function*(){return this._accessTokenFactory?yield this._accessTokenFactory():null})}_updateHeaderToken(e,t){if(e.headers||(e.headers={}),t){e.headers[j.Authorization]=`Bearer ${t}`;return}e.headers[j.Authorization]&&delete e.headers[j.Authorization]}_poll(e,t){return G(this,null,function*(){try{for(;this._running;){const i=yield this._getAccessToken();this._updateHeaderToken(t,i);try{const r=`${e}&_=${Date.now()}`;this._logger.log(c.i.Trace,`(LongPolling transport) polling: ${r}.`);const h=yield this._httpClient.get(r,t);h.statusCode===204?(this._logger.log(c.i.Information,"(LongPolling transport) Poll terminated by server."),this._running=!1):h.statusCode!==200?(this._logger.log(c.i.Error,`(LongPolling transport) Unexpected response code: ${h.statusCode}.`),this._closeError=new H(h.statusText||"",h.statusCode),this._running=!1):h.content?(this._logger.log(c.i.Trace,`(LongPolling transport) data received. ${(0,m.o4)(h.content,this._options.logMessageContent)}.`),this.onreceive&&this.onreceive(h.content)):this._logger.log(c.i.Trace,"(LongPolling transport) Poll timed out, reissuing.")}catch(r){this._running?r instanceof P?this._logger.log(c.i.Trace,"(LongPolling transport) Poll timed out, reissuing."):(this._closeError=r,this._running=!1):this._logger.log(c.i.Trace,`(LongPolling transport) Poll errored after shutdown: ${r.message}`)}}}finally{this._logger.log(c.i.Trace,"(LongPolling transport) Polling complete."),this.pollAborted||this._raiseOnClose()}})}send(e){return G(this,null,function*(){return this._running?(0,m.bG)(this._logger,"LongPolling",this._httpClient,this._url,this._accessTokenFactory,e,this._options):Promise.reject(new Error("Cannot send until the transport is connected"))})}stop(){return G(this,null,function*(){this._logger.log(c.i.Trace,"(LongPolling transport) Stopping polling."),this._running=!1,this._pollAbort.abort();try{yield this._receiving,this._logger.log(c.i.Trace,`(LongPolling transport) sending DELETE request to ${this._url}.`);const e={},[t,i]=(0,m.hS)();e[t]=i;const r={headers:ie(ie({},e),this._options.headers),timeout:this._options.timeout,withCredentials:this._options.withCredentials},h=yield this._getAccessToken();this._updateHeaderToken(r,h),yield this._httpClient.delete(this._url,r),this._logger.log(c.i.Trace,"(LongPolling transport) DELETE request sent.")}finally{this._logger.log(c.i.Trace,"(LongPolling transport) Stop finished."),this._raiseOnClose()}})}_raiseOnClosevar Te=Object.defineProperty,he=Object.getOwnPropertySymbols,De=Object.prototype.hasOwnProperty,$e=Object.prototype.propertyIsEnumerable,ue=(o,e,t)=>e in o?Te(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,de=(o,e)=>{for(var t in e||(e={}))De.call(e,t)&&ue(o,t,e[t]);if(he)for(var t of he(e))$e.call(e,t)&&ue(o,t,e[t]);return o},ge=(o,e,t)=>new Promise((i,r)=>{var h=a=>{try{_(t.next(a))}catch(b){r(b)}},d=a=>{try{_(t.throw(a))}catch(b){r(b)}},_=a=>a.done?i(a.value):Promise.resolve(a.value).then(h,d);_((t=t.apply(o,e)).next())});class Oe{onnect(e,t){return ge(this,null,function*(){if(m.j7.isRequired(e,"url"),m.j7.isRequired(t,"transferFormat"),m.j7.isIn(t,O,"transferFormat"),this._logger.log(c.i.Trace,"(SSE transport) Connecting."),this._url=e,this._accessTokenFactory){const i=yield this._accessTokenFactory();i&&(e+=(e.indexOf("?")<0?"?":"&")+`access_token=${encodeURIComponent(i)}`)}return new Promise((i,r)=>{let h=!1;if(t!==O.Text){r(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));return}let d;if(m.t4.isBrowser||m.t4.isWebWorker)d=new this._options.EventSource(e,{withCredentials:this._options.withCredentials});else{const _=this._httpClient.getCookieString(e),a={};a.Cookie=_;const[b,U]=(0,m.hS)();a[b]=U,d=new this._options.EventSource(e,{withCredentials:this._options.withCredentials,headers:de(de({},a),this._options.headers)})}try{d.onmessage=_=>{if(this.onreceive)try{this._logger.log(c.i.Trace,`(SSE transport) data received. ${(0,m.o4)(_.data,this._options.logMessageContent)}.`),this.onreceive(_.data)}catch(a){this._close(a);return}},d.onerror=_=>{h?this._close():r(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."))},d.onopen=()=>{this._logger.log(c.i.Information,`SSE connected to ${this._url}`),this._eventSource=d,h=!0,i()}}catch(_){r(_);return}})})}send(e){return ge(this,null,function*(){return this._eventSource?(0,m.bG)(this._logger,"SSE",this._httpClient,this._url,this._accessTokenFactory,e,this._options):Promise.reject(new Error("Cannot send until the transport is connected"))})}closevar Re=Object.defineProperty,pe=Object.getOwnPropertySymbols,He=Object.prototype.hasOwnProperty,xe=Object.prototype.propertyIsEnumerable,fe=(o,e,t)=>e in o?Re(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,_e=(o,e)=>{for(var t in e||(e={}))He.call(e,t)&&fe(o,t,e[t]);if(pe)for(var t of pe(e))xe.call(e,t)&&fe(o,t,e[t]);return o},je=(o,e,t)=>new Promise((i,r)=>{var h=a=>{try{_(t.next(a))}catch(b){r(b)}},d=a=>{try{_(t.throw(a))}catch(b){r(b)}},_=a=>a.done?i(a.value):Promise.resolve(a.value).then(h,d);_((t=t.apply(o,e)).next())});class Ae{constructor(e,t,i,r,h,d){this._logger=i,this._accessTokenFactory=t,this._logMessageContent=r,this._webSocketConstructor=h,this._httpClient=e,this.onreceive=null,this.onclose=null,this._headers=d}connect(e,t){return je(this,null,function*(){if(m.j7.isRequired(e,"url"),m.j7.isRequired(t,"transferFormat"),m.j7.isIn(t,O,"transferFormat"),this._logger.log(c.i.Trace,"(WebSockets transport) Connecting."),this._accessTokenFactory){const i=yield this._accessTokenFactory();i&&(e+=(e.indexOf("?")<0?"?":"&")+`access_token=${encodeURIComponent(i)}`)}return new Promise((i,r)=>{e=e.replace(/^http/,"ws");let h;const d=this._httpClient.getCookieString(e);let _=!1;if(m.t4.isNode){const a={},[b,U]=(0,m.hS)();a[b]=U,d&&(a[j.Cookie]=`${d}`),h=new this._webSocketConstructor(e,void 0,{headers:_e(_e({},a),this._headers)})}h||(h=new this._webSocketConstructor(e)),t===O.Binary&&(h.binaryType="arraybuffer"),h.onopen=a=>{this._logger.log(c.i.Information,`WebSocket connected to ${e}.`),this._webSocket=h,_=!0,i()},h.onerror=a=>{let b=null;typeof ErrorEvent!="undefined"&&a instanceof ErrorEvent?b=a.error:b="There was an error with the transport",this._logger.log(c.i.Information,`(WebSockets transport) ${b}.`)},h.onmessage=a=>{if(this._logger.log(c.i.Trace,`(WebSockets transport) data received. ${(0,m.o4)(a.data,this._logMessageContent)}.`),this.onreceive)try{this.onreceive(a.data)}catch(b){this._close(b);return}},h.onclose=a=>{if(_)this._close(a);else{let b=null;typeof ErrorEvent!="undefined"&&a instanceof ErrorEvent?b=a.error:b="WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.",r(new Error(b))}}})})}send(e){return this._webSocket&&this._webSocket.readyState===this._webSocketConstructor.OPEN?(this._logger.log(c.i.Trace,`(WebSockets transport) sending data. ${(0,m.o4)(e,this._logMessageContent)}.`),this._webSocket.send(e),Promise.resolve()):Promise.reject("WebSocket is not in the OPEN state")}stopclose(e){this._webSocket&&(this._webSocket.onclose=()=>{},this._webSocket.onmessage=()=>{},this._webSocket.onerror=()=>{},this._webSocket.close(),this._webSocket=void 0),this._logger.log(c.i.Trace,"(WebSockets transport) socket closed."),this.onclose&&(this._isCloseEvent(e)&&(e.wasClean===!1||e.code!==1e3)?this.onclose(new Error(`WebSocket closed with status code: ${e.code} (${e.reason||"no reason given"}).`)):e instanceof Error?this.onclose(e):this.onclose())}_isCloseEvent(e){return e&&typeof e.wasClean=="boolean"&&typeof e.code=="number"}}var We=Object.defineProperty,me=Object.getOwnPropertySymbols,Ne=Object.prototype.hasOwnProperty,Le=Object.prototype.propertyIsEnumerable,we=(o,e,t)=>e in o?We(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,ve=(o,e)=>{for(var t in e||(e={}))Ne.call(e,t)&&we(o,t,e[t]);if(me)for(var t of me(e))Le.call(e,t)&&we(o,t,e[t]);return o},F=(o,e,t)=>new Promise((i,r)=>{var h=a=>{try{_(t.next(a))}catch(b){r(b)}},d=a=>{try{_(t.throw(a))}catch(b){r(b)}},_=a=>a.done?i(a.value):Promise.resolve(a.value).then(h,d);_((t=t.apply(o,e)).next())});const be=100;class Me{constructor(e,t={}){if(this._stopPromiseResolver=this.features={},this._negotiateVersion=1,m.j7.isRequired(e,"url"),this._logger=(0,m.hu)(t.logger),this.baseUrl=this._resolveUrl(e),t=t||{},t.logMessageContent=t.logMessageContent===void 0?!1:t.logMessageContent,typeof t.withCredentials=="boolean"||t.withCredentials===void 0)t.withCredentials=t.withCredentials===void 0?!0:t.withCredentials;else throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");t.timeout=t.timeout===void 0?100*1e3:t.timeout;let i=null,r=null;if(m.t4.isNode){const h=require;i=h("ws"),r=h("eventsource")}!m.t4.isNode&&typeof WebSocket!="undefined"&&!t.WebSocket?t.WebSocket=WebSocket:m.t4.isNode&&!t.WebSocket&&i&&(t.WebSocket=i),!m.t4.isNode&&typeof EventSource!="undefined"&&!t.EventSource?t.EventSource=EventSource:m.t4.isNode&&!t.EventSource&&typeof r!="undefined"&&(t.EventSource=r),this._httpClient=t.httpClient||new M(this._logger),this._connectionState="Disconnected",this._connectionStarted=!1,this._options=t,this.onreceive=null,this.onclose=null}start(e){return F(this,null,function*(){if(e=e||O.Binary,m.j7.isIn(e,O,"transferFormat"),this._logger.log(c.i.Debug,`Starting connection with transfer format '${O[e]}'.`),this._connectionState!=="Disconnected")return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));if(this._connectionState="Connecting",this._startInternalPromise=this._startInternal(e),yield this._startInternalPromise,this._connectionState==="Disconnecting"){const t="Failed to start the HttpConnection before stop() was called.";return this._logger.log(c.i.Error,t),yield this._stopPromise,Promise.reject(new Error(t))}else if(this._connectionState!=="Connected"){const t="HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";return this._logger.log(c.i.Error,t),Promise.reject(new Error(t))}this._connectionStarted=!0})}send(e){return this._connectionState!=="Connected"?Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")):(this._sendQueue||(this._sendQueue=new se(this.transport)),this._sendQueue.send(e))}stop(e){return F(this,null,function*(){if(this._connectionState==="Disconnected")return this._logger.log(c.i.Debug,`Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnected state.`),Promise.resolve();if(this._connectionState==="Disconnecting")return this._logger.log(c.i.Debug,`Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;this._connectionState="Disconnecting",this._stopPromise=new Promise(,yield this._stopInternal(e),yield this._stopPromise})}_stopInternal(e){return F(this,null,function*(){this._stopError=e;try{yield this._startInternalPromise}catch(t){}if(this.transport){try{yield this.transport.stop()}catch(t){this._logger.log(c.i.Error,`HttpConnection.transport.stop() threw error '${t}'.`),this._stopConnection()}this.transport=void 0}else this._logger.log(c.i.Debug,"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")})}_startInternal(e){return F(this,null,function*(){let t=this.baseUrl;this._accessTokenFactory=this._options.accessTokenFactory;try{if(this._options.skipNegotiation)if(this._options.transport===D.WebSockets)this.transport=this._constructTransport(D.WebSockets),yield this._startTransport(t,e);else throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");else{let i=null,r=0;do{if(i=yield this._getNegotiationResponse(t),this._connectionState==="Disconnecting"||this._connectionState==="Disconnected")throw new Error("The connection was stopped during negotiation.");if(i.error)throw new Error(i.error);if(i.ProtocolVersion)throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");if(i.url&&(t=i.url),i.accessToken){const h=i.accessToken;this._accessTokenFactory=()=>h}r++}while(i.url&&r<be);if(r===be&&i.url)throw new Error("Negotiate redirection limit exceeded.");yield this._createTransport(t,this._options.transport,i,e)}this.transport instanceof le&&(this.features.inherentKeepAlive=!0),this._connectionState==="Connecting"&&(this._logger.log(c.i.Debug,"The HttpConnection connected successfully."),this._connectionState="Connected")}catch(i){return this._logger.log(c.i.Error,"Failed to start the connection: "+i),this._connectionState="Disconnected",this.transport=void 0,this._stopPromiseResolver(),Promise.reject(i)}})}_getNegotiationResponse(e){return F(this,null,function*(){const t={};if(this._accessTokenFactory){const d=yield this._accessTokenFactory();d&&(t[j.Authorization]=`Bearer ${d}`)}const[i,r]=(0,m.hS)();t[i]=r;const h=this._resolveNegotiateUrl(e);this._logger.log(c.i.Debug,`Sending negotiation request: ${h}.`);try{const d=yield this._httpClient.post(h,{content:"",headers:ve(ve({},t),this._options.headers),timeout:this._options.timeout,withCredentials:this._options.withCredentials});if(d.statusCode!==200)return Promise.reject(new Error(`Unexpected status code returned from negotiate '${d.statusCode}'`));const _=JSON.parse(d.content);return(!_.negotiateVersion||_.negotiateVersion<1)&&(_.connectionToken=_.connectionId),_}catch(d){let _="Failed to complete negotiation with the server: "+d;return d instanceof H&&d.statusCode===404&&(_=_+" Either this is not a SignalR endpoint or there is a proxy blocking the connection."),this._logger.log(c.i.Error,_),Promise.reject(new X(_))}})}_createConnectUrl(e,t){return t?e+(e.indexOf("?")===-1?"?":"&")+`id=${t}`:e}_createTransport(e,t,i,r){return F(this,null,function*(){let h=this._createConnectUrl(e,i.connectionToken);if(this._isITransport(t)){this._logger.log(c.i.Debug,"Connection was provided an instance of ITransport, using that directly."),this.transport=t,yield this._startTransport(h,r),this.connectionId=i.connectionId;return}const d=[],_=i.availableTransports||[];let a=i;for(const b of _){const U=this._resolveTransportOrError(b,t,r);if(U instanceof Error)d.push(`${b.transport} failed:`),d.push(U);else if(this._isITransport(U)){if(this.transport=U,!a){try{a=yield this._getNegotiationResponse(e)}catch(q){return Promise.reject(q)}h=this._createConnectUrl(e,a.connectionToken)}try{yield this._startTransport(h,r),this.connectionId=a.connectionId;return}catch(q){if(this._logger.log(c.i.Error,`Failed to start the transport '${b.transport}': ${q}`),a=void 0,d.push(new z(`${b.transport} failed: ${q}`,D[b.transport])),this._connectionState!=="Connecting"){const Pe="Failed to select transport before stop() was called.";return this._logger.log(c.i.Debug,Pe),Promise.reject(new Error(Pe))}}}}return d.length>0?Promise.reject(new T(`Unable to connect to the server with any of the available transports. ${d.join(" ")}`,d)):Promise.reject(new Error("None of the transports supported by the client are supported by the server."))})}_constructTransport(e){switch(e){case D.WebSockets:if(!this._options.WebSocket)throw new Error("'WebSocket' is not supported in your environment.");return new Ae(this._httpClient,this._accessTokenFactory,this._logger,this._options.logMessageContent,this._options.WebSocket,this._options.headers||{});case D.ServerSentEvents:if(!this._options.EventSource)throw new Error("'EventSource' is not supported in your environment.");return new Oe(this._httpClient,this._accessTokenFactory,this._logger,this._options);case D.LongPolling:return new le(this._httpClient,this._accessTokenFactory,this._logger,this._options);default:throw new Error(`Unknown transport: ${e}.`)}}_startTransport(e,t){return this.transport.onreceive=this.onreceive,this.transport.onclose=i=>this._stopConnection(i),this.transport.connect(e,t)}_resolveTransportOrError(e,t,i){const r=D[e.transport];if(r==null)return this._logger.log(c.i.Debug,`Skipping transport '${e.transport}' because it is not supported by this client.`),new Error(`Skipping transport '${e.transport}' because it is not supported by this client.`);if(Ue(t,r))if(e.transferFormats.map(d=>O[d]).indexOf(i)>=0){if(r===D.WebSockets&&!this._options.WebSocket||r===D.ServerSentEvents&&!this._options.EventSource)return this._logger.log(c.i.Debug,`Skipping transport '${D[r]}' because it is not supported in your environment.'`),new K(`'${D[r]}' is not supported in your environment.`,r);this._logger.log(c.i.Debug,`Selecting transport '${D[r]}'.`);try{return this._constructTransport(r)}catch(d){return d}}else return this._logger.log(c.i.Debug,`Skipping transport '${D[r]}' because it does not support the requested transfer format '${O[i]}'.`),new Error(`'${D[r]}' does not support ${O[i]}.`);else return this._logger.log(c.i.Debug,`Skipping transport '${D[r]}' because it was disabled by the client.`),new L(`'${D[r]}' is disabled by the client.`,r)}_isITransportstopConnection(e){if(this._logger.log(c.i.Debug,`HttpConnection.stopConnection(${e}) called while in state ${this._connectionState}.`),this.transport=void 0,e=this._stopError||e,this._stopError=void 0,this._connectionState==="Disconnected"){this._logger.log(c.i.Debug,`Call to HttpConnection.stopConnection(${e}) was ignored because the connection is already in the disconnected state.`);return}if(this._connectionState==="Connecting")throw this._logger.log(c.i.Warning,`Call to HttpConnection.stopConnection(${e}) was ignored because the connection is still in the connecting state.`),new Error(`HttpConnection.stopConnection(${e}) was called while the connection is still in the connecting state.`);if(this._connectionState==="Disconnecting"&&this._stopPromiseResolver(),e?this._logger.log(c.i.Error,`Connection disconnected with error '${e}'.`):this._logger.log(c.i.Information,"Connection disconnected."),this._sendQueue&&(this._sendQueue.stop().catch(t=>{this._logger.log(c.i.Error,`TransportSendQueue.stop() threw error '${t}'.`)}),this._sendQueue=void 0),this.connectionId=void 0,this._connectionState="Disconnected",this._connectionStarted){this._connectionStarted=!1;try{this.onclose&&this.onclose(e)}catch(t){this._logger.log(c.i.Error,`HttpConnection.onclose(${e}) threw error '${t}'.`)}}}_resolveUrl(e){if(e.lastIndexOf("https://",0)===0||e.lastIndexOf("http://",0)===0)return e;if(!m.t4.isBrowser)throw new Error(`Cannot resolve '${e}'.`);const t=window.document.createElement("a");return t.href=e,this._logger.log(c.i.Information,`Normalizing '${e}' to '${t.href}'.`),t.href}_resolveNegotiateUrl(e){const t=e.indexOf("?");let i=e.substring(0,t===-1?e.length:t);return i[i.length-1]!=="/"&&(i+="/"),i+="negotiate",i+=t===-1?"":e.substring(t),i.indexOf("negotiateVersion")===-1&&(i+=t===-1?"?":"&",i+="negotiateVersion="+this._negotiateVersion),i}}lass se{constructor(e){this._transport=e,this._buffer=[],this._executing=!0,this._sendBufferedData=new Z,this._transportResult=new Z,this._sendLoopPromise=this._sendLoop()}sendtopbufferData(e){if(this._buffer.length&&typeof this._buffer[0]!=typeof e)throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof e}`);this._buffer.push(e),this._sendBufferedData.resolve()}_sendLoop(){return F(this,null,function*(){for(;;){if(yield this._sendBufferedData.promise,!this._executing){this._transportResult&&this._transportResult.reject("Connection stopped.");break}this._sendBufferedData=new Z;const e=this._transportResult;this._transportResult=void 0;const t=typeof this._buffer[0]=="string"?this._buffer.join(""):se._concatBuffers(this._buffer);this._buffer.length=0;try{yield this._transport.send(t),e.resolve()}catch(i){e.reject(i)}}})}static _concatBuffers(e){const t=e.map(.reduce(,i=new Uint8Array(t);let r=0;for(const h of e)i.set(new Uint8Array(h),r),r+=h.byteLength;return i.buffer}}class Z{constructor(){this.promise=new Promise((e,t)=>[this._resolver,this._rejecter]=[e,t])}ar Be=I(75759),Q=I(23011),ye=I(34835),Se=I(50542);const Fe="json";class Ve{constructor(){this.name=Fe,this.version=1,this.transferFormat=O.Text}parseMessages(e,t){if(typeof e!="string")throw new Error("Invalid input for JSON hub protocol. Expected a string.");if(!e)return[];t===null&&(t=ye.W.instance);const i=Se.d.parse(e),r=[];for(const h of i){const d=JSON.parse(h);if(typeof d.type!="number")throw new Error("Invalid payload.");switch(d.type){case Q.C.Invocation:this._isInvocationMessage(d);break;case Q.C.StreamItem:this._isStreamItemMessage(d);break;case Q.C.Completion:this._isCompletionMessage(d);break;case Q.C.Ping:break;case Q.C.Close:break;default:t.log(c.i.Information,"Unknown message type '"+d.type+"' ignored.");continue}r.push(d)}return r}writeMessage(e){return Se.d.write(JSON.stringify(e))}_isInvocationMessage(e){this._assertNotEmptyString(e.target,"Invalid payload for Invocation message."),e.invocationId!==void 0&&this._assertNotEmptyString(e.invocationId,"Invalid payload for Invocation message.")}_isStreamItemMessage(e){if(this._assertNotEmptyString(e.invocationId,"Invalid payload for StreamItem message."),e.item===void 0)throw new Error("Invalid payload for StreamItem message.")}_isCompletionMessageassertNotEmptyString(e,t){if(typeof e!="string"||e==="")throw new Error(t)}}var ze=Object.defineProperty,Xe=Object.defineProperties,Ke=Object.getOwnPropertyDescriptors,Ce=Object.getOwnPropertySymbols,Je=Object.prototype.hasOwnProperty,Ge=Object.prototype.propertyIsEnumerable,Ee=(o,e,t)=>e in o?ze(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t,ce=(o,e)=>{for(var t in e||(e={}))Je.call(e,t)&&Ee(o,t,e[t]);if(Ce)for(var t of Ce(e))Ge.call(e,t)&&Ee(o,t,e[t]);return o},Qe=const Ye={trace:c.i.Trace,debug:c.i.Debug,info:c.i.Information,information:c.i.Information,warn:c.i.Warning,warning:c.i.Warning,error:c.i.Error,critical:c.i.Critical,none:c.i.None};function Ze(o){const e=Ye[o.toLowerCase()];if(typeof e!="undefined")return e;throw new Error(`Unknown log level: ${o}`)}class qe{configureLogging(e){if(m.j7.isRequired(e,"logging"),et(e))this.logger=e;else if(typeof e=="string"){const t=Ze(e);this.logger=new m.kw(t)}else this.logger=new m.kw(e);return this}withUrl(e,t){return m.j7.isRequired(e,"url"),m.j7.isNotEmpty(e,"url"),this.url=e,typeof t=="object"?this.httpConnectionOptions=ce(ce({},this.httpConnectionOptions),t):this.httpConnectionOptions=Qe(ce({},this.httpConnectionOptions),{transport:t}),this}withHubProtocolithAutomaticReconnectuild(){const e=this.httpConnectionOptions||{};if(e.logger===void 0&&(e.logger=this.logger),!this.url)throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");const t=new Me(this.url,e);return Be.R.create(t,this.logger||ye.W.instance,this.protocol||new Ve,this.reconnectPolicy)}},23011:(V,A,I)=>{I.d(A,{C:()=>S});var S;(function(w){w[w.Invocation=1]="Invocation",w[w.StreamItem=2]="StreamItem",w[w.Completion=3]="Completion",w[w.StreamInvocation=4]="StreamInvocation",w[w.CancelInvocation=5]="CancelInvocation",w[w.Ping=6]="Ping",w[w.Close=7]="Close"})(S||(S={}))},51458:(V,A,I)=>{I.d(A,{i:()=>S});var S;((S||(S={}))},34835:(V,A,I)=>{I.d(A,{W:()=>S});class S{.instance=new S},50542:(V,A,I)=>{I.d(A,{d:()=>S});class S{static writetatic parseS.RecordSeparatorCode=30,S.RecordSeparator=String.fromCharCode(S.RecordSeparatorCode)},71783:(V,A,I)=>{I.d(A,{E9:()=>ne,HH:()=>te,WQ:()=>k,bG:()=>g,eP:()=>u,hS:()=>$,hu:()=>E,j7:()=>W,kw:()=>C,o4:()=>s,t4:()=>n});var S=I(51458),w=I(34835),H=I(52673),P=Object.defineProperty,v=Object.getOwnPropertySymbols,K=Object.prototype.hasOwnProperty,L=Object.prototype.propertyIsEnumerable,z=X=T=(p,f,y)=>new Promise((x,R)=>{var N=D=>{try{j(y.next(D))}catch(O){R(O)}},M=D=>{try{j(y.throw(D))}catch(O){R(O)}},j=D=>D.done?x(D.value):Promise.resolve(D.value).then(N,M);j((y=y.apply(p,f)).next())});const B="6.0.15";class W{static isRequired(f,y){if(f==null)throw new Error(`The '${y}' argument is required.`)}static isNotEmpty(f,y){if(!f||f.match(/^\s*$/))throw new Error(`The '${y}' argument should not be empty.`)}static isIn(f,y,x){if(!(f in y))throw new Error(`Unknown ${x} value: ${f}.`)}}class n{static get isBrowser(){return typeof window=="object"&&typeof window.document=="object"}static get isWebWorker(){return typeof self=="object"&&"importScripts"in self}static get isReactNative(){return typeof window=="object"&&typeof window.document=="undefined"}function s(p,f){let y="";return u(p)?(y=`Binary data of length ${p.byteLength}`,f&&(y+=`. Content: '${l(p)}'`)):typeof p=="string"&&(y=`String data of length ${p.length}`,f&&(y+=`. Content: '${p}'`)),y}function l(p){const f=new Uint8Array(p);let y="";return f.forEach(x=>{const R=x<16?"0":"";y+=`0x${R}${x.toString(16)} `}),y.substr(0,y.length-1)}function u(p){return p&&typeof ArrayBuffer!="undefined"&&(p instanceof ArrayBuffer||p.constructor&&p.constructor.name==="ArrayBuffer")}function g(p,f,y,x,R,N,M){return T(this,null,function*(){let j={};if(R){const J=yield R();J&&(j={Authorization:`Bearer ${J}`})}const[D,O]=$();j[D]=O,p.log(S.i.Trace,`(${f} transport) sending data. ${s(N,M.logMessageContent)}.`);const oe=u(N)?"arraybuffer":"text",re=yield y.post(x,{content:N,headers:X(X({},j),M.headers),responseType:oe,timeout:M.timeout,withCredentials:M.withCredentials});p.log(S.i.Trace,`(${f} transport) request complete. Response status: ${re.statusCode}.`)})}function E(p){return p===void 0?new C(S.i.Information):p===null?w.W.instance:p.log!==void 0?p:new C(p)}class k{ispose(){const f=this._subject.observers.indexOf(this._observer);f>-1&&this._subject.observers.splice(f,1),this._subject.observers.length===0&&this._subject.cancelCallback&&this._subject.cancelCallback().catch(}}class C{og(f,y){if(f>=this._minLevel){const x=`[${new Date().toISOString()}] ${S.i[f]}: ${y}`;switch(f){case S.i.Critical:case S.i.Error:this.out.error(x);break;case S.i.Warning:this.out.warn(x);break;case S.i.Information:this.out.info(x);break;default:this.out.log(x);break}}}}function $(){let p="X-SignalR-User-Agent";return n.isNode&&(p="User-Agent"),[p,c(B,m(),Y(),ee())]}function c(p,f,y,x){let R="Microsoft SignalR/";const N=p.split(".");return R+=`${N[0]}.${N[1]}`,R+=` (${p}; `,f&&f!==""?R+=`${f}; `:R+="Unknown OS; ",R+=`${y}`,x?R+=`; ${x}`:R+="; Unknown Runtime Version",R+=")",R}function m(){if(n.isNode)switch(H.platform){case"win32":return"Windows NT";case"darwin":return"macOS";case"linux":return"Linux";default:return H.platform}else return""}nction te(p){return p.stack?p.stack:p.message?p.message:`${p}`}function ne(){if(typeof globalThis!="undefined")return globalThis;if(typeof self!="undefined")return self;if(typeof window!="undefined")return window;if(typeof I.g!="undefined")return I.g;throw new Error("could not find global")}}}]);
