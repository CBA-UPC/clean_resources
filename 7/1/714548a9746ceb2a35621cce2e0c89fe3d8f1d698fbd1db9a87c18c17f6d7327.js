// threejs.org/license
!this,(function(t){"use strict";void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52)),void 0===Number.isInteger&&(Number.isInteger=,void 0===Math.sign&&(Math.sign=,"name"in Function.prototype==!1&&Object.defineProperty(Function.prototype,"name",{get:),void 0===Object.assign&&(Object.assign=;var e="object"==typeof module?module.exports:{});try{regeneratorRuntime=e}catch(t){Function("r","regeneratorRuntime = r")(e)}var n="125",i=100,r=300,a=301,o=302,s=303,c=304,l=306,u=307,h=1e3,d=1001,p=1002,f=1003,m=1004,v=1005,g=1006,y=1007,x=1008,_=1009,b=1012,w=1014,M=1015,S=1016,T=1020,E=1022,A=1023,L=1026,R=1027,C=33776,P=33777,O=33778,I=33779,D=35840,N=35841,B=35842,z=35843,F=37492,H=37496,G=2300,U=2301,k=2302,V=2400,W=2401,j=2402,q=2500,X=2501,Y=3e3,Z=3001,J=3007,Q=3002,K=3004,$=3005,tt=3006,et=7680,nt=35044,it=35048,rt="300 es";ssign(dt.prototype,{addEventListener:hasEventListener:removeEventListener:dispatchEvent:);for(var pt=[],ft=0;ft<256;ft++)pt[ft]=(ft<16?"0":"")+ft.toString(16);var mt,vt=1234567,gt={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:clamp:euclideanModulo:mapLinear:lerp:damp:pingpong:function(t,e){return void 0===e&&(e=1),e-Math.abs(gt.euclideanModulo(t,2*e)-e)},smoothstep:smootherstep:randInt:randFloat:randFloatSpread:seededRandom:degToRad:function(t){return t*gt.DEG2RAD},radToDeg:isPowerOfTwo:ceilPowerOfTwo:function(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))},floorPowerOfTwo:setQuaternionFromProperEuler:,yt=),xt=function(){ar e=t.prototype;return e.set=e.identity=e.clone=e.copy=e.extractBasis=function(t,e,n){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this},e.setFromMatrix4=e.multiply=e.premultiply=function(t){return this.multiplyMatrices(t,this)},e.multiplyMatrices=e.multiplyScalar=e.determinant=e.invert=e.transpose=e.getNormalMatrix=e.transposeIntoArray=e.setUvTransform=e.scale=e.rotate=e.translate=e.equals=function(t){for(var e=this.elements,n=t.elements,i=0;i<9;i++)if(e[i]!==n[i])return!1;return!0},e.fromArray=function(t,e){void 0===e&&(e=0);for(var n=0;n<9;n++)this.elements[n]=t[n+e];return this},e.toArray=t}(),_t={getDataURL:,bt=0;function wt(t,e,n,i,r,a,o,s,c,l){void 0===t&&(t=wt.DEFAULT_IMAGE),void 0===e&&(e=wt.DEFAULT_MAPPING),void 0===n&&(n=d),void 0===i&&(i=d),void 0===r&&(r=g),void 0===a&&(a=x),void 0===o&&(o=A),void 0===s&&(s=_),void 0===c&&(c=1),void 0===l&&(l=Y),Object.defineProperty(this,"id",{value:bt++}),this.uuid=gt.generateUUID(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=s,this.offset=new yt(0,0),this.repeat=new yt(1,1),this.center=new yt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new xt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=l,this.version=0,this.onUpdate=null}t.DEFAULT_IMAGE=void 0,wt.DEFAULT_MAPPING=r,wt.prototype=Object.assign(Object.create(dt.prototype),{constructor:wt,isTexture:!0,updateMatrix:clone:function(){return(new this.constructor).copy(this)},copy:toJSON:function(t){var e=void 0===t||"string"==typeof t;if(!e&&void 0!==t.textures[this.uuid])return t.textures[this.uuid];var n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){var i=this.image;if(void 0===i.uuid&&(i.uuid=gt.generateUUID()),!e&&void 0===t.images[i.uuid]){var r;if(Array.isArray(i)){r=[];for(var a=0,o=i.length;a<o;a++)i[a].isDataTexture?r.push(Mt(i[a].image)):r.push(Mt(i[a]))}else r=Mt(i);t.images[i.uuid]={uuid:i.uuid,url:r}}n.image=i.uuid}return e||(t.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:),Object.defineProperty(wt.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}});var St=function(){function t(t,e,n,i){void 0===t&&(t=0),void 0===e&&(e=0),void 0===n&&(n=0),void 0===i&&(i=1),Object.defineProperty(this,"isVector4",{value:!0}),this.x=t,this.y=e,this.z=n,this.w=i}var e=t.prototype;return e.set=e.setScalar=e.setX=function(t){return this.x=t,this},e.setY=function(t){return this.y=t,this},e.setZ=function(t){return this.z=t,this},e.setW=function(t){return this.w=t,this},e.setComponent=e.getComponent=e.clone=function(){return new this.constructor(this.x,this.y,this.z,this.w)},e.copy=e.add=e.addScalar=e.addVectors=e.addScaledVector=e.sub=e.subScalar=e.subVectors=e.multiply=e.multiplyScalar=e.applyMatrix4=e.divideScalar=function(t){return this.multiplyScalar(1/t)},e.setAxisAngleFromQuaternion=e.setAxisAngleFromRotationMatrix=e.min=function(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this},e.max=e.clamp=e.clampScalar=e.clampLength=function(t,e){var n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(t,Math.min(e,n)))},e.floor=function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this},e.ceil=function(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this},e.round=e.roundToZero=e.negate=e.dot=function(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w},e.lengthSq=function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},e.length=function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},e.manhattanLength=e.normalize=function(){return this.divideScalar(this.length()||1)},e.setLength=function(t){return this.normalize().multiplyScalar(t)},e.lerp=e.lerpVectors=e.equals=function(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w},e.fromArray=e.toArray=function(t,e){return void 0===t&&(t=[]),void 0===e&&(e=0),t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t},e.fromBufferAttribute=e.random=st(t,[{key:"width",get:function(){return this.z},set:function(t){this.z=t}},{key:"height",get:function(){return this.w},set:function(t){this.w=t}}]),t}(),Tt=function(t){function e(e,n,i){var r;return r=t.call(this)||this,Object.defineProperty(lt(r),"isWebGLRenderTarget",{value:!0}),r.width=e,r.height=n,r.scissor=new St(0,0,e,n),r.scissorTest=!1,r.viewport=new St(0,0,e,n),i=i||{},r.texture=new wt(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),r.texture.image={},r.texture.image.width=e,r.texture.image.height=n,r.texture.generateMipmaps=void 0!==i.generateMipmaps&&i.generateMipmaps,r.texture.minFilter=void 0!==i.minFilter?i.minFilter:g,r.depthBuffer=void 0===i.depthBuffer||i.depthBuffer,r.stencilBuffer=void 0!==i.stencilBuffer&&i.stencilBuffer,r.depthTexture=void 0!==i.depthTexture?i.depthTexture:null,r}ct(e,t);var n=e.prototype;return n.setSize=n.clone=function(){return(new this.constructor).copy(this)},n.copy=n.dispose=function(){this.dispatchEvent({type:"dispose"})},e}(dt),Et=function(t){function e(e,n,i){var r;return r=t.call(this,e,n,i)||this,Object.defineProperty(lt(r),"isWebGLMultisampleRenderTarget",{value:!0}),r.samples=4,r}return ct(e,t),e.prototype.copy=function(e){return t.prototype.copy.call(this,e),this.samples=e.samples,this},e}(Tt),At=),Lt=),Rt=new Lt,Ct=new At,Pt=function(){ar e=t.prototype;return e.set=function(t,e){return this.min.copy(t),this.max.copy(e),this},e.setFromArray=e.setFromBufferAttribute=e.setFromPoints=e.setFromCenterAndSize=e.setFromObject=e.clone=function(){return(new this.constructor).copy(this)},e.copy=function(t){return this.min.copy(t.min),this.max.copy(t.max),this},e.makeEmpty=e.isEmpty=e.getCenter=e.getSize=e.expandByPoint=function(t){return this.min.min(t),this.max.max(t),this},e.expandByVector=function(t){return this.min.sub(t),this.max.add(t),this},e.expandByScalar=e.expandByObject=e.containsPoint=e.containsBox=e.getParameter=e.intersectsBox=e.intersectsSphere=e.intersectsPlane=e.intersectsTriangle=e.clampPoint=e.distanceToPoint=e.getBoundingSphere=e.intersect=e.union=function(t){return this.min.min(t.min),this.max.max(t.max),this},e.applyMatrix4=e.translate=function(t){return this.min.add(t),this.max.add(t),this},e.equals=function(t){return t.min.equals(this.min)&&t.max.equals(this.max)},t}();ar It=[new Lt,new Lt,new Lt,new Lt,new Lt,new Lt,new Lt,new Lt],Dt=new Lt,Nt=new Pt,Bt=new Lt,zt=new Lt,Ft=new Lt,Ht=new Lt,Gt=new Lt,Ut=new Lt,kt=new Lt,Vt=new Lt,Wt=new Lt,jt=new Lt,qt=new Pt,Xt=),Yt=new Lt,Zt=new Lt,Jt=new Lt,Qt=new Lt,Kt=new Lt,$t=new Lt,te=new Lt,ee=function(){ar e=t.prototype;return e.set=e.clone=function(){return(new this.constructor).copy(this)},e.copy=e.at=e.lookAt=e.recast=e.closestPointToPoint=e.distanceToPoint=e.distanceSqToPoint=e.distanceSqToSegment=e.intersectSphere=e.intersectsSphere=e.distanceToPlane=e.intersectPlane=e.intersectsPlane=e.intersectBox=e.intersectsBox=e.intersectTriangle=e.applyMatrix4=e.equals=t}(),ne=function(){ar e=t.prototype;return e.set=e.identity=e.clone=e.copy=e.copyPosition=e.setFromMatrix3=e.extractBasis=e.makeBasis=e.extractRotation=e.makeRotationFromEuler=e.makeRotationFromQuaternion=e.lookAt=e.multiply=e.premultiply=e.multiplyMatrices=e.multiplyScalar=e.determinant=e.transpose=e.setPosition=e.invert=e.scale=e.getMaxScaleOnAxis=e.makeTranslation=e.makeRotationX=e.makeRotationY=e.makeRotationZ=e.makeRotationAxis=e.makeScale=e.makeShear=e.compose=e.decompose=e.makePerspective=e.makeOrthographic=e.equals=e.fromArray=e.toArray=t}(),ie=new Lt,re=new ne,ae=new Lt(0,0,0),oe=new Lt(1,1,1),se=new Lt,ce=new Lt,le=new Lt,ue=);ue.DefaultOrder="XYZ",ue.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];var he=new ne,de=new At,pe=),fe=0,me=new Lt,ve=new At,ge=new ne,ye=new Lt,xe=new Lt,_e=new Lt,be=new At,we=new Lt(1,0,0),Me=new Lt(0,1,0),Se=new Lt(0,0,1),Te={type:"added"},Ee={type:"removed"};function Ae(){Object.defineProperty(this,"id",{value:fe++}),this.uuid=gt.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ae.DefaultUp.clone();var t=new Lt,e=new ue,n=new At,i=new Lt(1,1,1);e._onChange((),n._onChange((),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ne},normalMatrix:{value:new xt}}),this.matrix=new ne,this.matrixWorld=new ne,this.matrixAutoUpdate=Ae.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new pe,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}Ae.DefaultUp=new Lt(0,1,0),Ae.DefaultMatrixAutoUpdate=!0,Ae.prototype=Object.assign(Object.create(dt.prototype),{constructor:Ae,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:applyQuaternion:function(t){return this.quaternion.premultiply(t),this},setRotationFromAxisAngle:function(t,e){this.quaternion.setFromAxisAngle(t,e)},setRotationFromEuler:setRotationFromMatrix:function(t){this.quaternion.setFromRotationMatrix(t)},setRotationFromQuaternion:function(t){this.quaternion.copy(t)},rotateOnAxis:function(t,e){return ve.setFromAxisAngle(t,e),this.quaternion.multiply(ve),this},rotateOnWorldAxis:rotateX:function(t){return this.rotateOnAxis(we,t)},rotateY:function(t){return this.rotateOnAxis(Me,t)},rotateZ:function(t){return this.rotateOnAxis(Se,t)},translateOnAxis:translateX:function(t){return this.translateOnAxis(we,t)},translateY:function(t){return this.translateOnAxis(Me,t)},translateZ:localToWorld:worldToLocal:lookAt:add:remove:clear:attach:getObjectById:function(t){return this.getObjectByProperty("id",t)},getObjectByName:getObjectByProperty:getWorldPosition:getWorldQuaternion:function(t){return void 0===t&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),t=new At),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(xe,t,_e),t},getWorldScale:getWorldDirection:raycast:function(){},traverse:traverseVisible:traverseAncestors:updateMatrix:updateMatrixWorld:updateWorldMatrix:toJSON:function(t){var e=void 0===t||"string"==typeof t,n={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});var i={};f(i.uuid=this.uuid,i.type=this.type,""!==this.name&&(i.name=this.name),!0===this.castShadow&&(i.castShadow=!0),!0===this.receiveShadow&&(i.receiveShadow=!0),!1===this.visible&&(i.visible=!1),!1===this.frustumCulled&&(i.frustumCulled=!1),0!==this.renderOrder&&(i.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON()),this.isMesh||this.isLine||this.isPoints){i.geometry=r(t.geometries,this.geometry);var a=this.geometry.parameters;if(void 0!==a&&void 0!==a.shapes){var o=a.shapes;if(Array.isArray(o))for(var s=0,c=o.length;s<c;s++){var l=o[s];r(t.shapes,l)}else r(t.shapes,o)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(r(t.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){for(var u=[],h=0,d=this.material.length;h<d;h++)u.push(r(t.materials,this.material[h]));i.material=u}else i.material=r(t.materials,this.material);if(this.children.length>0){i.children=[];for(var p=0;p<this.children.length;p++)i.children.push(this.children[p].toJSON(t).object)}if(this.animations.length>0){i.animations=[];for(var f=0;f<this.animations.length;f++){var m=this.animations[f];i.animations.push(r(t.animations,m))}}if(e){var v=M(t.geometries),g=M(t.materials),y=M(t.textures),x=M(t.images),_=M(t.shapes),b=M(t.skeletons),w=M(t.animations);v.length>0&&(n.geometries=v),g.length>0&&(n.materials=g),y.length>0&&(n.textures=y),x.length>0&&(n.images=x),_.length>0&&(n.shapes=_),b.length>0&&(n.skeletons=b),w.length>0&&(n.animations=w)}return n.object=i,n;function M(t){var e=[];for(var n in t){var i=t[n];delete i.metadata,e.push(i)}return e}},clone:copy:);var Le=new Lt,Re=new Lt,Ce=new xt,Pe=),Oe=new Lt,Ie=new Lt,De=new Lt,Ne=new Lt,Be=new Lt,ze=new Lt,Fe=new Lt,He=new Lt,Ge=new Lt,Ue=new Lt,ke=),Ve={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},We={h:0,s:0,l:0},je={h:0,s:0,l:0}; Ze=function(){ar e=t.prototype;return e.set=e.setScalar=e.setHex=e.setRGB=e.setHSL=e.setStyle=e.setColorName=e.clone=e.copy=e.copyGammaToLinear=e.copyLinearToGamma=e.convertGammaToLinear=function(t){return this.copyGammaToLinear(this,t),this},e.convertLinearToGamma=e.copySRGBToLinear=function(t){return this.r=Xe(t.r),this.g=Xe(t.g),this.b=Xe(t.b),this},e.copyLinearToSRGB=e.convertSRGBToLinear=function(){return this.copySRGBToLinear(this),this},e.convertLinearToSRGB=e.getHex=e.getHexString=e.getHSL=e.getStyle=e.offsetHSL=e.add=e.addColors=e.addScalar=e.sub=e.multiply=e.multiplyScalar=e.lerp=e.lerpColors=e.lerpHSL=e.equals=e.fromArray=e.toArray=e.fromBufferAttribute=e.toJSON=t}();Ze.NAMES=Ve,Ze.prototype.r=1,Ze.prototype.g=1,Ze.prototype.b=1;var Je=function(){function t(t,e,n,i,r,a){void 0===a&&(a=0),this.a=t,this.b=e,this.c=n,this.normal=i&&i.isVector3?i:new Lt,this.vertexNormals=Array.isArray(i)?i:[],this.color=r&&r.isColor?r:new Ze,this.vertexColors=Array.isArray(r)?r:[],this.materialIndex=a}var e=t.prototype;return e.clone=function(){return(new this.constructor).copy(this)},e.copy=t}(),Qe=0;.prototype=Object.assign(Object.create(dt.prototype),{constructor:Ke,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:setValues:toJSON:clone:function(){return(new this.constructor).copy(this)},copy:dispose:function(){this.dispatchEvent({type:"dispose"})}}),Object.defineProperty(Ke.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),$e.prototype=Object.create(Ke.prototype),$e.prototype.constructor=$e,$e.prototype.isMeshBasicMaterial=!0,$e.prototype.copy=var tn=new Lt,en=new yt;unction rn(t,e,n){nn.call(this,new Int8Array(t),e,n)}function an(t,e,n){nn.call(this,new Uint8Array(t),e,n)}function on(t,e,n){nn.call(this,new Uint8ClampedArray(t),e,n)}function sn(t,e,n){nn.call(this,new Int16Array(t),e,n)}function cn(t,e,n){nn.call(this,new Uint16Array(t),e,n)}function ln(t,e,n){nn.call(this,new Int32Array(t),e,n)}function un(t,e,n){nn.call(this,new Uint32Array(t),e,n)}function hn(t,e,n){nn.call(this,new Uint16Array(t),e,n)}function dn(t,e,n){nn.call(this,new Float32Array(t),e,n)}ject.defineProperty(nn.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(nn.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(t){return this.usage=t,this},copy:copyAt:copyArray:function(t){return this.array.set(t),this},copyColorsArray:function(t){for(var e=this.array,n=0,i=0,r=t.length;i<r;i++){var a=t[i];void 0===a&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),a=new Ze),e[n++]=a.r,e[n++]=a.g,e[n++]=a.b}return this},copyVector2sArray:copyVector3sArray:copyVector4sArray:applyMatrix3:applyMatrix4:function(t){for(var e=0,n=this.count;e<n;e++)tn.x=this.getX(e),tn.y=this.getY(e),tn.z=this.getZ(e),tn.applyMatrix4(t),this.setXYZ(e,tn.x,tn.y,tn.z);return this},applyNormalMatrix:function(t){for(var e=0,n=this.count;e<n;e++)tn.x=this.getX(e),tn.y=this.getY(e),tn.z=this.getZ(e),tn.applyNormalMatrix(t),this.setXYZ(e,tn.x,tn.y,tn.z);return this},transformDirection:set:getX:setX:getY:function(t){return this.array[t*this.itemSize+1]},setY:function(t,e){return this.array[t*this.itemSize+1]=e,this},getZ:function(t){return this.array[t*this.itemSize+2]},setZ:function(t,e){return this.array[t*this.itemSize+2]=e,this},getW:setW:setXY:setXYZ:setXYZW:onUpload:function(t){return this.onUploadCallback=t,this},clone:toJSON:),rn.prototype=Object.create(nn.prototype),rn.prototype.constructor=rn,an.prototype=Object.create(nn.prototype),an.prototype.constructor=an,on.prototype=Object.create(nn.prototype),on.prototype.constructor=on,sn.prototype=Object.create(nn.prototype),sn.prototype.constructor=sn,cn.prototype=Object.create(nn.prototype),cn.prototype.constructor=cn,ln.prototype=Object.create(nn.prototype),ln.prototype.constructor=ln,un.prototype=Object.create(nn.prototype),un.prototype.constructor=un,hn.prototype=Object.create(nn.prototype),hn.prototype.constructor=hn,hn.prototype.isFloat16BufferAttribute=!0,dn.prototype=Object.create(nn.prototype),dn.prototype.constructor=dn,pn.prototype=Object.create(nn.prototype),pn.prototype.constructor=pn;var mn={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:"undefined"!=typeof Uint8ClampedArray?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};ar gn=0,yn=new ne,xn=new Ae,_n=new Lt,bn=new Pt,wn=new Pt,Mn=new Lt;function Sn(){Object.defineProperty(this,"id",{value:gn++}),this.uuid=gt.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}Sn.prototype=Object.assign(Object.create(dt.prototype),{constructor:Sn,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:getAttribute:setAttribute:deleteAttribute:hasAttribute:addGroup:function(t,e,n){void 0===n&&(n=0),this.groups.push({start:t,count:e,materialIndex:n})},clearGroups:setDrawRange:applyMatrix4:rotateX:function(t){return yn.makeRotationX(t),this.applyMatrix4(yn),this},rotateY:function(t){return yn.makeRotationY(t),this.applyMatrix4(yn),this},rotateZ:translate:function(t,e,n){return yn.makeTranslation(t,e,n),this.applyMatrix4(yn),this},scale:lookAt:center:setFromPoints:computeBoundingBox:computeBoundingSphere:computeFaceNormals:function(){},computeTangents:function(){var t=this.index,e=this.attributes;if(null!==t&&void 0!==e.position&&void 0!==e.normal&&void 0!==e.uv){var n=t.array,i=e.position.array,r=e.normal.array,a=e.uv.array,o=i.length/3;void 0===e.tangent&&this.setAttribute("tangent",new nn(new Float32Array(4*o),4));for(var s=e.tangent.array,c=[],l=[],u=0;u<o;u++)c[u]=new Lt,l[u]=new Lt;var h=new Lt,d=new Lt,p=new Lt,f=new yt,m=new yt,v=new yt,g=new Lt,y=new Lt,x=this.groups;0===x.length&&(x=[{start:0,count:n.length}]);for(var _=0,b=x.length;_<b;++_)for(var w=x[_],M=w.start,S=M,T=M+w.count;S<T;S+=3)B(n[S+0],n[S+1],n[S+2]);for(var E=new Lt,A=new Lt,L=new Lt,R=new Lt,C=0,P=x.length;C<P;++C)for(var O=x[C],I=O.start,D=I,N=I+O.count;D<N;D+=3)z(n[D+0]),z(n[D+1]),z(n[D+2])}else console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");computeVertexNormals:merge:normalizeNormals:toNonIndexed:toJSON:clone:copy:dispose:);var Tn=new ne,En=new ee,An=new Xt,Ln=new Lt,Rn=new Lt,Cn=new Lt,Pn=new Lt,On=new Lt,In=new Lt,Dn=new Lt,Nn=new Lt,Bn=new Lt,zn=new yt,Fn=new yt,Hn=new yt,Gn=new Lt,Un=new Lt;function kn(t,e){void 0===t&&(t=new Sn),void 0===e&&(e=new $e),Ae.call(this),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}function Vn(t,e,n,i,r,a,o,s,c,l,u,h){Ln.fromBufferAttribute(r,l),Rn.fromBufferAttribute(r,u),Cn.fromBufferAttribute(r,h);var d=t.morphTargetInfluences;if(e.morphTargets&&a&&d){Dn.set(0,0,0),Nn.set(0,0,0),Bn.set(0,0,0);for(var p=0,f=a.length;p<f;p++){var m=d[p],v=a[p];0!==m&&(Pn.fromBufferAttribute(v,l),On.fromBufferAttribute(v,u),In.fromBufferAttribute(v,h),o?(Dn.addScaledVector(Pn,m),Nn.addScaledVector(On,m),Bn.addScaledVector(In,m)):(Dn.addScaledVector(Pn.sub(Ln),m),Nn.addScaledVector(On.sub(Rn),m),Bn.addScaledVector(In.sub(Cn),m)))}Ln.add(Dn),Rn.add(Nn),Cn.add(Bn)}t.isSkinnedMesh&&(t.boneTransform(l,Ln),t.boneTransform(u,Rn),t.boneTransform(h,Cn));var g=function(t,e,n,i,r,a,o,s){if(null===(1===e.side?i.intersectTriangle(o,a,r,!0,s):i.intersectTriangle(r,a,o,2!==e.side,s)))return null;Un.copy(s),Un.applyMatrix4(t.matrixWorld);var c=n.ray.origin.distanceTo(Un);return c<n.near||c>n.far?null:{distance:c,point:Un.clone(),object:t}}(t,e,n,i,Ln,Rn,Cn,Gn);if(g){s&&(zn.fromBufferAttribute(s,l),Fn.fromBufferAttribute(s,u),Hn.fromBufferAttribute(s,h),g.uv=ke.getUV(Gn,Ln,Rn,Cn,zn,Fn,Hn,new yt)),c&&(zn.fromBufferAttribute(c,l),Fn.fromBufferAttribute(c,u),Hn.fromBufferAttribute(c,h),g.uv2=ke.getUV(Gn,Ln,Rn,Cn,zn,Fn,Hn,new yt));var y=new Je(l,u,h);ke.getNormal(Ln,Rn,Cn,y.normal),g.face=y}return g}kn.prototype=Object.assign(Object.create(Ae.prototype),{constructor:kn,isMesh:!0,copy:updateMorphTargets:raycast:function(t,e){var n,i=this.geometry,r=this.material,a=this.matrixWorld;if(void 0!==r&&(null===i.boundingSphere&&i.computeBoundingSphere(),An.copy(i.boundingSphere),An.applyMatrix4(a),!1!==t.ray.intersectsSphere(An)&&(Tn.copy(a).invert(),En.copy(t.ray).applyMatrix4(Tn),null===i.boundingBox||!1!==En.intersectsBox(i.boundingBox))))if(i.isBufferGeometry){var o=i.index,s=i.attributes.position,c=i.morphAttributes.position,l=i.morphTargetsRelative,u=i.attributes.uv,h=i.attributes.uv2,d=i.groups,p=i.drawRange;if(null!==o)if(Array.isArray(r))for(var f=0,m=d.length;f<m;f++)for(var v=d[f],g=r[v.materialIndex],y=Math.max(v.start,p.start),x=Math.min(v.start+v.count,p.start+p.count);y<x;y+=3){var _=o.getX(y),b=o.getX(y+1),w=o.getX(y+2);(n=Vn(this,g,t,En,s,c,l,u,h,_,b,w))&&(n.faceIndex=Math.floor(y/3),n.face.materialIndex=v.materialIndex,e.push(n))}else for(var M=Math.max(0,p.start),S=Math.min(o.count,p.start+p.count);M<S;M+=3){var T=o.getX(M),E=o.getX(M+1),A=o.getX(M+2);(n=Vn(this,r,t,En,s,c,l,u,h,T,E,A))&&(n.faceIndex=Math.floor(M/3),e.push(n))}else if(void 0!==s)if(Array.isArray(r))for(var L=0,R=d.length;L<R;L++)for(var C=d[L],P=r[C.materialIndex],O=Math.max(C.start,p.start),I=Math.min(C.start+C.count,p.start+p.count);O<I;O+=3){(n=Vn(this,P,t,En,s,c,l,u,h,O,O+1,O+2))&&(n.faceIndex=Math.floor(O/3),n.face.materialIndex=C.materialIndex,e.push(n))}else for(var D=Math.max(0,p.start),N=Math.min(s.count,p.start+p.count);D<N;D+=3){(n=Vn(this,r,t,En,s,c,l,u,h,D,D+1,D+2))&&(n.faceIndex=Math.floor(D/3),e.push(n))}}else i.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}});var Wn=Sn);r Xn={clone:jn,merge:qn};nction Jn(t,e,n,i){void 0===t&&(t=50),void 0===e&&(e=1),void 0===n&&(n=.1),void 0===i&&(i=2e3),Zn.call(this),this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}Yn.prototype=Object.create(Ke.prototype),Yn.prototype.constructor=Yn,Yn.prototype.isShaderMaterial=!0,Yn.prototype.copy=Yn.prototype.toJSON=Zn.prototype=Object.assign(Object.create(Ae.prototype),{constructor:Zn,isCamera:!0,copy:getWorldDirection:updateMatrixWorld:function(t){Ae.prototype.updateMatrixWorld.call(this,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(t,e){Ae.prototype.updateWorldMatrix.call(this,t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return(new this.constructor).copy(this)}}),Jn.prototype=Object.assign(Object.create(Zn.prototype),{constructor:Jn,isPerspectiveCamera:!0,copy:setFocalLength:getFocalLength:getEffectiveFOV:getFilmWidth:getFilmHeight:setViewOffset:clearViewOffset:updateProjectionMatrix:function(){var t=this.near,e=t*Math.tan(.5*gt.DEG2RAD*this.fov)/this.zoom,n=2*e,i=this.aspect*n,r=-.5*i,a=this.view;if(null!==this.view&&this.view.enabled){var o=a.fullWidth,s=a.fullHeight;r+=a.offsetX*i/o,e-=a.offsetY*n/s,i*=a.width/o,n*=a.height/s}var c=this.filmOffset;0!==c&&(r+=t*c/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,e,e-n,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:);var Qn=90;function Kn(t,e,n){if(Ae.call(this),this.type="CubeCamera",!0===n.isWebGLCubeRenderTarget){this.renderTarget=n;var i=new Jn(Qn,1,t,e);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new Lt(1,0,0)),this.add(i);var r=new Jn(Qn,1,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new Lt(-1,0,0)),this.add(r);var a=new Jn(Qn,1,t,e);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new Lt(0,1,0)),this.add(a);var o=new Jn(Qn,1,t,e);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new Lt(0,-1,0)),this.add(o);var s=new Jn(Qn,1,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new Lt(0,0,1)),this.add(s);var c=new Jn(Qn,1,t,e);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new Lt(0,0,-1)),this.add(c),this.update=else console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.")}n.prototype=Object.create(Ae.prototype),Kn.prototype.constructor=Kn,$n.prototype=Object.create(wt.prototype),$n.prototype.constructor=$n,$n.prototype.isCubeTexture=!0,Object.defineProperty($n.prototype,"images",{get:function(){return this.image},set:);var ti=function(t){function e(e,n,i){var r;return Number.isInteger(n)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),n=i),r=t.call(this,e,e,n)||this,Object.defineProperty(lt(r),"isWebGLCubeRenderTarget",{value:!0}),n=n||{},r.texture=new $n(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),r.texture._needsFlipEnvMap=!1,r}ct(e,t);var n=e.prototype;return n.fromEquirectangularTexture=n.clear=e}(Tt);i.prototype=Object.create(wt.prototype),ei.prototype.constructor=ei,ei.prototype.isDataTexture=!0;var ni=new Xt,ii=new Lt,ri=function(){ar e=t.prototype;return e.set=e.clone=e.copy=e.setFromProjectionMatrix=e.intersectsObject=e.intersectsSprite=e.intersectsSphere=e.intersectsBox=e.containsPoint=t}();unction oi(t,e){var n=e.isWebGL2,i=new WeakMap;return{get:remove:update:function(e,r){if(e.isGLBufferAttribute){var a=i.get(e);(!a||a.version<e.version)&&i.set(e,{buffer:e.buffer,type:e.type,bytesPerElement:e.elementSize,version:e.version})}else{e.isInterleavedBufferAttribute&&(e=e.data);var o=i.get(e);void 0===o?i.set(e,e,r)):o.version<e.version&&(!o.buffer,e,r),o.version=e.version)}}}}var si=function(t){function e(e,n,i,r){var a;void 0===e&&(e=1),void 0===n&&(n=1),void 0===i&&(i=1),void 0===r&&(r=1),(a=t.call(this)||this).type="PlaneGeometry",a.parameters={width:e,height:n,widthSegments:i,heightSegments:r};for(var o=e/2,s=n/2,c=Math.floor(i),l=Math.floor(r),u=c+1,h=l+1,d=e/c,p=n/l,f=[],m=[],v=[],g=[],y=0;y<h;y++)for(var x=y*p-s,_=0;_<u;_++){var b=_*d-o;m.push(b,-x,0),v.push(0,0,1),g.push(_/c),g.push(1-y/l)}for(var w=0;w<l;w++)for(var M=0;M<c;M++){var S=M+u*w,T=M+u*(w+1),E=M+1+u*(w+1),A=M+1+u*w;f.push(S,T,A),f.push(T,E,A)}return a.setIndex(f),a.setAttribute("position",new dn(m,3)),a.setAttribute("normal",new dn(v,3)),a.setAttribute("uv",new dn(g,2)),a}return ct(e,t),e}(Sn),ci={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",normal_fragment_begin:"#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmissionmap_fragment:"#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",transmissionmap_pars_fragment:"#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",normal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",normal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"},li={common:{diffuse:{value:new Ze(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new xt},uv2Transform:{value:new xt},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new yt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Ze(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Ze(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new xt}},sprite:{diffuse:{value:new Ze(15658734)},opacity:{value:1},center:{value:new yt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new xt}}},ui={basic:{uniforms:qn([li.common,li.specularmap,li.envmap,li.aomap,li.lightmap,li.fog]),vertexShader:ci.meshbasic_vert,fragmentShader:ci.meshbasic_frag},lambert:{uniforms:qn([li.common,li.specularmap,li.envmap,li.aomap,li.lightmap,li.emissivemap,li.fog,li.lights,{emissive:{value:new Ze(0)}}]),vertexShader:ci.meshlambert_vert,fragmentShader:ci.meshlambert_frag},phong:{uniforms:qn([li.common,li.specularmap,li.envmap,li.aomap,li.lightmap,li.emissivemap,li.bumpmap,li.normalmap,li.displacementmap,li.fog,li.lights,{emissive:{value:new Ze(0)},specular:{value:new Ze(1118481)},shininess:{value:30}}]),vertexShader:ci.meshphong_vert,fragmentShader:ci.meshphong_frag},standard:{uniforms:qn([li.common,li.envmap,li.aomap,li.lightmap,li.emissivemap,li.bumpmap,li.normalmap,li.displacementmap,li.roughnessmap,li.metalnessmap,li.fog,li.lights,{emissive:{value:new Ze(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ci.meshphysical_vert,fragmentShader:ci.meshphysical_frag},toon:{uniforms:qn([li.common,li.aomap,li.lightmap,li.emissivemap,li.bumpmap,li.normalmap,li.displacementmap,li.gradientmap,li.fog,li.lights,{emissive:{value:new Ze(0)}}]),vertexShader:ci.meshtoon_vert,fragmentShader:ci.meshtoon_frag},matcap:{uniforms:qn([li.common,li.bumpmap,li.normalmap,li.displacementmap,li.fog,{matcap:{value:null}}]),vertexShader:ci.meshmatcap_vert,fragmentShader:ci.meshmatcap_frag},points:{uniforms:qn([li.points,li.fog]),vertexShader:ci.points_vert,fragmentShader:ci.points_frag},dashed:{uniforms:qn([li.common,li.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ci.linedashed_vert,fragmentShader:ci.linedashed_frag},depth:{uniforms:qn([li.common,li.displacementmap]),vertexShader:ci.depth_vert,fragmentShader:ci.depth_frag},normal:{uniforms:qn([li.common,li.bumpmap,li.normalmap,li.displacementmap,{opacity:{value:1}}]),vertexShader:ci.normal_vert,fragmentShader:ci.normal_frag},sprite:{uniforms:qn([li.sprite,li.fog]),vertexShader:ci.sprite_vert,fragmentShader:ci.sprite_frag},background:{uniforms:{uvTransform:{value:new xt},t2D:{value:null}},vertexShader:ci.background_vert,fragmentShader:ci.background_frag},cube:{uniforms:qn([li.envmap,{opacity:{value:1}}]),vertexShader:ci.cube_vert,fragmentShader:ci.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ci.equirect_vert,fragmentShader:ci.equirect_frag},distanceRGBA:{uniforms:qn([li.common,li.displacementmap,{referencePosition:{value:new Lt},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ci.distanceRGBA_vert,fragmentShader:ci.distanceRGBA_frag},shadow:{uniforms:qn([li.lights,li.fog,{color:{value:new Ze(0)},opacity:{value:1}}]),vertexShader:ci.shadow_vert,fragmentShader:ci.shadow_frag}};function hi(t,e,n,i,r){var a,o,s=new Ze(0),c=0,u=null,h=0,d=null;eturn{getClearColor:function(){return s},setClearColor:function(t,e){void 0===e&&(e=1),s.set(t),p(s,c=e)},getClearAlpha:setClearAlpha:render:function(n,r,f,m){var v=!0===r.isScene?r.background:null;v&&v.isTexture&&(v=e.get(v));var g=t.xr,y=g.getSession&&g.getSession();y&&"additive"===y.environmentBlendMode&&(v=null),null===v?p(s,c):v&&v.isColor&&(p(v,1),m=!0),(t.autoClear||m)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),v&&(v.isCubeTexture||v.isWebGLCubeRenderTarget||v.mapping===l)?(void 0===o&&((o=new kn(new Wn(1,1,1),new Yn({name:"BackgroundCubeMaterial",uniforms:jn(ui.cube.uniforms),vertexShader:ui.cube.vertexShader,fragmentShader:ui.cube.fragmentShader,side:1,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),o.geometry.deleteAttribute("uv"),o.onBeforeRender=Object.defineProperty(o.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(o)),v.isWebGLCubeRenderTarget&&(v=v.texture),o.material.uniforms.envMap.value=v,o.material.uniforms.flipEnvMap.value=v.isCubeTexture&&v._needsFlipEnvMap?-1:1,u===v&&h===v.version&&d===t.toneMapping||(o.material.needsUpdate=!0,u=v,h=v.version,d=t.toneMapping),n.unshift(o,o.geometry,o.material,0,0,null)):v&&v.isTexture&&(void 0===a&&((a=new kn(new si(2,2),new Yn({name:"BackgroundMaterial",uniforms:jn(ui.background.uniforms),vertexShader:ui.background.vertexShader,fragmentShader:ui.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=v,!0===v.matrixAutoUpdate&&v.updateMatrix(),a.material.uniforms.uvTransform.value.copy(v.matrix),u===v&&h===v.version&&d===t.toneMapping||(a.material.needsUpdate=!0,u=v,h=v.version,d=t.toneMapping),n.unshift(a,a.geometry,a.material,0,0,null))}}}function di(t,e,n,i){var r=t.getParameter(34921),a=i.isWebGL2?null:e.get("OES_vertex_array_object"),o=i.isWebGL2||null!==a,s={},c=d(null),l=c;function u(e){return i.isWebGL2?t.bindVertexArray(e):a.bindVertexArrayOES(e)}tup:function(r,c,h,y,x){var _=!1;if(o){var b=y,h,c);l!==b&&u((l=b).object),(_=function(t,e){var n=l.attributes,i=t.attributes,r=0;for(var a in i){var o=n[a],s=i[a];if(void 0===o)return!0;if(o.attribute!==s)return!0;if(o.data!==s.data)return!0;r++}return l.attributesNum!==r||l.index!==e}(y,x))&&function(t,e){var n={},i=t.attributes,r=0;for(var a in i){var o=i[a],s={};s.attribute=o,o.data&&(s.data=o.data),n[a]=s,r++}l.attributes=n,l.attributesNum=r,l.index=e}(y,x)}else{var w=!0===c.wireframe;l.geometry===y.id&&l.program===h.id&&l.wireframe===w||(l.geometry=y.id,l.program=h.id,l.wireframe=w,_=!0)}!0===r.isInstancedMesh&&(_=!0),null!==x&&n.update(x,34963),_&&(!r,c,h,y),null!==x&&t.bindBuffer(34963,n.get(x).buffer))},reset:y,resetDefaultState:x,dispose:releaseStatesOfGeometry:releaseStatesOfProgram:initAttributes:p,enableAttribute:f,disableUnusedAttributes:v}}ction vi(t){var e=new WeakMap;turn{get:function(r){if(r&&r.isTexture){var a=r.mapping;if(a===s||a===c){if(e.has(r))return n(e.get(r).texture,r.mapping);var o=r.image;if(o&&o.height>0){var l=t.getRenderList(),u=t.getRenderTarget(),h=new ti(o.height/2);return h.fromEquirectangularTexture(t,r),e.set(r,h),t.setRenderTarget(u),t.setRenderList(l),r.addEventListener("dispose",i),n(h.texture,r.mapping)}return null}}return r},dispose:function(){e=new WeakMap}}}unction yi(t,e,n,i){var r={},a=new WeakMap;turn{get:update:getWireframeAttribute:}tion Mi(t){for(var e={},n=new Float32Array(8),i=[],r=0;r<8;r++)i[r]=[r,0];return{update:function(r,a,o,s){var c=r.morphTargetInfluences,l=void 0===c?0:c.length,u=e[a.id];if(void 0===u){u=[];for(var h=0;h<l;h++)u[h]=[h,0];e[a.id]=u}for(var d=0;d<l;d++){var p=u[d];p[0]=d,p[1]=c[d]}u.sort(wi);for(var f=0;f<8;f++)f<l&&u[f][1]?(i[f][0]=u[f][0],i[f][1]=u[f][1]):(i[f][0]=Number.MAX_SAFE_INTEGER,i[f][1]=0);i.sort(bi);for(var m=o.morphTargets&&a.morphAttributes.position,v=o.morphNormals&&a.morphAttributes.normal,g=0,y=0;y<8;y++){var x=i[y],_=x[0],b=x[1];_!==Number.MAX_SAFE_INTEGER&&b?(m&&a.getAttribute("morphTarget"+y)!==m[_]&&a.setAttribute("morphTarget"+y,m[_]),v&&a.getAttribute("morphNormal"+y)!==v[_]&&a.setAttribute("morphNormal"+y,v[_]),n[y]=b,g+=b):(m&&!0===a.hasAttribute("morphTarget"+y)&&a.deleteAttribute("morphTarget"+y),v&&!0===a.hasAttribute("morphNormal"+y)&&a.deleteAttribute("morphNormal"+y),n[y]=0)}var w=a.morphTargetsRelative?1:1-g;s.getUniforms().setValue(t,"morphTargetBaseInfluence",w),s.getUniforms().setValue(t,"morphTargetInfluences",n)}}}unction Ti(t,e,n,i){void 0===t&&(t=null),void 0===e&&(e=1),void 0===n&&(n=1),void 0===i&&(i=1),wt.call(this,null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=f,this.minFilter=f,this.wrapR=d,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}function Ei(t,e,n,i){void 0===t&&(t=null),void 0===e&&(e=1),void 0===n&&(n=1),void 0===i&&(i=1),wt.call(this,null),this.image={data:t,width:e,height:n,depth:i},this.magFilter=f,this.minFilter=f,this.wrapR=d,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}ui.physical={uniforms:qn([ui.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new yt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Ze(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:ci.meshphysical_vert,fragmentShader:ci.meshphysical_frag},Ti.prototype=Object.create(wt.prototype),Ti.prototype.constructor=Ti,Ti.prototype.isDataTexture2DArray=!0,Ei.prototype=Object.create(wt.prototype),Ei.prototype.constructor=Ei,Ei.prototype.isDataTexture3D=!0;var Ai=new wt,Li=new Ti,Ri=new Ei,Ci=new $n,Pi=[],Oi=[],Ii=new Float32Array(16),Di=new Float32Array(9),Ni=new Float32Array(4);tion Gi(t,e){var n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}ction Wi(t,e){var n=this.cache,i=e.elements;if(void 0===i){if(zi(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),Fi(n,e)}else{if(zi(n,i))return;Ni.set(i),t.uniformMatrix2fv(this.addr,!1,Ni),Fi(n,i)}}function ji(t,e){var n=this.cache,i=e.elements;if(void 0===i){if(zi(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),Fi(n,e)}else{if(zi(n,i))return;Di.set(i),t.uniformMatrix3fv(this.addr,!1,Di),Fi(n,i)}}unction Xi(t,e,n){var i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.safeSetTexture2D(e||Ai,r)}function Yi(t,e,n){var i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(e||Li,r)}function Zi(t,e,n){var i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(t.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(e||Ri,r)}unction Qi(t,e){var n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function Ki(t,e){var n=this.cache;zi(n,e)||(t.uniform2iv(this.addr,e),Fi(n,e))}function $i(t,e){var n=this.cache;zi(n,e)||(t.uniform3iv(this.addr,e),Fi(n,e))}nction nr(t,e){t.uniform1fv(this.addr,e)}function ir(t,e){t.uniform1iv(this.addr,e)}function rr(t,e){t.uniform2iv(this.addr,e)}function ar(t,e){t.uniform3iv(this.addr,e)}unction sr(t,e){var n=Bi(e,this.size,2);t.uniform2fv(this.addr,n)}function cr(t,e){var n=Bi(e,this.size,3);t.uniform3fv(this.addr,n)}unction ur(t,e){var n=Bi(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function hr(t,e){var n=Bi(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}unction pr(t,e,n){var i=e.length,r=Hi(n,i);t.uniform1iv(this.addr,r);for(var a=0;a!==i;++a)n.safeSetTexture2D(e[a]||Ai,r[a])}rototype.updateCache=gr.prototype.setValue=var yr=/(\w+)(\])?(\[|\.)?/g;rototype.setValue=br.prototype.setOptional=br.upload=br.seqWithValue=var Mr=0;/^[ \t]*#include +<([\w\d./]+)>/gm;r Dr=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Nr=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;tion Gr(t,e,n,i){var r,s,c,h,d,p=t.getContext(),f=n.defines,m=n.vertexShader,v=n.fragmentShader,g=n),y=n),x=n),_=n),b=t.gammaFactor>0?t.gammaFactor:1,w=n.isWebGL2?"":n),M=f),S=p.createProgram(),T=n.glslVersion?"#version "+n.glslVersion+"\n":"";n.isRawShaderMaterial?((r=[M].filter(Lr).join("\n")).length>0&&(r+="\n"),(s=[w,M].filter(Lr).join("\n")).length>0&&(s+="\n")):(r=[Hr(n),"#define SHADER_NAME "+n.shaderName,M,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+b,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+x:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&!1===n.flatShading?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+g:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#ifdef USE_COLOR","\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(Lr).join("\n"),s=[w,Hr(n),"#define SHADER_NAME "+n.shaderName,M,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+b,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+y:"",n.envMap?"#define "+x:"",n.envMap?"#define "+_:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+g:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==n.toneMapping?"#define TONE_MAPPING":"",0!==n.toneMapping?ci.tonemapping_pars_fragment:"",0!==n.toneMapping?Ar("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",ci.encodings_pars_fragment,n.map?Er("mapTexelToLinear",n.mapEncoding):"",n.matcap?Er("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?Er("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?Er("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?Er("lightMapTexelToLinear",n.lightMapEncoding):"",(c="linearToOutputTexel",h=n.outputEncoding,d=Sr(h),"vec4 "+c+"( vec4 value ) { return LinearTo"+d[0]+d[1]+"; }"),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"","\n"].filter(Lr).join("\n")),m=Cr(m=Rr(m=Or(m),n),n),v=Cr(v=Rr(v=Or(v),n),n),m=Br(m),v=Br(v),n.isWebGL2&&!0!==n.isRawShaderMaterial&&(T="#version 300 es\n",r=["#define attribute in","#define varying out","#define texture2D texture"].join("\n")+"\n"+r,s=["#define varying in",n.glslVersion===rt?"":"out highp vec4 pc_fragColor;",n.glslVersion===rt?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+s);var E,A,L=T+s+v,R=wr(p,35633,T+r+m),C=wr(p,35632,L);if(p.attachShader(S,R),p.attachShader(S,C),void 0!==n.index0AttributeName?p.bindAttribLocation(S,0,n.index0AttributeName):!0===n.morphTargets&&p.bindAttribLocation(S,0,"position"),p.linkProgram(S),t.debug.checkShaderErrors){var P=p.getProgramInfoLog(S).trim(),O=p.getShaderInfoLog(R).trim(),I=p.getShaderInfoLog(C).trim(),D=!0,N=!0;if(!1===p.getProgramParameter(S,35714)){D=!1;var B=Tr(p,R,"vertex"),z=Tr(p,C,"fragment");console.error("THREE.WebGLProgram: shader error: ",p.getError(),"35715",p.getProgramParameter(S,35715),"gl.getProgramInfoLog",P,B,z)}else""!==P?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",P):""!==O&&""!==I||(N=!1);N&&(this.diagnostics={runnable:D,programLog:P,vertexShader:{log:O,prefix:r},fragmentShader:{log:I,prefix:s}})}return p.deleteShader(R),p.deleteShader(C),this.getUniforms=this.getAttributes=this.destroy=this.name=n.shaderName,this.id=Mr++,this.cacheKey=e,this.usedTimes=1,this.program=S,this.vertexShader=R,this.fragmentShader=C,this}function Ur(t,e,n,i,r,a){var o=[],s=i.isWebGL2,c=i.logarithmicDepthBuffer,h=i.floatVertexTextures,d=i.maxVertexUniforms,p=i.vertexTextures,f=i.precision,m={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},v=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];eturn{getParameters:function(r,o,v,y,x){var _,b,w=y.fog,M=r.isMeshStandardMaterial?y.environment:null,S=e.get(r.envMap||M),T=m[r.type],E=x.isSkinnedMesh?x):0;if(null!==r.precision&&(f=i.getMaxPrecision(r.precision))!==r.precision&&console.warn("THREE.WebGLProgram.getParameters:",r.precision,"not supported, using",f,"instead."),T){var A=ui[T];_=A.vertexShader,b=A.fragmentShader}else _=r.vertexShader,b=r.fragmentShader;var L=t.getRenderTarget();return{isWebGL2:s,shaderID:T,shaderName:r.type,vertexShader:_,fragmentShader:b,defines:r.defines,isRawShaderMaterial:!0===r.isRawShaderMaterial,glslVersion:r.glslVersion,precision:f,instancing:!0===x.isInstancedMesh,instancingColor:!0===x.isInstancedMesh&&null!==x.instanceColor,supportsVertexTextures:p,outputEncoding:null!==L?g(L.texture):t.outputEncoding,map:!!r.map,mapEncoding:g(r.map),matcap:!!r.matcap,matcapEncoding:g(r.matcap),envMap:!!S,envMapMode:S&&S.mapping,envMapEncoding:g(S),envMapCubeUV:!!S&&(S.mapping===l||S.mapping===u),lightMap:!!r.lightMap,lightMapEncoding:g(r.lightMap),aoMap:!!r.aoMap,emissiveMap:!!r.emissiveMap,emissiveMapEncoding:g(r.emissiveMap),bumpMap:!!r.bumpMap,normalMap:!!r.normalMap,objectSpaceNormalMap:1===r.normalMapType,tangentSpaceNormalMap:0===r.normalMapType,clearcoatMap:!!r.clearcoatMap,clearcoatRoughnessMap:!!r.clearcoatRoughnessMap,clearcoatNormalMap:!!r.clearcoatNormalMap,displacementMap:!!r.displacementMap,roughnessMap:!!r.roughnessMap,metalnessMap:!!r.metalnessMap,specularMap:!!r.specularMap,alphaMap:!!r.alphaMap,gradientMap:!!r.gradientMap,sheen:!!r.sheen,transmissionMap:!!r.transmissionMap,combine:r.combine,vertexTangents:r.normalMap&&r.vertexTangents,vertexColors:r.vertexColors,vertexUvs:!!(r.map||r.bumpMap||r.normalMap||r.specularMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||r.clearcoatMap||r.clearcoatRoughnessMap||r.clearcoatNormalMap||r.displacementMap||r.transmissionMap),uvsVertexOnly:!(r.map||r.bumpMap||r.normalMap||r.specularMap||r.alphaMap||r.emissiveMap||r.roughnessMap||r.metalnessMap||r.clearcoatNormalMap||r.transmissionMap||!r.displacementMap),fog:!!w,useFog:r.fog,fogExp2:w&&w.isFogExp2,flatShading:r.flatShading,sizeAttenuation:r.sizeAttenuation,logarithmicDepthBuffer:c,skinning:r.skinning&&E>0,maxBones:E,useVertexTexture:h,morphTargets:r.morphTargets,morphNormals:r.morphNormals,maxMorphTargets:t.maxMorphTargets,maxMorphNormals:t.maxMorphNormals,numDirLights:o.directional.length,numPointLights:o.point.length,numSpotLights:o.spot.length,numRectAreaLights:o.rectArea.length,numHemiLights:o.hemi.length,numDirLightShadows:o.directionalShadowMap.length,numPointLightShadows:o.pointShadowMap.length,numSpotLightShadows:o.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:r.dithering,shadowMapEnabled:t.shadowMap.enabled&&v.length>0,shadowMapType:t.shadowMap.type,toneMapping:r.toneMapped?t.toneMapping:0,physicallyCorrectLights:t.physicallyCorrectLights,premultipliedAlpha:r.premultipliedAlpha,alphaTest:r.alphaTest,doubleSided:2===r.side,flipSided:1===r.side,depthPacking:void 0!==r.depthPacking&&r.depthPacking,index0AttributeName:r.index0AttributeName,extensionDerivatives:r.extensions&&r.extensions.derivatives,extensionFragDepth:r.extensions&&r.extensions.fragDepth,extensionDrawBuffers:r.extensions&&r.extensions.drawBuffers,extensionShaderTextureLOD:r.extensions&&r.extensions.shaderTextureLOD,rendererExtensionFragDepth:s||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:s||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:s||n.has("EXT_shader_texture_lod"),customProgramCacheKey:r.customProgramCacheKey()}},getProgramCacheKey:getUniforms:acquireProgram:releaseProgram:programs:o}}=0;unction Jr(t,e){for(var n,i=new Xr,r=(n={},{get:),a={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]},o=0;o<9;o++)a.probe.push(new Lt);var s=new Lt,c=new ne,l=new ne;return{setup:function(n){for(var o=0,s=0,c=0,l=0;l<9;l++)a.probe[l].set(0,0,0);var u=0,h=0,d=0,p=0,f=0,m=0,v=0,g=0;n.sort(Zr);for(var y=0,x=n.length;y<x;y++){var _=n[y],b=_.color,w=_.intensity,M=_.distance,S=_.shadow&&_.shadow.map?_.shadow.map.texture:null;if(_.isAmbientLight)o+=b.r*w,s+=b.g*w,c+=b.b*w;else if(_.isLightProbe)for(var T=0;T<9;T++)a.probe[T].addScaledVector(_.sh.coefficients[T],w);else if(_.isDirectionalLight){var E=i.get(_);if(E.color.copy(_.color).multiplyScalar(_.intensity),_.castShadow){var A=_.shadow,L=r.get(_);L.shadowBias=A.bias,L.shadowNormalBias=A.normalBias,L.shadowRadius=A.radius,L.shadowMapSize=A.mapSize,a.directionalShadow[u]=L,a.directionalShadowMap[u]=S,a.directionalShadowMatrix[u]=_.shadow.matrix,m++}a.directional[u]=E,u++}else if(_.isSpotLight){var R=i.get(_);if(R.position.setFromMatrixPosition(_.matrixWorld),R.color.copy(b).multiplyScalar(w),R.distance=M,R.coneCos=Math.cos(_.angle),R.penumbraCos=Math.cos(_.angle*(1-_.penumbra)),R.decay=_.decay,_.castShadow){var C=_.shadow,P=r.get(_);P.shadowBias=C.bias,P.shadowNormalBias=C.normalBias,P.shadowRadius=C.radius,P.shadowMapSize=C.mapSize,a.spotShadow[d]=P,a.spotShadowMap[d]=S,a.spotShadowMatrix[d]=_.shadow.matrix,g++}a.spot[d]=R,d++}else if(_.isRectAreaLight){var O=i.get(_);O.color.copy(b).multiplyScalar(w),O.halfWidth.set(.5*_.width,0,0),O.halfHeight.set(0,.5*_.height,0),a.rectArea[p]=O,p++}else if(_.isPointLight){var I=i.get(_);if(I.color.copy(_.color).multiplyScalar(_.intensity),I.distance=_.distance,I.decay=_.decay,_.castShadow){var D=_.shadow,N=r.get(_);N.shadowBias=D.bias,N.shadowNormalBias=D.normalBias,N.shadowRadius=D.radius,N.shadowMapSize=D.mapSize,N.shadowCameraNear=D.camera.near,N.shadowCameraFar=D.camera.far,a.pointShadow[h]=N,a.pointShadowMap[h]=S,a.pointShadowMatrix[h]=_.shadow.matrix,v++}a.point[h]=I,h++}else if(_.isHemisphereLight){var B=i.get(_);B.skyColor.copy(_.color).multiplyScalar(w),B.groundColor.copy(_.groundColor).multiplyScalar(w),a.hemi[f]=B,f++}}p>0&&(e.isWebGL2||!0===t.has("OES_texture_float_linear")?(a.rectAreaLTC1=li.LTC_FLOAT_1,a.rectAreaLTC2=li.LTC_FLOAT_2):!0===t.has("OES_texture_half_float_linear")?(a.rectAreaLTC1=li.LTC_HALF_1,a.rectAreaLTC2=li.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),a.ambient[0]=o,a.ambient[1]=s,a.ambient[2]=c;var z=a.hash;z.directionalLength===u&&z.pointLength===h&&z.spotLength===d&&z.rectAreaLength===p&&z.hemiLength===f&&z.numDirectionalShadows===m&&z.numPointShadows===v&&z.numSpotShadows===g||(a.directional.length=u,a.spot.length=d,a.rectArea.length=p,a.point.length=h,a.hemi.length=f,a.directionalShadow.length=m,a.directionalShadowMap.length=m,a.pointShadow.length=v,a.pointShadowMap.length=v,a.spotShadow.length=g,a.spotShadowMap.length=g,a.directionalShadowMatrix.length=m,a.pointShadowMatrix.length=v,a.spotShadowMatrix.length=g,z.directionalLength=u,z.pointLength=h,z.spotLength=d,z.rectAreaLength=p,z.hemiLength=f,z.numDirectionalShadows=m,z.numPointShadows=v,z.numSpotShadows=g,a.version=Yr++)},setupView:function(t,e){for(var n=0,i=0,r=0,o=0,u=0,h=e.matrixWorldInverse,d=0,p=t.length;d<p;d++){var f=t[d];if(f.isDirectionalLight){var m=a.directional[n];m.direction.setFromMatrixPosition(f.matrixWorld),s.setFromMatrixPosition(f.target.matrixWorld),m.direction.sub(s),m.direction.transformDirection(h),n++}else if(f.isSpotLight){var v=a.spot[r];v.position.setFromMatrixPosition(f.matrixWorld),v.position.applyMatrix4(h),v.direction.setFromMatrixPosition(f.matrixWorld),s.setFromMatrixPosition(f.target.matrixWorld),v.direction.sub(s),v.direction.transformDirection(h),r++}else if(f.isRectAreaLight){var g=a.rectArea[o];g.position.setFromMatrixPosition(f.matrixWorld),g.position.applyMatrix4(h),l.identity(),c.copy(f.matrixWorld),c.premultiply(h),l.extractRotation(c),g.halfWidth.set(.5*f.width,0,0),g.halfHeight.set(0,.5*f.height,0),g.halfWidth.applyMatrix4(l),g.halfHeight.applyMatrix4(l),o++}else if(f.isPointLight){var y=a.point[i];y.position.setFromMatrixPosition(f.matrixWorld),y.position.applyMatrix4(h),i++}else if(f.isHemisphereLight){var x=a.hemi[u];x.direction.setFromMatrixPosition(f.matrixWorld),x.direction.transformDirection(h),x.direction.normalize(),u++}}},state:a}}function Qr(t,e){var n=new Jr(t,e),i=[],r=[];return{init:state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:setupLightsView:pushLight:function(t){i.push(t)},pushShadow:}function Kr(t,e){var n=new WeakMap;return{get:function(i,r){var a;return void 0===r&&(r=0),!1===n.has(i)?(a=new Qr(t,e),n.set(i,[]),n.get(i).push(a)):r>=n.get(i).length?(a=new Qr(t,e),n.get(i).push(a)):a=n.get(i)[r],a},dispose:}.prototype=Object.create(Ke.prototype),$r.prototype.constructor=$r,$r.prototype.isMeshDepthMaterial=!0,$r.prototype.copy=ta.prototype=Object.create(Ke.prototype),ta.prototype.constructor=ta,ta.prototype.isMeshDistanceMaterial=!0,ta.prototype.copy=function ea(t,e,n){var i=new ri,r=new yt,a=new yt,o=new St,s=[],c=[],l={},u={0:1,1:0,2:2},h=new Yn({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new yt},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),d=h.clone();d.defines.HORIZONTAL_PASS=1;var p=new Sn;p.setAttribute("position",new nn(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));var m=new kn(p,h),v=this;ction b(e,n,i,r,a,o,s){var c=null,h=x,d=e.customDepthMaterial;if(!0===r.isPointLight&&(h=_,d=e.customDistanceMaterial),void 0===d){var p=!1;!0===i.morphTargets&&(p=n.morphAttributes&&n.morphAttributes.position&&n.morphAttributes.position.length>0);var f=!1;!0===e.isSkinnedMesh&&(!0===i.skinning?f=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",e)),c=h(p,f,!0===e.isInstancedMesh)}else c=d;if(t.localClippingEnabled&&!0===i.clipShadows&&0!==i.clippingPlanes.length){var m=c.uuid,v=i.uuid,g=l[m];void 0===g&&(g={},l[m]=g);var y=g[v];void 0===y&&(y=c.clone(),g[v]=y),c=y}return c.visible=i.visible,c.wireframe=i.wireframe,c.side=3===s?null!==i.shadowSide?i.shadowSide:i.side:null!==i.shadowSide?i.shadowSide:u[i.side],c.clipShadows=i.clipShadows,c.clippingPlanes=i.clippingPlanes,c.clipIntersection=i.clipIntersection,c.wireframeLinewidth=i.wireframeLinewidth,c.linewidth=i.linewidth,!0===r.isPointLight&&!0===c.isMeshDistanceMaterial&&(c.referencePosition.setFromMatrixPosition(r.matrixWorld),c.nearDistance=a,c.farDistance=o),c}his.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function na(t,e,n){var r,a,o=n.isWebGL2;var s=new c=new l=new u={},h=null,d=null,p=null,f=null,m=null,v=null,g=null,y=null,x=null,_=!1,b=null,w=null,M=null,S=null,T=null,E=t.getParameter(35661),A=!1,L=0,R=t.getParameter(7938);-1!==R.indexOf("WebGL")?(L=parseFloat(/^WebGL (\d)/.exec(R)[1]),A=L>=1):-1!==R.indexOf("OpenGL ES")&&(L=parseFloat(/^OpenGL ES (\d)/.exec(R)[1]),A=L>=2);var C=null,P={},O=new St,I=new St;ar N={};function B(e){!0!==u[e]&&(t.enable(e),u[e]=!0)}[3553]=D(3553,3553,1),N[34067]=D(34067,34069,6),s.setClear(0,0,0,1),c.setClear(1),l.setClear(0),B(2929),c.setFunc(3),k(!1),V(1),B(2884),U(0);var F=((r={})[100]=32774,r[101]=32778,r[102]=32779,r);if(o)F[103]=32775,F[104]=32776;else{var H=e.get("EXT_blend_minmax");null!==H&&(F[103]=H.MIN_EXT,F[104]=H.MAX_EXT)}var G=((a={})[200]=0,a[201]=1,a[202]=768,a[204]=770,a[210]=776,a[208]=774,a[206]=772,a[203]=769,a[205]=771,a[209]=775,a[207]=773,a);function U(e,n,r,a,o,s,c,l){if(0!==e){if(d||(B(3042),d=!0),5===e)o=o||n,s=s||r,c=c||a,n===f&&o===g||(t.blendEquationSeparate(F[n],F[o]),f=n,g=o),r===m&&a===v&&s===y&&c===x||(t.blendFuncSeparate(G[r],G[a],G[s],G[c]),m=r,v=a,y=s,x=c),p=e,_=null;else if(e!==p||l!==_){if(f===i&&g===i||(t.blendEquation(32774),f=i,g=i),l)switch(e){case 1:t.blendFuncSeparate(1,771,1,771);break;case 2:t.blendFunc(1,1);break;case 3:t.blendFuncSeparate(0,0,769,771);break;case 4:t.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}else switch(e){case 1:t.blendFuncSeparate(770,771,1,771);break;case 2:t.blendFunc(770,1);break;case 3:t.blendFunc(0,769);break;case 4:t.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",e)}m=null,v=null,y=null,x=null,p=e,_=l}}else d&&(z(3042),d=!1)}rn{buffers:{color:s,depth:c,stencil:l},enable:B,disable:z,useProgram:setBlending:U,setMaterial:setFlipSided:k,setCullFace:V,setLineWidth:setPolygonOffset:W,setScissorTest:function(t){t?B(3089):z(3089)},activeTexture:j,bindTexture:unbindTexture:compressedTexImage2D:function(){try{t.compressedTexImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage2D:function(){try{t.texImage2D.apply(t,arguments)}catch(t){console.error("THREE.WebGLState:",t)}},texImage3D:scissor:function(e){!1===O.equals(e)&&(t.scissor(e.x,e.y,e.z,e.w),O.copy(e))},viewport:reset:}function ia(t,e,n,i,r,a,o){var s,c,l,u=r.isWebGL2,h=r.maxTextures,p=r.maxCubemapSize,y=r.maxTextureSize,x=r.maxSamples,_=new WeakMap,C=!1;try{C="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(t){}nction k(e,r){var o=i.get(e);e.version>0&&o.__version!==e.version?function(e,i,r){if(6!==i.image.length)return;q(e,i),n.activeTexture(33984+r),n.bindTexture(34067,e.__webglTexture),t.pixelStorei(37440,i.flipY),t.pixelStorei(37441,i.premultiplyAlpha),t.pixelStorei(3317,i.unpackAlignment);for(var o=i&&(i.isCompressedTexture||i.image[0].isCompressedTexture),s=i.image[0]&&i.image[0].isDataTexture,c=[],l=0;l<6;l++)c[l]=o||s?s?i.image[l].image:i.image[l]:O(i.image[l],!1,!0,p);var h,d=c[0],f=I(d)||u,m=a.convert(i.format),v=a.convert(i.type),g=B(i.internalFormat,m,v);if(j(34067,i,f),o){for(var y=0;y<6;y++){h=c[y].mipmaps;for(var x=0;x<h.length;x++){var _=h[x];i.format!==A&&i.format!==E?null!==m?n.compressedTexImage2D(34069+y,x,g,_.width,_.height,0,_.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+y,x,g,_.width,_.height,0,m,v,_.data)}}e.__maxMipLevel=h.length-1}else{h=i.mipmaps;for(var b=0;b<6;b++)if(s){n.texImage2D(34069+b,0,g,c[b].width,c[b].height,0,m,v,c[b].data);for(var w=0;w<h.length;w++){var M=h[w].image[b].image;n.texImage2D(34069+b,w+1,g,M.width,M.height,0,m,v,M.data)}}else{n.texImage2D(34069+b,0,g,m,v,c[b]);for(var S=0;S<h.length;S++){var T=h[S];n.texImage2D(34069+b,S+1,g,m,v,T.image[b])}}e.__maxMipLevel=h.length}D(i,f)&&N(34067,i,d.width,d.height);e.__version=i.version,i.onUpdate&&i.onUpdate(i)}(o,e,r):(n.activeTexture(33984+r),n.bindTexture(34067,o.__webglTexture))}var V=((s={})[1e3]=10497,s[1001]=33071,s[1002]=33648,s),W=((c={})[1003]=9728,c[1004]=9984,c[1005]=9986,c[1006]=9729,c[1007]=9985,c[1008]=9987,c);1,$=!1;this.allocateTextureUnit=this.resetTextureUnits=this.setTexture2D=U,this.setTexture2DArray=function(t,e){var r=i.get(t);t.version>0&&r.__version!==t.version?X(r,t,e):(n.activeTexture(33984+e),n.bindTexture(35866,r.__webglTexture))},this.setTexture3D=this.setTextureCube=k,this.setupRenderTarget=this.updateRenderTargetMipmap=this.updateMultisampleRenderTarget=this.safeSetTexture2D=function(t,e){t&&t.isWebGLRenderTarget&&(!1===K&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),K=!0),t=t.texture),U(t,e)},this.safeSetTextureCube=unction aa(t){void 0===t&&(t=[]),Jn.call(this),this.cameras=t}function oa(){Ae.call(this),this.type="Group"}unction ca(t,e){var n=this,i=null,r=1,a=null,o="local-floor",s=null,c=[],l=new Map,u=new Jn;u.layers.enable(1),u.viewport=new St;var h=new Jn;h.layers.enable(2),h.viewport=new St;var d=[u,h],p=new aa;p.layers.enable(1),p.layers.enable(2);var f=null,m=null;s.enabled=!1,this.isPresenting=!1,this.getController=function(t){var e=c[t];return void 0===e&&(e=new sa,c[t]=e),e.getTargetRaySpace()},this.getControllerGrip=function(t){var e=c[t];return void 0===e&&(e=new sa,c[t]=e),e.getGripSpace()},this.getHand=this.setFramebufferScaleFactor=function(t){r=t,!0===n.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=this.getReferenceSpace=function(){return a},this.getSession=function(){return i},this.setSession=function(){var t,s=(t=regeneratorRuntime.mark((function t(s){var c,l,u;return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(null===(i=s)){t.next=24;break}if(i.addEventListener("select",v),i.addEventListener("selectstart",v),i.addEventListener("selectend",v),i.addEventListener("squeeze",v),i.addEventListener("squeezestart",v),i.addEventListener("squeezeend",v),i.addEventListener("end",g),i.addEventListener("inputsourceschange",y),!0===(c=e.getContextAttributes()).xrCompatible){t.next=14;break}return t.next=14,e.makeXRCompatible();case 14:return l={antialias:c.antialias,alpha:c.alpha,depth:c.depth,stencil:c.stencil,framebufferScaleFactor:r},u=new XRWebGLLayer(i,e,l),i.updateRenderState({baseLayer:u}),t.next=19,i.requestReferenceSpace(o);case 19:a=t.sent,M.setContext(i),M.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"});case 24:case"end":return t.stop()}}),t)})),;return ();var x=new Lt,_=new Lt;his.getCamera=function(t){p.near=h.near=u.near=t.near,p.far=h.far=u.far=t.far,f===p.near&&m===p.far||(i.updateRenderState({depthNear:p.near,depthFar:p.far}),f=p.near,m=p.far);var e=t.parent,n=p.cameras;b(p,e);for(var r=0;r<n.length;r++)b(n[r],e);t.matrixWorld.copy(p.matrixWorld),t.matrix.copy(p.matrix),t.matrix.decompose(t.position,t.quaternion,t.scale);for(var a=t.children,o=0,s=a.length;o<s;o++)a[o].updateMatrixWorld(!0);return 2===n.length?p,u,h):p.projectionMatrix.copy(u.projectionMatrix),p};var w=null;var M=new ai;M.setAnimationLoop((function(e,n){if(null!==(s=n.getViewerPose(a))){var r=s.views,o=i.renderState.baseLayer;t.setFramebuffer(o.framebuffer);var l=!1;r.length!==p.cameras.length&&(p.cameras.length=0,l=!0);for(var u=0;u<r.length;u++){var h=r[u],f=o.getViewport(h),m=d[u];m.matrix.fromArray(h.transform.matrix),m.projectionMatrix.fromArray(h.projectionMatrix),m.viewport.set(f.x,f.y,f.width,f.height),0===u&&p.matrix.copy(m.matrix),!0===l&&p.cameras.push(m)}}for(var v=i.inputSources,g=0;g<c.length;g++){var y=c[g],x=v[g];y.update(x,n,a)}w&&w(e,n)})),this.setAnimationLoop=function(t){w=t},this.dispose=function(){}}function la(t){turn{refreshFogUniforms:refreshMaterialUniforms:}function ua(t){var e,n=void 0!==(t=t||{}).canvas?t.canvas:((e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")).style.display="block",e),i=void 0!==t.context?t.context:null,r=void 0!==t.alpha&&t.alpha,a=void 0===t.depth||t.depth,o=void 0===t.stencil||t.stencil,s=void 0!==t.antialias&&t.antialias,c=void 0===t.premultipliedAlpha||t.premultipliedAlpha,l=void 0!==t.preserveDrawingBuffer&&t.preserveDrawingBuffer,u=void 0!==t.powerPreference?t.powerPreference:"default",h=void 0!==t.failIfMajorPerformanceCaveat&&t.failIfMajorPerformanceCaveat,d=null,p=null,f=[];this.domElement=n,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Y,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;var m=this,v=!1,g=null,y=0,x=0,b=null,w=null,T=-1,E=null,L=new St,R=new St,C=null,P=n.width,O=n.height,I=1,D=null,N=null,B=new St(0,0,P,O),z=new St(0,0,P,O),F=!1,H=new ri,G=!1,U=!1,k=new ne,V=new Lt,W={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};ar q,X,Z,J,Q,K,$,tt,et,nt,it,rt,at,ot,st,ct,lt,ut,ht,dt,pt,ft=i;ry{var vt={alpha:r,depth:a,stencil:o,antialias:s,premultipliedAlpha:c,preserveDrawingBuffer:l,powerPreference:u,failIfMajorPerformanceCaveat:h};if(n.addEventListener("webglcontextlost",Mt,!1),n.addEventListener("webglcontextrestored",Tt,!1),null===ft){var xt=["webgl2","webgl","experimental-webgl"];if(!0===m.isWebGL1Renderer&&xt.shift(),null===(ft=mt(xt,vt)))throw mt(xt)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}void 0===ft.getShaderPrecisionFormat&&(ft.getShaderPrecisionFormat=}catch(t){throw console.error("THREE.WebGLRenderer: "+t.message),t}function _t(){q=new gi(ft),X=new fi(ft,q,t),q.init(X),dt=new ra(ft,q,X),(Z=new na(ft,q,X)).scissor(R.copy(z).multiplyScalar(I).floor()),Z.viewport(L.copy(B).multiplyScalar(I).floor()),J=new _i(ft),Q=new kr,K=new ia(ft,q,Z,Q,X,dt,J),$=new vi(m),tt=new oi(ft,X),pt=new di(ft,q,tt,X),et=new yi(ft,tt,J,pt),nt=new Si(ft,et,tt,J),lt=new Mi(ft),st=new mi(Q),it=new Ur(m,$,q,X,pt,st),rt=new la(Q),at=new qr(Q),ot=new Kr(q,X),ct=new hi(m,$,Z,nt,c),ut=new pi(ft,q,J,X),ht=new xi(ft,q,J,X),J.programs=it.programs,m.capabilities=X,m.extensions=q,m.properties=Q,m.renderLists=at,m.state=Z,m.info=J}_t();var bt=new ca(m,ft);this.xr=bt;var wt=new ea(m,nt,X.maxTextureSize);.shadowMap=wt,this.getContext=function(){return ft},this.getContextAttributes=function(){return ft.getContextAttributes()},this.forceContextLoss=function(){var t=q.get("WEBGL_lose_context");t&&t.loseContext()},this.forceContextRestore=this.getPixelRatio=function(){return I},this.setPixelRatio=this.getSize=this.setSize=this.getDrawingBufferSize=this.setDrawingBufferSize=this.getCurrentViewport=this.getViewport=function(t){return t.copy(B)},this.setViewport=function(t,e,n,i){t.isVector4?B.set(t.x,t.y,t.z,t.w):B.set(t,e,n,i),Z.viewport(L.copy(B).multiplyScalar(I).floor())},this.getScissor=this.setScissor=this.getScissorTest=function(){return F},this.setScissorTest=this.setOpaqueSort=function(t){D=t},this.setTransparentSort=function(t){N=t},this.getClearColor=function(t){return void 0===t&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),t=new Ze),t.copy(ct.getClearColor())},this.setClearColor=function(){ct.setClearColor.apply(ct,arguments)},this.getClearAlpha=function(){return ct.getClearAlpha()},this.setClearAlpha=this.clear=this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=this.dispose=this.renderBufferImmediate=this.renderBufferDirect=this.compile=function(t,e){(p=ot.get(t)).init(),t.traverseVisible((),p.setupLights();var n=new WeakMap;t.traverse(()};var Rt=null;var Ct=new ai;unction Ot(t,e,n){for(var i=!0===e.isScene?e.overrideMaterial:null,r=0,a=t.length;r<a;r++){var o=t[r],s=o.object,c=o.geometry,l=null===i?o.material:i,u=o.group;if(n.isArrayCamera)for(var h=n.cameras,d=0,f=h.length;d<f;d++){var m=h[d];s.layers.test(m.layers)&&(Z.viewport(L.copy(m.viewport)),p.setupLightsView(m),It(s,e,m,c,l,u))}else It(s,e,n,c,l,u)}}function It(t,e,n,i,r,a){if(t.onBeforeRender(m,e,n,i,r,a),t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,t.matrixWorld),t.normalMatrix.getNormalMatrix(t.modelViewMatrix),t.isImmediateRenderObject){var o=Nt(n,e,r,t);Z.setMaterial(r),pt.reset(),t,o)}else m.renderBufferDirect(n,e,i,r,t,a);t.onAfterRender(m,e,n,i,r,a)}function Dt(t,e,n){!0!==e.isScene&&(e=W);var i=Q.get(t),r=p.state.lights,a=p.state.shadowsArray,o=r.state.version,s=it.getParameters(t,r.state,a,e,n),c=it.getProgramCacheKey(s),l=i.program,u=!0;if(i.environment=t.isMeshStandardMaterial?e.environment:null,i.fog=e.fog,i.envMap=$.get(t.envMap||i.environment),void 0===l)t.addEventListener("dispose",Et);else if(l.cacheKey!==c)At(t);else if(i.lightsStateVersion!==o)u=!1;else{if(void 0!==s.shaderID)return;u=!1}u&&(s.uniforms=it.getUniforms(t),t.onBeforeCompile(s,m),l=it.acquireProgram(s,c),i.program=l,i.uniforms=s.uniforms,i.outputEncoding=s.outputEncoding);var h=i.uniforms;(t.isShaderMaterial||t.isRawShaderMaterial)&&!0!==t.clipping||(i.numClippingPlanes=st.numPlanes,i.numIntersection=st.numIntersection,h.clippingPlanes=st.uniform),i.needsLights=t),i.lightsStateVersion=o,i.needsLights&&(h.ambientLightColor.value=r.state.ambient,h.lightProbe.value=r.state.probe,h.directionalLights.value=r.state.directional,h.directionalLightShadows.value=r.state.directionalShadow,h.spotLights.value=r.state.spot,h.spotLightShadows.value=r.state.spotShadow,h.rectAreaLights.value=r.state.rectArea,h.ltc_1.value=r.state.rectAreaLTC1,h.ltc_2.value=r.state.rectAreaLTC2,h.pointLights.value=r.state.point,h.pointLightShadows.value=r.state.pointShadow,h.hemisphereLights.value=r.state.hemi,h.directionalShadowMap.value=r.state.directionalShadowMap,h.directionalShadowMatrix.value=r.state.directionalShadowMatrix,h.spotShadowMap.value=r.state.spotShadowMap,h.spotShadowMatrix.value=r.state.spotShadowMatrix,h.pointShadowMap.value=r.state.pointShadowMap,h.pointShadowMatrix.value=r.state.pointShadowMatrix);var d=i.program.getUniforms(),f=br.seqWithValue(d.seq,h);i.uniformsList=f}function Nt(t,e,n,i){!0!==e.isScene&&(e=W),K.resetTextureUnits();var r=e.fog,a=n.isMeshStandardMaterial?e.environment:null,o=null===b?m.outputEncoding:b.texture.encoding,s=$.get(n.envMap||a),c=Q.get(n),l=p.state.lights;if(!0===G&&(!0===U||t!==E)){var u=t===E&&n.id===T;st.setState(n,t,u)}n.version===c.__version?n.fog&&c.fog!==r||c.environment!==a||c.needsLights&&c.lightsStateVersion!==l.state.version?Dt(n,e,i):void 0===c.numClippingPlanes||c.numClippingPlanes===st.numPlanes&&c.numIntersection===st.numIntersection?(c.outputEncoding!==o||c.envMap!==s)&&Dt(n,e,i):Dt(n,e,i):(Dt(n,e,i),c.__version=n.version);var h,d,f=!1,v=!1,g=!1,y=c.program,x=y.getUniforms(),_=c.uniforms;if(Z.useProgram(y.program)&&(f=!0,v=!0,g=!0),n.id!==T&&(T=n.id,v=!0),f||E!==t){if(x.setValue(ft,"projectionMatrix",t.projectionMatrix),X.logarithmicDepthBuffer&&x.setValue(ft,"logDepthBufFC",2/(Math.log(t.far+1)/Math.LN2)),E!==t&&(E=t,v=!0,g=!0),n.isShaderMaterial||n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshStandardMaterial||n.envMap){var w=x.map.cameraPosition;void 0!==w&&w.setValue(ft,V.setFromMatrixPosition(t.matrixWorld))}(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial)&&x.setValue(ft,"isOrthographic",!0===t.isOrthographicCamera),(n.isMeshPhongMaterial||n.isMeshToonMaterial||n.isMeshLambertMaterial||n.isMeshBasicMaterial||n.isMeshStandardMaterial||n.isShaderMaterial||n.isShadowMaterial||n.skinning)&&x.setValue(ft,"viewMatrix",t.matrixWorldInverse)}if(n.skinning){x.setOptional(ft,i,"bindMatrix"),x.setOptional(ft,i,"bindMatrixInverse");var S=i.skeleton;if(S){var L=S.bones;if(X.floatVertexTextures){if(null===S.boneTexture){var R=Math.sqrt(4*L.length);R=gt.ceilPowerOfTwo(R),R=Math.max(R,4);var C=new Float32Array(R*R*4);C.set(S.boneMatrices);var P=new ei(C,R,R,A,M);S.boneMatrices=C,S.boneTexture=P,S.boneTextureSize=R}x.setValue(ft,"boneTexture",S.boneTexture,K),x.setValue(ft,"boneTextureSize",S.boneTextureSize)}else x.setOptional(ft,S,"boneMatrices")}}return(v||c.receiveShadow!==i.receiveShadow)&&(c.receiveShadow=i.receiveShadow,x.setValue(ft,"receiveShadow",i.receiveShadow)),v&&(x.setValue(ft,"toneMappingExposure",m.toneMappingExposure),c.needsLights&&(d=g,(h=_).ambientLightColor.needsUpdate=d,h.lightProbe.needsUpdate=d,h.directionalLights.needsUpdate=d,h.directionalLightShadows.needsUpdate=d,h.pointLights.needsUpdate=d,h.pointLightShadows.needsUpdate=d,h.spotLights.needsUpdate=d,h.spotLightShadows.needsUpdate=d,h.rectAreaLights.needsUpdate=d,h.hemisphereLights.needsUpdate=d),r&&n.fog&&rt.refreshFogUniforms(_,r),rt.refreshMaterialUniforms(_,n,I,O),br.upload(ft,c.uniformsList,_,K)),n.isShaderMaterial&&!0===n.uniformsNeedUpdate&&(br.upload(ft,c.uniformsList,_,K),n.uniformsNeedUpdate=!1),n.isSpriteMaterial&&x.setValue(ft,"center",i.center),x.setValue(ft,"modelViewMatrix",i.modelViewMatrix),x.setValue(ft,"normalMatrix",i.normalMatrix),x.setValue(ft,"modelMatrix",i.matrixWorld),y}Ct.setAnimationLoop((),"undefined"!=typeof window&&Ct.setContext(window),this.setAnimationLoop=this.render=function(t,e){var n,i;if(void 0!==arguments[2]&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),n=arguments[2]),void 0!==arguments[3]&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),i=arguments[3]),void 0===e||!0===e.isCamera){if(!0!==v){pt.resetDefaultState(),T=-1,E=null,!0===t.autoUpdate&&t.updateMatrixWorld(),null===e.parent&&e.updateMatrixWorld(),!0===bt.enabled&&!0===bt.isPresenting&&(e=bt.getCamera(e)),!0===t.isScene&&t.onBeforeRender(m,t,e,n||b),(p=ot.get(t,f.length)).init(),f.push(p),k.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),H.setFromProjectionMatrix(k),U=this.localClippingEnabled,G=st.init(this.clippingPlanes,U,e),(d=at.get(t,e)).init(),Pt(t,e,0,m.sortObjects),d.finish(),!0===m.sortObjects&&d.sort(D,N),!0===G&&st.beginShadows();var r=p.state.shadowsArray;wt.render(r,t,e),p.setupLights(),p.setupLightsView(e),!0===G&&st.endShadows(),!0===this.info.autoReset&&this.info.reset(),void 0!==n&&this.setRenderTarget(n),ct.render(d,t,e,i);var a=d.opaque,o=d.transparent;a.length>0&&Ot(a,t,e),o.length>0&&Ot(o,t,e),!0===t.isScene&&t.onAfterRender(m,t,e),null!==b&&(K.updateRenderTargetMipmap(b),K.updateMultisampleRenderTarget(b)),Z.buffers.depth.setTest(!0),Z.buffers.depth.setMask(!0),Z.buffers.color.setMask(!0),Z.setPolygonOffset(!1),f.pop(),p=f.length>0?f[f.length-1]:null,d=null}}else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")},this.setFramebuffer=this.getActiveCubeFace=function(){return y},this.getActiveMipmapLevel=function(){return x},this.getRenderList=function(){return d},this.setRenderList=function(t){d=t},this.getRenderTarget=function(){return b},this.setRenderTarget=this.readRenderTargetPixels=function(t,e,n,i,r,a,o){if(t&&t.isWebGLRenderTarget){var s=Q.get(t).__webglFramebuffer;if(t.isWebGLCubeRenderTarget&&void 0!==o&&(s=s[o]),s){var c=!1;s!==w&&(ft.bindFramebuffer(36160,s),c=!0);try{var l=t.texture,u=l.format,h=l.type;if(u!==A&&dt.convert(u)!==ft.getParameter(35739))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");var d=h===S&&(q.has("EXT_color_buffer_half_float")||X.isWebGL2&&q.has("EXT_color_buffer_float"));if(!(h===_||dt.convert(h)===ft.getParameter(35738)||h===M&&(X.isWebGL2||q.has("OES_texture_float")||q.has("WEBGL_color_buffer_float"))||d))return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");36053===ft.checkFramebufferStatus(36160)?e>=0&&e<=t.width-i&&n>=0&&n<=t.height-r&&ft.readPixels(e,n,i,r,dt.convert(u),dt.convert(h),a):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{c&&ft.bindFramebuffer(36160,w)}}}else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")},this.copyFramebufferToTexture=this.copyTextureToTexture=this.initTexture=this.resetState="undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function ha(t){ua.call(this,t)}aa.prototype=Object.assign(Object.create(Jn.prototype),{constructor:aa,isArrayCamera:!0}),oa.prototype=Object.assign(Object.create(Ae.prototype),{constructor:oa,isGroup:!0}),Object.assign(sa.prototype,{constructor:sa,getHandSpace:getTargetRaySpace:function(){return null===this._targetRay&&(this._targetRay=new oa,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:dispatchEvent:disconnect:update:function(t,e,n){var i=null,r=null,a=null,o=this._targetRay,s=this._grip,c=this._hand;if(t&&"visible-blurred"!==e.session.visibilityState)if(c&&t.hand){a=!0;for(var l,u=ht(t.hand.values());!(l=u()).done;){var h=l.value,d=e.getJointPose(h,n);if(void 0===c.joints[h.jointName]){var p=new oa;p.matrixAutoUpdate=!1,p.visible=!1,c.joints[h.jointName]=p,c.add(p)}var f=c.joints[h.jointName];null!==d&&(f.matrix.fromArray(d.transform.matrix),f.matrix.decompose(f.position,f.rotation,f.scale),f.jointRadius=d.radius),f.visible=null!==d}var m=c.joints["index-finger-tip"],v=c.joints["thumb-tip"],g=m.position.distanceTo(v.position);c.inputState.pinching&&g>.025?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!c.inputState.pinching&&g<=.015&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else null!==o&&null!==(i=e.getPose(t.targetRaySpace,n))&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale)),null!==s&&t.gripSpace&&null!==(r=e.getPose(t.gripSpace,n))&&(s.matrix.fromArray(r.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale));return null!==o&&(o.visible=null!==i),null!==s&&(s.visible=null!==r),null!==c&&(c.visible=null!==a),this}}),Object.assign(ca.prototype,dt.prototype),ha.prototype=Object.assign(Object.create(ua.prototype),{constructor:ha,isWebGL1Renderer:!0});var da=),pa=),fa=Ae);bject.defineProperty(ma.prototype,"needsUpdate",{set:function(t){!0===t&&this.version++}}),Object.assign(ma.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(t){return this.usage=t,this},copy:copyAt:function(t,e,n){t*=this.stride,n*=e.stride;for(var i=0,r=this.stride;i<r;i++)this.array[t+i]=e.array[n+i];return this},set:function(t,e){return void 0===e&&(e=0),this.array.set(t,e),this},clone:onUpload:function(t){return this.onUploadCallback=t,this},toJSON:);var va,ga=new Lt;unction xa(t){Ke.call(this),this.type="SpriteMaterial",this.color=new Ze(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}Object.defineProperties(ya.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:}),Object.assign(ya.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:setX:setY:function(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this},setZ:function(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this},setW:getX:getY:function(t){return this.data.array[t*this.data.stride+this.offset+1]},getZ:function(t){return this.data.array[t*this.data.stride+this.offset+2]},getW:setXY:setXYZ:setXYZW:clone:toJSON:),xa.prototype=Object.create(Ke.prototype),xa.prototype.constructor=xa,xa.prototype.isSpriteMaterial=!0,xa.prototype.copy=function(t){return Ke.prototype.copy.call(this,t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this};var _a=new Lt,ba=new Lt,wa=new Lt,Ma=new yt,Sa=new yt,Ta=new ne,Ea=new Lt,Aa=new Lt,La=new Lt,Ra=new yt,Ca=new yt,Pa=new yt;.prototype=Object.assign(Object.create(Ae.prototype),{constructor:Oa,isSprite:!0,raycast:copy:);var Da=new Lt,Na=new Lt;a.prototype=Object.assign(Object.create(Ae.prototype),{constructor:Ba,isLOD:!0,copy:addLevel:getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:raycast:update:toJSON:);var za=new Lt,Fa=new St,Ha=new St,Ga=new Lt,Ua=new ne;.prototype=Object.assign(Object.create(kn.prototype),{constructor:ka,isSkinnedMesh:!0,copy:bind:pose:normalizeSkinWeights:updateMatrixWorld:function(t){kn.prototype.updateMatrixWorld.call(this,t),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:),Va.prototype=Object.assign(Object.create(Ae.prototype),{constructor:Va,isBone:!0});var Wa=new ne,ja=new ne;function qa(t,e){void 0===t&&(t=[]),void 0===e&&(e=[]),this.uuid=gt.generateUUID(),this.bones=t.slice(0),this.boneInverses=e,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(qa.prototype,{init:calculateInverses:pose:update:clone:getBoneByName:dispose:fromJSON:toJSON:);var Xa=new ne,Ya=new ne,Za=[],Ja=new kn;.prototype=Object.assign(Object.create(kn.prototype),{constructor:Qa,isInstancedMesh:!0,copy:function(t){return kn.prototype.copy.call(this,t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this},getColorAt:function(t,e){e.fromArray(this.instanceColor.array,3*t)},getMatrixAt:function(t,e){e.fromArray(this.instanceMatrix.array,16*t)},raycast:setColorAt:setMatrixAt:updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}}),Ka.prototype=Object.create(Ke.prototype),Ka.prototype.constructor=Ka,Ka.prototype.isLineBasicMaterial=!0,Ka.prototype.copy=var $a=new Lt,to=new Lt,eo=new ne,no=new ee,io=new Xt;function ro(t,e){void 0===t&&(t=new Sn),void 0===e&&(e=new Ka),Ae.call(this),this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}ro.prototype=Object.assign(Object.create(Ae.prototype),{constructor:ro,isLine:!0,copy:function(t){return Ae.prototype.copy.call(this,t),this.material=t.material,this.geometry=t.geometry,this},computeLineDistances:function(){var t=this.geometry;if(t.isBufferGeometry)if(null===t.index){for(var e=t.attributes.position,n=[0],i=1,r=e.count;i<r;i++)$a.fromBufferAttribute(e,i-1),to.fromBufferAttribute(e,i),n[i]=n[i-1],n[i]+=$a.distanceTo(to);t.setAttribute("lineDistance",new dn(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this},raycast:function(t,e){var n=this.geometry,i=this.matrixWorld,r=t.params.Line.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),io.copy(n.boundingSphere),io.applyMatrix4(i),io.radius+=r,!1!==t.ray.intersectsSphere(io)){eo.copy(i).invert(),no.copy(t.ray).applyMatrix4(eo);var a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a,s=new Lt,c=new Lt,l=new Lt,u=new Lt,h=this.isLineSegments?2:1;if(n.isBufferGeometry){var d=n.index,p=n.attributes.position;if(null!==d)for(var f=d.array,m=0,v=f.length-1;m<v;m+=h){var g=f[m],y=f[m+1];if(s.fromBufferAttribute(p,g),c.fromBufferAttribute(p,y),!(no.distanceSqToSegment(s,c,u,l)>o)){u.applyMatrix4(this.matrixWorld);var x=t.ray.origin.distanceTo(u);x<t.near||x>t.far||e.push({distance:x,point:l.clone().applyMatrix4(this.matrixWorld),index:m,face:null,faceIndex:null,object:this})}}else for(var _=0,b=p.count-1;_<b;_+=h){if(s.fromBufferAttribute(p,_),c.fromBufferAttribute(p,_+1),!(no.distanceSqToSegment(s,c,u,l)>o)){u.applyMatrix4(this.matrixWorld);var w=t.ray.origin.distanceTo(u);w<t.near||w>t.far||e.push({distance:w,point:l.clone().applyMatrix4(this.matrixWorld),index:_,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},updateMorphTargets:function(){var t=this.geometry;if(t.isBufferGeometry){var e=t.morphAttributes,n=Object.keys(e);if(n.length>0){var i=e[n[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var r=0,a=i.length;r<a;r++){var o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{var s=t.morphTargets;void 0!==s&&s.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});var ao=new Lt,oo=new Lt;function so(t,e){ro.call(this,t,e),this.type="LineSegments"}function co(t,e){ro.call(this,t,e),this.type="LineLoop"}o.prototype=Object.assign(Object.create(ro.prototype),{constructor:so,isLineSegments:!0,computeLineDistances:function(){var t=this.geometry;if(t.isBufferGeometry)if(null===t.index){for(var e=t.attributes.position,n=[],i=0,r=e.count;i<r;i+=2)ao.fromBufferAttribute(e,i),oo.fromBufferAttribute(e,i+1),n[i]=0===i?0:n[i-1],n[i+1]=n[i]+ao.distanceTo(oo);t.setAttribute("lineDistance",new dn(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}),co.prototype=Object.assign(Object.create(ro.prototype),{constructor:co,isLineLoop:!0}),lo.prototype=Object.create(Ke.prototype),lo.prototype.constructor=lo,lo.prototype.isPointsMaterial=!0,lo.prototype.copy=var uo=new ne,ho=new ee,po=new Xt,fo=new Lt;function mo(t,e){void 0===t&&(t=new Sn),void 0===e&&(e=new lo),Ae.call(this),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}ototype=Object.assign(Object.create(Ae.prototype),{constructor:mo,isPoints:!0,copy:function(t){return Ae.prototype.copy.call(this,t),this.material=t.material,this.geometry=t.geometry,this},raycast:function(t,e){var n=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold;if(null===n.boundingSphere&&n.computeBoundingSphere(),po.copy(n.boundingSphere),po.applyMatrix4(i),po.radius+=r,!1!==t.ray.intersectsSphere(po)){uo.copy(i).invert(),ho.copy(t.ray).applyMatrix4(uo);var a=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=a*a;if(n.isBufferGeometry){var s=n.index,c=n.attributes.position;if(null!==s)for(var l=s.array,u=0,h=l.length;u<h;u++){var d=l[u];fo.fromBufferAttribute(c,d),vo(fo,d,o,i,t,e,this)}else for(var p=0,f=c.count;p<f;p++)fo.fromBufferAttribute(c,p),vo(fo,p,o,i,t,e,this)}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},updateMorphTargets:function(){var t=this.geometry;if(t.isBufferGeometry){var e=t.morphAttributes,n=Object.keys(e);if(n.length>0){var i=e[n[0]];if(void 0!==i){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(var r=0,a=i.length;r<a;r++){var o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{var s=t.morphTargets;void 0!==s&&s.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}),go.prototype=Object.assign(Object.create(wt.prototype),{constructor:go,clone:isVideoTexture:!0,update:),yo.prototype=Object.create(wt.prototype),yo.prototype.constructor=yo,yo.prototype.isCompressedTexture=!0,xo.prototype=Object.create(wt.prototype),xo.prototype.constructor=xo,xo.prototype.isCanvasTexture=!0,_o.prototype=Object.create(wt.prototype),_o.prototype.constructor=_o,_o.prototype.isDepthTexture=!0;var bo=function(t){function e(e,n,i,r){var a;void 0===e&&(e=1),void 0===n&&(n=8),void 0===i&&(i=0),void 0===r&&(r=2*Math.PI),(a=t.call(this)||this).type="CircleGeometry",a.parameters={radius:e,segments:n,thetaStart:i,thetaLength:r},n=Math.max(3,n);var o=[],s=[],c=[],l=[],u=new Lt,h=new yt;s.push(0,0,0),c.push(0,0,1),l.push(.5,.5);for(var d=0,p=3;d<=n;d++,p+=3){var f=i+d/n*r;u.x=e*Math.cos(f),u.y=e*Math.sin(f),s.push(u.x,u.y,u.z),c.push(0,0,1),h.x=(s[p]/e+1)/2,h.y=(s[p+1]/e+1)/2,l.push(h.x,h.y)}for(var m=1;m<=n;m++)o.push(m,m+1,0);return a.setIndex(o),a.setAttribute("position",new dn(s,3)),a.setAttribute("normal",new dn(c,3)),a.setAttribute("uv",new dn(l,2)),a}return ct(e,t),e}(Sn),wo=function(t){function e(e,n,i,r,a,o,s,c){var l;void 0===e&&(e=1),void 0===n&&(n=1),void 0===i&&(i=1),void 0===r&&(r=8),void 0===a&&(a=1),void 0===o&&(o=!1),void 0===s&&(s=0),void 0===c&&(c=2*Math.PI),(l=t.call(this)||this).type="CylinderGeometry",l.parameters={radiusTop:e,radiusBottom:n,height:i,radialSegments:r,heightSegments:a,openEnded:o,thetaStart:s,thetaLength:c};var u=lt(l);r=Math.floor(r),a=Math.floor(a);var h=[],d=[],p=[],f=[],m=0,v=[],g=i/2,y=0;eturn ),!1===o&&(e>0&&x(!0),n>0&&x(!1)),l.setIndex(h),l.setAttribute("position",new dn(d,3)),l.setAttribute("normal",new dn(p,3)),l.setAttribute("uv",new dn(f,2)),l}return ct(e,t),e}(Sn),Mo=function(t){function e(e,n,i,r,a,o,s){var c;return void 0===e&&(e=1),void 0===n&&(n=1),void 0===i&&(i=8),void 0===r&&(r=1),void 0===a&&(a=!1),void 0===o&&(o=0),void 0===s&&(s=2*Math.PI),(c=t.call(this,0,e,n,i,r,a,o,s)||this).type="ConeGeometry",c.parameters={radius:e,height:n,radialSegments:i,heightSegments:r,openEnded:a,thetaStart:o,thetaLength:s},c}return ct(e,t),e}(wo),So=function(t){function e(e,n,i,r){var a;void 0===i&&(i=1),void 0===r&&(r=0),(a=t.call(this)||this).type="PolyhedronGeometry",a.parameters={vertices:e,indices:n,radius:i,detail:r};var o=[],s=[];n r),i),),a.setAttribute("position",new dn(o,3)),a.setAttribute("normal",new dn(o.slice(),3)),a.setAttribute("uv",new dn(s,2)),0===r?a.computeVertexNormals():a.normalizeNormals(),a}return ct(e,t),e}(Sn),To=function(t){function e(e,n){var i;void 0===e&&(e=1),void 0===n&&(n=0);var r=(1+Math.sqrt(5))/2,a=1/r,o=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-a,-r,0,-a,r,0,a,-r,0,a,r,-a,-r,0,-a,r,0,a,-r,0,a,r,0,-r,0,-a,r,0,-a,-r,0,a,r,0,a];return(i=t.call(this,o,[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],e,n)||this).type="DodecahedronGeometry",i.parameters={radius:e,detail:n},i}return ct(e,t),e}(So),Eo=new Lt,Ao=new Lt,Lo=new Lt,Ro=new ke,Co=function(t){function e(e,n){var i;if((i=t.call(this)||this).type="EdgesGeometry",i.parameters={thresholdAngle:n},n=void 0!==n?n:1,!0===e.isGeometry)return console.error("THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),lt(i);for(var r=Math.pow(10,4),a=Math.cos(gt.DEG2RAD*n),o=e.getIndex(),s=e.getAttribute("position"),c=o?o.count:s.count,l=[0,0,0],u=["a","b","c"],h=new Array(3),d={},p=[],f=0;f<c;f+=3){o?(l[0]=o.getX(f),l[1]=o.getX(f+1),l[2]=o.getX(f+2)):(l[0]=f,l[1]=f+1,l[2]=f+2);var m=Ro.a,v=Ro.b,g=Ro.c;if(m.fromBufferAttribute(s,l[0]),v.fromBufferAttribute(s,l[1]),g.fromBufferAttribute(s,l[2]),Ro.getNormal(Lo),h[0]=Math.round(m.x*r)+","+Math.round(m.y*r)+","+Math.round(m.z*r),h[1]=Math.round(v.x*r)+","+Math.round(v.y*r)+","+Math.round(v.z*r),h[2]=Math.round(g.x*r)+","+Math.round(g.y*r)+","+Math.round(g.z*r),h[0]!==h[1]&&h[1]!==h[2]&&h[2]!==h[0])for(var y=0;y<3;y++){var x=(y+1)%3,_=h[y],b=h[x],w=Ro[u[y]],M=Ro[u[x]],S=_+"_"+b,T=b+"_"+_;T in d&&d[T]?(Lo.dot(d[T].normal)<=a&&(p.push(w.x,w.y,w.z),p.push(M.x,M.y,M.z)),d[T]=null):S in d||(d[S]={index0:l[y],index1:l[x],normal:Lo.clone()})}}for(var E in d)if(d[E]){var A=d[E],L=A.index0,R=A.index1;Eo.fromBufferAttribute(s,L),Ao.fromBufferAttribute(s,R),p.push(Eo.x,Eo.y,Eo.z),p.push(Ao.x,Ao.y,Ao.z)}return i.setAttribute("position",new dn(p,3)),i}return ct(e,t),e}(Sn),Po=function(t,e,n){n=n||2;var i,r,a,o,s,c,l,u=e&&e.length,h=u?e[0]*n:t.length,d=Oo(t,0,h,n,!0),p=[];if(!d||d.next===d.prev)return p;if(u&&(d=t,e,d,n)),t.length>80*n){i=a=t[0],r=o=t[1];for(var f=n;f<h;f+=n)(s=t[f])<i&&(i=s),(c=t[f+1])<r&&(r=c),s>a&&(a=s),c>o&&(o=c);l=0!==(l=Math.max(a-i,o-r))?1/l:0}return Do(d,p,n,i,r,l),p};n Ho(t,e){return t.x-e.x}lockWise:triangulateShape:;r as=function(t){function e(e,n){var i;(i=t.call(this)||this).type="ExtrudeGeometry",i.parameters={shapes:e,options:n},e=Array.isArray(e)?e:[e];for(var r=lt(i),a=[],o=[],s=0,c=e.length;s<c;s++){l(e[s])}eturn i.setAttribute("position",new dn(a,3)),i.setAttribute("uv",new dn(o,2)),i.computeVertexNormals(),i}return ct(e,t),e.prototype.toJSON=e}(Sn),os={generateTopUV:generateSideWallUV:;var ss=function(t){function e(e,n){var i;void 0===e&&(e=1),void 0===n&&(n=0);var r=(1+Math.sqrt(5))/2,a=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1];return(i=t.call(this,a,[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e,n)||this).type="IcosahedronGeometry",i.parameters={radius:e,detail:n},i}return ct(e,t),e}(So),cs=function(t){function e(e,n,i,r){var a;void 0===n&&(n=12),void 0===i&&(i=0),void 0===r&&(r=2*Math.PI),(a=t.call(this)||this).type="LatheGeometry",a.parameters={points:e,segments:n,phiStart:i,phiLength:r},n=Math.floor(n),r=gt.clamp(r,0,2*Math.PI);for(var o=[],s=[],c=[],l=1/n,u=new Lt,h=new yt,d=0;d<=n;d++)for(var p=i+d*l*r,f=Math.sin(p),m=Math.cos(p),v=0;v<=e.length-1;v++)u.x=e[v].x*f,u.y=e[v].y,u.z=e[v].x*m,s.push(u.x,u.y,u.z),h.x=d/n,h.y=v/(e.length-1),c.push(h.x,h.y);for(var g=0;g<n;g++)for(var y=0;y<e.length-1;y++){var x=y+g*e.length,_=x,b=x+e.length,w=x+e.length+1,M=x+1;o.push(_,b,M),o.push(b,w,M)}if(a.setIndex(o),a.setAttribute("position",new dn(s,3)),a.setAttribute("uv",new dn(c,2)),a.computeVertexNormals(),r===2*Math.PI)for(var S=a.attributes.normal.array,T=new Lt,E=new Lt,A=new Lt,L=n*e.length*3,R=0,C=0;R<e.length;R++,C+=3)T.x=S[C+0],T.y=S[C+1],T.z=S[C+2],E.x=S[L+C+0],E.y=S[L+C+1],E.z=S[L+C+2],A.addVectors(T,E).normalize(),S[C+0]=S[L+C+0]=A.x,S[C+1]=S[L+C+1]=A.y,S[C+2]=S[L+C+2]=A.z;return a}return ct(e,t),e}(Sn),ls=function(t){function e(e,n){var i;void 0===e&&(e=1),void 0===n&&(n=0);return(i=t.call(this,[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],e,n)||this).type="OctahedronGeometry",i.parameters={radius:e,detail:n},i}return ct(e,t),e}(So);s.prototype=Object.create(Sn.prototype),us.prototype.constructor=us;var hs=function(t){function e(e,n,i,r,a,o){var s;void 0===e&&(e=.5),void 0===n&&(n=1),void 0===i&&(i=8),void 0===r&&(r=1),void 0===a&&(a=0),void 0===o&&(o=2*Math.PI),(s=t.call(this)||this).type="RingGeometry",s.parameters={innerRadius:e,outerRadius:n,thetaSegments:i,phiSegments:r,thetaStart:a,thetaLength:o},i=Math.max(3,i);for(var c=[],l=[],u=[],h=[],d=e,p=(n-e)/(r=Math.max(1,r)),f=new Lt,m=new yt,v=0;v<=r;v++){for(var g=0;g<=i;g++){var y=a+g/i*o;f.x=d*Math.cos(y),f.y=d*Math.sin(y),l.push(f.x,f.y,f.z),u.push(0,0,1),m.x=(f.x/n+1)/2,m.y=(f.y/n+1)/2,h.push(m.x,m.y)}d+=p}for(var x=0;x<r;x++)for(var _=x*(i+1),b=0;b<i;b++){var w=b+_,M=w,S=w+i+1,T=w+i+2,E=w+1;c.push(M,S,E),c.push(S,T,E)}return s.setIndex(c),s.setAttribute("position",new dn(l,3)),s.setAttribute("normal",new dn(u,3)),s.setAttribute("uv",new dn(h,2)),s}return ct(e,t),e}(Sn),ds=function(t){function e(e,n){var i;void 0===n&&(n=12),(i=t.call(this)||this).type="ShapeGeometry",i.parameters={shapes:e,curveSegments:n};var r=[],a=[],o=[],s=[],c=0,l=0;if(!1===Array.isArray(e))h(e);else for(var u=0;u<e.length;u++)h(e[u]),i.addGroup(c,l,u),c+=l,l=0;eturn i.setIndex(r),i.setAttribute("position",new dn(a,3)),i.setAttribute("normal",new dn(o,3)),i.setAttribute("uv",new dn(s,2)),i}return ct(e,t),e.prototype.toJSON=e}(Sn);var ps=function(t){function e(e,n,i,r,a,o,s){var c;void 0===e&&(e=1),void 0===n&&(n=8),void 0===i&&(i=6),void 0===r&&(r=0),void 0===a&&(a=2*Math.PI),void 0===o&&(o=0),void 0===s&&(s=Math.PI),(c=t.call(this)||this).type="SphereGeometry",c.parameters={radius:e,widthSegments:n,heightSegments:i,phiStart:r,phiLength:a,thetaStart:o,thetaLength:s},n=Math.max(3,Math.floor(n)),i=Math.max(2,Math.floor(i));for(var l=Math.min(o+s,Math.PI),u=0,h=[],d=new Lt,p=new Lt,f=[],m=[],v=[],g=[],y=0;y<=i;y++){var x=[],_=y/i,b=0;0==y&&0==o?b=.5/n:y==i&&l==Math.PI&&(b=-.5/n);for(var w=0;w<=n;w++){var M=w/n;d.x=-e*Math.cos(r+M*a)*Math.sin(o+_*s),d.y=e*Math.cos(o+_*s),d.z=e*Math.sin(r+M*a)*Math.sin(o+_*s),m.push(d.x,d.y,d.z),p.copy(d).normalize(),v.push(p.x,p.y,p.z),g.push(M+b,1-_),x.push(u++)}h.push(x)}for(var S=0;S<i;S++)for(var T=0;T<n;T++){var E=h[S][T+1],A=h[S][T],L=h[S+1][T],R=h[S+1][T+1];(0!==S||o>0)&&f.push(E,A,R),(S!==i-1||l<Math.PI)&&f.push(A,L,R)}return c.setIndex(f),c.setAttribute("position",new dn(m,3)),c.setAttribute("normal",new dn(v,3)),c.setAttribute("uv",new dn(g,2)),c}return ct(e,t),e}(Sn),fs=function(t){function e(e,n){var i;void 0===e&&(e=1),void 0===n&&(n=0);return(i=t.call(this,[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],e,n)||this).type="TetrahedronGeometry",i.parameters={radius:e,detail:n},i}return ct(e,t),e}(So),ms=function(t){function e(e,n){var i;void 0===n&&(n={});var r=n.font;if(!r||!r.isFont)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new Sn||lt(i);var a=r.generateShapes(e,n.size);return n.depth=void 0!==n.height?n.height:50,void 0===n.bevelThickness&&(n.bevelThickness=10),void 0===n.bevelSize&&(n.bevelSize=8),void 0===n.bevelEnabled&&(n.bevelEnabled=!1),(i=t.call(this,a,n)||this).type="TextGeometry",i}return ct(e,t),e}(as),vs=function(t){function e(e,n,i,r,a){var o;void 0===e&&(e=1),void 0===n&&(n=.4),void 0===i&&(i=8),void 0===r&&(r=6),void 0===a&&(a=2*Math.PI),(o=t.call(this)||this).type="TorusGeometry",o.parameters={radius:e,tube:n,radialSegments:i,tubularSegments:r,arc:a},i=Math.floor(i),r=Math.floor(r);for(var s=[],c=[],l=[],u=[],h=new Lt,d=new Lt,p=new Lt,f=0;f<=i;f++)for(var m=0;m<=r;m++){var v=m/r*a,g=f/i*Math.PI*2;d.x=(e+n*Math.cos(g))*Math.cos(v),d.y=(e+n*Math.cos(g))*Math.sin(v),d.z=n*Math.sin(g),c.push(d.x,d.y,d.z),h.x=e*Math.cos(v),h.y=e*Math.sin(v),p.subVectors(d,h).normalize(),l.push(p.x,p.y,p.z),u.push(m/r),u.push(f/i)}for(var y=1;y<=i;y++)for(var x=1;x<=r;x++){var _=(r+1)*y+x-1,b=(r+1)*(y-1)+x-1,w=(r+1)*(y-1)+x,M=(r+1)*y+x;s.push(_,b,M),s.push(b,w,M)}return o.setIndex(s),o.setAttribute("position",new dn(c,3)),o.setAttribute("normal",new dn(l,3)),o.setAttribute("uv",new dn(u,2)),o}return ct(e,t),e}(Sn),gs=function(t){function e(e,n,i,r,a,o){var s;void 0===e&&(e=1),void 0===n&&(n=.4),void 0===i&&(i=64),void 0===r&&(r=8),void 0===a&&(a=2),void 0===o&&(o=3),(s=t.call(this)||this).type="TorusKnotGeometry",s.parameters={radius:e,tube:n,tubularSegments:i,radialSegments:r,p:a,q:o},i=Math.floor(i),r=Math.floor(r);for(var c=[],l=[],u=[],h=[],d=new Lt,p=new Lt,f=new Lt,m=new Lt,v=new Lt,g=new Lt,y=new Lt,x=0;x<=i;++x){var _=x/i*a*Math.PI*2;P(_,a,o,e,f),P(_+.01,a,o,e,m),g.subVectors(m,f),y.addVectors(m,f),v.crossVectors(g,y),y.crossVectors(v,g),v.normalize(),y.normalize();for(var b=0;b<=r;++b){var w=b/r*Math.PI*2,M=-n*Math.cos(w),S=n*Math.sin(w);d.x=f.x+(M*y.x+S*v.x),d.y=f.y+(M*y.y+S*v.y),d.z=f.z+(M*y.z+S*v.z),l.push(d.x,d.y,d.z),p.subVectors(d,f).normalize(),u.push(p.x,p.y,p.z),h.push(x/i),h.push(b/r)}}for(var T=1;T<=i;T++)for(var E=1;E<=r;E++){var A=(r+1)*(T-1)+(E-1),L=(r+1)*T+(E-1),R=(r+1)*T+E,C=(r+1)*(T-1)+E;c.push(A,L,C),c.push(L,R,C)}eturn s.setIndex(c),s.setAttribute("position",new dn(l,3)),s.setAttribute("normal",new dn(u,3)),s.setAttribute("uv",new dn(h,2)),s}return ct(e,t),e}(Sn),ys=function(t){function e(e,n,i,r,a){var o;void 0===n&&(n=64),void 0===i&&(i=1),void 0===r&&(r=8),void 0===a&&(a=!1),(o=t.call(this)||this).type="TubeGeometry",o.parameters={path:e,tubularSegments:n,radius:i,radialSegments:r,closed:a};var s=e.computeFrenetFrames(n,a);o.tangents=s.tangents,o.normals=s.normals,o.binormals=s.binormals;var c=new Lt,l=new Lt,u=new yt,h=new Lt,d=[],p=[],f=[],m=[];eturn ),o.setIndex(m),o.setAttribute("position",new dn(d,3)),o.setAttribute("normal",new dn(p,3)),o.setAttribute("uv",new dn(f,2)),o}return ct(e,t),e.prototype.toJSON=e}(Sn),xs=function(t){function e(e){var n;if((n=t.call(this)||this).type="WireframeGeometry",!0===e.isGeometry)return console.error("THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),lt(n);var i=[],r=[0,0],a={},o=new Lt;if(null!==e.index){var s=e.attributes.position,c=e.index,l=e.groups;0===l.length&&(l=[{start:0,count:c.count,materialIndex:0}]);for(var u=0,h=l.length;u<h;++u)for(var d=l[u],p=d.start,f=p,m=p+d.count;f<m;f+=3)for(var v=0;v<3;v++){var g=c.getX(f+v),y=c.getX(f+(v+1)%3);r[0]=Math.min(g,y),r[1]=Math.max(g,y);var x=r[0]+","+r[1];void 0===a[x]&&(a[x]={index1:r[0],index2:r[1]})}for(var _ in a){var b=a[_];o.fromBufferAttribute(s,b.index1),i.push(o.x,o.y,o.z),o.fromBufferAttribute(s,b.index2),i.push(o.x,o.y,o.z)}}else for(var w=e.attributes.position,M=0,S=w.count/3;M<S;M++)for(var T=0;T<3;T++){var E=3*M+T;o.fromBufferAttribute(w,E),i.push(o.x,o.y,o.z);var A=3*M+(T+1)%3;o.fromBufferAttribute(w,A),i.push(o.x,o.y,o.z)}return n.setAttribute("position",new dn(i,3)),n}return ct(e,t),e}(Sn),_s=Object.freeze({__proto__:null,BoxGeometry:Wn,BoxBufferGeometry:Wn,CircleGeometry:bo,CircleBufferGeometry:bo,ConeGeometry:Mo,ConeBufferGeometry:Mo,CylinderGeometry:wo,CylinderBufferGeometry:wo,DodecahedronGeometry:To,DodecahedronBufferGeometry:To,EdgesGeometry:Co,ExtrudeGeometry:as,ExtrudeBufferGeometry:as,IcosahedronGeometry:ss,IcosahedronBufferGeometry:ss,LatheGeometry:cs,LatheBufferGeometry:cs,OctahedronGeometry:ls,OctahedronBufferGeometry:ls,ParametricGeometry:us,ParametricBufferGeometry:us,PlaneGeometry:si,PlaneBufferGeometry:si,PolyhedronGeometry:So,PolyhedronBufferGeometry:So,RingGeometry:hs,RingBufferGeometry:hs,ShapeGeometry:ds,ShapeBufferGeometry:ds,SphereGeometry:ps,SphereBufferGeometry:ps,TetrahedronGeometry:fs,TetrahedronBufferGeometry:fs,TextGeometry:ms,TextBufferGeometry:ms,TorusGeometry:vs,TorusBufferGeometry:vs,TorusKnotGeometry:gs,TorusKnotBufferGeometry:gs,TubeGeometry:ys,TubeBufferGeometry:ys,WireframeGeometry:xs});pe=Object.create(Ke.prototype),bs.prototype.constructor=bs,bs.prototype.isShadowMaterial=!0,bs.prototype.copy=function(t){return Ke.prototype.copy.call(this,t),this.color.copy(t.color),this},ws.prototype=Object.create(Yn.prototype),ws.prototype.constructor=ws,ws.prototype.isRawShaderMaterial=!0,Ms.prototype=Object.create(Ke.prototype),Ms.prototype.constructor=Ms,Ms.prototype.isMeshStandardMaterial=!0,Ms.prototype.copy=Ss.prototype=Object.create(Ms.prototype),Ss.prototype.constructor=Ss,Ss.prototype.isMeshPhysicalMaterial=!0,Ss.prototype.copy=Ts.prototype=Object.create(Ke.prototype),Ts.prototype.constructor=Ts,Ts.prototype.isMeshPhongMaterial=!0,Ts.prototype.copy=Es.prototype=Object.create(Ke.prototype),Es.prototype.constructor=Es,Es.prototype.isMeshToonMaterial=!0,Es.prototype.copy=As.prototype=Object.create(Ke.prototype),As.prototype.constructor=As,As.prototype.isMeshNormalMaterial=!0,As.prototype.copy=Ls.prototype=Object.create(Ke.prototype),Ls.prototype.constructor=Ls,Ls.prototype.isMeshLambertMaterial=!0,Ls.prototype.copy=Rs.prototype=Object.create(Ke.prototype),Rs.prototype.constructor=Rs,Rs.prototype.isMeshMatcapMaterial=!0,Rs.prototype.copy=Cs.prototype=Object.create(Ka.prototype),Cs.prototype.constructor=Cs,Cs.prototype.isLineDashedMaterial=!0,Cs.prototype.copy=var Ps=Object.freeze({__proto__:null,ShadowMaterial:bs,SpriteMaterial:xa,RawShaderMaterial:ws,ShaderMaterial:Yn,PointsMaterial:lo,MeshPhysicalMaterial:Ss,MeshStandardMaterial:Ms,MeshPhongMaterial:Ts,MeshToonMaterial:Es,MeshNormalMaterial:As,MeshLambertMaterial:Ls,MeshDepthMaterial:$r,MeshDistanceMaterial:ta,MeshBasicMaterial:$e,MeshMatcapMaterial:Rs,LineDashedMaterial:Cs,LineBasicMaterial:Ka,Material:Ke}),Os={arraySlice:convertArray:isTypedArray:getKeyframeOrder:sortedArray:flattenJSON:subclip:function(t,e,n,i,r){void 0===r&&(r=30);var a=t.clone();a.name=e;for(var o=[],s=0;s<a.tracks.length;++s){for(var c=a.tracks[s],l=c.getValueSize(),u=[],h=[],d=0;d<c.times.length;++d){var p=c.times[d]*r;if(!(p<n||p>=i)){u.push(c.times[d]);for(var f=0;f<l;++f)h.push(c.values[d*l+f])}}0!==u.length&&(c.times=Os.convertArray(u,c.times.constructor),c.values=Os.convertArray(h,c.values.constructor),o.push(c))}a.tracks=o;for(var m=1/0,v=0;v<a.tracks.length;++v)m>a.tracks[v].times[0]&&(m=a.tracks[v].times[0]);for(var g=0;g<a.tracks.length;++g)a.tracks[g].shift(-1*m);return a.resetDuration(),a},makeClipAdditive:function(t,e,n,i){void 0===e&&(e=0),void 0===n&&(n=t),void 0===i&&(i=30),i<=0&&(i=30);for(var r=n.tracks.length,a=e/i,o=s=0;s<r;++s)o(s);return t.blendMode=X,t}};nction Ns(t,e,n,i){Is.call(this,t,e,n,i)}function Bs(t,e,n,i){Is.call(this,t,e,n,i)}nction Hs(t,e,n,i){zs.call(this,t,e,n,i)}function Gs(t,e,n,i){zs.call(this,t,e,n,i)}function Us(t,e,n,i){Is.call(this,t,e,n,i)}function ks(t,e,n,i){zs.call(this,t,e,n,i)}function Vs(t,e,n,i){zs.call(this,t,e,n,i)}unction js(t,e,n,i){void 0===e&&(e=-1),void 0===i&&(i=q),this.name=t,this.tracks=n,this.duration=e,this.blendMode=i,this.uuid=gt.generateUUID(),this.duration<0&&this.resetDuration()}bject.assign(Is.prototype,{evaluate:settings:null,DefaultSettings_:{},getSettings_:copySampleValue_:interpolate_:intervalChanged_:function(){}}),Object.assign(Is.prototype,{beforeStart_:Is.prototype.copySampleValue_,afterEnd_:Is.prototype.copySampleValue_}),Ds.prototype=Object.assign(Object.create(Is.prototype),{constructor:Ds,DefaultSettings_:{endingStart:V,endingEnd:V},intervalChanged_:interpolate_:),Ns.prototype=Object.assign(Object.create(Is.prototype),{constructor:Ns,interpolate_:),Bs.prototype=Object.assign(Object.create(Is.prototype),{constructor:Bs,interpolate_:),Object.assign(zs,{toJSON:),Object.assign(zs.prototype,{constructor:zs,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:U,InterpolantFactoryMethodDiscrete:function(t){return new Bs(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodLinear:function(t){return new Ns(this.times,this.values,this.getValueSize(),t)},InterpolantFactoryMethodSmooth:function(t){return new Ds(this.times,this.values,this.getValueSize(),t)},setInterpolation:getInterpolation:getValueSize:shift:scale:trim:validate:optimize:clone:),Fs.prototype=Object.assign(Object.create(zs.prototype),{constructor:Fs,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:G,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Hs.prototype=Object.assign(Object.create(zs.prototype),{constructor:Hs,ValueTypeName:"color"}),Gs.prototype=Object.assign(Object.create(zs.prototype),{constructor:Gs,ValueTypeName:"number"}),Us.prototype=Object.assign(Object.create(Is.prototype),{constructor:Us,interpolate_:),ks.prototype=Object.assign(Object.create(zs.prototype),{constructor:ks,ValueTypeName:"quaternion",DefaultInterpolation:U,InterpolantFactoryMethodLinear:InterpolantFactoryMethodSmooth:void 0}),Vs.prototype=Object.assign(Object.create(zs.prototype),{constructor:Vs,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:G,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0}),Ws.prototype=Object.assign(Object.create(zs.prototype),{constructor:Ws,ValueTypeName:"vector"}),Object.assign(js,{parse:function(t){for(var e=[],n=t.tracks,i=1/(t.fps||1),r=0,a=n.length;r!==a;++r)e.push(qs(n[r]).scale(i));var o=new js(t.name,t.duration,e,t.blendMode);return o.uuid=t.uuid,o},toJSON:CreateFromMorphTargetSequence:findByName:CreateClipsFromMorphTargetSequences:parseAnimation:),Object.assign(js.prototype,{resetDuration:trim:validate:optimize:clone:toJSON:);var Xs={enabled:!1,files:{},add:get:remove:clear:;ar Zs=new Ys;bject.assign(Js.prototype,{load:function(){},loadAsync:parse:function(){},setCrossOrigin:function(t){return this.crossOrigin=t,this},setWithCredentials:function(t){return this.withCredentials=t,this},setPath:function(t){return this.path=t,this},setResourcePath:function(t){return this.resourcePath=t,this},setRequestHeader:function(t){return this.requestHeader=t,this}});var Qs={};function Ks(t){Js.call(this,t)}function $s(t){Js.call(this,t)}function tc(t){Js.call(this,t)}function ec(t){Js.call(this,t)}function nc(t){Js.call(this,t)}function ic(t){Js.call(this,t)}function rc(t){Js.call(this,t)}rototype=Object.assign(Object.create(Js.prototype),{constructor:Ks,load:setResponseType:function(t){return this.responseType=t,this},setMimeType:function(t){return this.mimeType=t,this}}),$s.prototype=Object.assign(Object.create(Js.prototype),{constructor:$s,load:function(t,e,n,i){var r=this,a=new Ks(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)},parse:),tc.prototype=Object.assign(Object.create(Js.prototype),{constructor:tc,load:function(t,e,n,i){var r=this,a=[],o=new yo,s=new Ks(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(r.withCredentials);var c=0;function l(l){s.load(t[l],(,n,i)}if(Array.isArray(t))for(var u=0,h=t.length;u<h;++u)l(u);else s.load(t,(function(t){var n=r.parse(t,!0);if(n.isCubemap){for(var i=n.mipmaps.length/n.mipmapCount,s=0;s<i;s++){a[s]={mipmaps:[]};for(var c=0;c<n.mipmapCount;c++)a[s].mipmaps.push(n.mipmaps[s*n.mipmapCount+c]),a[s].format=n.format,a[s].width=n.width,a[s].height=n.height}o.image=a}else o.image.width=n.width,o.image.height=n.height,o.mipmaps=n.mipmaps;1===n.mipmapCount&&(o.minFilter=g),o.format=n.format,o.needsUpdate=!0,e&&e(o)}),n,i);return o}}),ec.prototype=Object.assign(Object.create(Js.prototype),{constructor:ec,load:),nc.prototype=Object.assign(Object.create(Js.prototype),{constructor:nc,load:),ic.prototype=Object.assign(Object.create(Js.prototype),{constructor:ic,load:function(t,e,n,i){var r=this,a=new ei,o=new Ks(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(t,(function(t){var n=r.parse(t);n&&(void 0!==n.image?a.image=n.image:void 0!==n.data&&(a.image.width=n.width,a.image.height=n.height,a.image.data=n.data),a.wrapS=void 0!==n.wrapS?n.wrapS:d,a.wrapT=void 0!==n.wrapT?n.wrapT:d,a.magFilter=void 0!==n.magFilter?n.magFilter:g,a.minFilter=void 0!==n.minFilter?n.minFilter:g,a.anisotropy=void 0!==n.anisotropy?n.anisotropy:1,void 0!==n.encoding&&(a.encoding=n.encoding),void 0!==n.flipY&&(a.flipY=n.flipY),void 0!==n.format&&(a.format=n.format),void 0!==n.type&&(a.type=n.type),void 0!==n.mipmaps&&(a.mipmaps=n.mipmaps,a.minFilter=x),1===n.mipmapCount&&(a.minFilter=g),a.needsUpdate=!0,e&&e(a,n))}),n,i),a}}),rc.prototype=Object.assign(Object.create(Js.prototype),{constructor:rc,load:),Object.assign(ac.prototype,{getPoint:getPointAt:function(t,e){var n=this.getUtoTmapping(t);return this.getPoint(n,e)},getPoints:function(t){void 0===t&&(t=5);for(var e=[],n=0;n<=t;n++)e.push(this.getPoint(n/t));return e},getSpacedPoints:getLength:function(){var t=this.getLengths();return t[t.length-1]},getLengths:function(t){if(void 0===t&&(t=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var e,n=[],i=this.getPoint(0),r=0;n.push(0);for(var a=1;a<=t;a++)r+=(e=this.getPoint(a/t)).distanceTo(i),n.push(r),i=e;return this.cacheArcLengths=n,n},updateArcLengths:getUtoTmapping:getTangent:getTangentAt:computeFrenetFrames:clone:function(){return(new this.constructor).copy(this)},copy:function(t){return this.arcLengthDivisions=t.arcLengthDivisions,this},toJSON:fromJSON:),oc.prototype=Object.create(ac.prototype),oc.prototype.constructor=oc,oc.prototype.isEllipseCurve=!0,oc.prototype.getPoint=oc.prototype.copy=function(t){return ac.prototype.copy.call(this,t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this},oc.prototype.toJSON=oc.prototype.fromJSON=sc.prototype=Object.create(oc.prototype),sc.prototype.constructor=sc,sc.prototype.isArcCurve=!0;var lc=new Lt,uc=new cc,hc=new cc,dc=new cc;function pc(t,e,n,i){void 0===t&&(t=[]),void 0===e&&(e=!1),void 0===n&&(n="centripetal"),void 0===i&&(i=.5),ac.call(this),this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=n,this.tension=i}ction gc(t,e,n,i){void 0===t&&(t=new yt),void 0===e&&(e=new yt),void 0===n&&(n=new yt),void 0===i&&(i=new yt),ac.call(this),this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=n,this.v3=i}function yc(t,e,n,i){void 0===t&&(t=new Lt),void 0===e&&(e=new Lt),void 0===n&&(n=new Lt),void 0===i&&(i=new Lt),ac.call(this),this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=n,this.v3=i}function xc(t,e){void 0===t&&(t=new yt),void 0===e&&(e=new yt),ac.call(this),this.type="LineCurve",this.v1=t,this.v2=e}function _c(t,e){void 0===t&&(t=new Lt),void 0===e&&(e=new Lt),ac.call(this),this.type="LineCurve3",this.v1=t,this.v2=e}function bc(t,e,n){void 0===t&&(t=new yt),void 0===e&&(e=new yt),void 0===n&&(n=new yt),ac.call(this),this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=n}function wc(t,e,n){void 0===t&&(t=new Lt),void 0===e&&(e=new Lt),void 0===n&&(n=new Lt),ac.call(this),this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=n}function Mc(t){void 0===t&&(t=[]),ac.call(this),this.type="SplineCurve",this.points=t}pc.prototype=Object.create(ac.prototype),pc.prototype.constructor=pc,pc.prototype.isCatmullRomCurve3=!0,pc.prototype.getPoint=function(t,e){void 0===e&&(e=new Lt);var n,i,r=e,a=this.points,o=a.length,s=(o-(this.closed?0:1))*t,c=Math.floor(s),l=s-c;this.closed?c+=c>0?0:(Math.floor(Math.abs(c)/o)+1)*o:0===l&&c===o-1&&(c=o-2,l=1),this.closed||c>0?n=a[(c-1)%o]:(lc.subVectors(a[0],a[1]).add(a[0]),n=lc);var u=a[c%o],h=a[(c+1)%o];if(this.closed||c+2<o?i=a[(c+2)%o]:(lc.subVectors(a[o-1],a[o-2]).add(a[o-1]),i=lc),"centripetal"===this.curveType||"chordal"===this.curveType){var d="chordal"===this.curveType?.5:.25,p=Math.pow(n.distanceToSquared(u),d),f=Math.pow(u.distanceToSquared(h),d),m=Math.pow(h.distanceToSquared(i),d);f<1e-4&&(f=1),p<1e-4&&(p=f),m<1e-4&&(m=f),uc.initNonuniformCatmullRom(n.x,u.x,h.x,i.x,p,f,m),hc.initNonuniformCatmullRom(n.y,u.y,h.y,i.y,p,f,m),dc.initNonuniformCatmullRom(n.z,u.z,h.z,i.z,p,f,m)}else"catmullrom"===this.curveType&&(uc.initCatmullRom(n.x,u.x,h.x,i.x,this.tension),hc.initCatmullRom(n.y,u.y,h.y,i.y,this.tension),dc.initCatmullRom(n.z,u.z,h.z,i.z,this.tension));return r.set(uc.calc(l),hc.calc(l),dc.calc(l)),r},pc.prototype.copy=pc.prototype.toJSON=pc.prototype.fromJSON=gc.prototype=Object.create(ac.prototype),gc.prototype.constructor=gc,gc.prototype.isCubicBezierCurve=!0,gc.prototype.getPoint=function(t,e){void 0===e&&(e=new yt);var n=e,i=this.v0,r=this.v1,a=this.v2,o=this.v3;return n.set(vc(t,i.x,r.x,a.x,o.x),vc(t,i.y,r.y,a.y,o.y)),n},gc.prototype.copy=function(t){return ac.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},gc.prototype.toJSON=function(){var t=ac.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t},gc.prototype.fromJSON=function(t){return ac.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this},yc.prototype=Object.create(ac.prototype),yc.prototype.constructor=yc,yc.prototype.isCubicBezierCurve3=!0,yc.prototype.getPoint=function(t,e){void 0===e&&(e=new Lt);var n=e,i=this.v0,r=this.v1,a=this.v2,o=this.v3;return n.set(vc(t,i.x,r.x,a.x,o.x),vc(t,i.y,r.y,a.y,o.y),vc(t,i.z,r.z,a.z,o.z)),n},yc.prototype.copy=function(t){return ac.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this},yc.prototype.toJSON=yc.prototype.fromJSON=xc.prototype=Object.create(ac.prototype),xc.prototype.constructor=xc,xc.prototype.isLineCurve=!0,xc.prototype.getPoint=function(t,e){void 0===e&&(e=new yt);var n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n},xc.prototype.getPointAt=function(t,e){return this.getPoint(t,e)},xc.prototype.getTangent=xc.prototype.copy=function(t){return ac.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},xc.prototype.toJSON=function(){var t=ac.prototype.toJSON.call(this);return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},xc.prototype.fromJSON=function(t){return ac.prototype.fromJSON.call(this,t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},_c.prototype=Object.create(ac.prototype),_c.prototype.constructor=_c,_c.prototype.isLineCurve3=!0,_c.prototype.getPoint=function(t,e){void 0===e&&(e=new Lt);var n=e;return 1===t?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(t).add(this.v1)),n},_c.prototype.getPointAt=_c.prototype.copy=function(t){return ac.prototype.copy.call(this,t),this.v1.copy(t.v1),this.v2.copy(t.v2),this},_c.prototype.toJSON=_c.prototype.fromJSON=bc.prototype=Object.create(ac.prototype),bc.prototype.constructor=bc,bc.prototype.isQuadraticBezierCurve=!0,bc.prototype.getPoint=function(t,e){void 0===e&&(e=new yt);var n=e,i=this.v0,r=this.v1,a=this.v2;return n.set(mc(t,i.x,r.x,a.x),mc(t,i.y,r.y,a.y)),n},bc.prototype.copy=function(t){return ac.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},bc.prototype.toJSON=function(){var t=ac.prototype.toJSON.call(this);return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t},bc.prototype.fromJSON=function(t){return ac.prototype.fromJSON.call(this,t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this},wc.prototype=Object.create(ac.prototype),wc.prototype.constructor=wc,wc.prototype.isQuadraticBezierCurve3=!0,wc.prototype.getPoint=function(t,e){void 0===e&&(e=new Lt);var n=e,i=this.v0,r=this.v1,a=this.v2;return n.set(mc(t,i.x,r.x,a.x),mc(t,i.y,r.y,a.y),mc(t,i.z,r.z,a.z)),n},wc.prototype.copy=function(t){return ac.prototype.copy.call(this,t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this},wc.prototype.toJSON=wc.prototype.fromJSON=Mc.prototype=Object.create(ac.prototype),Mc.prototype.constructor=Mc,Mc.prototype.isSplineCurve=!0,Mc.prototype.getPoint=function(t,e){void 0===e&&(e=new yt);var n=e,i=this.points,r=(i.length-1)*t,a=Math.floor(r),o=r-a,s=i[0===a?a:a-1],c=i[a],l=i[a>i.length-2?i.length-1:a+1],u=i[a>i.length-3?i.length-1:a+2];return n.set(fc(o,s.x,c.x,l.x,u.x),fc(o,s.y,c.y,l.y,u.y)),n},Mc.prototype.copy=function(t){ac.prototype.copy.call(this,t),this.points=[];for(var e=0,n=t.points.length;e<n;e++){var i=t.points[e];this.points.push(i.clone())}return this},Mc.prototype.toJSON=Mc.prototype.fromJSON=var Sc=Object.freeze({__proto__:null,ArcCurve:sc,CatmullRomCurve3:pc,CubicBezierCurve:gc,CubicBezierCurve3:yc,EllipseCurve:oc,LineCurve:xc,LineCurve3:_c,QuadraticBezierCurve:bc,QuadraticBezierCurve3:wc,SplineCurve:Mc});ction Lc(t,e){void 0===e&&(e=1),Ae.call(this),this.type="Light",this.color=new Ze(t),this.intensity=e}on Nc(t,e,n,i,r,a){void 0===t&&(t=-1),void 0===e&&(e=1),void 0===n&&(n=1),void 0===i&&(i=-1),void 0===r&&(r=.1),void 0===a&&(a=2e3),Zn.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=n,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}rototype=Object.assign(Object.create(ac.prototype),{constructor:Tc,add:closePath:getPoint:getLength:updateArcLengths:getCurveLengths:getSpacedPoints:getPoints:function(t){void 0===t&&(t=12);for(var e,n=[],i=0,r=this.curves;i<r.length;i++)for(var a=r[i],o=a&&a.isEllipseCurve?2*t:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?t*a.points.length:t,s=a.getPoints(o),c=0;c<s.length;c++){var l=s[c];e&&e.equals(l)||(n.push(l),e=l)}return this.autoClose&&n.length>1&&!n[n.length-1].equals(n[0])&&n.push(n[0]),n},copy:toJSON:function(){var t=ac.prototype.toJSON.call(this);t.autoClose=this.autoClose,t.curves=[];for(var e=0,n=this.curves.length;e<n;e++){var i=this.curves[e];t.curves.push(i.toJSON())}return t},fromJSON:),Ec.prototype=Object.assign(Object.create(Tc.prototype),{constructor:Ec,setFromPoints:moveTo:function(t,e){return this.currentPoint.set(t,e),this},lineTo:quadraticCurveTo:bezierCurveTo:splineThru:arc:absarc:ellipse:absellipse:copy:function(t){return Tc.prototype.copy.call(this,t),this.currentPoint.copy(t.currentPoint),this},toJSON:fromJSON:function(t){return Tc.prototype.fromJSON.call(this,t),this.currentPoint.fromArray(t.currentPoint),this}}),Ac.prototype=Object.assign(Object.create(Ec.prototype),{constructor:Ac,getPointsHoles:extractPoints:copy:toJSON:fromJSON:),Lc.prototype=Object.assign(Object.create(Ae.prototype),{constructor:Lc,isLight:!0,copy:toJSON:),Rc.prototype=Object.assign(Object.create(Lc.prototype),{constructor:Rc,isHemisphereLight:!0,copy:function(t){return Lc.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}),Object.assign(Cc.prototype,{_projScreenMatrix:new ne,_lightPositionWorld:new Lt,_lookTarget:new Lt,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:getViewport:function(t){return this._viewports[t]},getFrameExtents:function(){return this._frameExtents},copy:clone:function(){return(new this.constructor).copy(this)},toJSON:),Pc.prototype=Object.assign(Object.create(Cc.prototype),{constructor:Pc,isSpotLightShadow:!0,updateMatrices:),Oc.prototype=Object.assign(Object.create(Lc.prototype),{constructor:Oc,isSpotLight:!0,copy:),Ic.prototype=Object.assign(Object.create(Cc.prototype),{constructor:Ic,isPointLightShadow:!0,updateMatrices:),Dc.prototype=Object.assign(Object.create(Lc.prototype),{constructor:Dc,isPointLight:!0,copy:),Nc.prototype=Object.assign(Object.create(Zn.prototype),{constructor:Nc,isOrthographicCamera:!0,copy:setViewOffset:clearViewOffset:function(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:toJSON:),Bc.prototype=Object.assign(Object.create(Cc.prototype),{constructor:Bc,isDirectionalLightShadow:!0,updateMatrices:),zc.prototype=Object.assign(Object.create(Lc.prototype),{constructor:zc,isDirectionalLight:!0,copy:),Fc.prototype=Object.assign(Object.create(Lc.prototype),{constructor:Fc,isAmbientLight:!0}),Hc.prototype=Object.assign(Object.create(Lc.prototype),{constructor:Hc,isRectAreaLight:!0,copy:toJSON:);var Gc=);.prototype=Object.assign(Object.create(Lc.prototype),{constructor:Uc,isLightProbe:!0,copy:fromJSON:toJSON:),kc.prototype=Object.assign(Object.create(Js.prototype),{constructor:kc,load:function(t,e,n,i){var r=this,a=new Ks(r.manager);a.setPath(r.path),a.setRequestHeader(r.requestHeader),a.setWithCredentials(r.withCredentials),a.load(t,(function(n){try{e(r.parse(JSON.parse(n)))}catch(e){i?i(e):console.error(e),r.manager.itemError(t)}}),n,i)},parse:function(t){var e=this.textures;function n(t){return void 0===e[t]&&console.warn("THREE.MaterialLoader: Undefined texture",t),e[t]}var i=new Ps[t.type];if(void 0!==t.uuid&&(i.uuid=t.uuid),void 0!==t.name&&(i.name=t.name),void 0!==t.color&&void 0!==i.color&&i.color.setHex(t.color),void 0!==t.roughness&&(i.roughness=t.roughness),void 0!==t.metalness&&(i.metalness=t.metalness),void 0!==t.sheen&&(i.sheen=(new Ze).setHex(t.sheen)),void 0!==t.emissive&&void 0!==i.emissive&&i.emissive.setHex(t.emissive),void 0!==t.specular&&void 0!==i.specular&&i.specular.setHex(t.specular),void 0!==t.shininess&&(i.shininess=t.shininess),void 0!==t.clearcoat&&(i.clearcoat=t.clearcoat),void 0!==t.clearcoatRoughness&&(i.clearcoatRoughness=t.clearcoatRoughness),void 0!==t.fog&&(i.fog=t.fog),void 0!==t.flatShading&&(i.flatShading=t.flatShading),void 0!==t.blending&&(i.blending=t.blending),void 0!==t.combine&&(i.combine=t.combine),void 0!==t.side&&(i.side=t.side),void 0!==t.opacity&&(i.opacity=t.opacity),void 0!==t.transparent&&(i.transparent=t.transparent),void 0!==t.alphaTest&&(i.alphaTest=t.alphaTest),void 0!==t.depthTest&&(i.depthTest=t.depthTest),void 0!==t.depthWrite&&(i.depthWrite=t.depthWrite),void 0!==t.colorWrite&&(i.colorWrite=t.colorWrite),void 0!==t.stencilWrite&&(i.stencilWrite=t.stencilWrite),void 0!==t.stencilWriteMask&&(i.stencilWriteMask=t.stencilWriteMask),void 0!==t.stencilFunc&&(i.stencilFunc=t.stencilFunc),void 0!==t.stencilRef&&(i.stencilRef=t.stencilRef),void 0!==t.stencilFuncMask&&(i.stencilFuncMask=t.stencilFuncMask),void 0!==t.stencilFail&&(i.stencilFail=t.stencilFail),void 0!==t.stencilZFail&&(i.stencilZFail=t.stencilZFail),void 0!==t.stencilZPass&&(i.stencilZPass=t.stencilZPass),void 0!==t.wireframe&&(i.wireframe=t.wireframe),void 0!==t.wireframeLinewidth&&(i.wireframeLinewidth=t.wireframeLinewidth),void 0!==t.wireframeLinecap&&(i.wireframeLinecap=t.wireframeLinecap),void 0!==t.wireframeLinejoin&&(i.wireframeLinejoin=t.wireframeLinejoin),void 0!==t.rotation&&(i.rotation=t.rotation),1!==t.linewidth&&(i.linewidth=t.linewidth),void 0!==t.dashSize&&(i.dashSize=t.dashSize),void 0!==t.gapSize&&(i.gapSize=t.gapSize),void 0!==t.scale&&(i.scale=t.scale),void 0!==t.polygonOffset&&(i.polygonOffset=t.polygonOffset),void 0!==t.polygonOffsetFactor&&(i.polygonOffsetFactor=t.polygonOffsetFactor),void 0!==t.polygonOffsetUnits&&(i.polygonOffsetUnits=t.polygonOffsetUnits),void 0!==t.skinning&&(i.skinning=t.skinning),void 0!==t.morphTargets&&(i.morphTargets=t.morphTargets),void 0!==t.morphNormals&&(i.morphNormals=t.morphNormals),void 0!==t.dithering&&(i.dithering=t.dithering),void 0!==t.vertexTangents&&(i.vertexTangents=t.vertexTangents),void 0!==t.visible&&(i.visible=t.visible),void 0!==t.toneMapped&&(i.toneMapped=t.toneMapped),void 0!==t.userData&&(i.userData=t.userData),void 0!==t.vertexColors&&("number"==typeof t.vertexColors?i.vertexColors=t.vertexColors>0:i.vertexColors=t.vertexColors),void 0!==t.uniforms)for(var r in t.uniforms){var a=t.uniforms[r];switch(i.uniforms[r]={},a.type){case"t":i.uniforms[r].value=n(a.value);break;case"c":i.uniforms[r].value=(new Ze).setHex(a.value);break;case"v2":i.uniforms[r].value=(new yt).fromArray(a.value);break;case"v3":i.uniforms[r].value=(new Lt).fromArray(a.value);break;case"v4":i.uniforms[r].value=(new St).fromArray(a.value);break;case"m3":i.uniforms[r].value=(new xt).fromArray(a.value);break;case"m4":i.uniforms[r].value=(new ne).fromArray(a.value);break;default:i.uniforms[r].value=a.value}}if(void 0!==t.defines&&(i.defines=t.defines),void 0!==t.vertexShader&&(i.vertexShader=t.vertexShader),void 0!==t.fragmentShader&&(i.fragmentShader=t.fragmentShader),void 0!==t.extensions)for(var o in t.extensions)i.extensions[o]=t.extensions[o];if(void 0!==t.shading&&(i.flatShading=1===t.shading),void 0!==t.size&&(i.size=t.size),void 0!==t.sizeAttenuation&&(i.sizeAttenuation=t.sizeAttenuation),void 0!==t.map&&(i.map=n(t.map)),void 0!==t.matcap&&(i.matcap=n(t.matcap)),void 0!==t.alphaMap&&(i.alphaMap=n(t.alphaMap)),void 0!==t.bumpMap&&(i.bumpMap=n(t.bumpMap)),void 0!==t.bumpScale&&(i.bumpScale=t.bumpScale),void 0!==t.normalMap&&(i.normalMap=n(t.normalMap)),void 0!==t.normalMapType&&(i.normalMapType=t.normalMapType),void 0!==t.normalScale){var s=t.normalScale;!1===Array.isArray(s)&&(s=[s,s]),i.normalScale=(new yt).fromArray(s)}return void 0!==t.displacementMap&&(i.displacementMap=n(t.displacementMap)),void 0!==t.displacementScale&&(i.displacementScale=t.displacementScale),void 0!==t.displacementBias&&(i.displacementBias=t.displacementBias),void 0!==t.roughnessMap&&(i.roughnessMap=n(t.roughnessMap)),void 0!==t.metalnessMap&&(i.metalnessMap=n(t.metalnessMap)),void 0!==t.emissiveMap&&(i.emissiveMap=n(t.emissiveMap)),void 0!==t.emissiveIntensity&&(i.emissiveIntensity=t.emissiveIntensity),void 0!==t.specularMap&&(i.specularMap=n(t.specularMap)),void 0!==t.envMap&&(i.envMap=n(t.envMap)),void 0!==t.envMapIntensity&&(i.envMapIntensity=t.envMapIntensity),void 0!==t.reflectivity&&(i.reflectivity=t.reflectivity),void 0!==t.refractionRatio&&(i.refractionRatio=t.refractionRatio),void 0!==t.lightMap&&(i.lightMap=n(t.lightMap)),void 0!==t.lightMapIntensity&&(i.lightMapIntensity=t.lightMapIntensity),void 0!==t.aoMap&&(i.aoMap=n(t.aoMap)),void 0!==t.aoMapIntensity&&(i.aoMapIntensity=t.aoMapIntensity),void 0!==t.gradientMap&&(i.gradientMap=n(t.gradientMap)),void 0!==t.clearcoatMap&&(i.clearcoatMap=n(t.clearcoatMap)),void 0!==t.clearcoatRoughnessMap&&(i.clearcoatRoughnessMap=n(t.clearcoatRoughnessMap)),void 0!==t.clearcoatNormalMap&&(i.clearcoatNormalMap=n(t.clearcoatNormalMap)),void 0!==t.clearcoatNormalScale&&(i.clearcoatNormalScale=(new yt).fromArray(t.clearcoatNormalScale)),void 0!==t.transmission&&(i.transmission=t.transmission),void 0!==t.transmissionMap&&(i.transmissionMap=n(t.transmissionMap)),i},setTextures:function(t){return this.textures=t,this}});var Vc={decodeText:extractUrlBase:;nction qc(t){Js.call(this,t)}Wc.prototype=Object.assign(Object.create(Sn.prototype),{constructor:Wc,isInstancedBufferGeometry:!0,copy:function(t){return Sn.prototype.copy.call(this,t),this.instanceCount=t.instanceCount,this},clone:function(){return(new this.constructor).copy(this)},toJSON:function(){var t=Sn.prototype.toJSON.call(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}),jc.prototype=Object.assign(Object.create(nn.prototype),{constructor:jc,isInstancedBufferAttribute:!0,copy:function(t){return nn.prototype.copy.call(this,t),this.meshPerAttribute=t.meshPerAttribute,this},toJSON:),qc.prototype=Object.assign(Object.create(Js.prototype),{constructor:qc,load:parse:function(t){var e={},n={};function i(t,i){if(void 0!==e[i])return e[i];var r=t.interleavedBuffers[i],a=t,r.buffer),o=new ma(vn(r.type,a),r.stride);return o.uuid=r.uuid,e[i]=o,o}var r=t.isInstancedBufferGeometry?new Wc:new Sn,a=t.data.index;if(void 0!==a){var o=vn(a.type,a.array);r.setIndex(new nn(o,1))}var s=t.data.attributes;for(var c in s){var l=s[c],u=void 0;if(l.isInterleavedBufferAttribute){u=new ya(i(t.data,l.data),l.itemSize,l.offset,l.normalized)}else{var h=vn(l.type,l.array);u=new(l.isInstancedBufferAttribute?jc:nn)(h,l.itemSize,l.normalized)}void 0!==l.name&&(u.name=l.name),r.setAttribute(c,u)}var d=t.data.morphAttributes;if(d)for(var p in d){for(var f=d[p],m=[],v=0,g=f.length;v<g;v++){var y=f[v],x=void 0;if(y.isInterleavedBufferAttribute)x=new ya(i(t.data,y.data),y.itemSize,y.offset,y.normalized);else x=new nn(vn(y.type,y.array),y.itemSize,y.normalized);void 0!==y.name&&(x.name=y.name),m.push(x)}r.morphAttributes[p]=m}t.data.morphTargetsRelative&&(r.morphTargetsRelative=!0);var _=t.data.groups||t.data.drawcalls||t.data.offsets;if(void 0!==_)for(var b=0,w=_.length;b!==w;++b){var M=_[b];r.addGroup(M.start,M.count,M.materialIndex)}var S=t.data.boundingSphere;if(void 0!==S){var T=new Lt;void 0!==S.center&&T.fromArray(S.center),r.boundingSphere=new Xt(T,S.radius)}return t.name&&(r.name=t.name),t.userData&&(r.userData=t.userData),r}});var Xc=function(t){t(e,t);var n=e.prototype;return n.load=n.parse=function(t,e){var n=this.parseAnimations(t.animations),i=this.parseShapes(t.shapes),r=this.parseGeometries(t.geometries,i),a=this.parseImages(t.images,(),o=this.parseTextures(t.textures,a),s=this.parseMaterials(t.materials,o),c=this.parseObject(t.object,r,s,n),l=this.parseSkeletons(t.skeletons,c);if(this.bindSkeletons(c,l),void 0!==e){var u=!1;for(var h in a)if(a[h]instanceof HTMLImageElement){u=!0;break}!1===u&&e(c)}return c},n.parseShapes=n.parseSkeletons=n.parseGeometries=function(t,e){var n,i={};if(void 0!==t)for(var r=new qc,a=0,o=t.length;a<o;a++){var s=void 0,c=t[a];switch(c.type){case"PlaneGeometry":case"PlaneBufferGeometry":s=new _s[c.type](c.width,c.height,c.widthSegments,c.heightSegments);break;case"BoxGeometry":case"BoxBufferGeometry":s=new _s[c.type](c.width,c.height,c.depth,c.widthSegments,c.heightSegments,c.depthSegments);break;case"CircleGeometry":case"CircleBufferGeometry":s=new _s[c.type](c.radius,c.segments,c.thetaStart,c.thetaLength);break;case"CylinderGeometry":case"CylinderBufferGeometry":s=new _s[c.type](c.radiusTop,c.radiusBottom,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"ConeGeometry":case"ConeBufferGeometry":s=new _s[c.type](c.radius,c.height,c.radialSegments,c.heightSegments,c.openEnded,c.thetaStart,c.thetaLength);break;case"SphereGeometry":case"SphereBufferGeometry":s=new _s[c.type](c.radius,c.widthSegments,c.heightSegments,c.phiStart,c.phiLength,c.thetaStart,c.thetaLength);break;case"DodecahedronGeometry":case"DodecahedronBufferGeometry":case"IcosahedronGeometry":case"IcosahedronBufferGeometry":case"OctahedronGeometry":case"OctahedronBufferGeometry":case"TetrahedronGeometry":case"TetrahedronBufferGeometry":s=new _s[c.type](c.radius,c.detail);break;case"RingGeometry":case"RingBufferGeometry":s=new _s[c.type](c.innerRadius,c.outerRadius,c.thetaSegments,c.phiSegments,c.thetaStart,c.thetaLength);break;case"TorusGeometry":case"TorusBufferGeometry":s=new _s[c.type](c.radius,c.tube,c.radialSegments,c.tubularSegments,c.arc);break;case"TorusKnotGeometry":case"TorusKnotBufferGeometry":s=new _s[c.type](c.radius,c.tube,c.tubularSegments,c.radialSegments,c.p,c.q);break;case"TubeGeometry":case"TubeBufferGeometry":s=new _s[c.type]((new Sc[c.path.type]).fromJSON(c.path),c.tubularSegments,c.radius,c.radialSegments,c.closed);break;case"LatheGeometry":case"LatheBufferGeometry":s=new _s[c.type](c.points,c.segments,c.phiStart,c.phiLength);break;case"PolyhedronGeometry":case"PolyhedronBufferGeometry":s=new _s[c.type](c.vertices,c.indices,c.radius,c.details);break;case"ShapeGeometry":case"ShapeBufferGeometry":n=[];for(var l=0,u=c.shapes.length;l<u;l++){var h=e[c.shapes[l]];n.push(h)}s=new _s[c.type](n,c.curveSegments);break;case"ExtrudeGeometry":case"ExtrudeBufferGeometry":n=[];for(var d=0,p=c.shapes.length;d<p;d++){var f=e[c.shapes[d]];n.push(f)}var m=c.options.extrudePath;void 0!==m&&(c.options.extrudePath=(new Sc[m.type]).fromJSON(m)),s=new _s[c.type](n,c.options);break;case"BufferGeometry":case"InstancedBufferGeometry":s=r.parse(c);break;case"Geometry":console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+c.type+'"');continue}s.uuid=c.uuid,void 0!==c.name&&(s.name=c.name),!0===s.isBufferGeometry&&void 0!==c.userData&&(s.userData=c.userData),i[c.uuid]=s}return i},n.parseMaterials=n.parseAnimations=n.parseImages=function(t,e){var n,i=this,r={};f(void 0!==t&&t.length>0){var o=new Ys(e);(n=new ec(o)).setCrossOrigin(this.crossOrigin);for(var s=0,c=t.length;s<c;s++){var l=t[s],u=l.url;if(Array.isArray(u)){r[l.uuid]=[];for(var h=0,d=u.length;h<d;h++){var p=a(u[h]);null!==p&&(p instanceof HTMLImageElement?r[l.uuid].push(p):r[l.uuid].push(new ei(p.data,p.width,p.height)))}}else{var f=a(l.url);null!==f&&(r[l.uuid]=f)}}}return r},n.parseTextures=function(t,e){ar i={};if(void 0!==t)for(var r=0,a=t.length;r<a;r++){var o=t[r];void 0===o.image&&console.warn('THREE.ObjectLoader: No "image" specified for',o.uuid),void 0===e[o.image]&&console.warn("THREE.ObjectLoader: Undefined image",o.image);var s=void 0,c=e[o.image];Array.isArray(c)?(s=new $n(c),6===c.length&&(s.needsUpdate=!0)):(s=c&&c.data?new ei(c.data,c.width,c.height):new wt(c),c&&(s.needsUpdate=!0)),s.uuid=o.uuid,void 0!==o.name&&(s.name=o.name),void 0!==o.mapping&&(s.mapping=n(o.mapping,Yc)),void 0!==o.offset&&s.offset.fromArray(o.offset),void 0!==o.repeat&&s.repeat.fromArray(o.repeat),void 0!==o.center&&s.center.fromArray(o.center),void 0!==o.rotation&&(s.rotation=o.rotation),void 0!==o.wrap&&(s.wrapS=n(o.wrap[0],Zc),s.wrapT=n(o.wrap[1],Zc)),void 0!==o.format&&(s.format=o.format),void 0!==o.type&&(s.type=o.type),void 0!==o.encoding&&(s.encoding=o.encoding),void 0!==o.minFilter&&(s.minFilter=n(o.minFilter,Jc)),void 0!==o.magFilter&&(s.magFilter=n(o.magFilter,Jc)),void 0!==o.anisotropy&&(s.anisotropy=o.anisotropy),void 0!==o.flipY&&(s.flipY=o.flipY),void 0!==o.premultiplyAlpha&&(s.premultiplyAlpha=o.premultiplyAlpha),void 0!==o.unpackAlignment&&(s.unpackAlignment=o.unpackAlignment),i[o.uuid]=s}return i},n.parseObject=function(t,e,n,i){var r,a,o;itch(t.type){case"Scene":r=new fa,void 0!==t.background&&Number.isInteger(t.background)&&(r.background=new Ze(t.background)),void 0!==t.fog&&("Fog"===t.fog.type?r.fog=new pa(t.fog.color,t.fog.near,t.fog.far):"FogExp2"===t.fog.type&&(r.fog=new da(t.fog.color,t.fog.density)));break;case"PerspectiveCamera":r=new Jn(t.fov,t.aspect,t.near,t.far),void 0!==t.focus&&(r.focus=t.focus),void 0!==t.zoom&&(r.zoom=t.zoom),void 0!==t.filmGauge&&(r.filmGauge=t.filmGauge),void 0!==t.filmOffset&&(r.filmOffset=t.filmOffset),void 0!==t.view&&(r.view=Object.assign({},t.view));break;case"OrthographicCamera":r=new Nc(t.left,t.right,t.top,t.bottom,t.near,t.far),void 0!==t.zoom&&(r.zoom=t.zoom),void 0!==t.view&&(r.view=Object.assign({},t.view));break;case"AmbientLight":r=new Fc(t.color,t.intensity);break;case"DirectionalLight":r=new zc(t.color,t.intensity);break;case"PointLight":r=new Dc(t.color,t.intensity,t.distance,t.decay);break;case"RectAreaLight":r=new Hc(t.color,t.intensity,t.width,t.height);break;case"SpotLight":r=new Oc(t.color,t.intensity,t.distance,t.angle,t.penumbra,t.decay);break;case"HemisphereLight":r=new Rc(t.color,t.groundColor,t.intensity);break;case"LightProbe":r=(new Uc).fromJSON(t);break;case"SkinnedMesh":r=new ka(a=s(t.geometry),o=c(t.material)),void 0!==t.bindMode&&(r.bindMode=t.bindMode),void 0!==t.bindMatrix&&r.bindMatrix.fromArray(t.bindMatrix),void 0!==t.skeleton&&(r.skeleton=t.skeleton);break;case"Mesh":r=new kn(a=s(t.geometry),o=c(t.material));break;case"InstancedMesh":a=s(t.geometry),o=c(t.material);var l=t.count,u=t.instanceMatrix;(r=new Qa(a,o,l)).instanceMatrix=new nn(new Float32Array(u.array),16);break;case"LOD":r=new Ba;break;case"Line":r=new ro(s(t.geometry),c(t.material));break;case"LineLoop":r=new co(s(t.geometry),c(t.material));break;case"LineSegments":r=new so(s(t.geometry),c(t.material));break;case"PointCloud":case"Points":r=new mo(s(t.geometry),c(t.material));break;case"Sprite":r=new Oa(c(t.material));break;case"Group":r=new oa;break;case"Bone":r=new Va;break;default:r=new Ae}if(r.uuid=t.uuid,void 0!==t.name&&(r.name=t.name),void 0!==t.matrix?(r.matrix.fromArray(t.matrix),void 0!==t.matrixAutoUpdate&&(r.matrixAutoUpdate=t.matrixAutoUpdate),r.matrixAutoUpdate&&r.matrix.decompose(r.position,r.quaternion,r.scale)):(void 0!==t.position&&r.position.fromArray(t.position),void 0!==t.rotation&&r.rotation.fromArray(t.rotation),void 0!==t.quaternion&&r.quaternion.fromArray(t.quaternion),void 0!==t.scale&&r.scale.fromArray(t.scale)),void 0!==t.castShadow&&(r.castShadow=t.castShadow),void 0!==t.receiveShadow&&(r.receiveShadow=t.receiveShadow),t.shadow&&(void 0!==t.shadow.bias&&(r.shadow.bias=t.shadow.bias),void 0!==t.shadow.normalBias&&(r.shadow.normalBias=t.shadow.normalBias),void 0!==t.shadow.radius&&(r.shadow.radius=t.shadow.radius),void 0!==t.shadow.mapSize&&r.shadow.mapSize.fromArray(t.shadow.mapSize),void 0!==t.shadow.camera&&(r.shadow.camera=this.parseObject(t.shadow.camera))),void 0!==t.visible&&(r.visible=t.visible),void 0!==t.frustumCulled&&(r.frustumCulled=t.frustumCulled),void 0!==t.renderOrder&&(r.renderOrder=t.renderOrder),void 0!==t.userData&&(r.userData=t.userData),void 0!==t.layers&&(r.layers.mask=t.layers),void 0!==t.children)for(var h=t.children,d=0;d<h.length;d++)r.add(this.parseObject(h[d],e,n,i));if(void 0!==t.animations)for(var p=t.animations,f=0;f<p.length;f++){var m=p[f];r.animations.push(i[m])}if("LOD"===t.type){void 0!==t.autoUpdate&&(r.autoUpdate=t.autoUpdate);for(var v=t.levels,g=0;g<v.length;g++){var y=v[g],x=r.getObjectByProperty("uuid",y.object);void 0!==x&&r.addLevel(x,y.distance)}}return r},n.bindSkeletons=n.setTexturePath=e}(Js),Yc={UVMapping:r,CubeReflectionMapping:a,CubeRefractionMapping:o,EquirectangularReflectionMapping:s,EquirectangularRefractionMapping:c,CubeUVReflectionMapping:l,CubeUVRefractionMapping:u},Zc={RepeatWrapping:h,ClampToEdgeWrapping:d,MirroredRepeatWrapping:p},Jc={NearestFilter:f,NearestMipmapNearestFilter:m,NearestMipmapLinearFilter:v,LinearFilter:g,LinearMipmapNearestFilter:y,LinearMipmapLinearFilter:x};.prototype=Object.assign(Object.create(Js.prototype),{constructor:Qc,isImageBitmapLoader:!0,setOptions:function(t){return this.options=t,this},load:),Object.assign(Kc.prototype,{moveTo:lineTo:quadraticCurveTo:bezierCurveTo:splineThru:toShapes:);var $c,tl=function(){function t(t){Object.defineProperty(this,"isFont",{value:!0}),this.type="Font",this.data=t}return t.prototype.generateShapes=t}();unction nl(t){Js.call(this,t)}nl.prototype=Object.assign(Object.create(Js.prototype),{constructor:nl,load:parse:);var il={getContext:setContext:function(t){$c=t}};prototype=Object.assign(Object.create(Js.prototype),{constructor:rl,load:),al.prototype=Object.assign(Object.create(Uc.prototype),{constructor:al,isHemisphereLightProbe:!0,copy:function(t){return Uc.prototype.copy.call(this,t),this},toJSON:function(t){return Uc.prototype.toJSON.call(this,t)}}),ol.prototype=Object.assign(Object.create(Uc.prototype),{constructor:ol,isAmbientLightProbe:!0,copy:toJSON:);var sl=new ne,cl=new ne;bject.assign(ll.prototype,{update:);var ul=function(){ar e=t.prototype;return e.start=e.stop=e.getElapsedTime=e.getDelta=t}();ar dl=new Lt,pl=new At,fl=new Lt,ml=new Lt,vl=Ae),gl=function(t){t(e,t);var n=e.prototype;return n.getOutput=function(){return this.gain},n.setNodeSource=n.setMediaElementSource=function(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this},n.setMediaStreamSource=n.setBuffer=n.play=n.pause=n.stop=n.connect=function(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this},n.disconnect=n.getFilters=function(){return this.filters},n.setFilters=n.setDetune=n.getDetune=function(){return this.detune},n.getFilter=n.setFilter=n.setPlaybackRate=n.getPlaybackRate=function(){return this.playbackRate},n.onEnded=n.getLoop=n.setLoop=n.setLoopStart=function(t){return this.loopStart=t,this},n.setLoopEnd=function(t){return this.loopEnd=t,this},n.getVolume=n.setVolume=e}(Ae),yl=new Lt,xl=new At,_l=new Lt,bl=new Lt,wl=gl),Ml=function(){function t(t,e){void 0===e&&(e=2048),this.analyser=t.context.createAnalyser(),this.analyser.fftSize=e,this.data=new Uint8Array(this.analyser.frequencyBinCount),t.getOutput().connect(this.analyser)}var e=t.prototype;return e.getFrequencyData=e.getAverageFrequency=t}();bject.assign(Sl.prototype,{accumulate:accumulateAdditive:apply:saveOriginalState:restoreOriginalState:_setAdditiveIdentityNumeric:_setAdditiveIdentityQuaternion:_setAdditiveIdentityOther:_select:_slerp:_slerpAdditive:_lerp:_lerpAdditive:);var Tl="\\[\\]\\.:\\/",El=new RegExp("[\\[\\]\\.:\\/]","g"),Al="[^\\[\\]\\.:\\/]",Ll="[^"+Tl.replace("\\.","")+"]",Rl=/((?:WC+[\/:])*)/.source.replace("WC",Al),Cl=/(WCOD+)?/.source.replace("WCOD",Ll),Pl=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",Al),Ol=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",Al),Il=new RegExp("^"+Rl+Cl+Pl+Ol+"$"),Dl=["material","materials","bones"];ect.assign(Nl.prototype,{getValue:setValue:bind:function(){for(var t=this._bindings,e=this._targetGroup.nCachedObjects_,n=t.length;e!==n;++e)t[e].bind()},unbind:),Object.assign(Bl,{Composite:Nl,create:sanitizeNodeName:parseTrackName:findNode:),Object.assign(Bl.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(t,e){t[e]=this.node[this.propertyName]},function(t,e){this.resolvedProperty.toArray(t,e)}],SetterByBindingTypeAndVersioning:[[function(t,e){this.targetObject[this.propertyName]=t[e]},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0},function(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,e){for(var n=this.resolvedProperty,i=0,r=n.length;i!==r;++i)n[i]=t[e++];this.targetObject.needsUpdate=!0},,[function(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0},,[function(t,e){this.resolvedProperty.fromArray(t,e)},function(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0},],getValue:function(t,e){this.bind(),this.getValue(t,e)},setValue:bind:unbind:),Object.assign(Bl.prototype,{_getValue_unbound:Bl.prototype.getValue,_setValue_unbound:Bl.prototype.setValue}),Object.assign(zl.prototype,{isAnimationObjectGroup:!0,add:remove:uncache:function(){for(var t=this._objects,e=this._indicesByUUID,n=this._bindings,i=n.length,r=this.nCachedObjects_,a=t.length,o=0,s=arguments.length;o!==s;++o){var c=arguments[o],l=c.uuid,u=e[l];if(void 0!==u)if(delete e[l],u<r){var h=--r,d=t[h],p=--a,f=t[p];e[d.uuid]=u,t[u]=d,e[f.uuid]=h,t[h]=f,t.pop();for(var m=0,v=i;m!==v;++m){var g=n[m],y=g[h],x=g[p];g[u]=y,g[h]=x,g.pop()}}else{var _=--a,b=t[_];_>0&&(e[b.uuid]=u),t[u]=b,t.pop();for(var w=0,M=i;w!==M;++w){var S=n[w];S[u]=S[_],S.pop()}}}this.nCachedObjects_=r},subscribe_:unsubscribe_:);var Fl=function(){function t(t,e,n,i){void 0===n&&(n=null),void 0===i&&(i=e.blendMode),this._mixer=t,this._clip=e,this._localRoot=n,this.blendMode=i;for(var r=e.tracks,a=r.length,o=new Array(a),s={endingStart:V,endingEnd:V},c=0;c!==a;++c){var l=r[c].createInterpolant(null);o[c]=l,l.settings=s}this._interpolantSettings=s,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}var e=t.prototype;return e.play=e.stop=e.reset=e.isRunning=e.isScheduled=e.startAt=function(t){return this._startTime=t,this},e.setLoop=function(t,e){return this.loop=t,this.repetitions=e,this},e.setEffectiveWeight=e.getEffectiveWeight=function(){return this._effectiveWeight},e.fadeIn=function(t){return this._scheduleFading(t,0,1)},e.fadeOut=e.crossFadeFrom=e.crossFadeTo=e.stopFading=function(){var t=this._weightInterpolant;return null!==t&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this},e.setEffectiveTimeScale=e.getEffectiveTimeScale=function(){return this._effectiveTimeScale},e.setDuration=e.syncWith=e.halt=e.warp=e.stopWarping=e.getMixer=function(){return this._mixer},e.getClip=function(){return this._clip},e.getRoot=e._update=e._updateWeight=e._updateTimeScale=e._updateTime=e._setEndings=e._scheduleFading=t}();l.prototype=Object.assign(Object.create(dt.prototype),{constructor:Hl,_bindAction:_activateAction:_deactivateAction:_initMemoryManager:_isActiveAction:_addInactiveAction:_removeInactiveAction:_removeInactiveBindingsForAction:_lendAction:function(t){var e=this._actions,n=t._cacheIndex,i=this._nActiveActions++,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_takeBackAction:function(t){var e=this._actions,n=t._cacheIndex,i=--this._nActiveActions,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_addInactiveBinding:_removeInactiveBinding:_lendBinding:_takeBackBinding:function(t){var e=this._bindings,n=t._cacheIndex,i=--this._nActiveBindings,r=e[i];t._cacheIndex=i,e[i]=t,r._cacheIndex=n,e[n]=r},_lendControlInterpolant:_takeBackControlInterpolant:_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:existingAction:stopAllAction:update:setTime:getRoot:uncacheClip:uncacheRoot:uncacheAction:);var Gl=function(){eturn t.prototype.clone=t}();ototype=Object.assign(Object.create(ma.prototype),{constructor:Ul,isInstancedInterleavedBuffer:!0,copy:clone:toJSON:),Object.defineProperty(kl.prototype,"needsUpdate",{set:),Object.assign(kl.prototype,{isGLBufferAttribute:!0,setBuffer:function(t){return this.buffer=t,this},setType:setItemSize:function(t){return this.itemSize=t,this},setCount:),Object.assign(Vl.prototype,{set:setFromCamera:intersectObject:intersectObjects:);var ql=),Xl=),Yl=new yt,Zl=),Jl=new Lt,Ql=new Lt,Kl=);l.prototype=Object.create(Ae.prototype),$l.prototype.constructor=$l,$l.prototype.isImmediateRenderObject=!0;var tu=new Lt,eu=Ae),nu=new Lt,iu=new ne,ru=new ne,au=function(t){eturn ct(e,t),e.prototype.updateMatrixWorld=function(e){var n=this.bones,i=this.geometry,r=i.getAttribute("position");ru.copy(this.root.matrixWorld).invert();for(var a=0,o=0;a<n.length;a++){var s=n[a];s.parent&&s.parent.isBone&&(iu.multiplyMatrices(ru,s.matrixWorld),nu.setFromMatrixPosition(iu),r.setXYZ(o,nu.x,nu.y,nu.z),iu.multiplyMatrices(ru,s.parent.matrixWorld),nu.setFromMatrixPosition(iu),r.setXYZ(o+1,nu.x,nu.y,nu.z),o+=2)}i.getAttribute("position").needsUpdate=!0,t.prototype.updateMatrixWorld.call(this,e)},e}(so);ar su=kn),cu=new Lt,lu=new Ze,uu=new Ze,hu=Ae),du=function(t){function e(e,n,i,r){var a;void 0===e&&(e=10),void 0===n&&(n=10),void 0===i&&(i=4473924),void 0===r&&(r=8947848),i=new Ze(i),r=new Ze(r);for(var o=n/2,s=e/n,c=e/2,l=[],u=[],h=0,d=0,p=-c;h<=n;h++,p+=s){l.push(-c,0,p,c,0,p),l.push(p,0,-c,p,0,c);var f=h===o?i:r;f.toArray(u,d),d+=3,f.toArray(u,d),d+=3,f.toArray(u,d),d+=3,f.toArray(u,d),d+=3}var m=new Sn;m.setAttribute("position",new dn(l,3)),m.setAttribute("color",new dn(u,3));var v=new Ka({vertexColors:!0,toneMapped:!1});return(a=t.call(this,m,v)||this).type="GridHelper",a}return ct(e,t),e}(so),pu=function(t){function e(e,n,i,r,a,o){var s;void 0===e&&(e=10),void 0===n&&(n=16),void 0===i&&(i=8),void 0===r&&(r=64),void 0===a&&(a=4473924),void 0===o&&(o=8947848),a=new Ze(a),o=new Ze(o);for(var c=[],l=[],u=0;u<=n;u++){var h=u/n*(2*Math.PI),d=Math.sin(h)*e,p=Math.cos(h)*e;c.push(0,0,0),c.push(d,0,p);var f=1&u?a:o;l.push(f.r,f.g,f.b),l.push(f.r,f.g,f.b)}for(var m=0;m<=i;m++)for(var v=1&m?a:o,g=e-e/i*m,y=0;y<r;y++){var x=y/r*(2*Math.PI),_=Math.sin(x)*g,b=Math.cos(x)*g;c.push(_,0,b),l.push(v.r,v.g,v.b),x=(y+1)/r*(2*Math.PI),_=Math.sin(x)*g,b=Math.cos(x)*g,c.push(_,0,b),l.push(v.r,v.g,v.b)}var w=new Sn;w.setAttribute("position",new dn(c,3)),w.setAttribute("color",new dn(l,3));var M=new Ka({vertexColors:!0,toneMapped:!1});return(s=t.call(this,w,M)||this).type="PolarGridHelper",s}return ct(e,t),e}(so),fu=new Lt,mu=new Lt,vu=new Lt,gu=Ae),yu=new Lt,xu=new Zn,_u=function(t){eturn ct(e,t),e.prototype.update=e}(so);ar wu,Mu,Su,Tu=new Pt,Eu=so),Au=so),Lu=function(t){function e(e,n,i){var r;void 0===n&&(n=1),void 0===i&&(i=16776960);var a=i,o=new Sn;o.setAttribute("position",new dn([1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0],3)),o.computeBoundingSphere(),(r=t.call(this,o,new Ka({color:a,toneMapped:!1}))||this).type="PlaneHelper",r.plane=e,r.size=n;var s=new Sn;return s.setAttribute("position",new dn([1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1],3)),s.computeBoundingSphere(),r.add(new kn(s,new $e({color:a,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1}))),r}return ct(e,t),e.prototype.updateMatrixWorld=e}(ro),Ru=new Lt,Cu=Ae),Pu=so),Ou=new Float32Array(1),Iu=new Int32Array(Ou.buffer),Du={toHalfFloat:function(t){Ou[0]=t;var e=Iu[0],n=e>>16&32768,i=e>>12&2047,r=e>>23&255;return r<103?n:r>142?(n|=31744,n|=(255==r?0:1)&&8388607&e):r<113?n|=((i|=2048)>>114-r)+(i>>113-r&1):(n|=r-112<<10|i>>1,n+=1&i)}},Nu=Math.pow(2,8),Bu=[.125,.215,.35,.446,.526,.582],zu=5+Bu.length,Fu=20,Hu=((Su={})[3e3]=0,Su[3001]=1,Su[3002]=2,Su[3004]=3,Su[3005]=4,Su[3006]=5,Su[3007]=6,Su),Gu=new $e({side:1,depthWrite:!1,depthTest:!1}),Uu=new kn(new Wn,Gu),ku=new Nc,Vu=eh(),Wu=Vu._lodPlanes,ju=Vu._sizeLods,qu=Vu._sigmas,Xu=new Ze,Yu=null,Zu=(1+Math.sqrt(5))/2,Ju=1/Zu,Qu=[new Lt(1,1,1),new Lt(-1,1,1),new Lt(1,1,-1),new Lt(-1,1,-1),new Lt(0,Zu,Ju),new Lt(0,Zu,-Ju),new Lt(Ju,0,Zu),new Lt(-Ju,0,Zu),new Lt(Zu,Ju,0),new Lt(-Zu,Ju,0)];function Ku(t){var e=Math.max(t.r,t.g,t.b),n=Math.min(Math.max(Math.ceil(Math.log2(e)),-128),127);return t.multiplyScalar(Math.pow(2,-n)),(n+128)/255}var $u=function(){function t(t){var e,n,i;this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=(e=Fu,n=new Float32Array(e),i=new Lt(0,1,0),new ws({name:"SphericalGaussianBlur",defines:{n:e},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i},inputEncoding:{value:Hu[3e3]},outputEncoding:{value:Hu[3e3]}},vertexShader:"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t",blending:0,depthTest:!1,depthWrite:!1})),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}var e=t.prototype;return e.fromScene=e.fromEquirectangular=function(t){return this._fromTexture(t)},e.fromCubemap=e.compileCubemapShader=function(){null===this._cubemapShader&&(this._cubemapShader=ah(),this._compileMaterial(this._cubemapShader))},e.compileEquirectangularShader=e.dispose=e._cleanup=e._fromTexture=e._allocateTargets=e._compileMaterial=e._sceneToCubeUV=function(t,e,n,i){var r=new Jn(90,1,e,n),a=[1,-1,1,1,1,1],o=[1,1,1,-1,-1,-1],s=this._renderer,c=s.autoClear,l=s.outputEncoding,u=s.toneMapping;s.getClearColor(Xu),s.toneMapping=0,s.outputEncoding=Y,s.autoClear=!1;var h=!1,d=t.background;if(d){if(d.isColor){Gu.color.copy(d).convertSRGBToLinear(),t.background=null;var p=Ku(Gu.color);Gu.opacity=p,h=!0}}else{Gu.color.copy(Xu).convertSRGBToLinear();var f=Ku(Gu.color);Gu.opacity=f,h=!0}for(var m=0;m<6;m++){var v=m%3;0==v?(r.up.set(0,a[m],0),r.lookAt(o[m],0,0)):1==v?(r.up.set(0,0,a[m]),r.lookAt(0,o[m],0)):(r.up.set(0,a[m],0),r.lookAt(0,0,o[m])),ih(i,v*Nu,m>2?Nu:0,Nu,Nu),s.setRenderTarget(i),h&&s.render(Uu,r),s.render(t,r)}s.toneMapping=u,s.outputEncoding=l,s.autoClear=c},e._textureToCubeUV=e._applyPMREM=e._blur=e._halfBlur=function(t,e,n,i,r,a,o){var s=this._renderer,c=this._blurMaterial;"latitudinal"!==a&&"longitudinal"!==a&&console.error("blur direction must be either latitudinal or longitudinal!");var l=new kn(Wu[i],c),u=c.uniforms,h=ju[n]-1,d=isFinite(r)?Math.PI/(2*h):2*Math.PI/39,p=r/d,f=isFinite(r)?1+Math.floor(3*p):Fu;f>Fu&&console.warn("sigmaRadians, "+r+", is too large and will clip, as it requested "+f+" samples when the maximum is set to "+Fu);for(var m=[],v=0,g=0;g<Fu;++g){var y=g/p,x=Math.exp(-y*y/2);m.push(x),0==g?v+=x:g<f&&(v+=2*x)}for(var _=0;_<m.length;_++)m[_]=m[_]/v;u.envMap.value=t.texture,u.samples.value=f,u.weights.value=m,u.latitudinal.value="latitudinal"===a,o&&(u.poleAxis.value=o),u.dTheta.value=d,u.mipInt.value=8-n,u.inputEncoding.value=Hu[t.texture.encoding],u.outputEncoding.value=Hu[t.texture.encoding];var b=ju[i];ih(e,3*Math.max(0,Nu-2*b),(0===i?0:2*Nu)+2*b*(i>4?i-8+4:0),3*b,2*b),s.setRenderTarget(e),s.render(l,ku)},t}();unction eh(){for(var t=[],e=[],n=[],i=8,r=0;r<zu;r++){var a=Math.pow(2,i);e.push(a);var o=1/a;r>4?o=Bu[r-8+4-1]:0==r&&(o=0),n.push(o);for(var s=1/(a-1),c=-s/2,l=1+s/2,u=[c,c,l,c,l,l,c,c,l,l,c,l],h=new Float32Array(108),d=new Float32Array(72),p=new Float32Array(36),f=0;f<6;f++){var m=f%3*2/3-1,v=f>2?0:-1,g=[m,v,0,m+2/3,v,0,m+2/3,v+1,0,m,v,0,m+2/3,v+1,0,m,v+1,0];h.set(g,18*f),d.set(u,12*f);var y=[f,f,f,f,f,f];p.set(y,6*f)}var x=new Sn;x.setAttribute("position",new nn(h,3)),x.setAttribute("uv",new nn(d,2)),x.setAttribute("faceIndex",new nn(p,1)),t.push(x),i>4&&i--}return{_lodPlanes:t,_sizeLods:e,_sigmas:n}}ion sh(t){console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),pc.call(this,t),this.type="catmullrom"}c.create=Object.assign(Ec.prototype,{fromPoints:function(t){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(t)}}),oh.prototype=Object.create(pc.prototype),sh.prototype=Object.create(pc.prototype),ch.prototype=Object.create(pc.prototype),Object.assign(ch.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}}),du.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},au.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},Object.assign(Js.prototype,{extractUrlBase:function(t){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Vc.extractUrlBase(t)}}),Js.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},Object.assign(Zl.prototype,{center:function(t){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},size:function(t){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(t)}}),Object.assign(Pt.prototype,{center:function(t){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(t)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(t){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionSphere:function(t){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)},size:function(t){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(t)}}),Object.assign(Xt.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}}),ri.prototype.setFromMatrix=function(t){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(t)},Kl.prototype.center=function(t){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(t)},Object.assign(gt,{random16:nearestPowerOfTwo:function(t){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),gt.floorPowerOfTwo(t)},nextPowerOfTwo:),Object.assign(xt.prototype,{flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},multiplyVector3:function(t){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(t){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),t.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(t){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(t).invert()}}),Object.assign(ne.prototype,{extractPosition:function(t){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(t)},flattenToArrayOffset:function(t,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(t,e)},getPosition:setRotationFromQuaternion:function(t){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(t)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(t){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector4:function(t){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:crossVector:function(t){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(t){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),t.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:getInverse:),Pe.prototype.isIntersectionLine=function(t){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(t)},Object.assign(At.prototype,{multiplyVector3:inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}}),Object.assign(ee.prototype,{isIntersectionBox:function(t){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(t)},isIntersectionPlane:function(t){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(t)},isIntersectionSphere:function(t){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(t)}}),Object.assign(ke.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(t,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(t,e)},midpoint:function(t){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(t)},normal:function(t){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(t)},plane:function(t){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(t)}}),Object.assign(ke,{barycoordFromPoint:normal:),Object.assign(Ac.prototype,{extractAllPoints:function(t){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(t)},extrude:function(t){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new as(this,t)},makeGeometry:),Object.assign(yt.prototype,{fromAttribute:function(t,e,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},distanceToManhattan:function(t){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Lt.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(t){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(t)},getScaleFromMatrix:function(t){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(t)},getColumnFromMatrix:function(t,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,t)},applyProjection:function(t){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(t)},fromAttribute:function(t,e,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(t,e,n)},distanceToManhattan:function(t){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(t)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(St.prototype,{fromAttribute:lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}}),Object.assign(Ae.prototype,{getChildByName:function(t){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(t)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(t,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,t)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(t){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)}}),Object.defineProperties(Ae.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(t){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=t}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),Object.assign(kn.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}),Object.defineProperties(kn.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),Object.defineProperties(Ba.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}}),Object.defineProperty(qa.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}}),ka.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},Object.defineProperty(ac.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(t){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=t}}),Jn.prototype.setLens=Object.defineProperties(Lc.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(t){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=t}},shadowCameraLeft:{set:function(t){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=t}},shadowCameraRight:{set:function(t){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=t}},shadowCameraTop:{set:function(t){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=t}},shadowCameraBottom:{set:function(t){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=t}},shadowCameraNear:{set:function(t){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=t}},shadowCameraFar:{set:function(t){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=t}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(t){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=t}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(t){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=t}},shadowMapHeight:{set:function(t){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=t}}}),Object.defineProperties(nn.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===it},set:}),Object.assign(nn.prototype,{setDynamic:function(t){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===t?it:nt),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(Sn.prototype,{addIndex:function(t){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(t)},addAttribute:addDrawCall:clearDrawCalls:computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(t){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(t)},applyMatrix:function(t){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(t)}}),Object.defineProperties(Sn.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),Object.defineProperties(Wc.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(t){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=t}}}),Object.defineProperties(Vl.prototype,{linePrecision:{get:set:}),Object.defineProperties(ma.prototype,{dynamic:{get:set:function(t){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(t)}}}),Object.assign(ma.prototype,{setDynamic:setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}}),Object.assign(as.prototype,{getArrays:function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")}}),Object.assign(fa.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}}),Object.defineProperties(Gl.prototype,{dynamic:{set:function(){console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")}},onUpdate:{value:}),Object.defineProperties(Ke.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:,shading:{get:set:,stencilMask:{get:set:}),Object.defineProperties(Ts.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}}),Object.defineProperties(Ss.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:}),Object.defineProperties(Yn.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(t){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=t}}}),Object.assign(ua.prototype,{clearTarget:animate:function(t){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(t)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:enableScissorTest:initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}}),Object.defineProperties(ua.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=t}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(t){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=t}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:set:,toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(ea.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(Tt.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=t}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(t){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=t}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=t}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(t){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=t}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(t){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=t}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(t){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=t}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(t){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=t}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(t){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=t}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(t){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=t}},generateMipmaps:{get:set:}),Object.defineProperties(gl.prototype,{load:{value:,startTime:{set:function(){console.warn("THREE.Audio: .startTime is now .play( delay ).")}}}),Ml.prototype.getData=Kn.prototype.updateCubeMap=Kn.prototype.clear=var lh={merge:center:;_t.crossOrigin=void 0,_t.loadTexture=function(t,e,n,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");var r=new rc;r.setCrossOrigin(this.crossOrigin);var a=r.load(t,n,void 0,i);return e&&(a.mapping=e),a},_t.loadTextureCube=_t.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},_t.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};var uh={createMultiMaterialObject:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},detach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")},attach:function(){console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js")}};"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:n}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=n),t.ACESFilmicToneMapping=4,t.AddEquation=i,t.AddOperation=2,t.AdditiveAnimationBlendMode=X,t.AdditiveBlending=2,t.AlphaFormat=1021,t.AlwaysDepth=1,t.AlwaysStencilFunc=519,t.AmbientLight=Fc,t.AmbientLightProbe=ol,t.AnimationClip=js,t.AnimationLoader=$s,t.AnimationMixer=Hl,t.AnimationObjectGroup=zl,t.AnimationUtils=Os,t.ArcCurve=sc,t.ArrayCamera=aa,t.ArrowHelper=Cu,t.Audio=gl,t.AudioAnalyser=Ml,t.AudioContext=il,t.AudioListener=vl,t.AudioLoader=rl,t.AxesHelper=Pu,t.AxisHelper=function(t){return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),new Pu(t)},t.BackSide=1,t.BasicDepthPacking=3200,t.BasicShadowMap=0,t.BinaryTextureLoader=function(t){return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),new ic(t)},t.Bone=Va,t.BooleanKeyframeTrack=Fs,t.BoundingBoxHelper=function(t,e){return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),new Eu(t,e)},t.Box2=Zl,t.Box3=Pt,t.Box3Helper=Au,t.BoxBufferGeometry=Wn,t.BoxGeometry=Wn,t.BoxHelper=Eu,t.BufferAttribute=nn,t.BufferGeometry=Sn,t.BufferGeometryLoader=qc,t.ByteType=1010,t.Cache=Xs,t.Camera=Zn,t.CameraHelper=_u,t.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been removed")},t.CanvasTexture=xo,t.CatmullRomCurve3=pc,t.CineonToneMapping=3,t.CircleBufferGeometry=bo,t.CircleGeometry=bo,t.ClampToEdgeWrapping=d,t.Clock=ul,t.ClosedSplineCurve3=oh,t.Color=Ze,t.ColorKeyframeTrack=Hs,t.CompressedTexture=yo,t.CompressedTextureLoader=tc,t.ConeBufferGeometry=Mo,t.ConeGeometry=Mo,t.CubeCamera=Kn,t.CubeReflectionMapping=a,t.CubeRefractionMapping=o,t.CubeTexture=$n,t.CubeTextureLoader=nc,t.CubeUVReflectionMapping=l,t.CubeUVRefractionMapping=u,t.CubicBezierCurve=gc,t.CubicBezierCurve3=yc,t.CubicInterpolant=Ds,t.CullFaceBack=1,t.CullFaceFront=2,t.CullFaceFrontBack=3,t.CullFaceNone=0,t.Curve=ac,t.CurvePath=Tc,t.CustomBlending=5,t.CustomToneMapping=5,t.CylinderBufferGeometry=wo,t.CylinderGeometry=wo,t.Cylindrical=Xl,t.DataTexture=ei,t.DataTexture2DArray=Ti,t.DataTexture3D=Ei,t.DataTextureLoader=ic,t.DataUtils=Du,t.DecrementStencilOp=7683,t.DecrementWrapStencilOp=34056,t.DefaultLoadingManager=Zs,t.DepthFormat=L,t.DepthStencilFormat=R,t.DepthTexture=_o,t.DirectionalLight=zc,t.DirectionalLightHelper=gu,t.DiscreteInterpolant=Bs,t.DodecahedronBufferGeometry=To,t.DodecahedronGeometry=To,t.DoubleSide=2,t.DstAlphaFactor=206,t.DstColorFactor=208,t.DynamicBufferAttribute=t.DynamicCopyUsage=35050,t.DynamicDrawUsage=it,t.DynamicReadUsage=35049,t.EdgesGeometry=Co,t.EdgesHelper=function(t,e){return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),new so(new Co(t.geometry),new Ka({color:void 0!==e?e:16777215}))},t.EllipseCurve=oc,t.EqualDepth=4,t.EqualStencilFunc=514,t.EquirectangularReflectionMapping=s,t.EquirectangularRefractionMapping=c,t.Euler=ue,t.EventDispatcher=dt,t.ExtrudeBufferGeometry=as,t.ExtrudeGeometry=as,t.Face3=Je,t.Face4=t.FaceColors=1,t.FileLoader=Ks,t.FlatShading=1,t.Float16BufferAttribute=hn,t.Float32Attribute=function(t,e){return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),new dn(t,e)},t.Float32BufferAttribute=dn,t.Float64Attribute=function(t,e){return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),new pn(t,e)},t.Float64BufferAttribute=pn,t.FloatType=M,t.Fog=pa,t.FogExp2=da,t.Font=tl,t.FontLoader=nl,t.FrontSide=0,t.Frustum=ri,t.GLBufferAttribute=kl,t.GLSL1="100",t.GLSL3=rt,t.GammaEncoding=J,t.GeometryUtils=lh,t.GreaterDepth=6,t.GreaterEqualDepth=5,t.GreaterEqualStencilFunc=518,t.GreaterStencilFunc=516,t.GridHelper=du,t.Group=oa,t.HalfFloatType=S,t.HemisphereLight=Rc,t.HemisphereLightHelper=hu,t.HemisphereLightProbe=al,t.IcosahedronBufferGeometry=ss,t.IcosahedronGeometry=ss,t.ImageBitmapLoader=Qc,t.ImageLoader=ec,t.ImageUtils=_t,t.ImmediateRenderObject=$l,t.IncrementStencilOp=7682,t.IncrementWrapStencilOp=34055,t.InstancedBufferAttribute=jc,t.InstancedBufferGeometry=Wc,t.InstancedInterleavedBuffer=Ul,t.InstancedMesh=Qa,t.Int16Attribute=function(t,e){return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),new sn(t,e)},t.Int16BufferAttribute=sn,t.Int32Attribute=function(t,e){return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),new ln(t,e)},t.Int32BufferAttribute=ln,t.Int8Attribute=function(t,e){return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),new rn(t,e)},t.Int8BufferAttribute=rn,t.IntType=1013,t.InterleavedBuffer=ma,t.InterleavedBufferAttribute=ya,t.Interpolant=Is,t.InterpolateDiscrete=G,t.InterpolateLinear=U,t.InterpolateSmooth=k,t.InvertStencilOp=5386,t.JSONLoader=function(){console.error("THREE.JSONLoader has been removed.")},t.KeepStencilOp=et,t.KeyframeTrack=zs,t.LOD=Ba,t.LatheBufferGeometry=cs,t.LatheGeometry=cs,t.Layers=pe,t.LensFlare=t.LessDepth=2,t.LessEqualDepth=3,t.LessEqualStencilFunc=515,t.LessStencilFunc=513,t.Light=Lc,t.LightProbe=Uc,t.Line=ro,t.Line3=Kl,t.LineBasicMaterial=Ka,t.LineCurve=xc,t.LineCurve3=_c,t.LineDashedMaterial=Cs,t.LineLoop=co,t.LinePieces=1,t.LineSegments=so,t.LineStrip=0,t.LinearEncoding=Y,t.LinearFilter=g,t.LinearInterpolant=Ns,t.LinearMipMapLinearFilter=1008,t.LinearMipMapNearestFilter=1007,t.LinearMipmapLinearFilter=x,t.LinearMipmapNearestFilter=y,t.LinearToneMapping=1,t.Loader=Js,t.LoaderUtils=Vc,t.LoadingManager=Ys,t.LogLuvEncoding=3003,t.LoopOnce=2200,t.LoopPingPong=2202,t.LoopRepeat=2201,t.LuminanceAlphaFormat=1025,t.LuminanceFormat=1024,t.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},t.Material=Ke,t.MaterialLoader=kc,t.Math=gt,t.MathUtils=gt,t.Matrix3=xt,t.Matrix4=ne,t.MaxEquation=104,t.Mesh=kn,t.MeshBasicMaterial=$e,t.MeshDepthMaterial=$r,t.MeshDistanceMaterial=ta,t.MeshFaceMaterial=t.MeshLambertMaterial=Ls,t.MeshMatcapMaterial=Rs,t.MeshNormalMaterial=As,t.MeshPhongMaterial=Ts,t.MeshPhysicalMaterial=Ss,t.MeshStandardMaterial=Ms,t.MeshToonMaterial=Es,t.MinEquation=103,t.MirroredRepeatWrapping=p,t.MixOperation=1,t.MultiMaterial=t.MultiplyBlending=4,t.MultiplyOperation=0,t.NearestFilter=f,t.NearestMipMapLinearFilter=1005,t.NearestMipMapNearestFilter=1004,t.NearestMipmapLinearFilter=v,t.NearestMipmapNearestFilter=m,t.NeverDepth=0,t.NeverStencilFunc=512,t.NoBlending=0,t.NoColors=0,t.NoToneMapping=0,t.NormalAnimationBlendMode=q,t.NormalBlending=1,t.NotEqualDepth=7,t.NotEqualStencilFunc=517,t.NumberKeyframeTrack=Gs,t.Object3D=Ae,t.ObjectLoader=Xc,t.ObjectSpaceNormalMap=1,t.OctahedronBufferGeometry=ls,t.OctahedronGeometry=ls,t.OneFactor=201,t.OneMinusDstAlphaFactor=207,t.OneMinusDstColorFactor=209,t.OneMinusSrcAlphaFactor=205,t.OneMinusSrcColorFactor=203,t.OrthographicCamera=Nc,t.PCFShadowMap=1,t.PCFSoftShadowMap=2,t.PMREMGenerator=$u,t.ParametricBufferGeometry=us,t.ParametricGeometry=us,t.Particle=function(t){return console.warn("THREE.Particle has been renamed to THREE.Sprite."),new Oa(t)},t.ParticleBasicMaterial=function(t){return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),new lo(t)},t.ParticleSystem=function(t,e){return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),new mo(t,e)},t.ParticleSystemMaterial=function(t){return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),new lo(t)},t.Path=Ec,t.PerspectiveCamera=Jn,t.Plane=Pe,t.PlaneBufferGeometry=si,t.PlaneGeometry=si,t.PlaneHelper=Lu,t.PointCloud=function(t,e){return console.warn("THREE.PointCloud has been renamed to THREE.Points."),new mo(t,e)},t.PointCloudMaterial=function(t){return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),new lo(t)},t.PointLight=Dc,t.PointLightHelper=su,t.Points=mo,t.PointsMaterial=lo,t.PolarGridHelper=pu,t.PolyhedronBufferGeometry=So,t.PolyhedronGeometry=So,t.PositionalAudio=wl,t.PropertyBinding=Bl,t.PropertyMixer=Sl,t.QuadraticBezierCurve=bc,t.QuadraticBezierCurve3=wc,t.Quaternion=At,t.QuaternionKeyframeTrack=ks,t.QuaternionLinearInterpolant=Us,t.REVISION=n,t.RGBADepthPacking=3201,t.RGBAFormat=A,t.RGBAIntegerFormat=1033,t.RGBA_ASTC_10x10_Format=37819,t.RGBA_ASTC_10x5_Format=37816,t.RGBA_ASTC_10x6_Format=37817,t.RGBA_ASTC_10x8_Format=37818,t.RGBA_ASTC_12x10_Format=37820,t.RGBA_ASTC_12x12_Format=37821,t.RGBA_ASTC_4x4_Format=37808,t.RGBA_ASTC_5x4_Format=37809,t.RGBA_ASTC_5x5_Format=37810,t.RGBA_ASTC_6x5_Format=37811,t.RGBA_ASTC_6x6_Format=37812,t.RGBA_ASTC_8x5_Format=37813,t.RGBA_ASTC_8x6_Format=37814,t.RGBA_ASTC_8x8_Format=37815,t.RGBA_BPTC_Format=36492,t.RGBA_ETC2_EAC_Format=H,t.RGBA_PVRTC_2BPPV1_Format=z,t.RGBA_PVRTC_4BPPV1_Format=B,t.RGBA_S3TC_DXT1_Format=P,t.RGBA_S3TC_DXT3_Format=O,t.RGBA_S3TC_DXT5_Format=I,t.RGBDEncoding=tt,t.RGBEEncoding=Q,t.RGBEFormat=1023,t.RGBFormat=E,t.RGBIntegerFormat=1032,t.RGBM16Encoding=$,t.RGBM7Encoding=K,t.RGB_ETC1_Format=36196,t.RGB_ETC2_Format=F,t.RGB_PVRTC_2BPPV1_Format=N,t.RGB_PVRTC_4BPPV1_Format=D,t.RGB_S3TC_DXT1_Format=C,t.RGFormat=1030,t.RGIntegerFormat=1031,t.RawShaderMaterial=ws,t.Ray=ee,t.Raycaster=Vl,t.RectAreaLight=Hc,t.RedFormat=1028,t.RedIntegerFormat=1029,t.ReinhardToneMapping=2,t.RepeatWrapping=h,t.ReplaceStencilOp=7681,t.ReverseSubtractEquation=102,t.RingBufferGeometry=hs,t.RingGeometry=hs,t.SRGB8_ALPHA8_ASTC_10x10_Format=37851,t.SRGB8_ALPHA8_ASTC_10x5_Format=37848,t.SRGB8_ALPHA8_ASTC_10x6_Format=37849,t.SRGB8_ALPHA8_ASTC_10x8_Format=37850,t.SRGB8_ALPHA8_ASTC_12x10_Format=37852,t.SRGB8_ALPHA8_ASTC_12x12_Format=37853,t.SRGB8_ALPHA8_ASTC_4x4_Format=37840,t.SRGB8_ALPHA8_ASTC_5x4_Format=37841,t.SRGB8_ALPHA8_ASTC_5x5_Format=37842,t.SRGB8_ALPHA8_ASTC_6x5_Format=37843,t.SRGB8_ALPHA8_ASTC_6x6_Format=37844,t.SRGB8_ALPHA8_ASTC_8x5_Format=37845,t.SRGB8_ALPHA8_ASTC_8x6_Format=37846,t.SRGB8_ALPHA8_ASTC_8x8_Format=37847,t.Scene=fa,t.SceneUtils=uh,t.ShaderChunk=ci,t.ShaderLib=ui,t.ShaderMaterial=Yn,t.ShadowMaterial=bs,t.Shape=Ac,t.ShapeBufferGeometry=ds,t.ShapeGeometry=ds,t.ShapePath=Kc,t.ShapeUtils=ns,t.ShortType=1011,t.Skeleton=qa,t.SkeletonHelper=au,t.SkinnedMesh=ka,t.SmoothShading=2,t.Sphere=Xt,t.SphereBufferGeometry=ps,t.SphereGeometry=ps,t.Spherical=ql,t.SphericalHarmonics3=Gc,t.Spline=ch,t.SplineCurve=Mc,t.SplineCurve3=sh,t.SpotLight=Oc,t.SpotLightHelper=eu,t.Sprite=Oa,t.SpriteMaterial=xa,t.SrcAlphaFactor=204,t.SrcAlphaSaturateFactor=210,t.SrcColorFactor=202,t.StaticCopyUsage=35046,t.StaticDrawUsage=nt,t.StaticReadUsage=35045,t.StereoCamera=ll,t.StreamCopyUsage=35042,t.StreamDrawUsage=35040,t.StreamReadUsage=35041,t.StringKeyframeTrack=Vs,t.SubtractEquation=101,t.SubtractiveBlending=3,t.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},t.TangentSpaceNormalMap=0,t.TetrahedronBufferGeometry=fs,t.TetrahedronGeometry=fs,t.TextBufferGeometry=ms,t.TextGeometry=ms,t.Texture=wt,t.TextureLoader=rc,t.TorusBufferGeometry=vs,t.TorusGeometry=vs,t.TorusKnotBufferGeometry=gs,t.TorusKnotGeometry=gs,t.Triangle=ke,t.TriangleFanDrawMode=2,t.TriangleStripDrawMode=1,t.TrianglesDrawMode=0,t.TubeBufferGeometry=ys,t.TubeGeometry=ys,t.UVMapping=r,t.Uint16Attribute=function(t,e){return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),new cn(t,e)},t.Uint16BufferAttribute=cn,t.Uint32Attribute=function(t,e){return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),new un(t,e)},t.Uint32BufferAttribute=un,t.Uint8Attribute=function(t,e){return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),new an(t,e)},t.Uint8BufferAttribute=an,t.Uint8ClampedAttribute=t.Uint8ClampedBufferAttribute=on,t.Uniform=Gl,t.UniformsLib=li,t.UniformsUtils=Xn,t.UnsignedByteType=_,t.UnsignedInt248Type=T,t.UnsignedIntType=w,t.UnsignedShort4444Type=1017,t.UnsignedShort5551Type=1018,t.UnsignedShort565Type=1019,t.UnsignedShortType=b,t.VSMShadowMap=3,t.Vector2=yt,t.Vector3=Lt,t.Vector4=St,t.VectorKeyframeTrack=Ws,t.Vertex=t.VertexColors=2,t.VideoTexture=go,t.WebGL1Renderer=ha,t.WebGLCubeRenderTarget=ti,t.WebGLMultisampleRenderTarget=Et,t.WebGLRenderTarget=Tt,t.WebGLRenderTargetCube=t.WebGLRenderer=ua,t.WebGLUtils=ra,t.WireframeGeometry=xs,t.WireframeHelper=t.WrapAroundEnding=j,t.XHRLoader=t.ZeroCurvatureEnding=V,t.ZeroFactor=200,t.ZeroSlopeEnding=W,t.ZeroStencilOp=0,t.sRGBEncoding=Z,Object.defineProperty(t,"__esModule",{value:!0})}));
