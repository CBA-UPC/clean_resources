/*!
 * @preserve
 * espn-web-player-bundle v5.3.16
 * 2023-11-10T00:44:16.922Z
 */
((this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	
	var check = 

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  // eslint-disable-next-line es/no-global-this -- safe
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  // eslint-disable-next-line no-restricted-globals -- safe
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func -- fallback
	  (function () { return this; })() || commonjsGlobal || Function('return this')();

	var fails$1 = 

	var fails = fails$1;

	var functionBindNative = !fails(;

	var NATIVE_BIND = functionBindNative;

	var FunctionPrototype$2 = Function.prototype;
	var apply$1 = FunctionPrototype$2.apply;
	var call$3 = FunctionPrototype$2.call;

	// eslint-disable-next-line es/no-reflect -- safe
	var functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call$3.bind(apply$1) : function () {
	  return call$3.apply(apply$1, arguments);
	});

	var FunctionPrototype$1 = Function.prototype;
	var call$2 = FunctionPrototype$1.call;
	var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype$1.bind.bind(call$2, call$2);

	var functionUncurryThis = NATIVE_BIND ? uncurryThisWithBind : 

	var uncurryThis$1 = functionUncurryThis;

	var toString$4 = uncurryThis$1({}.toString);
	var stringSlice$1 = uncurryThis$1(''.slice);

	var classofRaw = 

	var classof$2 = classofRaw;

	var functionUncurryThisClause = 

	var documentAll$2 = typeof document == 'object' && document.all;

	// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
	// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
	var IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;

	var documentAll_1 = {
	  all: documentAll$2,
	  IS_HTMLDDA: IS_HTMLDDA
	};

	var $documentAll = documentAll_1;

	var documentAll$1 = $documentAll.all;

	// `IsCallable` abstract operation
	// https://tc39.es/ecma262/#sec-iscallable
	var isCallable$1 = $documentAll.IS_HTMLDDA ? : function (argument) {
	  return typeof argument == 'function';
	};

	// Detect IE8's incomplete defineProperty implementation
	var descriptors = !fails(;

	var call$1 = Function.prototype.call;

	var functionCall = NATIVE_BIND ? call$1.bind(call$1) : function () {
	  return call$1.apply(call$1, arguments);
	};

	var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var getOwnPropertyDescriptor$3 = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor$3 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
	var f$7 = NASHORN_BUG ? : $propertyIsEnumerable$1;

	var objectPropertyIsEnumerable = {
		f: f$7
	};

	var createPropertyDescriptor$1 = 

	var $Object$4 = Object;
	var split = uncurryThis$1(''.split);

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails( ? : $Object$4;

	// we can't use just `it == null` since of `document.all` special case
	// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
	var isNullOrUndefined$1 = 

	var isNullOrUndefined = isNullOrUndefined$1;

	var $TypeError$g = TypeError;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.es/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible$1 = 

	var IndexedObject = indexedObject;

	var requireObjectCoercible = requireObjectCoercible$1;

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject$1 = function (it) {
	  return IndexedObject(requireObjectCoercible(it));
	};

	var isCallable = isCallable$1;

	var documentAll = $documentAll.all;

	var isObject$1 = $documentAll.IS_HTMLDDA ? : 

	var path$1 = {};

	var path = path$1;

	var global$3 = global_1;

	var aFunction = 

	var getBuiltIn$1 = 

	var objectIsPrototypeOf = uncurryThis$1({}.isPrototypeOf);

	var engineUserAgent = typeof navigator != 'undefined' && String(navigator.userAgent) || '';

	var userAgent = engineUserAgent;

	var process$4 = global$3.process;
	var Deno$1 = global$3.Deno;
	var versions$1 = process$4 && process$4.versions || Deno$1 && Deno$1.version;
	var v8 = versions$1 && versions$1.v8;
	var match, version$1;

	if (v8) {
	  match = v8.split('.');
	  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
	  // but their correct versions are not interesting for us
	  version$1 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
	}

	// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
	// so check `userAgent` even if `.v8` exists, but 0
	if (!version$1 && userAgent) {
	  match = userAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = userAgent.match(/Chrome\/(\d+)/);
	    if (match) version$1 = +match[1];
	  }
	}

	var engineV8Version = version$1;

	var V8_VERSION = engineV8Version;

	/* eslint-disable es/no-symbol -- required for testing */




	var $String$5 = global$3.String;

	// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
	var symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails(;

	var NATIVE_SYMBOL = symbolConstructorDetection;

	/* eslint-disable es/no-symbol -- required for testing */


	var useSymbolAsUid = NATIVE_SYMBOL
	  && !Symbol.sham
	  && typeof Symbol.iterator == 'symbol';

	var getBuiltIn = getBuiltIn$1;

	var isPrototypeOf = objectIsPrototypeOf;

	var USE_SYMBOL_AS_UID = useSymbolAsUid;

	var $Object$3 = Object;

	var isSymbol$2 = USE_SYMBOL_AS_UID ? : 

	var $String$4 = String;

	var tryToString$1 = 

	var tryToString = tryToString$1;

	var $TypeError$f = TypeError;

	// `Assert: IsCallable(argument) is true`
	var aCallable$1 = function (argument) {
	  if (isCallable(argument)) return argument;
	  throw $TypeError$f(tryToString(argument) + ' is not a function');
	};

	var aCallable = aCallable$1;

	// `GetMethod` abstract operation
	// https://tc39.es/ecma262/#sec-getmethod
	var getMethod$1 = 

	var call = functionCall;

	var isObject = isObject$1;

	var $TypeError$e = TypeError;

	// `OrdinaryToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-ordinarytoprimitive
	var ordinaryToPrimitive$1 = 

	var isPure = true;

	// eslint-disable-next-line es/no-object-defineproperty -- safe
	var defineProperty$2 = Object.defineProperty;

	var defineGlobalProperty$1 = 

	var defineGlobalProperty = defineGlobalProperty$1;

	var SHARED = '__core-js_shared__';
	var store$2 = global$3[SHARED] || defineGlobalProperty(SHARED, {});

	var sharedStore = store$2;

	var IS_PURE = isPure;

	var store$1 = sharedStore;

	var shared$1 = createCommonjsModule(function (module) {
	(module.exports = ('versions', []).push({
	  version: '3.31.0',
	  mode: IS_PURE ? 'pure' : 'global',
	  copyright: 'Â© 2014-2023 Denis Pushkarev (zloirock.ru)',
	  license: 'https://github.com/zloirock/core-js/blob/v3.31.0/LICENSE',
	  source: 'https://github.com/zloirock/core-js'
	});
	});

	var $Object$2 = Object;

	// `ToObject` abstract operation
	// https://tc39.es/ecma262/#sec-toobject
	var toObject$1 = function (argument) {
	  return $Object$2(requireObjectCoercible(argument));
	};

	var toObject = toObject$1;

	var hasOwnProperty$1 = uncurryThis$1({}.hasOwnProperty);

	// `HasOwnProperty` abstract operation
	// https://tc39.es/ecma262/#sec-hasownproperty
	// eslint-disable-next-line es/no-object-hasown -- safe
	var hasOwnProperty_1 = Object.hasOwn ||;

	var id$1 = 0;
	var postfix = Math.random();
	var toString$3 = uncurryThis$1(1.0.toString);

	var uid$1 =;

	var shared = shared$1;

	var hasOwn = hasOwnProperty_1;

	var uid = uid$1;

	var Symbol$2 = global$3.Symbol;
	var WellKnownSymbolsStore = shared('wks');
	var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$2['for'] || Symbol$2 : Symbol$2 && Symbol$2.withoutSetter || uid;

	var wellKnownSymbol$1 =;

	var isSymbol$1 = isSymbol$2;

	var getMethod = getMethod$1;

	var ordinaryToPrimitive = ordinaryToPrimitive$1;

	var wellKnownSymbol = wellKnownSymbol$1;

	var $TypeError$d = TypeError;
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

	// `ToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-toprimitive
	var toPrimitive$1 =;

	var toPrimitive = toPrimitive$1;

	// `ToPropertyKey` abstract operation
	// https://tc39.es/ecma262/#sec-topropertykey
	var toPropertyKey$1 =;

	var document$3 = global$3.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS$1 = isObject(document$3) && isObject(document$3.createElement);

	var documentCreateElement =;

	var DESCRIPTORS = descriptors;

	var createElement = documentCreateElement;

	// Thanks to IE8 for its funny defineProperty
	var ie8DomDefine = !DESCRIPTORS && !fails);

	var require$$0$p = objectPropertyIsEnumerable;

	var createPropertyDescriptor = createPropertyDescriptor$1;

	var toIndexedObject = toIndexedObject$1;

	var toPropertyKey = toPropertyKey$1;

	var IE8_DOM_DEFINE = ie8DomDefine;

	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
	var f$6 = DESCRIPTORS ? $getOwnPropertyDescriptor$1 :;

	var objectGetOwnPropertyDescriptor = {
		f: f$6
	};

	var replacement = /#|\.prototype\./;

	var isForced$1 =;

	var normalize = isForced$1.normalize =;

	var data = isForced$1.data = {};
	var NATIVE = isForced$1.NATIVE = 'N';
	var POLYFILL = isForced$1.POLYFILL = 'P';

	var isForced_1 = isForced$1;

	var uncurryThis = functionUncurryThisClause;

	var bind$2 = uncurryThis(uncurryThis.bind);

	// optional / simple context binding
	var functionBindContext =;

	// V8 ~ Chrome 36-
	// https://bugs.chromium.org/p/v8/issues/detail?id=3334
	var v8PrototypeDefineBug = DESCRIPTORS && fails);

	var $String$3 = String;
	var $TypeError$c = TypeError;

	// `Assert: Type(argument) is Object`
	var anObject$1 = function (argument) {
	  if (isObject(argument)) return argument;
	  throw $TypeError$c($String$3(argument) + ' is not an object');
	};

	var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;

	var anObject = anObject$1;

	var $TypeError$b = TypeError;
	// eslint-disable-next-line es/no-object-defineproperty -- safe
	var $defineProperty = Object.defineProperty;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var ENUMERABLE = 'enumerable';
	var CONFIGURABLE$1 = 'configurable';
	var WRITABLE = 'writable';

	// `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	var f$5 = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? : $defineProperty :;

	var objectDefineProperty = {
		f: f$5
	};

	var require$$0$o = objectDefineProperty;

	var createNonEnumerableProperty$1 = DESCRIPTORS ? :;

	var apply = functionApply;

	var require$$0$n = objectGetOwnPropertyDescriptor;

	var isForced = isForced_1;

	var bind$1 = functionBindContext;

	var createNonEnumerableProperty = createNonEnumerableProperty$1;

	var getOwnPropertyDescriptor$2 = require$$0$n.f;






	var wrapConstructor =;

	/*
	  options.target         - name of the target object
	  options.global         - target is the global object
	  options.stat           - export as static methods of target
	  options.proto          - export as prototype methods of target
	  options.real           - real prototype method for the `pure` version
	  options.forced         - export even if the native feature is available
	  options.bind           - bind methods to the target, required for the `pure` version
	  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
	  options.sham           - add a flag to not completely full polyfills
	  options.enumerable     - export as enumerable property
	  options.dontCallGetSet - prevent calling a getter on target
	  options.name           - the .name of the function if it does not match the key
	*/
	var _export =;

	var keys$3 = shared('keys');

	var sharedKey$1 =;

	var correctPrototypeGetter = !fails);

	var sharedKey = sharedKey$1;

	var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

	var IE_PROTO$1 = sharedKey('IE_PROTO');
	var $Object$1 = Object;
	var ObjectPrototype = $Object$1.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof
	// eslint-disable-next-line es/no-object-getprototypeof -- safe
	var objectGetPrototypeOf$1 = CORRECT_PROTOTYPE_GETTER ? $Object$1.getPrototypeOf :;

	var functionUncurryThisAccessor =;

	var $String$2 = String;
	var $TypeError$a = TypeError;

	var aPossiblePrototype$1 =;

	var uncurryThisAccessor = functionUncurryThisAccessor;

	var aPossiblePrototype = aPossiblePrototype$1;

	/* eslint-disable no-proto -- safe */




	// `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	// eslint-disable-next-line es/no-object-setprototypeof -- safe
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ?() : undefined);

	var ceil = Math.ceil;
	var floor$2 = Math.floor;

	// `Math.trunc` method
	// https://tc39.es/ecma262/#sec-math.trunc
	// eslint-disable-next-line es/no-math-trunc -- safe
	var mathTrunc = Math.trunc ||;

	var trunc = mathTrunc;

	// `ToIntegerOrInfinity` abstract operation
	// https://tc39.es/ecma262/#sec-tointegerorinfinity
	var toIntegerOrInfinity$1 =;

	var toIntegerOrInfinity = toIntegerOrInfinity$1;

	var max$3 = Math.max;
	var min$2 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex$1 =;

	var min$1 = Math.min;

	// `ToLength` abstract operation
	// https://tc39.es/ecma262/#sec-tolength
	var toLength$1 =;

	var toLength = toLength$1;

	// `LengthOfArrayLike` abstract operation
	// https://tc39.es/ecma262/#sec-lengthofarraylike
	var lengthOfArrayLike$1 =;

	var toAbsoluteIndex = toAbsoluteIndex$1;

	var lengthOfArrayLike = lengthOfArrayLike$1;

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod$4 =;

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.es/ecma262/#sec-array.prototype.includes
	  includes: createMethod$4(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$4(false)
	};

	var hiddenKeys$2 = {};

	var require$$0$m = arrayIncludes;

	var hiddenKeys$1 = hiddenKeys$2;

	var indexOf = require$$0$m.indexOf;


	var push$5 = uncurryThis$1([].push);

	var objectKeysInternal =;

	// IE8- don't enum bug keys
	var enumBugKeys$1 = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	var internalObjectKeys = objectKeysInternal;

	var enumBugKeys = enumBugKeys$1;

	var hiddenKeys = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames
	// eslint-disable-next-line es/no-object-getownpropertynames -- safe
	var f$4 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return internalObjectKeys(O, hiddenKeys);
	};

	var objectGetOwnPropertyNames = {
		f: f$4
	};

	// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
	var f$3 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$3
	};

	var getOwnPropertyNamesModule = objectGetOwnPropertyNames;

	var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;

	var concat$4 = uncurryThis$1([].concat);

	// all object keys, includes non-enumerable and symbols
	var ownKeys$1 = getBuiltIn('Reflect', 'ownKeys') ||;

	var ownKeys = ownKeys$1;

	var copyConstructorProperties$1 =;

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	// eslint-disable-next-line es/no-object-keys -- safe
	var objectKeys$1 = Object.keys ||;

	var objectKeys = objectKeys$1;

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	// eslint-disable-next-line es/no-object-defineproperties -- safe
	var f$2 = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties :;

	var objectDefineProperties = {
		f: f$2
	};

	var html$1 = getBuiltIn('document', 'documentElement');

	var definePropertiesModule = objectDefineProperties;

	var html = html$1;

	/* global ActiveXObject -- old IE, WSH */








	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag =;

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX =;

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame =;

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject =;

	hiddenKeys$1[IE_PROTO] = true;

	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create
	// eslint-disable-next-line es/no-object-create -- safe
	var objectCreate = Object.create ||;

	// `InstallErrorCause` abstract operation
	// https://tc39.es/proposal-error-cause/#sec-errorobjects-install-error-cause
	var installErrorCause$1 =;

	var $Error$1 = Error;
	var replace$2 = uncurryThis$1(''.replace);

	var TEST = )('zxcasd');
	// eslint-disable-next-line redos/no-vulnerable -- safe
	var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
	var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);

	var errorStackClear =;

	var errorStackInstallable = !fails);

	var clearErrorStack = errorStackClear;

	var ERROR_STACK_INSTALLABLE = errorStackInstallable;

	// non-standard V8
	var captureStackTrace = Error.captureStackTrace;

	var errorStackInstall =;

	var iterators = {};

	var Iterators = iterators;

	var ITERATOR$4 = wellKnownSymbol('iterator');
	var ArrayPrototype$7 = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod$1 =;

	var TO_STRING_TAG$4 = wellKnownSymbol('toStringTag');
	var test$1 = {};

	test$1[TO_STRING_TAG$4] = 'z';

	var toStringTagSupport = String(test$1) === '[object z]';

	var TO_STRING_TAG_SUPPORT = toStringTagSupport;

	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');
	var $Object = Object;

	// ES3 wrong here
	var CORRECT_ARGUMENTS = classof$2(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet =;

	// getting tag from ES6+ `Object.prototype.toString`
	var classof$1 = TO_STRING_TAG_SUPPORT ? classof$2 :;

	var classof = classof$1;

	var ITERATOR$3 = wellKnownSymbol('iterator');

	var getIteratorMethod$1 =;

	var getIteratorMethod = getIteratorMethod$1;

	var $TypeError$9 = TypeError;

	var getIterator$1 =;

	var iteratorClose$1 =;

	var isArrayIteratorMethod = isArrayIteratorMethod$1;

	var getIterator = getIterator$1;

	var iteratorClose = iteratorClose$1;

	var $TypeError$8 = TypeError;

	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var ResultPrototype = Result.prototype;

	var iterate$1 =;

	var $String$1 = String;

	var toString_1 =;

	var toString$2 = toString_1;

	var normalizeStringArgument$1 =;

	var $ = _export;

	var objectGetPrototypeOf = objectGetPrototypeOf$1;

	var setPrototypeOf = objectSetPrototypeOf;

	var copyConstructorProperties = copyConstructorProperties$1;

	var create = objectCreate;

	var installErrorCause = installErrorCause$1;

	var installErrorStack = errorStackInstall;

	var iterate = iterate$1;

	var normalizeStringArgument = normalizeStringArgument$1;

	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');
	var $Error = Error;
	var push$4 = [].push;

	var $AggregateError =;

	if (setPrototypeOf) setPrototypeOf($AggregateError, $Error);
	else copyConstructorProperties($AggregateError, $Error, { name: true });

	var AggregateErrorPrototype = $AggregateError.prototype = create($Error.prototype, {
	  constructor: createPropertyDescriptor(1, $AggregateError),
	  message: createPropertyDescriptor(1, ''),
	  name: createPropertyDescriptor(1, 'AggregateError')
	});

	// `AggregateError` constructor
	// https://tc39.es/ecma262/#sec-aggregate-error-constructor
	$({ global: true, constructor: true, arity: 2 }, {
	  AggregateError: $AggregateError
	});

	var addToUnscopables$1 = function () { /* empty */ };

	var WeakMap$1 = global$3.WeakMap;

	var weakMapBasicDetection = isCallable(WeakMap$1) && /native code/.test(String(WeakMap$1));

	var NATIVE_WEAK_MAP = weakMapBasicDetection;

	var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
	var TypeError$2 = global$3.TypeError;
	var WeakMap = global$3.WeakMap;
	var set$1, get, has;

	var enforce =;

	var getterFor =;

	if (NATIVE_WEAK_MAP || store$1.state) {
	  var store = store$1.state || (store$1.state = new WeakMap());
	  /* eslint-disable no-self-assign -- prototype methods protection */
	  store.get = store.get;
	  store.has = store.has;
	  store.set = store.set;
	  /* eslint-enable no-self-assign -- prototype methods protection */
	  set$1 =;
	  get =;
	  has =;
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys$1[STATE] = true;
	  set$1 =;
	  get =;
	  has =;
	}

	var internalState = {
	  set: set$1,
	  get: get,
	  has: has,
	  enforce: enforce,
	  getterFor: getterFor
	};

	var FunctionPrototype = Function.prototype;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

	var EXISTS = hasOwn(FunctionPrototype, 'name');
	// additional protection from minified / mangled / dropped function names
	var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
	var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

	var functionName = {
	  EXISTS: EXISTS,
	  PROPER: PROPER,
	  CONFIGURABLE: CONFIGURABLE
	};

	var defineBuiltIn$1 =;

	var defineBuiltIn = defineBuiltIn$1;

	var ITERATOR$2 = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS$1 = false;

	// `%IteratorPrototype%` object
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

	/* eslint-disable es/no-array-prototype-keys -- safe */
	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
	  }
	}

	var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype$2) || fails);

	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};
	else if (IS_PURE) IteratorPrototype$2 = create(IteratorPrototype$2);

	// `%IteratorPrototype%[@@iterator]()` method
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
	if (!isCallable(IteratorPrototype$2[ITERATOR$2])) {
	  defineBuiltIn(IteratorPrototype$2, ITERATOR$2, function () {
	    return this;
	  });
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype$2,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
	};

	// `Object.prototype.toString` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.tostring
	var objectToString$1 = TO_STRING_TAG_SUPPORT ? {}.toString :;

	var toString$1 = objectToString$1;

	var defineProperty$1 = require$$0$o.f;





	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');

	var setToStringTag$1 =;

	var IteratorsCore = iteratorsCore;

	var setToStringTag = setToStringTag$1;

	var IteratorPrototype$1 = IteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var iteratorCreateConstructor =;

	var require$$0$l = functionName;

	var createIteratorConstructor = iteratorCreateConstructor;

	var PROPER_FUNCTION_NAME$1 = require$$0$l.PROPER;
	var CONFIGURABLE_FUNCTION_NAME = require$$0$l.CONFIGURABLE;
	var IteratorPrototype = IteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$1 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis = function () { return this; };

	var iteratorDefine =;

	// `CreateIterResultObject` abstract operation
	// https://tc39.es/ecma262/#sec-createiterresultobject
	var createIterResultObject$1 =;

	var addToUnscopables = addToUnscopables$1;

	var InternalStateModule = internalState;

	var defineIterator = iteratorDefine;

	var createIterResultObject = createIterResultObject$1;

	var defineProperty = require$$0$o.f;





	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$2 = InternalStateModule.set;
	var getInternalState$1 = InternalStateModule.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.es/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.es/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.es/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.es/ecma262/#sec-createarrayiterator
	defineIterator(Array, 'Array',,, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.es/ecma262/#sec-createmappedargumentsobject
	var values = Iterators.Arguments = Iterators.Array;

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables();
	addToUnscopables();
	addToUnscopables();

	// V8 ~ Chrome 45- bug
	if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
	  defineProperty(values, 'name', { value: 'values' });
	} catch (error) { /* empty */ }

	var global$2 = (typeof global !== "undefined" ? global :
	  typeof self !== "undefined" ? self :
	  typeof window !== "undefined" ? window : {});

	// shim for using process in browser
	// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}

	var cachedSetTimeout = defaultSetTimout;
	var cachedClearTimeout = defaultClearTimeout;
	if (typeof global$2.setTimeout === 'function') {
	    cachedSetTimeout = setTimeout;
	}
	if (typeof global$2.clearTimeout === 'function') {
	    cachedClearTimeout = clearTimeout;
	}



	var queue$3 = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;




	function nextTick(fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue$3.push(new Item(fun, args));
	    if (queue$3.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	}
	// v8 likes predictible objects

	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	var title = 'browser';
	var platform$1 = 'browser';
	var browser = true;
	var env = {};
	var argv = [];
	var version = ''; // empty string to avoid regexp issues
	var versions = {};
	var release = {};
	var config$2 = {};

	function noop$3() {}

	var on = noop$3;
	var addListener = noop$3;
	var once = noop$3;
	var off = noop$3;
	var removeListener = noop$3;
	var removeAllListeners = noop$3;
	var emit = noop$3;

	function binding(name) {
	    throw new Error('process.binding is not supported');
	}

	function cwd () { return '/' }
function umask() { return 0; }

	// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
	var performance = global$2.performance || {};
	var performanceNow =
	  performance.now        ||
	  performance.mozNow     ||
	  performance.msNow      ||
	  performance.oNow       ||
	  performance.webkitNow  ||
	  function(){ return (new Date()).getTime() };

	// generate timestamp or delta
	// see http://nodejs.org/api/process.html#process_process_hrtime
	function hrtime(previousTimestamp){
	  var clocktime = performanceNow.call(performance)*1e-3;
	  var seconds = Math.floor(clocktime);
	  var nanoseconds = Math.floor((clocktime%1)*1e9);
	  if (previousTimestamp) {
	    seconds = seconds - previousTimestamp[0];
	    nanoseconds = nanoseconds - previousTimestamp[1];
	    if (nanoseconds<0) {
	      seconds--;
	      nanoseconds += 1e9;
	    }
	  }
	  return [seconds,nanoseconds]
	}

	var startTime = new Date();
	function uptime() {
	  var currentTime = new Date();
	  var dif = currentTime - startTime;
	  return dif / 1000;
	}

	var browser$1 = {
	  nextTick: nextTick,
	  title: title,
	  browser: browser,
	  env: env,
	  argv: argv,
	  version: version,
	  versions: versions,
	  on: on,
	  addListener: addListener,
	  once: once,
	  off: off,
	  removeListener: removeListener,
	  removeAllListeners: removeAllListeners,
	  emit: emit,
	  binding: binding,
	  cwd: cwd,
	  chdir: chdir,
	  umask: umask,
	  hrtime: hrtime,
	  platform: platform$1,
	  release: release,
	  config: config$2,
	  uptime: uptime
	};

	var process$3 = browser$1;

	var engineIsNode = typeof process$3 != 'undefined' && classof$2(process$3) == 'process';

	var defineBuiltInAccessor$1 =;

	var defineBuiltInAccessor = defineBuiltInAccessor$1;

	var SPECIES$5 = wellKnownSymbol('species');

	var setSpecies$1 =;

	var $TypeError$7 = TypeError;

	var anInstance$1 =;

	var functionToString = uncurryThis$1(Function.toString);

	// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
	if (!isCallable(store$1.inspectSource)) {
	  store$1.inspectSource = function (it) {
	    return functionToString(it);
	  };
	}

	var inspectSource$1 = store$1.inspectSource;

	var inspectSource = inspectSource$1;

	var noop$2 = function () { /* empty */ };
	var empty = [];
	var construct = getBuiltIn('Reflect', 'construct');
	var constructorRegExp = /^\s*(?:class|function)\b/;
	var exec$1 = uncurryThis$1(constructorRegExp.exec);
	var INCORRECT_TO_STRING = !constructorRegExp.exec(noop$2);

	var isConstructorModern =;

	var isConstructorLegacy =;

	isConstructorLegacy.sham = true;

	// `IsConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-isconstructor
	var isConstructor$1 = !construct || fails) ? isConstructorLegacy : isConstructorModern;

	var isConstructor = isConstructor$1;

	var $TypeError$6 = TypeError;

	// `Assert: IsConstructor(argument) is true`
	var aConstructor$1 =;

	var aConstructor = aConstructor$1;

	var SPECIES$4 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-speciesconstructor
	var speciesConstructor$1 =;

	var arraySlice$2 = uncurryThis$1([].slice);

	var $TypeError$5 = TypeError;

	var validateArgumentsLength$1 =;

	// eslint-disable-next-line redos/no-vulnerable -- safe
	var engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent);

	var arraySlice$1 = arraySlice$2;

	var validateArgumentsLength = validateArgumentsLength$1;

	var IS_IOS$1 = engineIsIos;

	var IS_NODE = engineIsNode;

	var set = global$3.setImmediate;
	var clear = global$3.clearImmediate;
	var process$2 = global$3.process;
	var Dispatch = global$3.Dispatch;
	var Function$1 = global$3.Function;
	var MessageChannel = global$3.MessageChannel;
	var String$1 = global$3.String;
	var counter = 0;
	var queue$2 = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var $location, defer, channel, port;

	fails);

	var run =;

	var runner =;

	var eventListener =;

	var globalPostMessageDefer =;

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set || !clear) {
	  set =;
	  clear =;
	  // Node.js 0.8-
	  if (IS_NODE) {
	    defer = function (id) {
	      process$2.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer =;
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !IS_IOS$1) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = eventListener;
	    defer = bind$1(port.postMessage, port);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (
	    global$3.addEventListener &&
	    isCallable(global$3.postMessage) &&
	    !global$3.importScripts &&
	    $location && $location.protocol !== 'file:' &&
	    !fails(globalPostMessageDefer)
	  ) {
	    defer = globalPostMessageDefer;
	    global$3.addEventListener('message', eventListener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in createElement('script')) {
	    defer =;
	  // Rest old browsers
	  } else {
	    defer =;
	  }
	}

	var task$1 = {
	  set: set,
	  clear: clear
	};

	var Queue$1 = function () {
	  this.head = null;
	  this.tail = null;
	};

	Queue$1.prototype = {
	  add:,
	  get:
	};

	var queue$1 = Queue$1;

	var engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent) && typeof Pebble != 'undefined';

	var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent);

	var require$$0$k = task$1;

	var Queue = queue$1;

	var IS_IOS_PEBBLE = engineIsIosPebble;

	var IS_WEBOS_WEBKIT = engineIsWebosWebkit;

	var getOwnPropertyDescriptor$1 = require$$0$n.f;
	var macrotask = require$$0$k.set;






	var MutationObserver = global$3.MutationObserver || global$3.WebKitMutationObserver;
	var document$2 = global$3.document;
	var process$1 = global$3.process;
	var Promise$1 = global$3.Promise;
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$1(global$3, 'queueMicrotask');
	var microtask$1 = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
	var notify$1, toggle, node, promise$3, then;

	// modern engines have queueMicrotask method
	if (!microtask$1) {
	  var queue = new Queue();

	  var flush =;

	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
	  if (!IS_IOS$1 && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {
	    toggle = true;
	    node = document$2.createTextNode('');
	    new MutationObserver(flush).observe(node, { characterData: true });
	    notify$1 =;
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise$3 = Promise$1.resolve(undefined);
	    // workaround of WebKit ~ iOS Safari 10.1 bug
	    promise$3.constructor = Promise$1;
	    then = bind$1(promise$3.then, promise$3);
	    notify$1 = function () {
	      then(flush);
	    };
	  // Node.js without promises
	  } else if (IS_NODE) {
	    notify$1 = function () {
	      process$1.nextTick(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessage
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    // `webpack` dev server bug on IE global methods - use bind(fn, global)
	    macrotask = bind$1(macrotask, global$3);
	    notify$1 =;
	  }

	  microtask$1 =;
	}

	var microtask_1 = microtask$1;

	var hostReportErrors$1 =;

	var perform$1 =;

	var promiseNativeConstructor = global$3.Promise;

	/* global Deno -- Deno case */
	var engineIsDeno = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';

	var IS_DENO = engineIsDeno;

	var engineIsBrowser = !IS_DENO && !IS_NODE
	  && typeof window == 'object'
	  && typeof document == 'object';

	var NativePromiseConstructor = promiseNativeConstructor;

	var IS_BROWSER = engineIsBrowser;

	var NativePromisePrototype$3 = NativePromiseConstructor && NativePromiseConstructor.prototype;
	var SPECIES$3 = wellKnownSymbol('species');
	var SUBCLASSING = false;
	var NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable(global$3.PromiseRejectionEvent);

	var FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise',);

	var promiseConstructorDetection = {
	  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,
	  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,
	  SUBCLASSING: SUBCLASSING
	};

	var $TypeError$4 = TypeError;

	var PromiseCapability =;

	// `NewPromiseCapability` abstract operation
	// https://tc39.es/ecma262/#sec-newpromisecapability
	var f$1 =;

	var newPromiseCapability$1 = {
		f: f$1
	};

	var setSpecies = setSpecies$1;

	var anInstance = anInstance$1;

	var speciesConstructor = speciesConstructor$1;

	var microtask = microtask_1;

	var hostReportErrors = hostReportErrors$1;

	var perform = perform$1;

	var require$$0$j = promiseConstructorDetection;

	var newPromiseCapabilityModule = newPromiseCapability$1;

	var task = require$$0$k.set;









	var PROMISE = 'Promise';
	var FORCED_PROMISE_CONSTRUCTOR$4 = require$$0$j.CONSTRUCTOR;
	var NATIVE_PROMISE_REJECTION_EVENT = require$$0$j.REJECTION_EVENT;
	var NATIVE_PROMISE_SUBCLASSING = require$$0$j.SUBCLASSING;
	var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
	var setInternalState$1 = InternalStateModule.set;
	var NativePromisePrototype$2 = NativePromiseConstructor && NativePromiseConstructor.prototype;
	var PromiseConstructor = NativePromiseConstructor;
	var PromisePrototype = NativePromisePrototype$2;
	var TypeError$1 = global$3.TypeError;
	var document$1 = global$3.document;
	var process = global$3.process;
	var newPromiseCapability = newPromiseCapabilityModule.f;
	var newGenericPromiseCapability = newPromiseCapability;

	var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$3.dispatchEvent);
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;

	var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

	// helpers
	var isThenable =;

	var callReaction =;

	var notify =;

	var dispatchEvent =;

	var onUnhandled =;

	var isUnhandled =;

	var onHandleUnhandled =;

	var bind =;

	var internalReject =;

	var internalResolve =;

	// constructor polyfill
	if (FORCED_PROMISE_CONSTRUCTOR$4) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor =;

	  PromisePrototype = PromiseConstructor.prototype;

	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  Internal =;

	  // `Promise.prototype.then` method
	  // https://tc39.es/ecma262/#sec-promise.prototype.then
	  Internal.prototype = defineBuiltIn(PromisePrototype, 'then',);

	  OwnPromiseCapability =;

	  newPromiseCapabilityModule.f = newPromiseCapability =;

	  if (!IS_PURE && isCallable(NativePromiseConstructor) && NativePromisePrototype$2 !== Object.prototype) {
	    nativeThen = NativePromisePrototype$2.then;

	    if (!NATIVE_PROMISE_SUBCLASSING) {
	      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs
	      defineBuiltIn(NativePromisePrototype$2, 'then',, { unsafe: true });
	    }

	    // make `.constructor === Promise` work for native promise-based APIs
	    try {
	      delete NativePromisePrototype$2.constructor;
	    } catch (error) { /* empty */ }

	    // make `instanceof Promise` work for native promise-based APIs
	    if (setPrototypeOf) {
	      setPrototypeOf(NativePromisePrototype$2, PromisePrototype);
	    }
	  }
	}

	$({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false, true);
	setSpecies(PROMISE);

	var ITERATOR = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next:,
	    'return':
	  };
	  iteratorWithReturn[ITERATOR] =;
	  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
	  Array.from(iteratorWithReturn,);
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration$1 =;

	var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;

	var FORCED_PROMISE_CONSTRUCTOR$3 = require$$0$j.CONSTRUCTOR;

	var promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration);

	var PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;

	// `Promise.all` method
	// https://tc39.es/ecma262/#sec-promise.all
	$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
	  all:
	});

	var FORCED_PROMISE_CONSTRUCTOR$2 = require$$0$j.CONSTRUCTOR;





	var NativePromisePrototype$1 = NativePromiseConstructor && NativePromiseConstructor.prototype;

	// `Promise.prototype.catch` method
	// https://tc39.es/ecma262/#sec-promise.prototype.catch
	$({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {
	  'catch':
	});

	// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`
	if (!IS_PURE && isCallable(NativePromiseConstructor)) {
	  var method$8 = getBuiltIn('Promise').prototype['catch'];
	  if (NativePromisePrototype$1['catch'] !== method$8) {
	    defineBuiltIn(NativePromisePrototype$1, 'catch', method$8, { unsafe: true });
	  }
	}

	// `Promise.race` method
	// https://tc39.es/ecma262/#sec-promise.race
	$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
	  race:
	});

	var FORCED_PROMISE_CONSTRUCTOR$1 = require$$0$j.CONSTRUCTOR;

	// `Promise.reject` method
	// https://tc39.es/ecma262/#sec-promise.reject
	$({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {
	  reject:
	});

	var promiseResolve$1 =;

	var promiseResolve = promiseResolve$1;

	var FORCED_PROMISE_CONSTRUCTOR = require$$0$j.CONSTRUCTOR;


	var PromiseConstructorWrapper = getBuiltIn('Promise');
	var CHECK_WRAPPER = IS_PURE && !FORCED_PROMISE_CONSTRUCTOR;

	// `Promise.resolve` method
	// https://tc39.es/ecma262/#sec-promise.resolve
	$({ target: 'Promise', stat: true, forced: IS_PURE || FORCED_PROMISE_CONSTRUCTOR }, {
	  resolve:
	});

	// `Promise.allSettled` method
	// https://tc39.es/ecma262/#sec-promise.allsettled
	$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
	  allSettled:
	});

	var PROMISE_ANY_ERROR = 'No one promise resolved';

	// `Promise.any` method
	// https://tc39.es/ecma262/#sec-promise.any
	$({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {
	  any:
	});

	var NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;

	// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
	var NON_GENERIC = !!NativePromiseConstructor && fails);

	// `Promise.prototype.finally` method
	// https://tc39.es/ecma262/#sec-promise.prototype.finally
	$({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
	  'finally':
	});

	// makes sure that native promise-based APIs `Promise#finally` properly works with patched `Promise#then`
	if (!IS_PURE && isCallable(NativePromiseConstructor)) {
	  var method$7 = getBuiltIn('Promise').prototype['finally'];
	  if (NativePromisePrototype['finally'] !== method$7) {
	    defineBuiltIn(NativePromisePrototype, 'finally', method$7, { unsafe: true });
	  }
	}

	var charAt$2 = uncurryThis$1(''.charAt);
	var charCodeAt$1 = uncurryThis$1(''.charCodeAt);
	var stringSlice = uncurryThis$1(''.slice);

	var createMethod$3 =;

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$3(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$3(true)
	};

	var require$$0$i = stringMultibyte;

	var charAt$1 = require$$0$i.charAt;





	var STRING_ITERATOR = 'String Iterator';
	var setInternalState = InternalStateModule.set;
	var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String',,);

	var promise$2 = path.Promise;

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	var DOMIterables = domIterables;

	var TO_STRING_TAG = wellKnownSymbol('toStringTag');

	for (var COLLECTION_NAME in DOMIterables) {
	  var Collection = global$3[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
	    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
	  }
	  Iterators[COLLECTION_NAME] = Iterators.Array;
	}

	var parent$d = promise$2;

	var promise$1 = parent$d;

	var require$$0$h = promise$1;

	var promise = require$$0$h;

	class EventCoordinator {
	   
	    addEventListener(event, listener) {
	        const listeners = this.listeners[event] || [];
	        listeners.push(listener);
	        this.listeners[event] = listeners;
	        return this;
	    }
	    removeEventListener(event, listener) {
	        this.listeners[event] = (this.listeners[event] || []).filter);
	        return this;
	    }
	   
	   
	    coordinate(event, value) {
	        const interceptor = this.interceptors[event] || );
	        const listeners = this.listeners[event] || [];
	        return Promise.resolve()
	            .then)
	            .then(result => {
	            listeners.forEach);
	            return result;
	        });
	    }
	}

	var Brand;
	)(Brand || (Brand = {}));
	function getBrandNames(brand) {
	    switch (brand) {
	        case Brand.abc:
	            return 'ABC';
	        case Brand.abcNews:
	            return 'ABC News';
	        case Brand.abcNewsLive:
	            return 'ABC News Live';
	        case Brand.abcOtv:
	            return 'ABC OTV';
	        case Brand.cricinfo:
	            return 'ESPNcricinfo';
	        case Brand.disney:
	            return 'Disney';
	        case Brand.disneyJr:
	            return 'Disney Junior';
	        case Brand.disneyXD:
	            return 'Disney XD';
	        case Brand.disneyNow:
	            return 'DisneyNow';
	        case Brand.espn:
	            return 'ESPN';
	        case Brand.espnFantasy:
	            return 'ESPN Fantasy';
	        case Brand.fiveThirtyEight:
	            return 'FiveThirtyEight';
	        case Brand.foxLatam:
	            return 'Fox Latam';
	        case Brand.freeform:
	            return 'Freeform';
	        case Brand.fxNow:
	            return 'FX Now';
	        case Brand.fx:
	            return 'FX Networks';
	        case Brand.fxm:
	            return 'FX Movie Channel';
	        case Brand.fxx:
	            return 'FXX';
	        case Brand.oscar:
	            return 'Oscar';
	        case Brand.marvel:
	            return 'Marvel';
	        case Brand.natGeoTV:
	            return 'National Geographic TV ';
	        case Brand.natGeo:
	            return 'National Geographic Chanel';
	        case Brand.natGeoWild:
	            return 'National Geographic Wild';
	        case Brand.theUndefeated:
	            return 'The Undefeated';
	        case Brand.fast:
	            return 'Fast';
	        case Brand.unknown:
	            return Brand.unknown;
	    }
	}
	function brandLegacyId(brand) {
	    switch (brand) {
	        case Brand.abc:
	            return '001';
	        case Brand.freeform:
	            return '002';
	        case Brand.abcNews:
	            return '003';
	        case Brand.disney:
	            return '004';
	        case Brand.disneyJr:
	            return '008';
	        case Brand.disneyXD:
	            return '009';
	        case Brand.disneyNow:
	            return '011';
	        case Brand.oscar:
	            return '005';
	        case Brand.fxNow:
	            return '025';
	        case Brand.fx:
	            return '020';
	        case Brand.fxm:
	            return '022';
	        case Brand.fxx:
	            return '021';
	        case Brand.natGeoTV:
	            return '026';
	        case Brand.natGeo:
	            return '023';
	        case Brand.natGeoWild:
	            return '024';
	        case Brand.fast:
	            return '200';
	        case Brand.unknown:
	            return Brand.unknown;
	    }
	}


	function getChannelMapping(brand) {
	    switch (brand) {
	        case Brand.abc:
	            return 'abc';
	        case Brand.abcNews:
	        case Brand.abcNewsLive:
	            return 'abcnews';
	        case Brand.abcOtv:
	            return 'abcotv';
	        case Brand.cricinfo:
	        case Brand.espn:
	            return 'espn';
	        case Brand.freeform:
	            return 'freeform';
	        case Brand.fxNow:
	            return 'fxnow';
	        case Brand.fx:
	            return 'fx';
	        case Brand.fxm:
	            return 'fxm';
	        case Brand.fxx:
	            return 'fxx';
	        case Brand.marvel:
	            return 'marvel';
	        case Brand.natGeoTV:
	        case Brand.natGeo:
	            return 'natgeo';
	        case Brand.natGeoWild:
	            return 'natgeowild';
	        case Brand.fast:
	            return 'Fast';
	        default:
	            return null;
	    }
	}

	class ErrorExceptionEvent extends Error {
	   
	   
	    get cause() {
	        return this.config_.cause;
	    }
	    get reason() {
	        return this.config_.reason;
	    }
	}

	var LOG_LEVEL$1;
	(function (LOG_LEVEL) {
	    LOG_LEVEL[LOG_LEVEL["NONE"] = -1] = "NONE";
	    LOG_LEVEL[LOG_LEVEL["ERROR"] = 0] = "ERROR";
	    LOG_LEVEL[LOG_LEVEL["WARN"] = 1] = "WARN";
	    LOG_LEVEL[LOG_LEVEL["INFO"] = 2] = "INFO";
	    LOG_LEVEL[LOG_LEVEL["DEBUG"] = 3] = "DEBUG";
	})(LOG_LEVEL$1 || (LOG_LEVEL$1 = {}));
	var SEVERITY$1;
	(function (SEVERITY) {
	    SEVERITY[SEVERITY["FAILURE"] = 0] = "FAILURE";
	    SEVERITY[SEVERITY["WARNING"] = 1] = "WARNING";
	})(SEVERITY$1 || (SEVERITY$1 = {}));
	var PLATFORMS$1;
	(function (PLATFORMS) {
	    PLATFORMS["ANDROID"] = "A";
	    PLATFORMS["APPLE"] = "I";
	    PLATFORMS["JAVASCRIPT"] = "J";
	})(PLATFORMS$1 || (PLATFORMS$1 = {}));
	var SEGMENTS$1;
	(function (SEGMENTS) {
	    SEGMENTS["PLAYER_CORE"] = "PE";
	    SEGMENTS["PLAYER_UI"] = "PUI";
	})(SEGMENTS$1 || (SEGMENTS$1 = {}));
	var REASONS$1;
	)(REASONS$1 || (REASONS$1 = {}));
	const REASONS_NAMES$1 = {
	    [REASONS$1.UNEXPECTED_ERROR]: 'unexpectedError',
	    [REASONS$1.IDENTITY_REQUIRED]: 'identityRequired',
	    [REASONS$1.AUTHENTICATION_REQUIRED]: 'authenticationRequired',
	    [REASONS$1.NOT_ENTITLED]: 'notEntitled',
	    [REASONS$1.CONCURRENCY_LIMIT_REACHED]: 'concurrencyLimitReached',
	    [REASONS$1.PARENTAL_RESTRICTIONS]: 'parentalRestrictions',
	    [REASONS$1.GEO_LOCATION_REQUIRED]: 'geoLocationRequired',
	    [REASONS$1.GEO_LOCATION_ACQUISITION_ERROR]: 'geoLocationAcquisitionError',
	    [REASONS$1.GEO_LOCATION_NOT_ALLOWED]: 'geoLocationNotAllowed',
	    [REASONS$1.INVALID_MEDIA]: 'invalidMedia',
	    [REASONS$1.MEDIA_UNAVAILABLE]: 'mediaUnavailable',
	    [REASONS$1.TEMPORARY_UNAVAILABLE]: 'temporarilyUnavailable',
	    [REASONS$1.NETWORK_CONNECTION]: 'networkConnection',
	    [REASONS$1.UNSUPPORTED_DRM]: 'unsupportedDRM',
	    [REASONS$1.REQUIRES_LBS]: 'requiresLbs',
	    [REASONS$1.PLAYREADY_LICENSE_FAILED]: 'playreadyLicenseFailed',
	    [REASONS$1.DAMAGED_MEDIA_DATA]: 'damagedMediaData',
	};
	var COMPONENTS$1;
	(function (COMPONENTS) {
	    COMPONENTS["MEDIA_ITEM"] = "MI";
	    COMPONENTS["PLAYBACK_ACCESS"] = "PA";
	    COMPONENTS["PLAYBACK_SESSION"] = "PS";
	    COMPONENTS["MEDIA_PLAYER"] = "MP";
	    COMPONENTS["PLAYER_PLUGIN"] = "PL";
	})(COMPONENTS$1 || (COMPONENTS$1 = {}));
	var FEATURES$1;
	(function (FEATURES) {
	    FEATURES["PLAYBACK_CFA"] = "CFA";
	    FEATURES["GRAPH_QL"] = "GQL";
	    FEATURES["ENTERTAINMENT"] = "ENT";
	    FEATURES["PLAYBACK_ACCESS_MANAGER"] = "PAM";
	    FEATURES["ADOBE_PASS"] = "AP";
	    FEATURES["ISP"] = "ISP";
	    FEATURES["TVE"] = "TVE";
	    FEATURES["BAM"] = "BAM";
	    FEATURES["CHROMECAST_RECEIVER_MEDIA_PLAYER"] = "CRMP";
	    FEATURES["PLAYER_ADAPTER_BUNDLE"] = "PAB";
	    FEATURES["DIGITAL_RIGHTS_MANAGEMENT"] = "DRM";
	    FEATURES["SHIELD"] = "SHD";
	    FEATURES["ENTITLEMENT"] = "ENTL";
	    FEATURES["CONCURRENCY_MONITORING"] = "CM";
	    FEATURES["END_CARD_UI"] = "ECU";
	})(FEATURES$1 || (FEATURES$1 = {}));
	var ERROR_CODES;
	(function (ERROR_CODES) {
	    ERROR_CODES["BAD_REQUEST"] = "400";
	    ERROR_CODES["UNAUTHORIZED"] = "401";
	    ERROR_CODES["FORBIDDEN"] = "403";
	    ERROR_CODES["NOT_FOUND"] = "404";
	    ERROR_CODES["METHOD_NOT_ALLOWED"] = "405";
	    ERROR_CODES["NOT_ACCEPTABLE"] = "406";
	    ERROR_CODES["TIMEOUT"] = "408";
	    ERROR_CODES["CONFLICT"] = "409";
	    ERROR_CODES["GONE"] = "410";
	    ERROR_CODES["LENGTH_REQUIRED"] = "411";
	    ERROR_CODES["PRECONDITION_FAILED"] = "412";
	    ERROR_CODES["ENTITY_TOO_LARGE"] = "413";
	    ERROR_CODES["URI_TOO_LONG"] = "414";
	    ERROR_CODES["UNSUPPORTED_MEDIA_TYPE"] = "415";
	    ERROR_CODES["RANGE_NOT_SATISFIABLE"] = "416";
	    ERROR_CODES["EXPECTATION_FAILED"] = "417";
	    ERROR_CODES["INTERNAL_SERVER_ERROR"] = "500";
	    ERROR_CODES["NOT_IMPLEMENTED"] = "501";
	    ERROR_CODES["BAD_GATEWAY"] = "502";
	    ERROR_CODES["SERVICE_UNAVAILABLE"] = "503";
	    ERROR_CODES["GATEWAY_TIMEOUT"] = "504";
	    ERROR_CODES["HTTP_VERSION_NOT_SUPPORTED"] = "505";
	    ERROR_CODES["EMBARGOED_CONTENT"] = "100";
	    ERROR_CODES["EXPIRED_CONTENT"] = "101";
	    ERROR_CODES["INVALID_RESPONSE"] = "102";
	    ERROR_CODES["INVALID_DEVICE"] = "103";
	    ERROR_CODES["UNSUPPORTED_SESSION"] = "104";
	    ERROR_CODES["GEOLOCATION_NOT_ALLOWED"] = "105";
	    ERROR_CODES["PROXY_NOT_ALLOWED"] = "106";
	    ERROR_CODES["REFERRER_NOT_ALLOWED"] = "107";
	    ERROR_CODES["INVALID_DATA_PROVIDED"] = "108";
	    ERROR_CODES["SHIELD_DRM_REQUIRED"] = "109";
	    ERROR_CODES["PLAYER_BUNDLE_FAILED_TO_LOAD"] = "700";
	    ERROR_CODES["PLAYER_NOT_READY"] = "701";
	    ERROR_CODES["PLAYER_CAN_NOT_BE_DISPOSED"] = "702";
	    ERROR_CODES["PLAYER_CAN_NOT_PLAY_PAUSE"] = "703";
	    ERROR_CODES["PLAYER_SHAKA_ERROR"] = "704";
	    ERROR_CODES["PLAYER_NO_VIDEO_TAG"] = "705";
	    ERROR_CODES["PLAYER_NO_CORE_FOUND"] = "706";
	    ERROR_CODES["PLAYER_MEDIA_ERR_CUSTOM"] = "708";
	    ERROR_CODES["PLAYER_MEDIA_ERR_ABORTED"] = "709";
	    ERROR_CODES["PLAYER_MEDIA_ERR_NETWORK"] = "710";
	    ERROR_CODES["PLAYER_MEDIA_ERR_DECODE"] = "711";
	    ERROR_CODES["PLAYER_MEDIA_ERR_SRC_NOT_SUPPORTED"] = "712";
	    ERROR_CODES["PLAYER_MEDIA_ERR_ENCRYPTED"] = "713";
	    ERROR_CODES["PLAYER_UNKNOWN"] = "003";
	    ERROR_CODES["ADS_PROVIDER_ERR"] = "801";
	    ERROR_CODES["ADS_FAILED_TO_LOAD"] = "802";
	    ERROR_CODES["SHAKA_PLAYER_DRM_ERROR"] = "715";
	    ERROR_CODES["PLAYREADY_LICENSE_FAILED"] = "718";
	    ERROR_CODES["PLAYER_BUNDLE_FAILED_TO_CREATE"] = "719";
	    ERROR_CODES["AD_ONLY_FAILED"] = "720";
	    ERROR_CODES["PLAYER_CONFIGURATION_ERR"] = "721";
	    ERROR_CODES["PLAYER_ANALYTIC_INIT_ERR"] = "722";
	    ERROR_CODES["CONCURRENCY_LIMIT_REACHED"] = "707";
	    ERROR_CODES["PLAYER_PROGRAM_CHANGE_FAILED"] = "728";
	    ERROR_CODES["TEXT_DECODER_ABSENT"] = "723";
	    ERROR_CODES["AUDIO_CONTEXT_ABSENT"] = "724";
	    ERROR_CODES["TEXT_DECODING_FAILED"] = "725";
	    ERROR_CODES["STYLE_SETUP_FAILED"] = "726";
	    ERROR_CODES["SOCIAL_COPY_FAILED"] = "727";
	    ERROR_CODES["GEOLOCATION_PROXY"] = "200x";
	    ERROR_CODES["DISTRIBUTOR_REQUEST_FAILED"] = "201x";
	    ERROR_CODES["MEDIA_ITEM_MISSING"] = "200";
	    ERROR_CODES["END_CARD_ERR"] = "201";
	    ERROR_CODES["PLUTO_REQUEST_FAILED"] = "302";
	    ERROR_CODES["SHIELD_REQUEST_FAILED"] = "202";
	    ERROR_CODES["GQL_REQUEST_FAILED"] = "600";
	    ERROR_CODES["UNKNOWN"] = "000";
	    ERROR_CODES["NO_INTERNET"] = "001";
	})(ERROR_CODES || (ERROR_CODES = {}));

	class ErrorExceptionLogger {
	    constructor(logLevel) {
	        this.logLevel_ = LOG_LEVEL$1.DEBUG;
	        this.logLevel_ = logLevel;
	    }
	    set logLevel(v) {
	        this.logLevel_ = v;
	    }
	    get logLevel() {
	        return this.logLevel_;
	    }
	    error(...args) {
	        if (this.logLevel_ >= LOG_LEVEL$1.ERROR) {
	            console.error(...args);
	        }
	    }
	    warn(...args) {
	        if (this.logLevel_ >= LOG_LEVEL$1.WARN) {
	            console.warn(...args);
	        }
	    }
	    info(...args) {
	        if (this.logLevel_ >= LOG_LEVEL$1.INFO) {
	            console.info(...args);
	        }
	    }
	    debug(...args) {
	        if (this.logLevel_ >= LOG_LEVEL$1.DEBUG) {
	            console.debug(...args);
	        }
	    }
	}
	var ErrorExceptionLogger$1 = new ErrorExceptionLogger(LOG_LEVEL$1.DEBUG);

	class ErrorExceptionFactory {
	    constructor() {
	        this.platform_ = PLATFORMS$1.JAVASCRIPT;
	    }
	    set logLevel(level) {
	        ErrorExceptionLogger$1.logLevel = level;
	    }
	    get logLevel() {
	        return ErrorExceptionLogger$1.logLevel;
	    }
	    set eventCoordinator(coordinator) {
	        this.coordinator_ = coordinator;
	    }
	    get eventCoordinator() {
	        return this.coordinator_;
	    }
	    unexpectedError(config) {
	        config.reason = REASONS$1.UNEXPECTED_ERROR;
	        if (!config.caller)
	            config.caller = 'unexpectedError';
	        return this.generateEvent(config);
	    }
	    identityRequired(config) {
	        config.reason = REASONS$1.IDENTITY_REQUIRED;
	        if (!config.caller)
	            config.caller = 'identityRequired';
	        return this.generateEvent(config);
	    }
	    authenticationRequired(config) {
	        config.reason = REASONS$1.AUTHENTICATION_REQUIRED;
	        if (!config.caller)
	            config.caller = 'authenticationRequired';
	        return this.generateEvent(config);
	    }
	    notEntitled(config) {
	        config.reason = REASONS$1.NOT_ENTITLED;
	        if (!config.caller)
	            config.caller = 'notEntitled';
	        return this.generateEvent(config);
	    }
	    concurrencyLimitReached(config) {
	        config.reason = REASONS$1.CONCURRENCY_LIMIT_REACHED;
	        if (!config.caller)
	            config.caller = 'concurrencyLimitReached';
	        return this.generateEvent(config);
	    }
	    parentalRestrictions(config) {
	        config.reason = REASONS$1.PARENTAL_RESTRICTIONS;
	        if (!config.caller)
	            config.caller = 'parentalRestrictions';
	        return this.generateEvent(config);
	    }
	    geoLocationRequired(config) {
	        config.reason = REASONS$1.GEO_LOCATION_REQUIRED;
	        if (!config.caller)
	            config.caller = 'geoLocationRequired';
	        return this.generateEvent(config);
	    }
	    geoLocationAcquisitionError(config) {
	        config.reason = REASONS$1.GEO_LOCATION_ACQUISITION_ERROR;
	        if (!config.caller)
	            config.caller = 'geoLocationAcquisitionError';
	        return this.generateEvent(config);
	    }
	    geoLocationNotAllowed(config) {
	        config.reason = REASONS$1.GEO_LOCATION_NOT_ALLOWED;
	        if (!config.caller)
	            config.caller = 'geoLocationNotAllowed';
	        return this.generateEvent(config);
	    }
	    invalidMedia(config) {
	        config.reason = REASONS$1.INVALID_MEDIA;
	        if (!config.caller)
	            config.caller = 'invalidMedia';
	        return this.generateEvent(config);
	    }
	    mediaUnavailable(config) {
	        config.reason = REASONS$1.MEDIA_UNAVAILABLE;
	        if (!config.caller)
	            config.caller = 'mediaUnavailable';
	        return this.generateEvent(config);
	    }
	    temporarilyUnavailable(config) {
	        config.reason = REASONS$1.TEMPORARY_UNAVAILABLE;
	        if (!config.caller)
	            config.caller = 'temporarilyUnavailable';
	        return this.generateEvent(config);
	    }
	    networkConnection(config) {
	        config.reason = REASONS$1.NETWORK_CONNECTION;
	        if (!config.caller)
	            config.caller = 'networkConnection';
	        return this.generateEvent(config);
	    }
	    unsupportedDRM(config) {
	        config.reason = REASONS$1.UNSUPPORTED_DRM;
	        if (!config.caller)
	            config.caller = 'unsupportedDRM';
	        return this.generateEvent(config);
	    }
	    requiresLbs(config) {
	        config.reason = REASONS$1.REQUIRES_LBS;
	        if (!config.caller)
	            config.caller = 'requiresLbs';
	        return this.generateEvent(config);
	    }
	    playreadyLicenseFailed(config) {
	        config.reason = REASONS$1.PLAYREADY_LICENSE_FAILED;
	        if (!config.caller)
	            config.caller = 'playreadyLicenseFailed';
	        return this.generateEvent(config);
	    }
	    damagedMediaData(config) {
	        config.reason = REASONS$1.DAMAGED_MEDIA_DATA;
	        if (!config.caller)
	            config.caller = 'damagedMediaData';
	        return this.generateEvent(config);
	    }
	    generateEvent(config) {
	        if (!config.platform) {
	            config.platform = this.platform_;
	        }
	        if (!config.reason || !config.platform || !config.segment || !config.component || !config.feature || !config.errorCode) {
	            ErrorExceptionLogger$1.error(`${this.constructor.name}->'track' called from ${config.caller}: specify all CodesConfig params to track event ${config}`);
	            return null;
	        }
	        const event = new ErrorExceptionEvent(config);
	        if (this.coordinator_ && config.eventName) {
	            this.coordinator_.coordinate(config.eventName, event);
	        }
	        let message = `${this.constructor.name}: ${event.code} ${event.message}`;
	        if (event.cause)
	            message += `. Caused by`;
	        switch (config.severity) {
	            case SEVERITY$1.WARNING:
	                event.cause ? ErrorExceptionLogger$1.warn(message, event.cause) : ErrorExceptionLogger$1.warn(message);
	                break;
	            default:
	                event.cause ? ErrorExceptionLogger$1.error(message, event.cause) : ErrorExceptionLogger$1.error(message);
	                break;
	        }
	        return event;
	    }
	    defineMediaItemFeatureByIdentifier(identifier) {
	        if (identifier.match('natgeo')) {
	            return FEATURES$1.PLAYBACK_CFA;
	        }
	        else if (identifier.match('abcnews')) {
	            return FEATURES$1.ENTERTAINMENT;
	        }
	        else {
	            return FEATURES$1.GRAPH_QL;
	        }
	    }
	    defineMediaItemErrorCodesByIdentifier(identifier) {
	        if (identifier.match('natgeo')) {
	            return ERROR_CODES.SHIELD_REQUEST_FAILED;
	        }
	        else if (identifier.match('abcnews')) {
	            return ERROR_CODES.PLUTO_REQUEST_FAILED;
	        }
	        else {
	            return ERROR_CODES.GQL_REQUEST_FAILED;
	        }
	    }
	}

	var ErrorExceptionService = new ErrorExceptionFactory();

	var $includes = require$$0$m.includes;



	// FF99+ bug
	var BROKEN_ON_SPARSE = fails);

	// `Array.prototype.includes` method
	// https://tc39.es/ecma262/#sec-array.prototype.includes
	$({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
	addToUnscopables();

	var entryVirtual$1 =;

	var entryVirtual = entryVirtual$1;

	var includes$4 = entryVirtual('Array').includes;

	var MATCH$1 = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.es/ecma262/#sec-isregexp
	var isRegexp =;

	var isRegExp = isRegexp;

	var $TypeError$3 = TypeError;

	var notARegexp =;

	var MATCH = wellKnownSymbol('match');

	var correctIsRegexpLogic =;

	var notARegExp = notARegexp;

	var correctIsRegExpLogic = correctIsRegexpLogic;

	var stringIndexOf = uncurryThis$1(''.indexOf);

	// `String.prototype.includes` method
	// https://tc39.es/ecma262/#sec-string.prototype.includes
	$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
	  includes:
	});

	var includes$3 = entryVirtual('String').includes;

	var arrayMethod = includes$4;

	var stringMethod = includes$3;

	var ArrayPrototype$6 = Array.prototype;
	var StringPrototype$1 = String.prototype;

	var includes$2 =;

	var parent$c = includes$2;

	var includes$1 = parent$c;

	var require$$0$g = includes$1;

	var includes = require$$0$g;





	var LOG_LEVEL;
	(function (LOG_LEVEL) {
	    LOG_LEVEL[LOG_LEVEL["NONE"] = -1] = "NONE";
	    LOG_LEVEL[LOG_LEVEL["ERROR"] = 0] = "ERROR";
	    LOG_LEVEL[LOG_LEVEL["WARN"] = 1] = "WARN";
	    LOG_LEVEL[LOG_LEVEL["INFO"] = 2] = "INFO";
	    LOG_LEVEL[LOG_LEVEL["DEBUG"] = 3] = "DEBUG";
	})(LOG_LEVEL || (LOG_LEVEL = {}));
	var SEVERITY;
	(function (SEVERITY) {
	    SEVERITY[SEVERITY["FAILURE"] = 0] = "FAILURE";
	    SEVERITY[SEVERITY["WARNING"] = 1] = "WARNING";
	})(SEVERITY || (SEVERITY = {}));
	var PLATFORMS;
	(function (PLATFORMS) {
	    PLATFORMS["ANDROID"] = "A";
	    PLATFORMS["APPLE"] = "I";
	    PLATFORMS["JAVASCRIPT"] = "J";
	})(PLATFORMS || (PLATFORMS = {}));
	var SEGMENTS;
	(function (SEGMENTS) {
	    SEGMENTS["PLAYER_CORE"] = "PE";
	    SEGMENTS["PLAYER_UI"] = "PUI";
	})(SEGMENTS || (SEGMENTS = {}));
	var REASONS;
	(function (REASONS) {
	    REASONS["PLAYBACK_COMPLETED"] = "40";
	})(REASONS || (REASONS = {}));
	const REASONS_NAMES = {
	    [REASONS.PLAYBACK_COMPLETED]: 'mediaItemPlaybackCompleted',
	};
	var COMPONENTS;
	(function (COMPONENTS) {
	    COMPONENTS["MEDIA_ITEM"] = "MI";
	    COMPONENTS["PLAYBACK_ACCESS"] = "PA";
	    COMPONENTS["PLAYBACK_SESSION"] = "PS";
	    COMPONENTS["MEDIA_PLAYER"] = "MP";
	    COMPONENTS["PLAYER_PLUGIN"] = "PL";
	})(COMPONENTS || (COMPONENTS = {}));
	var FEATURES;
	)(FEATURES || (FEATURES = {}));

	class PlaybackEventsLogger {
	   
	    set logLevel(v) {
	        this.logLevel_ = v;
	    }
	    get logLevel() {
	        return this.logLevel_;
	    }
	    error(...args) {
	        if (this.logLevel_ >= LOG_LEVEL.ERROR) {
	            console.error(...args);
	        }
	    }
	    warn(...args) {
	        if (this.logLevel_ >= LOG_LEVEL.WARN) {
	            console.warn(...args);
	        }
	    }
	    info(...args) {
	        if (this.logLevel_ >= LOG_LEVEL.INFO) {
	            console.info(...args);
	        }
	    }
	    debug(...args) {
	        if (this.logLevel_ >= LOG_LEVEL.DEBUG) {
	            console.debug(...args);
	        }
	    }
	}
	var PlaybackEventLogger = new PlaybackEventsLogger(LOG_LEVEL.DEBUG);

	class PlaybackFactory {
	    constructor() {
	        this.platform_ = PLATFORMS.JAVASCRIPT;
	    }
	   
	    get logLevel() {
	        return PlaybackEventLogger.logLevel;
	    }
	    set eventCoordinator(coordinator) {
	        this.coordinator_ = coordinator;
	    }
	    get eventCoordinator() {
	        return this.coordinator_;
	    }
	    playbackSuccess(config) {
	        config.reason = REASONS.PLAYBACK_COMPLETED;
	        if (!config.caller) {
	            config.caller = 'playbackSuccess';
	        }
	        return this.generateEvent(config);
	    }
	    generateEvent(config) {
	        if (!config.platform) {
	            config.platform = this.platform_;
	        }
	        if (!config.reason || !config.platform || !config.segment || !config.component || !config.feature) {
	            PlaybackEventLogger.warn(`${this.constructor.name}->'track' called from ${config.caller}: specify all CodesConfig params to track event ${config}`);
	            return null;
	        }
	        const event = new PlaybackEvent(config);
	        if (this.coordinator_ && config.eventName) {
	            this.coordinator_.coordinate(config.eventName, event);
	        }
	        return event;
	    }
	}

	var PlaybackEventsService = new PlaybackFactory();

	class BreadcrumbsFactory {
	   
	    ad
	    setErrorReason(reason) {
	        this.errorReason_ = reason;
	    }
	    getErrorReason() {
	        return this.errorReason_;
	    }
	    getCrumbs() {
	        return this.breadcrumbs_;
	    }
	   
	}

	var BREADCRUMBS;
	(function (BREADCRUMBS) {
	    BREADCRUMBS["FINISH"] = "finish";
	    BREADCRUMBS["FMI"] = "FMI";
	    BREADCRUMBS["FETCH_ITEM"] = "FMI";
	    BREADCRUMBS["FMI_S"] = "FMI_S";
	    BREADCRUMBS["FMI_F"] = "FMI_F";
	    BREADCRUMBS["FMI_E"] = "FMI_E";
	    BREADCRUMBS["FMI_R"] = "FMI_R";
	    BREADCRUMBS["FC"] = "FC";
	    BREADCRUMBS["FC_S"] = "FC_S";
	    BREADCRUMBS["FC_F"] = "FC_F";
	    BREADCRUMBS["CAZ"] = "CAZ";
	    BREADCRUMBS["CAN_T"] = "CAN<T>";
	    BREADCRUMBS["CAZ_T"] = "CAZ<T>";
	    BREADCRUMBS["B_FM"] = "B_FM";
	    BREADCRUMBS["B_FMF"] = "B_FMF";
	    BREADCRUMBS["B_RIT"] = "B_RIT";
	    BREADCRUMBS["B_L"] = "B_L";
	    BREADCRUMBS["B_RA"] = "B_RA";
	    BREADCRUMBS["T_FESPN"] = "T_FESPN";
	    BREADCRUMBS["T_FESPNF"] = "T_FESPNF";
	    BREADCRUMBS["T_FSH"] = "T_FSH";
	    BREADCRUMBS["T_FSHF"] = "T_FSHF";
	    BREADCRUMBS["T_FSS"] = "T_FSS";
	    BREADCRUMBS["T_FSSF"] = "T_FSSF";
	    BREADCRUMBS["T_FE"] = "T_FE";
	    BREADCRUMBS["T_FEF"] = "T_FEF";
	    BREADCRUMBS["T_NIT"] = "T_NIT";
	    BREADCRUMBS["T_CHP"] = "T_CHP";
	    BREADCRUMBS["T_PL"] = "T_PL";
	    BREADCRUMBS["T_CMAN"] = "T_CMAN";
	    BREADCRUMBS["T_PJWT"] = "T_PJWT";
	    BREADCRUMBS["T_NJWT"] = "T_NJWT";
	    BREADCRUMBS["T_BJWT"] = "T_BJWT";
	    BREADCRUMBS["MPS"] = "MPS";
	    BREADCRUMBS["CM_I"] = "CM_I";
	    BREADCRUMBS["CM_IF"] = "CM_IF";
	    BREADCRUMBS["B_P"] = "B_P";
	    BREADCRUMBS["MP_I"] = "MP_I";
	    BREADCRUMBS["MP_L"] = "MP_L";
	    BREADCRUMBS["MP_S"] = "MP_S";
	    BREADCRUMBS["MP_C_PA"] = "MP_C_PA";
	    BREADCRUMBS["MP_C_PL"] = "MP_C_PL";
	    BREADCRUMBS["MP_SE"] = "MP_SE";
	    BREADCRUMBS["MP_S_S"] = "MP_S_S";
	    BREADCRUMBS["MP_S_E"] = "MP_S_E";
	    BREADCRUMBS["MP_V_M"] = "MP_V_M";
	    BREADCRUMBS["MP_V_U"] = "MP_V_U";
	    BREADCRUMBS["MP_CC_ON"] = "MP_CC_ON";
	    BREADCRUMBS["MP_CC_OFF"] = "MP_CC_OFF";
	    BREADCRUMBS["MP_C_C"] = "MP_C_C";
	    BREADCRUMBS["MP_D"] = "MP_D";
	    BREADCRUMBS["C_P_G_C_F"] = "C_P_G_C_F";
	    BREADCRUMBS["C_P_G_T_F"] = "C_P_G_T_F";
	    BREADCRUMBS["C_P_T_F"] = "C_P_T_F";
	    BREADCRUMBS["C_P_R_V_F"] = "C_P_R_V_F";
	    BREADCRUMBS["MP_AB_S"] = "MP_AB_S";
	    BREADCRUMBS["MP_AB_E"] = "MP_AB_E";
	    BREADCRUMBS["MP_A_S"] = "MP_A_S";
	    BREADCRUMBS["MP_A_E"] = "MP_A_E";
	    BREADCRUMBS["MP_A_CL"] = "MP_A_CL";
	    BREADCRUMBS["MP_A_CO"] = "MP_A_CO";
	    BREADCRUMBS["MP_A_F"] = "MP_A_F";
	    BREADCRUMBS["AOF"] = "AOF";
	    BREADCRUMBS["AOF_F"] = "AOF_F";
	    BREADCRUMBS["AOF_E"] = "AOF_E";
	    BREADCRUMBS["AOF_S"] = "AOF_S";
	    BREADCRUMBS["PCHF"] = "PCHF";
	    BREADCRUMBS["PCHF_I"] = "PCHF_I";
	    BREADCRUMBS["PCHF_I_F"] = "PCHF_I_F";
	    BREADCRUMBS["PCHF_I_S"] = "PCHF_I_S";
	    BREADCRUMBS["PCHF_M"] = "PCHF_M";
	    BREADCRUMBS["PCHF_M_F"] = "PCHF_M_F";
	    BREADCRUMBS["PCHF_M_S"] = "PCHF_M_S";
	    BREADCRUMBS["PCHF_PCH"] = "PCHF_PCH";
	    BREADCRUMBS["PCHF_PNCH"] = "PCHF_PNCH";
	})(BREADCRUMBS || (BREADCRUMBS = {}));

	var BreadcrumbsService = new BreadcrumbsFactory();

	class NewRelicEventParser {
	    parse(data, errorException) {
	        const result = this.deviceData_();
	        if (data) {
	            let trail = BreadcrumbsService.getCrumbs();
	            if (Array.isArray(data.trail) && data.trail.length) {
	                trail = data.trail;
	            }
	            if (trail.length) {
	                data.trail = this.constructTrail_(data.name, trail, errorException);
	                BreadcrumbsService.reset();
	            }
	            for (const key in data) {
	                if (data[key] !== undefined) {
	                    result[key] = data[key];
	                }
	                if (typeof result[key] === 'object') {
	                    result[key] = JSON.stringify(result[key]);
	                }
	            }
	        }
	        if (errorException && errorException.code) {
	            result['error.instrumentationCode'] = errorException.code;
	            result['error'] = REASONS_NAMES$1[errorException['reason']];
	            if (!result['error.message']) {
	                result['error.message'] = errorException.message;
	            }
	            if (errorException.cause && errorException.cause.message) {
	                result['error.cause.message'] = errorException.cause.message;
	            }
	        }
	        return this.makeCamelCaseInsteadPeriod_(result);
	    }
	    makeCamelCaseInsteadPeriod_(body) {
	        const keys = Object.keys(body);
	        const converted = {};
	        keys.forEach(key => {
	            const arr = key.split('.');
	            if (arr.length > 1) {
	                for (let i = 1; i < arr.length; i++) {
	                    arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].slice(1);
	                }
	            }
	            converted[arr.join('')] = body[key];
	        });
	        return converted;
	    }
	   
	    constructTrail_(name, breadcrumbs, errorException) {
	        let trail;
	        if (breadcrumbs && breadcrumbs.length >= 0) {
	            trail = `start:${name}`;
	            for (let i = 0; i < breadcrumbs.length; i++) {
	                trail += `|${breadcrumbs[i]}`;
	            }
	        }
	        if (errorException) {
	            const reason = REASONS_NAMES$1[errorException['reason']] || REASONS_NAMES[errorException['reason']];
	            trail += `|$end,signpostError=${reason}`;
	        }
	        return trail;
	    }
	}

	class NewRelicFactory {
	    constructor() {
	        this.newRelicError_ = new NewRelicErrors();
	        this.parser_ = new NewRelicEventParser();
	        this.enabled_ = false;
	        this.serviceUrl_ = 'https://insights-collector.newrelic.com/v1/accounts';
	        this.insertKey_ = 'NRII-RUdHfa4sRhagSedsRB8tArX7y3Zszm0u';
	        this.accountId_ = '459463';
	    }
	    init(config) {
	        this.enabled_ = config.enabled || false;
	        this.serviceUrl_ = config.serviceUrl || this.serviceUrl_;
	        this.insertKey_ = config.insertKey || this.insertKey_;
	        this.accountId_ = config.accountId || this.accountId_;
	    }
	    onPause_() {
	        this.addCrumb(BREADCRUMBS.MP_C_PA);
	    }
	    onPlay_() {
	        this.addCrumb(BREADCRUMBS.MP_C_PL);
	    }
	    onMediaItemFetch_() {
	        this.addCrumb(BREADCRUMBS.FMI);
	    }
	    onMediaItemFetched(isSuccess) {
	        if (isSuccess) {
	            this.addCrumb(BREADCRUMBS.FMI_S);
	        }
	        else {
	            this.addCrumb(BREADCRUMBS.FMI_F);
	        }
	    }
	    onMediaItemFetchedEmpty() {
	        this.addCrumb(BREADCRUMBS.FMI_E);
	    }
	    onCaptionToggled_(showCaptions) {
	        if (showCaptions) {
	            this.addCrumb(BREADCRUMBS.MP_CC_ON);
	        }
	        else {
	            this.addCrumb(BREADCRUMBS.MP_CC_OFF);
	        }
	    }
	    onConfigFetch_() {
	        this.addCrumb(BREADCRUMBS.FC);
	    }
	    onConfigFetched(isSuccess) {
	        if (isSuccess) {
	            this.addCrumb(BREADCRUMBS.FC_S);
	        }
	        else {
	            this.addCrumb(BREADCRUMBS.FC_F);
	        }
	    }
	    onDisposed() {
	        this.addCrumb(BREADCRUMBS.MP_D);
	    }
	    onEmbedded() {
	        this.addCrumb(BREADCRUMBS.MP_I);
	    }
	   
	   
	   
	    getServiceUrl_() {
	        if (!this.serviceUrl_ || !this.accountId_)
	            return null;
	        return `${this.serviceUrl_}/${this.accountId_}/events`;
	    }
	    sendEvent(event, errorException) {
	        const url = this.getServiceUrl_();
	        if (!url || !this.enabled_) {
	            const error = `NewRelicFactory error -> recording new relic insights event. invalid url: %@ ${this.serviceUrl_}/${this.accountId_}/events`;
	            console.debug(error);
	            return Promise.resolve({ error: error });
	        }
	        const headers = {
	            'X-Insert-Key': this.insertKey_,
	            'Content-Type': 'application/json',
	        };
	        const body = this.parser_.parse(event, errorException);
	        if (body) {
	            const options = {
	                method: 'POST',
	                headers: headers,
	                body: JSON.stringify(body),
	            };
	            return fetch(url, options)
	                .then(result => {
	                if (!result.ok) {
	                    const error = this.newRelicError_.getErrorMsg(result.status);
	                    console.debug(error);
	                    return Promise.resolve({ error: error });
	                }
	                else {
	                    return Promise.resolve(result.json());
	                }
	            })
	                .catch(error => {
	                console.debug(error);
	                return Promise.resolve({ error: error });
	            });
	        }
	        const error = 'NewRelicFactory error -> nothing to send';
	        console.debug(error);
	        return Promise.resolve({ error: error });
	    }
	}

	new NewRelicFactory();

	var MediaItemMediaCommand$7;
	(function (MediaItemMediaCommand) {
	    MediaItemMediaCommand[MediaItemMediaCommand["all"] = 0] = "all";
	    MediaItemMediaCommand[MediaItemMediaCommand["linearPlayback"] = 1] = "linearPlayback";
	})(MediaItemMediaCommand$7 || (MediaItemMediaCommand$7 = {}));
	var MediaItemMediaCommand$8 = MediaItemMediaCommand$7;

	var MediaItemNetworkType$7;
	(function (MediaItemNetworkType) {
	    MediaItemNetworkType["linear"] = "linear";
	    MediaItemNetworkType["event"] = "event";
	})(MediaItemNetworkType$7 || (MediaItemNetworkType$7 = {}));
	var MediaItemNetworkType$8 = MediaItemNetworkType$7;

	var MediaItemSourceVariant$7;
	(function (MediaItemSourceVariant) {
	    MediaItemSourceVariant["stitchedPreroll"] = "stitchedPreroll";
	})(MediaItemSourceVariant$7 || (MediaItemSourceVariant$7 = {}));
	var MediaItemSourceVariant$8 = MediaItemSourceVariant$7;

	var MediaItemStreamType$9;
	(function (MediaItemStreamType) {
	    MediaItemStreamType["live"] = "live";
	    MediaItemStreamType["onDemand"] = "onDemand";
	})(MediaItemStreamType$9 || (MediaItemStreamType$9 = {}));
	var MediaItemStreamType$a = MediaItemStreamType$9;

	var MediaItemTrackingType$7;
	(function (MediaItemTrackingType) {
	    MediaItemTrackingType["nielsen"] = "nielsen";
	    MediaItemTrackingType["comscore"] = "comscore";
	    MediaItemTrackingType["conviva"] = "conviva";
	    MediaItemTrackingType["heartbeats"] = "heartbeats";
	})(MediaItemTrackingType$7 || (MediaItemTrackingType$7 = {}));
	var MediaItemTrackingType$8 = MediaItemTrackingType$7;

	var MediaItemEntityType$9;
	(function (MediaItemEntityType) {
	    MediaItemEntityType["shortform"] = "shortform";
	    MediaItemEntityType["longform"] = "longform";
	})(MediaItemEntityType$9 || (MediaItemEntityType$9 = {}));
	var MediaItemEntityType$a = MediaItemEntityType$9;

	var MediaItemType$8;
	(function (MediaItemType) {
	    MediaItemType["audio"] = "audio";
	    MediaItemType["video"] = "video";
	})(MediaItemType$8 || (MediaItemType$8 = {}));
	var MediaItemType$9 = MediaItemType$8;

	var ApiSource$c;
	(function (ApiSource) {
	    ApiSource["pluto"] = "pluto";
	    ApiSource["graphQL"] = "graphQL";
	    ApiSource["cfa"] = "cfa";
	    ApiSource["itemFeed"] = "itemFeed";
	})(ApiSource$c || (ApiSource$c = {}));
	var ApiSource$d = ApiSource$c;

	var MediaItemAuthenticationType$b;
	(function (MediaItemAuthenticationType) {
	    MediaItemAuthenticationType["open"] = "OPEN";
	    MediaItemAuthenticationType["direct"] = "DIRECT";
	    MediaItemAuthenticationType["mvpd"] = "MVPD";
	    MediaItemAuthenticationType["isp"] = "ISP";
	    MediaItemAuthenticationType["none"] = "NONE";
	})(MediaItemAuthenticationType$b || (MediaItemAuthenticationType$b = {}));
	var MediaItemAuthenticationType$c = MediaItemAuthenticationType$b;

	var MediaItemSourceType$9;
	(function (MediaItemSourceType) {
	    MediaItemSourceType["none"] = "none";
	    MediaItemSourceType["startSession"] = "startSession";
	    MediaItemSourceType["bam"] = "bam";
	    MediaItemSourceType["shield"] = "shield";
	    MediaItemSourceType["entitlement"] = "entitlement";
	})(MediaItemSourceType$9 || (MediaItemSourceType$9 = {}));
	var MediaItemSourceType$a = MediaItemSourceType$9;

	class MediaItemSource$1 {
	   
	    static fromObject(object) {
	        if (!object) {
	            return null;
	        }
	        const { url, type, hasEspnId3Heartbeats, hasNielsenWatermarks, hasPassThroughAds, commercialReplacement, startSessionUrl, variant, } = object;
	        const sourceType = MediaItemSourceType$a[type] || MediaItemSourceType$a.none;
	        return new MediaItemSource$1(url, sourceType, hasEspnId3Heartbeats, hasNielsenWatermarks, hasPassThroughAds, commercialReplacement, startSessionUrl, variant);
	    }
	}

	class MediaItemNetwork$1 {
	    constructor(id, type, name, resource, affiliate = null) {
	        this.id = id;
	        this.type = type;
	        this.name = name;
	        this.resource = resource;
	        this.affiliate = affiliate;
	    }
	    static fromObject(object) {
	        if (!object) {
	            return null;
	        }
	        const type = MediaItemNetworkType$8[object.type];
	        return new MediaItemNetwork$1(object.id, type, object.name, object.resource, object.affiliate);
	    }
	}

	class MediaItemImage$1 {
	    constructor(url, ratio) {
	        this.url = url;
	        this.ratio = ratio;
	    }
	    static fromObject(object) {
	        if (object === null || object === void 0 ? void 0 : object.url) {
	            const { url, ratio } = object;
	            return new MediaItemImage$1(url, ratio);
	        }
	        return null;
	    }
	}

	class MediaItemPackage$1 {
	    constructor(name) {
	        this.name = name;
	    }
	   
	    static fromObject(object) {
	        if (!object) {
	            return null;
	        }
	        return new MediaItemPackage$1(object.name);
	    }
	}

	class MediaItem$1 {
	    constructor(id, title, duration, language, source) {
	        this.id = id;
	        this.title = title;
	        this.duration = duration;
	        this.language = language || 'en';
	        this.source = source;
	        this.description = null;
	        this.authenticationTypes = [];
	        this.mrss = null;
	        this.seekInSeconds = null;
	        this.tracking = {};
	        this.references = {};
	        this.network = null;
	        this.streamType = null;
	        this.supportedMediaCommands = MediaItemMediaCommand$8.all;
	        this.images = [];
	        this.type = MediaItemType$9.video;
	        this.packages = [];
	        this.tier = null;
	        this.entityType = null;
	        this.isSyndicatable = null;
	        this.brand = null;
	        this.siteBrandId = null;
	        this.apiSource = null;
	        this.adUnitId = null;
	        this.cues = null;
	        this.adTarget = null;
	        this.show = null;
	        this.remoteTextTrack = null;
	        this.advertisingInfo = null;
	        this.schedule = null;
	    }
	   
	   
	    static fromObject(json) {
	        const source = MediaItemSource$1.fromObject(json.source);
	        const mediaItem = new MediaItem$1(json.id, json.title, json.duration, json.language, source);
	        mediaItem.airDate = json.airDate;
	        mediaItem.apiSource = json.apiSource;
	        mediaItem.authenticationTypes = json.authenticationTypes;
	        mediaItem.description = json.description;
	        mediaItem.images = (json.images || []).map(img => MediaItemImage$1.fromObject(img));
	        mediaItem.mrss = json.mrss;
	        mediaItem.network = MediaItemNetwork$1.fromObject(json.network);
	        mediaItem.seekInSeconds = json.seekInSeconds;
	        mediaItem.streamType = MediaItemStreamType$a[json.streamType];
	        mediaItem.supportedMediaCommands = json.supportedMediaCommands;
	        mediaItem.tracking = json.tracking;
	        mediaItem.references = json.references;
	        mediaItem.packages = (json.packages || []).map);
	        mediaItem.tier = json.tier;
	        mediaItem.type = MediaItemType$9[json.type];
	        mediaItem.entityType = MediaItemEntityType$a[json.entityType];
	        mediaItem.isSyndicatable = json.isSyndicatable;
	        mediaItem.brand = json.brand;
	        mediaItem.siteBrandId = json.siteBrandId;
	        mediaItem.adUnitId = json.adUnitId;
	        mediaItem.cues = json.cues;
	        mediaItem.show = json.show;
	        mediaItem.adTarget = json.adTarget;
	        mediaItem.seekBarThumbnails = json.seekBarThumbnails;
	        mediaItem.availableDate = json.availableDate;
	        mediaItem.episodeNumber = json.episodeNumber;
	        mediaItem.locale = json.locale;
	        mediaItem.seasonNumber = json.seasonNumber;
	        mediaItem.tmsid = json.tmsid;
	        mediaItem.videoShowGenre = json.videoShowGenre;
	        mediaItem.remoteTextTrack = json.remoteTextTrack;
	        mediaItem.advertisingInfo = json.advertisingInfo;
	        mediaItem.schedule = json.schedule;
	        return mediaItem;
	    }
	   
	}

	function QueryStringParser$1(identifier) {
	    const query = identifier.split('?')[1];
	    const result = {};
	    if (query) {
	        const vars = query.split('&');
	        for (let i = 0; i < vars.length; i += 1) {
	            const pair = vars[i].split('=');
	            result[pair[0]] = pair[1];
	        }
	    }
	    return result;
	}

	class MediaItemIdentifier$1 {
	    constructor(identifier) {
	        const query = QueryStringParser$1(identifier);
	        this.original = identifier;
	        this.id = (query.videoID || query.playID || query.clip || query.externalId);
	        if (identifier.match('sportscenter')) {
	            this.gameId = query.playGameID;
	            this.channel = query.playChannel;
	            this.simulcastAiringId = query.simulcastAiringId;
	            const resumeTime = parseInt(query.resumeTime, 10);
	            if (!isNaN(resumeTime)) {
	                this.resumeTime = resumeTime;
	            }
	            this.eventId = query.eventId;
	        }
	        else if (identifier.match('abcnews')) {
	            this.channel = query.playChannel;
	            this.id = (query.videoID || query.id);
	        }
	        this.source = query['x-source'];
	        if (query.videoID) {
	            this.entityType = MediaItemEntityType$a.shortform;
	        }
	        else {
	            this.entityType = MediaItemEntityType$a.longform;
	        }
	        this.type = MediaItemType$9.video;
	    }
	    toString(source) {
	        if (source == ApiSource$d.graphQL) {
	            return `<MediaItemIdentifier id:${this.id}, gameId:${this.gameId}, channel:${this.channel}, source:${this.source}>`;
	        }
	        else {
	            return `<MediaItemIdentifier id:${this.id}, source:${this.source}>`;
	        }
	    }
	    static identifierStringForNetwork(id, source) {
	        switch (source) {
	            case ApiSource$d.cfa:
	                return `natgeo://playVideo?videoID=${id}`;
	            case ApiSource$d.itemFeed:
	                return `abcnews://playVideo?playChannel=${id}`;
	            case ApiSource$d.graphQL:
	            default:
	                return `sportscenter://x-callback-url/showWatchStream?playChannel=${id}`;
	        }
	    }
	}

	/*! *****************************************************************************
	Copyright (c) Microsoft Corporation.

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
	REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
	AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
	INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
	LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
	OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
	PERFORMANCE OF THIS SOFTWARE.
	***************************************************************************** */



	var loglevel = createCommonjsModule(function (module) {
	/*
	* loglevel - https://github.com/pimterry/loglevel
	*
	* Copyright (c) 2013 Tim Perry
	* Licensed under the MIT license.
	*/
	(function (root, definition) {
	    if (module.exports) {
	        module.exports = definition();
	    } else {
	        root.log = definition();
	    }
	}(commonjsGlobal, function () {

	    // Slightly dubious tricks to cut down minimized file size
	    var noop = function() {};
	    var undefinedType = "undefined";
	    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
	        /Trident\/|MSIE /.test(window.navigator.userAgent)
	    );

	    var logMethods = [
	        "trace",
	        "debug",
	        "info",
	        "warn",
	        "error"
	    ];

	    // Cross-browser bind equivalent that works at least back to IE6
	   

	    // Trace() doesn't print the message in IE, so for that case we need to wrap it
	   

	    // Build the best logging method possible for this env
	    // Wherever possible we want to bind, not wrap, to preserve stack traces
	   

	    // These private functions always need `this` to be set properly

	   

	    // In old IE versions, the console isn't present until you first open it.
	    // We build realMethod() replacements here that regenerate logging methods
	   

	    // By default, we use closely bound real methods wherever possible, and
	    // otherwise we wait for a console to appear, and then try again.
	   

	    function Logger(name, defaultLevel, factory) {
	      var self = this;
	      var currentLevel;
	      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;

	      var storageKey = "loglevel";
	      if (typeof name === "string") {
	        storageKey += ":" + name;
	      } else if (typeof name === "symbol") {
	        storageKey = undefined;
	      }

	     

	     

	      function clearPersistedLevel() {
	          if (typeof window === undefinedType || !storageKey) return;

	          // Use localStorage if available
	          try {
	              window.localStorage.removeItem(storageKey);
	              return;
	          } catch (ignore) {}

	          // Use session cookie as fallback
	          try {
	              window.document.cookie =
	                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
	          } catch (ignore) {}
	      }

	      /*
	       *
	       * Public logger API - see https://github.com/pimterry/loglevel for details
	       *
	       */

	      self.name = name;

	      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
	          "ERROR": 4, "SILENT": 5};

	      self.methodFactory = factory || defaultMethodFactory;

	      self.getLevel = function () {
	          return currentLevel;
	      };

	      self.setLevel =;

	      self.setDefaultLevel = function (level) {
	          defaultLevel = level;
	          if (!getPersistedLevel()) {
	              self.setLevel(level, false);
	          }
	      };

	      self.resetLevel =;

	      self.enableAll = function(persist) {
	          self.setLevel(self.levels.TRACE, persist);
	      };

	      self.disableAll =;

	      // Initialize with the right level
	      var initialLevel = getPersistedLevel();
	      if (initialLevel == null) {
	          initialLevel = defaultLevel;
	      }
	      self.setLevel(initialLevel, false);
	    }

	    /*
	     *
	     * Top-level API
	     *
	     */

	    var defaultLogger = new Logger();

	    var _loggersByName = {};
	    defaultLogger.getLogger =;

	    // Grab the current global log variable in case of overwrite
	    var _log = (typeof window !== undefinedType) ? window.log : undefined;
	    defaultLogger.noConflict =;

	    defaultLogger.getLoggers = function getLoggers() {
	        return _loggersByName;
	    };

	    // ES6 default export, for compatibility
	    defaultLogger['default'] = defaultLogger;

	    return defaultLogger;
	}));
	});

	const primaryLinearNetworks = new Set(['ESPN', 'ESPN2']);



	function shouldSetAdLoadTypeToOne(entityType, streamType, networkName) {
	    const isLongform = entityType === MediaItemEntityType$a.longform;
	    const isLive = streamType === MediaItemStreamType$a.live;
	    const isVod = streamType === MediaItemStreamType$a.onDemand;
	    return (isLongform && isVod) || isEspnPlus(networkName) || (isLive && isPrimaryLinearNetworks(networkName));
	}
	function buildNielsenMetadata(graphQLResponse, entityType, streamType) {
	    if (!graphQLResponse) {
	        return {};
	    }
	    const { duration, id, league, name, network, program, sport, startDateTime, tracking } = graphQLResponse;
	    const metadata = {};
	    let adLoadType = '2';
	    if (shouldSetAdLoadTypeToOne(entityType, streamType, network === null || network === void 0 ? void 0 : network.name)) {
	        adLoadType = '1';
	    }
	    metadata.adloadtype = adLoadType;
	    if (streamType === MediaItemStreamType$a.live && isPrimaryLinearNetworks(network === null || network === void 0 ? void 0 : network.name)) {
	        metadata.admodel = '1';
	    }
	    metadata.type = 'content';
	    metadata.assetid = (tracking && tracking.trackingId) || id;
	    metadata.program = name;
	    metadata.title = name;
	    metadata.clientid = 'us-600140';
	    if (streamType === MediaItemStreamType$a.onDemand) {
	        metadata.vcid = 'c17';
	    }
	    if (entityType === MediaItemEntityType$a.longform) {
	        metadata.length = `${duration}`;
	        metadata.segB = (league && league.name) || 'No League';
	        metadata.segC = `${(program && program.code) || ''}${(sport && sport.code) || ''}`;
	        if (startDateTime) {
	            const airDate = new Date(startDateTime);
	            metadata.airdate = `${airDate.getUTCFullYear().toString() +
                `0${airDate.getUTCMonth()}`.slice(-2) +
                `0${airDate.getUTCDate()}`.slice(-2)} ${`0${airDate.getUTCHours()}`.slice(-2)}:${`0${airDate.getUTCMinutes()}`.slice(-2)}:${`0${airDate.getUTCSeconds()}`.slice(-2)}`;
	        }
	        metadata.isfullepisode = 'y';
	        metadata.crossId1 = (tracking && tracking.nielsenCrossId1) || '';
	        metadata.crossId2 = (network && network.name) || '';
	        metadata.hasAds = '1';
	        metadata.progen = 'SE';
	    }
	    if (entityType === MediaItemEntityType$a.shortform) {
	        metadata.accmethod = '1';
	        metadata.length = `${duration}`;
	        metadata.segA = name;
	        metadata.segB = 'No League';
	        metadata.segC = 'VOD';
	        metadata.isfullepisode = 'n';
	        metadata.crossId1 = '';
	    }
	    return metadata;
	}

	function buildComscoreMetadata(graphQLResponse, entityType) {
	    if (!graphQLResponse) {
	        return {};
	    }
	    const { id, duration, name, league, startDateTime, network, sport, status, tracking, program } = graphQLResponse;
	    const metadata = {};
	    let leagueName = '';
	    let sportName = '';
	    if (entityType === MediaItemEntityType$a.longform) {
	        metadata.ns_st_cl = 0;
	        metadata.ns_st_ct = 'vc';
	        if (status && (status.toLowerCase() === 'live' || status.toLowerCase() === 'over')) {
	            metadata.ns_st_cl = 0;
	            metadata.ns_st_ct = 'vc13';
	            metadata.ns_st_pr = name;
	            metadata.ns_st_ep = '*null';
	        }
	        else {
	            metadata.ns_st_cl = duration;
	            metadata.ns_st_ct = 'vc12';
	            metadata.ns_st_pr = 'VOD';
	            metadata.ns_st_ep = name;
	        }
	        metadata.c3 = 'WATCHESPNLIVE';
	        if (league === null || league === void 0 ? void 0 : league.name) {
	            leagueName = `${league.name}`;
	        }
	        if (sport === null || sport === void 0 ? void 0 : sport.name) {
	            sportName = `${sport.name}`;
	        }
	    }
	    else {
	        metadata.ns_st_cl = duration;
	        metadata.ns_st_ct = 'vc11';
	        metadata.ns_st_pr = 'VOD';
	        metadata.ns_st_ep = name;
	        if ((tracking === null || tracking === void 0 ? void 0 : tracking.leagueName) && (tracking === null || tracking === void 0 ? void 0 : tracking.leagueName) !== 'No League') {
	            leagueName = `${tracking.leagueName}`;
	        }
	        if (tracking === null || tracking === void 0 ? void 0 : tracking.sportName) {
	            sportName = `${tracking.sportName}`;
	        }
	        metadata.c3 = 'vod';
	    }
	    if (leagueName) {
	        metadata.c6 = (program === null || program === void 0 ? void 0 : program.isStudio) ? `${leagueName} studio` : leagueName;
	    }
	    else if (sportName) {
	        metadata.c6 = (program === null || program === void 0 ? void 0 : program.isStudio) ? `${sportName} studio` : sportName;
	    }
	    else {
	        metadata.c6 = (sport === null || sport === void 0 ? void 0 : sport.code) || 'No Sport';
	    }
	    metadata.ns_st_ti = '*null';
	    metadata.ns_st_ia = '*null';
	    metadata.ns_st_ce = '*null';
	    metadata.ns_st_ci = id;
	    if (startDateTime) {
	        const date = new Date(startDateTime);
	        metadata.ns_st_ddt = date.toDateString();
	        metadata.ns_st_tdt = date.toDateString();
	    }
	    metadata.ns_st_st = network ? network.id : '*null';
	    metadata.ns_st_en = '*null';
	    metadata.ns_st_cn = '1';
	    metadata.ns_st_pn = '1';
	    metadata.ns_st_tp = '1';
	    metadata.ns_st_pu = 'ESPN';
	    metadata.ns_st_cu = 'none';
	    metadata.ns_st_ad = '0';
	    metadata.ns_st_ge = 'Sports';
	    return metadata;
	}

	function buildConvivaMetadata(graphQLResponse, entityType, source) {
	    if (!graphQLResponse) {
	        return {};
	    }
	    const { name, id, airingId, eventId, duration, network, status, sport, league, pccId, tracking } = graphQLResponse;
	    const tags = tracking === null || tracking === void 0 ? void 0 : tracking.tags;
	    const custom = {};
	    custom.contentId = id;
	    if (pccId) {
	        custom.pccId = pccId;
	    }
	    if (airingId) {
	        custom.airingId = airingId;
	    }
	    if (eventId) {
	        custom.eventId = `${eventId}`;
	        custom.eventName = name;
	    }
	    if (network) {
	        custom.network = network.id;
	    }
	    if (entityType === MediaItemEntityType$a.shortform) {
	        custom.assetType = 'clip';
	    }
	    else if (status && (status.toLowerCase() === 'live' || status.toLowerCase() === 'over')) {
	        custom.assetType = 'live';
	    }
	    else {
	        custom.assetType = 'vod';
	    }
	    let assetName = `${name} - ${id}`;
	    if (network && network.type === MediaItemNetworkType$8.linear && custom.assetType === 'live') {
	        assetName = network.id;
	    }
	    custom.sport = (sport && sport.name) || 'NA';
	    custom.league = (league && league.name) || 'NA';
	    custom.appBrand = Brand.espn;
	    return {
	        assetName,
	        duration,
	        tags,
	        streamUrl: source && source.url,
	        custom,
	    };
	}

	function buildHeartbeatMetadata(graphQLResponse, entityType) {
	    if (!graphQLResponse) {
	        return {};
	    }
	    const { duration, airingId, network, status, sport, league, name, program, startDateTime, tracking, originalPublishDate, expirationDate, lastModifiedDate, ad, coverageType, brands, } = graphQLResponse;
	    const info = {};
	    info.ContentDuration = duration;
	    if (entityType === MediaItemEntityType$a.longform) {
	        info.CMSID = (tracking && tracking.name) || name;
	        info.isFullEpisode = 'y';
	        if (airingId) {
	            info.AiringID = airingId;
	        }
	        if (network) {
	            info.NetworkName = network.id;
	            info.Channel = network.id;
	        }
	        if (status) {
	            info.VideoType = status === 'REPLAY' ? 'replay' : 'live';
	        }
	        info.Sport = (sport && sport.name) || 'Not Applicable';
	        info.SportCode = (sport && sport.code) || 'Not Applicable';
	        info.League = (league && league.name) || 'Not Applicable';
	        if (program && program.code && program.categoryCode) {
	            info.ProgramCode = program.categoryCode + program.code;
	        }
	        else {
	            info.ProgramCode = 'Not Applicable';
	        }
	        info.IsStudio = (program && program.isStudio) || 'Not Applicable';
	        if (startDateTime) {
	            const date = new Date(startDateTime);
	            info.AirDate = date.toDateString();
	            info.AirTime = date.toTimeString();
	        }
	        if (Array.isArray(brands) && brands.length) {
	            const { id, name, type } = brands[0];
	            info['a.media.asset'] = id;
	            info['a.media.show'] = name;
	            info['a.media.genre'] = type;
	        }
	    }
	    else if (entityType === MediaItemEntityType$a.shortform) {
	        info.isFullEpisode = 'n';
	        info.VideoType = 'vod';
	        info.Sport = (tracking && tracking.sportName) || 'Not Applicable';
	        info.League = (tracking && tracking.leagueName) || 'Not Applicable';
	        info.ShowCode = (ad && ad.bundle) || 'Not Applicable';
	        if (tracking && tracking.name) {
	            info.CMSID = tracking.name;
	        }
	        if (originalPublishDate) {
	            const date = new Date(originalPublishDate);
	            info.PublishDate = date.toISOString().substring(0, 10);
	            info.PublishTime = date.toISOString().substring(11);
	        }
	        if (expirationDate) {
	            const date = new Date(expirationDate);
	            info.ExpirationDate = date.toISOString();
	        }
	        if (lastModifiedDate) {
	            const date = new Date(lastModifiedDate);
	            info.DateLastModified = date.toISOString();
	        }
	        if (coverageType) {
	            info.VideoTypeDetail = coverageType;
	        }
	    }
	    return info;
	}

	function buildNatGeoHeartbeatMetadata(response) {
	    if (!response) {
	        return {};
	    }
	    const info = {};
	    const { id, title, duration } = response;
	    info.c_video_id_code = id;
	    info.c_a_media_airdate = 'unknown';
	    info.c_a_media_daypart = 'daytime';
	    info.c_a_media_digitaldate = 'unknown';
	    info.c_a_media_episode = 'none';
	    info.c_a_media_feed = 'natgeo live';
	    info.c_a_media_format = 'vod';
	    info.c_a_media_genre = 'none';
	    info.c_a_media_network = 'natgeo';
	    info.c_a_media_originator = 'natgeo';
	    info.c_a_media_pass_auth = 'none';
	    info.c_a_media_pass_mvpd = 'none';
	    info.c_a_media_rating = 'none';
	    info.c_a_media_season = 'none';
	    info.c_a_media_show = title;
	    info.c_a_media_streamtype = MediaItemType$8.video;
	    info.c_a_media_length = duration;
	    return info;
	}

	function buildMediaItemTracking(mediaItem, response, entityType, source) {
	    if (!response) {
	        return {};
	    }
	    let nielsen, comscore, conviva, heartbeats = null;
	    const streamType = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.streamType;
	    if ((mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.brand) === Brand.natGeo) {
	        heartbeats = buildNatGeoHeartbeatMetadata(response);
	    }
	    else {
	        nielsen = buildNielsenMetadata(response, entityType, streamType);
	        comscore = buildComscoreMetadata(response, entityType);
	        conviva = buildConvivaMetadata(response, entityType, source);
	        heartbeats = buildHeartbeatMetadata(response, entityType);
	    }
	    const tracking = {};
	    tracking[MediaItemTrackingType$8.nielsen] = nielsen;
	    tracking[MediaItemTrackingType$8.comscore] = comscore;
	    tracking[MediaItemTrackingType$8.conviva] = conviva;
	    tracking[MediaItemTrackingType$8.heartbeats] = heartbeats;
	    return tracking;
	}

	function mediaItemFromGraphQL(response, entityType, options) {
	    const { id, name, description, duration, image, eventId, requiresLinearPlayback, authTypes, source: src, prerollSource, packages, language, mrss, seekInSeconds, tracking, simulcastAiringId, network, status, cerebroId, syndicatable, } = response;
	    const isLive = status && (status.toUpperCase() === 'LIVE' || status.toUpperCase() === 'OVER');
	    const streamType = isLive ? MediaItemStreamType$a.live : MediaItemStreamType$a.onDemand;
	    const sourceType = )(src.authorizationType);
	    let source = new MediaItemSource$1(src.url, sourceType, src.hasEspnId3Heartbeats, src.hasNielsenWatermarks, src.hasPassThroughAds, src.commercialReplacement, src.startSessionUrl);
	    if (options && options.sourceVariant === MediaItemSourceVariant$8.stitchedPreroll && prerollSource) {
	        source = new MediaItemSource$1(prerollSource.url, MediaItemSourceType$a.none);
	        source.variant = MediaItemSourceVariant$8.stitchedPreroll;
	    }
	    const supportedMediaCommands = requiresLinearPlayback ? MediaItemMediaCommand$8.linearPlayback : MediaItemMediaCommand$8.all;
	    const trackingId = (tracking && tracking.trackingId) || id;
	    const mediaItem = new MediaItem$1(id, name, duration, language, source);
	    mediaItem.authenticationTypes = authTypes.map((item) => {
	        switch (item) {
	            case 'DIRECT':
	                return MediaItemAuthenticationType$c.direct;
	            case 'OPEN':
	                return MediaItemAuthenticationType$c.open;
	            case 'MVPD':
	                return MediaItemAuthenticationType$c.mvpd;
	            case 'ISP':
	                return MediaItemAuthenticationType$c.isp;
	            default:
	                return MediaItemAuthenticationType$c.none;
	        }
	    });
	    mediaItem.description = description;
	    mediaItem.isSyndicatable = syndicatable;
	    if (Array.isArray(mediaItem.images) && (image === null || image === void 0 ? void 0 : image.url)) {
	        mediaItem.images.push(new MediaItemImage$1(image.url));
	    }
	    mediaItem.mrss = mrss;
	    if (network) {
	        const networkType = network.type === 'linear' ? MediaItemNetworkType$8.linear : MediaItemNetworkType$8.event;
	        mediaItem.network = new MediaItemNetwork$1(network.id, networkType, network.name, network.adobeResource);
	    }
	    mediaItem.seekInSeconds = seekInSeconds;
	    mediaItem.streamType = streamType;
	    mediaItem.supportedMediaCommands = supportedMediaCommands;
	    mediaItem.brand = mediaItem.brand ? mediaItem.brand : 'espn';
	    mediaItem.references = {
	        eventId,
	        simulcastAiringId,
	        trackingId,
	        cerebroId,
	    };
	    mediaItem.type = MediaItemType$9.video;
	    mediaItem.entityType = entityType;
	    mediaItem.apiSource = ApiSource$d.graphQL;
	    mediaItem.packages = (packages || []).map);
	    mediaItem.tracking = buildMediaItemTracking(mediaItem, response, entityType, source);
	    return mediaItem;
	}

	function sortMediaItems(mediaItems, networkSortOrder, lang) {
	    return mediaItems
	        .sort((first, second) => {
	        const firstTier = first.tier === 'PRIMARY' ? 0 : first.tier === 'SECONDARY' ? 1 : 2;
	        const secondTier = second.tier === 'PRIMARY' ? 0 : second.tier === 'SECONDARY' ? 1 : 2;
	        if (firstTier < secondTier) {
	            return -1;
	        }
	        if (firstTier > secondTier) {
	            return 1;
	        }
	        return 0;
	    })
	        .sort((first, second) => {
	        const firstNetwork = (first.network && first.network.id.toLowerCase()) || 'unknown';
	        const secondNetwork = (second.network && second.network.id.toLowerCase()) || 'unknown';
	        let firstNetworkIndex = networkSortOrder.indexOf(firstNetwork);
	        let secondNetworkIndex = networkSortOrder.indexOf(secondNetwork);
	        if (firstNetworkIndex === -1) {
	            firstNetworkIndex = 999;
	        }
	        if (secondNetworkIndex === -1) {
	            secondNetworkIndex = 999;
	        }
	        if (firstNetworkIndex < secondNetworkIndex) {
	            return -1;
	        }
	        if (firstNetworkIndex > secondNetworkIndex) {
	            return 1;
	        }
	        return 0;
	    })
	        .sort((first, second) => {
	        const firstLanguage = first.language === lang ? 0 : 1;
	        const secondLanguage = second.language === lang ? 0 : 1;
	        if (firstLanguage < secondLanguage) {
	            return -1;
	        }
	        if (firstLanguage < secondLanguage) {
	            return 1;
	        }
	        return 0;
	    });
	}

	const graphQLAiringProps = '{ ' +
	    'id name description mrss:adobeRSS authTypes ' +
	    'requiresLinearPlayback status:type startDateTime endDateTime duration ' +
	    'source(authorization: SHIELD) { url authorizationType hasEspnId3Heartbeats hasNielsenWatermarks hasPassThroughAds commercialReplacement startSessionUrl } ' +
	    'network { id type name adobeResource } ' +
	    'image { url } ' +
	    'sport { name code uid } ' +
	    'league { name uid } ' +
	    'program { code categoryCode isStudio } ' +
	    'seekInSeconds simulcastAiringId airingId ' +
	    'tracking { nielsenCrossId1 trackingId } ' +
	    'eventId ' +
	    'packages { name } ' +
	    'language tier feedName ' +
	    'brands { id name type } ' +
	    '}';
	const graphQLVODProps = '{' +
	    'id name description authTypes language ' +
	    'duration originalPublishDate expirationDate ' +
	    'requiresLinearPlayback lastModifiedDate ' +
	    'source { url authorizationType } ' +
	    'image { url } ' +
	    'tracking { name sportName leagueName } ' +
	    'coverageType ' +
	    'prerollSource:source(variant:PREROLL) { url authorizationType }' +
	    'ad { sport bundle } ' +
	    'links { web } ' +
	    'cerebroId syndicatable pccId ' +
	    '}';
	function identifierToUrl(identifier, serviceUrl, apiKey, countryCode, languageCode) {
	    let queryType = '';
	    let identifierParams = '';
	    let props = '';
	    const country = countryCode || 'US';
	    const languageParam = languageCode ? `,languageCode:"${languageCode}"` : '';
	    if (identifier.entityType === MediaItemEntityType$a.shortform) {
	        queryType = 'VOD';
	        props = graphQLVODProps;
	        identifierParams = `id:"${identifier.id}"`;
	    }
	    else {
	        queryType = 'airing';
	        props = graphQLAiringProps;
	        if (identifier.id) {
	            identifierParams = `id:"${identifier.id}"`;
	        }
	        else if (identifier.channel) {
	            queryType = 'airings';
	            identifierParams = `networks:["${identifier.channel}"],type:LIVE`;
	        }
	        else if (identifier.gameId) {
	            queryType = 'airings';
	            identifierParams = `eventId:"${identifier.eventId || identifier.gameId}"`;
	        }
	    }
	    const query = encodeURIComponent(`{ ${queryType}(${identifierParams},countryCode:"${country}"${languageParam},deviceType:SETTOP,tz:"Z") ${props} }`);
	    return `${serviceUrl}?apiKey=${apiKey}&query=${query}`;
	}

	const defaultGraphQLServiceUrl$6 = 'https://watch.graph.api.espn.com/api';
	const defaultGraphQLApiKey$6 = 'd15c5790-7cb0-4fe1-8782-25f4698d0739';
	const defaultGraphQLNetworkSortOrder$6 = [
	    'espn_ppv',
	    'espn_dtc',
	    'espn1',
	    'espn2',
	    'espn3',
	    'espnu',
	    'sec',
	    'espnews',
	    'espndeportes',
	    'longhorn',
	    'goalline',
	    'buzzerbeater',
	    'secplus',
	    'acc',
	    'accextra',
	    'espn_free',
	    'bam_dtc',
	];
	const defaultItemFeedServiceUrl$6 = 'https://abcnews.go.com/video/itemfeed';
	class Configuration$8 {
	    constructor(apiSource, serviceUrl, apiKey, networkSortOrder) {
	        if (apiSource === ApiSource$d.graphQL) {
	            this.serviceUrl = serviceUrl || defaultGraphQLServiceUrl$6;
	            this.apiKey = apiKey || defaultGraphQLApiKey$6;
	            this.networkSortOrder = networkSortOrder || defaultGraphQLNetworkSortOrder$6;
	        }
	        else if (apiSource === ApiSource$d.cfa) {
	            this.apiSource = apiSource;
	            this.serviceUrl = serviceUrl;
	        }
	        else if (apiSource === ApiSource$d.itemFeed) {
	            this.serviceUrl = serviceUrl || defaultItemFeedServiceUrl$6;
	        }
	    }
	}

	class GraphQLMediaItemAPI {
	    constructor() {
	        this.configuration_ = GraphQLMediaItemAPI.defaultConfiguration;
	    }
	    get configuration() {
	        return this.configuration_;
	    }
	    set configuration(configuration) {
	        this.configuration_ = configuration;
	    }
	    getMediaItems(identifiers, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return yield GraphQLMediaItemAPI.fetchMediaItems(identifiers, options, this.configuration);
	        });
	    }
	    static fetchMediaItems(identifiers, options, configuration) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const ids = identifiers.map(string => new MediaItemIdentifier$1(string));
	            const { serviceUrl, apiKey, networkSortOrder } = configuration;
	            const promiseMediaItems = yield Promise.all(ids.map));
	            const mediaItems = promiseMediaItems.filter(result => !(result instanceof Error) && result instanceof MediaItem$1);
	            if (mediaItems.length) {
	                return sortMediaItems(mediaItems, networkSortOrder, navigator.language);
	            }
	            return null;
	        });
	    }
	    static getPromiseMediaItems(identifier, serviceUrl, apiKey, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const url = identifierToUrl(identifier, serviceUrl, apiKey, options.countryCode, options.languageCode);
	            try {
	                const response = yield fetch(url);
	                const json = yield response.json();
	                let { airing } = json.data;
	                const { airings } = json.data;
	                if (airings) {
	                    const filter = identifier.simulcastAiringId
	                        ?
	                        :;
	                    airing = airings.filter(filter)[0];
	                }
	                const vod = json.data.VOD;
	                const obj = airing || vod;
	                if (!obj) {
	                    throw new Error('No results found.');
	                }
	                const mediaItem = mediaItemFromGraphQL(obj, identifier.entityType, options);
	                if (identifier.resumeTime) {
	                    mediaItem.seekInSeconds = identifier.resumeTime;
	                }
	                if (!mediaItem.source.url) {
	                    const isOver = obj.status.toUpperCase() === 'OVER';
	                    const isLinear = obj.network && obj.network.type === MediaItemNetworkType$8.linear;
	                    const networkId = obj.network && obj.network.id;
	                    if (isOver && isLinear && networkId) {
	                        return GraphQLMediaItemAPI.retryGetMediaItems(networkId, serviceUrl, apiKey, options);
	                    }
	                    throw new Error('No playable url');
	                }
	                return mediaItem;
	            }
	            catch (error) {
	                loglevel.warn(`Failed to retrieve MediaItem from GraphQL: ${error}`);
	                return null;
	            }
	        });
	    }
	    static retryGetMediaItems(networkId, serviceUrl, apiKey, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            try {
	                const identifierString = MediaItemIdentifier$1.identifierStringForNetwork(networkId, ApiSource$d.graphQL);
	                const identifier = new MediaItemIdentifier$1(identifierString);
	                const mediaItem = yield GraphQLMediaItemAPI.getPromiseMediaItems(identifier, serviceUrl, apiKey, options);
	                if (mediaItem && mediaItem instanceof MediaItem$1 === true) {
	                    return mediaItem;
	                }
	                throw new Error(`Retry fetchMediaItems failed with ${networkId}`);
	            }
	            catch (error) {
	                loglevel.warn(`MediaItem is over and retry failed: ${error}`);
	                return null;
	            }
	        });
	    }
	}
	GraphQLMediaItemAPI.defaultConfiguration = new Configuration$8(ApiSource$d.graphQL);

	function mediaItemFromCFA(response) {
	    var _a, _b;
	    const { id, title, duration, language, source: src, type, entityType, streamType, authenticationTypes, description, supportedMediaCommands, network, tracking, brand, images, textTracks, advertisingInfo, schedule, } = response;
	    const sourceType = src.type;
	    const source = new MediaItemSource$1(src.url, sourceType);
	    const supportedMedia = supportedMediaCommands === 2 ? MediaItemMediaCommand$8.linearPlayback : MediaItemMediaCommand$8.all;
	    const mParticleTrack = (tracking === null || tracking === void 0 ? void 0 : tracking.mParticle) || {};
	    let assetName = `${title} - ${id}`;
	    const shouldUseNetworkId = (network === null || network === void 0 ? void 0 : network.id) && (network === null || network === void 0 ? void 0 : network.type) === 'linear' && streamType === 'live';
	    if (shouldUseNetworkId) {
	        assetName = network.id;
	    }
	    let imagesData;
	    if ((_a = images === null || images === void 0 ? void 0 : images[0]) === null || _a === void 0 ? void 0 : _a.name) {
	        const thumbnailImages = images.filter(el => el.name === 'thumbnail')[0];
	        const imagesRawData = thumbnailImages.crops.filter)[0];
	        imagesData = [
	            {
	                url: imagesRawData.url,
	                ratio: imagesRawData.name,
	            },
	        ];
	    }
	    else {
	        imagesData = images;
	    }
	    const mediaItemData = {
	        id,
	        apiSource: ApiSource$d.cfa,
	        seasonNumber: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_season,
	        episodeNumber: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.episode_number,
	        genre: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_genre,
	        show: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_show,
	        network,
	        title,
	        duration,
	        language,
	        source,
	        description,
	        authenticationTypes,
	        brand,
	        type,
	        entityType,
	        streamType,
	        images: imagesData,
	        supportedMediaCommands: supportedMedia,
	        airDate: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_first_air_date,
	        availableDate: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_digital_date,
	        remoteTextTrack: ((_b = textTracks === null || textTracks === void 0 ? void 0 : textTracks[0]) === null || _b === void 0 ? void 0 : _b.source) || null,
	        tracking: {
	            nielsen: {
	                type: 'content',
	                assetid: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_asset_id,
	                program: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_title,
	                title: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_title,
	            },
	            conviva: {
	                assetName,
	                duration,
	                tags: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.tags,
	                streamURL: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.stream_url,
	                custom: {
	                    network,
	                    prt: 'dmed',
	                    airingId: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_airing_id,
	                    contentId: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_id,
	                    appBrand: brand,
	                    accessType: streamType,
	                },
	            },
	            heartbeats: {
	                ContentDuration: duration,
	                isFullEpisode: entityType === MediaItemEntityType$a.longform ? 'y' : 'n',
	                VideoType: streamType,
	                CMSID: assetName,
	                PublishDate: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_digital_date,
	            },
	            comscore: {
	                comscoreC6: 'No Sport',
	                comscoreContentType: mParticleTrack === null || mParticleTrack === void 0 ? void 0 : mParticleTrack.content_type,
	                publisher: brand,
	            },
	        },
	        advertisingInfo,
	        schedule,
	    };
	    mediaItemData.authenticationTypes = authenticationTypes.map);
	    const mediaItem = MediaItem$1.fromObject(mediaItemData);
	    return mediaItem;
	}

	class CFAMediaItemAPI {
	   
	    get configuration() {
	        return this.configuration_;
	    }
	    set configuration(configuration) {
	        this.configuration_ = configuration;
	    }
	    getMediaItems(identifiers, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const serviceUrl = this.getServiceUrl_(options === null || options === void 0 ? void 0 : options.brand);
	            return yield CFAMediaItemAPI.fetchMediaItems(identifiers, options, serviceUrl);
	        });
	    }
	    getServiceUrl_(brand) {
	        var _a;
	        if ((_a = this.configuration) === null || _a === void 0 ? void 0 : _a.serviceUrl) {
	            return this.configuration.serviceUrl;
	        }
	        switch (brand) {
	            case 'abcn':
	            case 'kabc':
	            case 'kfsn':
	            case 'kgo':
	            case 'ktrk':
	            case 'wabc':
	            case 'wls':
	            case 'wpvi':
	            case 'wtvd':
	                return this.serviceUrlForNews_;
	            case 'marvel':
	                return this.serviceUrlForMarvel_;
	            default:
	                return this.serviceUrlForNatgeo_;
	        }
	    }
	    static fetchMediaItems(identifiers, options, serviceUrl) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const mediaItemIdentifiers = identifiers.map(string => new MediaItemIdentifier$1(string));
	            const promiseMediaItems = yield Promise.all(mediaItemIdentifiers.map));
	            return promiseMediaItems.filter(result => !(result instanceof Error) && result instanceof MediaItem$1);
	        });
	    }
	    static getPromiseMediaItem(mediaItemIdentifier, options, serviceUrl) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const url = `${serviceUrl}/${mediaItemIdentifier.id}${CFAMediaItemAPI.getUrlParams(options)}`;
	            try {
	                const { token } = options;
	                let requestOptions = {};
	                if (token) {
	                    requestOptions = {
	                        header: `Authorization: Bearer ${token}`,
	                    };
	                }
	                const response = yield fetch(url, requestOptions);
	                const json = yield response.clone().json();
	                const mediaItem = mediaItemFromCFA(json);
	                return mediaItem;
	            }
	            catch (error) {
	                console.error(`Failed to retrieve MediaItem from CFA: ${error}`);
	                return null;
	            }
	        });
	    }
	    static getUrlParams(options) {
	        const { brand = '', platform = 'web', _passthrough, env = 'prod', containerId } = options || {};
	        const apiBrand = brand ? `&brand=${brand}` : '';
	        if (brand === 'natgeo' || brand === 'marvel') {
	            const containerIdParam = containerId ? `&container-id=${containerId}` : '';
	            let url = `?platform=${platform}${containerIdParam}`;
	            if (env === 'dev') {
	                const passthrough = _passthrough ? `&_passthrough=${_passthrough}` : '';
	                const meterRemaining = options['meter-remaining'] ? `&meter-remaining=${options['meter-remaining']}` : '';
	                url += `${passthrough}${meterRemaining}`;
	            }
	            return url;
	        }
	        return `?platform=${platform}${apiBrand}`;
	    }
	}

	const EMPTY_OBJ$2 = Object.freeze({});
	const EMPTY_ARY = Object.freeze({});
	const EMPTY_STR$2 = '';
	const NULL = null;
	const API_SOURCE = ApiSource$d.itemFeed;
	const ABCN = 'abcn';
	const NEWS = 'news';
	const NOT_APPLICABLE = 'none';
	const LINEAR_STREAM_TYPE = 'akamai live stream';
	const ABCNEWS_BRAND = 'abcnews';
	const LIVE$u = 'live';
	const ENTITY_TYPE_BY_VIDEO_CONTENT_TYPE = {
	    lf: 'longform',
	    sf: 'shortform',
	    live: 'longform',
	};
	const BRAND_BY_CHANNEL_OR_NETWORK = {
	    'abcn:fivethirtyeight': 'fivethirtyeight',
	    abcn: 'abcnews',
	};
	const DEFAULT_NETWORK = {
	    name: 'abc_news_live',
	    type: 'linear',
	};
	const preferredMediaContentTypes = ['HLS_ALL', 'PDL_MED', 'PDL_LOW'];
	function findPreferredMediaContent(mediaContents) {
	    var _a, _b;
	    const preferredMediaContentTypesLength = preferredMediaContentTypes.length;
	    const mediaContentsLength = mediaContents.length;
	    for (let i = 0; i < preferredMediaContentTypesLength; i++) {
	        const preferredMediaContentType = preferredMediaContentTypes[i];
	        for (let j = 0; j < mediaContentsLength; j++) {
	            const mediaContent = mediaContents[j];
	            if (((_b = (_a = mediaContent === null || mediaContent === void 0 ? void 0 : mediaContent['media-category']) === null || _a === void 0 ? void 0 : _a['@attributes']) === null || _b === void 0 ? void 0 : _b['label']) === preferredMediaContentType) {
	                return mediaContent;
	            }
	        }
	    }
	}
	function mediaItemFromItemFeed(_videoDataJSON) {
	    const videoData = _videoDataJSON || EMPTY_OBJ$2;
	    const channel = videoData.channel || EMPTY_OBJ$2;
	    const videoItem = channel.item || EMPTY_OBJ$2;
	    const mediaGroup = videoItem['media-group'] || EMPTY_OBJ$2;
	    const mediaContents = mediaGroup['media-content'] || EMPTY_ARY;
	    const mediaTitle = mediaGroup['media-title'];
	    const preferredMediaContent = findPreferredMediaContent(mediaContents) || EMPTY_OBJ$2;
	    const preferredMediaContentAttrs = preferredMediaContent['@attributes'] || EMPTY_OBJ$2;
	    const mediaThumbnail = mediaGroup['media-thumbnail'] || EMPTY_OBJ$2;
	    const mediaThumbnailAttrs = mediaThumbnail['@attributes'] || EMPTY_OBJ$2;
	    const { guid, title, temporalType, timestamp, link } = videoItem;
	    const { duration, url: streamURL, medium } = preferredMediaContentAttrs;
	    const omniture = videoItem.omniture || EMPTY_OBJ$2;
	    const omniChannel = omniture.channel || EMPTY_STR$2;
	    const [networkName = ABCN] = String(omniChannel).split(':');
	    const brand = BRAND_BY_CHANNEL_OR_NETWORK[omniChannel] || BRAND_BY_CHANNEL_OR_NETWORK[networkName] || ABCNEWS_BRAND;
	    const isVOD = temporalType === 'vod';
	    const isLive = temporalType === LIVE$u;
	    const entityType = ENTITY_TYPE_BY_VIDEO_CONTENT_TYPE[videoItem.videoContentType] || (isVOD ? 'shortform' : 'longform');
	    const videoTitle = mediaTitle || title;
	    const language = channel.language || 'en';
	    let publishedDate;
	    let publishedTime;
	    try {
	        [publishedDate, publishedTime] = new Date(timestamp).toISOString().split('T');
	    }
	    catch (err) {
	        console.warn(err);
	    }
	    const network = videoItem.mediatype === LINEAR_STREAM_TYPE && !isVOD ? Object.assign(Object.assign({}, DEFAULT_NETWORK), { id: guid }) : {};
	    const mediaItemData = {
	        id: guid,
	        apiSource: API_SOURCE,
	        seasonNumber: NOT_APPLICABLE,
	        eventId: NOT_APPLICABLE,
	        episodeNumber: NOT_APPLICABLE,
	        genre: NEWS,
	        tvrating: NOT_APPLICABLE,
	        network,
	        show: {
	            title: videoTitle,
	        },
	        title: videoTitle,
	        duration,
	        language,
	        source: {
	            url: streamURL,
	            type: NOT_APPLICABLE,
	        },
	        description: videoItem.description || mediaGroup['media-description'],
	        authenticationTypes: ['NONE'],
	        mrss: null,
	        seekInSeconds: null,
	        brand: brand,
	        type: medium === 'video' ? 'video' : 'audio',
	        entityType: entityType,
	        streamType: isLive ? LIVE$u : 'onDemand',
	        images: mediaThumbnailAttrs ? [{ url: mediaThumbnailAttrs.url }] : NULL,
	        airDate: videoItem.timestamp,
	        availableDate: videoItem.pubDate,
	        references: {
	            itemfeed: guid,
	        },
	        tracking: {
	            omniture: videoItem.omniture,
	            nielsen: {
	                type: 'content',
	                assetid: guid,
	                program: videoTitle,
	                title: videoTitle,
	            },
	            conviva: {
	                assetName: title,
	                duration,
	                streamURL,
	                custom: {
	                    contentId: guid,
	                    assetType: isVOD ? 'clip' : LIVE$u,
	                    sport: NOT_APPLICABLE,
	                    league: NOT_APPLICABLE,
	                    appBrand: videoItem.category || 'abcnews',
	                },
	            },
	            heartbeats: {
	                ContentDuration: duration,
	                isFullEpisode: entityType === 'shortform' || isLive ? 'n' : 'y',
	                VideoType: temporalType,
	                CMSID: videoTitle,
	                PublishDate: publishedDate,
	                PublishTime: publishedTime,
	            },
	        },
	        webHref: link,
	    };
	    const mediaItem = MediaItem$1.fromObject(mediaItemData);
	    return mediaItem;
	}

	var strictUriEncode =;

	var token = '%[a-f0-9]{2}';
	var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
	var multiMatcher = new RegExp('(' + token + ')+', 'gi');







	var decodeUriComponent =;

	var splitOnFirst =;

	var filterObj =;

	var queryString = createCommonjsModule(function (module, exports) {





	const isNullOrUndefined =;

	function encoderForArrayFormat(options) {
		switch (options.arrayFormat) {
			case 'index':
				return key => (result, value) => {
					const index = result.length;

					if (
						value === undefined ||
						(options.skipNull && value === null) ||
						(options.skipEmptyString && value === '')
					) {
						return result;
					}

					if (value === null) {
						return [...result, [encode(key, options), '[', index, ']'].join('')];
					}

					return [
						...result,
						[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')
					];
				};

			case 'bracket':
				return key => (result, value) => {
					if (
						value === undefined ||
						(options.skipNull && value === null) ||
						(options.skipEmptyString && value === '')
					) {
						return result;
					}

					if (value === null) {
						return [...result, [encode(key, options), '[]'].join('')];
					}

					return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
				};

			case 'comma':
			case 'separator':
				return key => (result, value) => {
					if (value === null || value === undefined || value.length === 0) {
						return result;
					}

					if (result.length === 0) {
						return [[encode(key, options), '=', encode(value, options)].join('')];
					}

					return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
				};

			default:
				return key => (result, value) => {
					if (
						value === undefined ||
						(options.skipNull && value === null) ||
						(options.skipEmptyString && value === '')
					) {
						return result;
					}

					if (value === null) {
						return [...result, encode(key, options)];
					}

					return [...result, [encode(key, options), '=', encode(value, options)].join('')];
				};
		}
	}

	function parserForArrayFormat(options) {
		let result;

		switch (options.arrayFormat) {
			case 'index':
				return;

			case 'bracket':
				return;

			case 'comma':
			case 'separator':
				return (key, value, accumulator) => {
					const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
					const isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));
					value = isEncodedArray ? decode(value, options) : value;
					const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map) : value === null ? value : decode(value, options);
					accumulator[key] = newValue;
				};

			default:
				return;
		}
	}

















	function parse(query, options) {
		options = Object.assign({
			decode: true,
			sort: true,
			arrayFormat: 'none',
			arrayFormatSeparator: ',',
			parseNumbers: false,
			parseBooleans: false
		}, options);

		validateArrayFormatSeparator(options.arrayFormatSeparator);

		const formatter = parserForArrayFormat(options);

		// Create an object with no prototype
		const ret = Object.create(null);

		if (typeof query !== 'string') {
			return ret;
		}

		query = query.trim().replace(/^[?#&]/, '');

		if (!query) {
			return ret;
		}

		for (const param of query.split('&')) {
			if (param === '') {
				continue;
			}

			let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');

			// Missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
			formatter(decode(key, options), value, ret);
		}

		for (const key of Object.keys(ret)) {
			const value = ret[key];
			if (typeof value === 'object' && value !== null) {
				for (const k of Object.keys(value)) {
					value[k] = parseValue(value[k], options);
				}
			} else {
				ret[key] = parseValue(value, options);
			}
		}

		if (options.sort === false) {
			return ret;
		}

		return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce, Object.create(null));
	}

	exports.extract = extract;
	exports.parse = parse;

	exports.stringify = (object, options) => {
		if (!object) {
			return '';
		}

		options = Object.assign({
			encode: true,
			strict: true,
			arrayFormat: 'none',
			arrayFormatSeparator: ','
		}, options);

		validateArrayFormatSeparator(options.arrayFormatSeparator);

		const shouldFilter =;

		const formatter = encoderForArrayFormat(options);

		const objectCopy = {};

		for (const key of Object.keys(object)) {
			if (!shouldFilter(key)) {
				objectCopy[key] = object[key];
			}
		}

		const keys = Object.keys(objectCopy);

		if (options.sort !== false) {
			keys.sort(options.sort);
		}

		return keys.map(key => {
			const value = object[key];

			if (value === undefined) {
				return '';
			}

			if (value === null) {
				return encode(key, options);
			}

			if (Array.isArray(value)) {
				return value
					.reduce(formatter(key), [])
					.join('&');
			}

			return encode(key, options) + '=' + encode(value, options);
		}).filter).join('&');
	};

	exports.parseUrl = (url, options) => {
		options = Object.assign({
			decode: true
		}, options);

		const [url_, hash] = splitOnFirst(url, '#');

		return Object.assign(
			{
				url: url_.split('?')[0] || '',
				query: parse(extract(url), options)
			},
			options && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}
		);
	};

	exports.stringifyUrl = (object, options) => {
		options = Object.assign({
			encode: true,
			strict: true
		}, options);

		const url = removeHash(object.url).split('?')[0] || '';
		const queryFromUrl = exports.extract(object.url);
		const parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});

		const query = Object.assign(parsedQueryFromUrl, object.query);
		let queryString = exports.stringify(query, options);
		if (queryString) {
			queryString = `?${queryString}`;
		}

		let hash = getHash(object.url);
		if (object.fragmentIdentifier) {
			hash = `#${encode(object.fragmentIdentifier, options)}`;
		}

		return `${url}${queryString}${hash}`;
	};

	exports.pick = (input, filter, options) => {
		options = Object.assign({
			parseFragmentIdentifier: true
		}, options);

		const {url, query, fragmentIdentifier} = exports.parseUrl(input, options);
		return exports.stringifyUrl({
			url,
			query: filterObj(query, filter),
			fragmentIdentifier
		}, options);
	};

	exports.exclude =;
	});
	queryString.extract;
	queryString.parse;
	queryString.stringify;
	queryString.parseUrl;
	queryString.stringifyUrl;
	queryString.pick;
	queryString.exclude;

	class ItemFeedMediaItemAPI {
	   
	    get configuration() {
	        return this.configuration_;
	    }
	    set configuration(configuration) {
	        this.configuration_ = configuration;
	    }
	   
	    static fetchMediaItems(identifiers, options, configuration) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const ids = identifiers.map);
	            const { serviceUrl } = configuration;
	            const promiseMediaItems = yield Promise.all(ids.map));
	            return promiseMediaItems.filter);
	        });
	    }
	    static getPromiseMediaItem(identifier, serviceUrl) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const params = queryString.stringify({
	                id: identifier.id || identifier.channel,
	            });
	            try {
	                const response = yield fetch(`${serviceUrl}?${params}&requester=guardians`);
	                const json = yield response.json();
	                const mediaItem = mediaItemFromItemFeed(json);
	                return mediaItem;
	            }
	            catch (error) {
	                loglevel.warn(`Failed to retrieve MediaItem from ItemFeed endpoint: ${error}`);
	                return null;
	            }
	        });
	    }
	}
	ItemFeedMediaItemAPI.defaultConfiguration = new Configuration$8(ApiSource$d.itemFeed);

	class UniversalMediaItemAPI {
	    get configuration() {
	        return this.configuration_;
	    }
	    set configuration(configuration) {
	        this.configuration_ = configuration;
	    }
	   
	    getMediaItemsFromIdentifier_(identifier, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const api = this.getMediaItemAPIClass_(identifier, options === null || options === void 0 ? void 0 : options.apiSource);
	            api.configuration = this.configuration instanceof Configuration$8 ? this.configuration : api.configuration;
	            try {
	                const mediaItems = yield api.getMediaItems([identifier], options);
	                return (Array.isArray(mediaItems) && mediaItems[0]) || null;
	            }
	            catch (err) {
	                console.error('UniversalMediaItemAPI getMediaItems error: ', err);
	            }
	            return null;
	        });
	    }
	    getMediaItemAPIClass_(identifier, apiSource) {
	        switch (true) {
	            case apiSource === ApiSource$d.cfa:
	                return new CFAMediaItemAPI();
	            case identifier.indexOf('abcnews') === 0:
	                return new ItemFeedMediaItemAPI();
	            default:
	                return new GraphQLMediaItemAPI();
	        }
	    }
	}

	const PLAYER_TYPE = {
	  videoPlayer: 'videoPlayer',
	  imaAdPlayer: 'imaAdPlayer'
	};
	const CUSTOM_EVENTS = {
	  FETCH_MEDIA_ITEM: 'FETCH_MEDIA_ITEM',
	  FETCH_MEDIA_ITEM_FINISHED: 'FETCH_MEDIA_ITEM_FINISHED',
	  FETCH_APP_CONFIG: 'FETCH_APP_CONFIG',
	  FETCH_APP_CONFIG_FINISHED: 'FETCH_APP_CONFIG_FINISHED',
	  PLAYER_LOAD_COMPLETE: 'PLAYER_LOAD_COMPLETE'
	};
	const ERRORS = {
	  STREAM_LIMITED: 'STREAM_LIMITED',
	  DRM_REQUIRED: 'DRM_REQUIRED',
	  MEDIA_ERR_CUSTOM: 'MEDIA_ERR_CUSTOM',
	  MEDIA_ERR_ABORTED: 'MEDIA_ERR_ABORTED',
	  MEDIA_ERR_NETWORK: 'MEDIA_ERR_NETWORK',
	  MEDIA_ERR_DECODE: 'MEDIA_ERR_DECODE',
	  MEDIA_ERR_SRC_NOT_SUPPORTED: 'MEDIA_ERR_SRC_NOT_SUPPORTED',
	  MEDIA_ERR_ENCRYPTED: 'MEDIA_ERR_ENCRYPTED',
	  MEDIA_INTERNAL_PLAYER_ERR: 'MEDIA_INTERNAL_PLAYER_ERR',
	  FAILED_TO_FETCH: 'failed to fetch'
	};
	const FATAL_ERRORS_LIST = [ERRORS.STREAM_LIMITED, ERRORS.MEDIA_ERR_CUSTOM, ERRORS.MEDIA_ERR_ABORTED, ERRORS.MEDIA_ERR_NETWORK, ERRORS.MEDIA_ERR_DECODE, ERRORS.MEDIA_ERR_SRC_NOT_SUPPORTED, ERRORS.MEDIA_ERR_ENCRYPTED];
	const AUTOPLAY_ALLOW_TYPE = {
	  MUTED: 'autoplay.muted.allowed',
	  UNMUTED: 'autoplay.unmuted.allowed',
	  BLOCKED: 'autoplay.blocked'
	};
	const NETWORK_ERROR_MSG = 'The video connection was lost, please confirm you are connected to the internet';
	const STREAM_LIMIT_ERROR_MSG = 'Youâre already playing the maximum number of streams allowed.';
	const CONCURRENCY_LIMIT_MSG = 'no more than 5 streams.';
	const NETWORK_ERROR_CONNECTION = 'The media could not be loaded, either because the server or network failed or because the format is not supported.';
	const STREAM_LIMIT_ERROR_CODE = -7;
	const RETRIES_LIMIT = 3;
	const VIDEO_SEEK_STEP = 10;
	const AUDIO_SEEK_STEP = 15;

	// all values will transformed to lower case eventually
	// camelCase here is just for readability
	const CONTROL_BAR_COMPONENT_NAMES = {
	  PLAY_TOGGLE: 'playToggle',
	  VOLUME_PANEL: 'volumePanel',
	  FAST_FORWARD: 'fastForward',
	  REWIND: 'rewind',
	  CURRENT_TIMER_DISPLAY: 'currentTimeDisplay',
	  TIME_DIVIDER: 'timeDivider',
	  DURATION_DISPLAY: 'durationDisplay',
	  PROGRESS_CONTROL: 'progressControl',
	  LIVE_DISPLAY: 'liveDisplay',
	  SEEK_TO_LIVE: 'seekToLive',
	  REMAINING_TIME_DISPLAY: 'remainingTimeDisplay',
	  CUSTOM_CONTROL_SPACER: 'customControlSpacer',
	  PLAYBACK_RATE_MENU_BUTTON: 'playbackRateMenuButton',
	  CHAPTERS_BUTTON: 'chaptersButton',
	  DESCRIPTIONS_BUTTON: 'descriptionsButton',
	  SUBS_CAPS_BUTTON: 'subsCapsButton',
	  AUDIO_TRACK_BUTTON: 'audioTrackButton',
	  PICTURE_IN_PICTURE_TOGGLE: 'pictureInPictureToggle',
	  SOCIAL_BUTTON: 'socialButton',
	  BRANDED_SOCIAL_BUTTON: 'brandedSocialButton',
	  CAPTION_TOGGLE_BUTTON: 'captionToggleButton',
	  SETTINGS_MENU_BUTTON: 'settingsMenuButton',
	  BRANDED_SETTINGS_MENU_BUTTON: 'BrandedSettingsMenuButton',
	  STREAM_PICKER_BUTTON: 'StreamPickerButton',
	  FULLSCREEN_TOGGLE: 'fullscreenToggle'
	};
	const PLAYER_CONFIG_URL_QA = 'https://api.config.watchabc.go.com/appsconfig/qa/js-mmp-espn/001/1.0.0/config.json';
	const PLAYER_CONFIG_URL_PROD = 'https://api.config.watchabc.go.com/appsconfig/prod/js-mmp-espn/001/1.0.0/config.json';
	const SHOW_CUSTOM_ERROR_CONTENT_EVENT = 'showCustomErrorContent';
	const SET_CUSTOM_ERROR_MESSAGES_EVENT = 'setCustomErrorMessages';
	const ENDCARD_TIMINGS = {
	  // in seconds
	  shortform: {
	    remaining: 5,
	    // how far off to show the endcard
	    countdown: 5 // endcard countdown
	  },

	  longform: {
	    remaining: 30,
	    countdown: 30
	  }
	};
	const PLAYER_START_TYPE = {
	  AUTOSTART: 'autostart',
	  MANUAL: 'manual',
	  ENDCARD_AUTOSTART: 'endcard_continuous',
	  ENDCARD_MANUAL: 'manual:endcard_continuous'
	};

	/*
	  UA-sniffing code borrowed from VideoJS
	  https://github.com/videojs/video.js/blob/master/src/js/utils/browser.js
	*/
	const USER_AGENT = typeof window !== 'undefined' && window.navigator && window.navigator.userAgent || '';
	const APP_VERSION = typeof window !== 'undefined' && window.navigator && window.navigator.appVersion || '';
	let platform = null;
	if (typeof window !== 'undefined' && window.navigator && window.navigator.userAgentData && window.navigator.userAgentData.platform) {
	  platform = window.navigator.userAgentData.platform;
	} else if (typeof window !== 'undefined' && window.navigator && window.navigator.platform) {
	  platform = window.navigator.platform;
	}
	const PLATFORM = platform;
	const IS_EDGE = /Edge/i.test(USER_AGENT);
	const IS_EDGE_CHROMIUM = /edg/i.test(USER_AGENT);
	const IS_CHROME = !IS_EDGE && /Chrome/i.test(USER_AGENT);
	const IS_ANDROID = /Android/i.test(USER_AGENT);
	const IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
	IS_SAFARI && /Version\/11/i.test(USER_AGENT);
	const IS_IPAD = PLATFORM === 'MacIntel' && window.navigator.maxTouchPoints > 0 || PLATFORM === 'iPad' || /iPad/i.test(USER_AGENT);
	const IS_WINDOWS = /Win/i.test(APP_VERSION);

	// The Facebook app's UIWebView identifies as both an iPhone and iPad, so
	// to identify iPhones, we need to exclude iPads.
	// http://artsy.github.io/blog/2012/10/18/the-perils-of-ios-user-agent-sniffing/
	const IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
	const IS_IPOD = /iPod/i.test(USER_AGENT);
	const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
	const IOS_VERSION = function IOS_VERSION() {
	  const match = USER_AGENT.match(/OS (\d+)_/i);
	  if (match && match[1]) {
	    return match[1];
	  }
	  return null;
	}();
	const IS_FIREFOX = /Firefox/i.test(USER_AGENT);
	const IS_OPERA = /Opera/i.test(USER_AGENT);

	// Detect tablet by looking for "mobile" in UA string
	// https://webmasters.googleblog.com/2011/03/mo-better-to-also-detect-mobile-user.html
	// Note, this may not be reliable as few Android vendors follow the spec.
	const IS_TABLET = IS_IPAD || IS_ANDROID && !/mobile/i.test(USER_AGENT);
	const IS_MOBILE = !IS_TABLET && (IS_IOS || IS_ANDROID);
	const IE_VERSION = function IE_VERSION() {
	  const result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
	  let version = result && parseFloat(result[1]);
	  if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) {
	    // IE 11 has a different user agent string than other IE versions
	    version = 11.0;
	  }
	  return version;
	}();
	const SUPPORTS_EME = typeof window !== 'undefined' && ('MediaKeys' in window || 'WebKitMediaKeys' in window || 'MSMediaKeys' in window);

	// https://stackoverflow.com/a/37705154, WebView will not contain `Safari`
	// Should match:
	// Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148
	const IS_IOS_WEBVIEW = IS_IOS && !IS_SAFARI;

	// https://developer.chrome.com/multidevice/user-agent#webview_user_agent
	// Should match:
	// Mozilla/5.0 (Linux; Android 9; Pixel 2 Build/PQ1A.190105.004; wv)
	// AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/70.0.3538.64 Mobile Safari/537.36
	const IS_ANDROID_WEBVIEW = IS_ANDROID && /wv/i.test(USER_AGENT);
	const IS_WEBVIEW = /WebView/i.test(USER_AGENT) || IS_IOS_WEBVIEW || IS_ANDROID_WEBVIEW;

	class NewRelicService extends NewRelicFactory {
	  constructor() {
	    super();
	    this.player_ = null;
	    this.session_ = null;
	    this.videoElm_ = null;
	    this.videoElmSrc_ = null;
	    this.adStartDuration_ = 0;
	    this.adProgress_ = 0;
	    this.isPrerollAds_ = false;
	    this.hasTrackedOnLoopingAds_ = false;
	    this.adapterConfigs_ = {};
	    this.wasMuted = false;
	    this.isHandledError = false;
	    this.stats = {
	      instantiatedTimeStamp: undefined,
	      loadedTimeStamp: undefined,
	      startedTimeStamp: undefined,
	      finishedTimeStamp: undefined
	    };
	    this.isSeeking = false;
	    this.isBuffering = false;
	    this.isRecoverableError_ = false;
	  }
	  set isRecoverableError(v) {
	    this.isRecoverableError_ = v;
	  }
	  get isRecoverableError() {
	    return this.isRecoverableError_;
	  }
	  setPlayer(player) {
	    this.player_ = player;
	  }
 }
	  setPlaybackSession(playbackSession) {
	    if (playbackSession) {
	      this.session_ = {
	        playbackUrl: playbackSession.playbackUrl,
	        playbackConfig: playbackSession.playbackConfig
	      };
	    } else {
	      this.session_ = null;
	    }
	  }
	  start(coordinator) {
	    this.wasMuted = this.player_.muted() || !this.player_.volume();
	    this.coordinator = coordinator;
	    this.isHandledError = false;
	    this.stats.instantiatedTimeStamp = Date.now();
	    this.enabled_ = true;
	    this.bindPlayerEvents_();
	  }
	  bindPlayerEvents_() {
	    this.onEmbedded = this.onEmbedded.bind(this);
	    this.onLoadeddata_ = this.onLoadeddata_.bind(this);
	    this.onConfigFetch_ = this.onConfigFetch_.bind(this);
	    this.onConfigFetched = this.onConfigFetched.bind(this);
	    this.onMediaItemFetch_ = this.onMediaItemFetch_.bind(this);
	    this.onMediaItemFetched = this.onMediaItemFetched.bind(this);
	    this.onAdsStarted_ = this.onAdsStarted_.bind(this);
	    this.onAdEnd_ = this.onAdEnd_.bind(this);
	    this.onAllAdsCompleted = this.onAllAdsCompleted.bind(this);
	    this.onAdsError_ = this.onAdsError_.bind(this);
	    this.onPlay_ = this.onPlay_.bind(this);
	    this.onContentplayback_ = this.onContentplayback_.bind(this);
	    this.onPlaying_ = this.onPlaying_.bind(this);
	    this.onPause_ = this.onPause_.bind(this);
	    this.onSeeking_ = this.onSeeking_.bind(this);
	    this.onSeeked_ = this.onSeeked_.bind(this);
	    this.onEnded_ = this.onEnded_.bind(this);
	    this.onVolumeChanged_ = this.onVolumeChanged_.bind(this);
	    this.onCaptionToggled = this.onCaptionToggled.bind(this);
	    this.onBuffering_ = this.onBuffering_.bind(this);
	    this.dispose_ = this.dispose_.bind(this);
	    this.coordinator.addEventListener('dtci.embedded', this.onEmbedded);
	    this.coordinator.addEventListener(CUSTOM_EVENTS.PLAYER_LOAD_COMPLETE, this.onLoadeddata_);
	    this.coordinator.addEventListener(CUSTOM_EVENTS.FETCH_APP_CONFIG, this.onConfigFetch_);
	    this.coordinator.addEventListener(CUSTOM_EVENTS.FETCH_APP_CONFIG_FINISHED, this.onConfigFetched);
	    this.coordinator.addEventListener(CUSTOM_EVENTS.FETCH_MEDIA_ITEM, this.onMediaItemFetch_);
	    this.coordinator.addEventListener(CUSTOM_EVENTS.FETCH_MEDIA_ITEM_FINISHED, this.onMediaItemFetched);
	    this.player_.on('adstart', this.onAdsStarted_);
	    this.player_.on('adend', this.onAdEnd_);
	    this.player_.on('ads-allpods-completed', this.onAllAdsCompleted);
	    this.player_.on('adserror', this.onAdsError_);
	    this.player_.on('dtci.play', this.onPlay_);
	    this.player_.on('contentplayback', this.onContentplayback_);
	    this.player_.on('playing', this.onPlaying_);
	    this.player_.on('pause', this.onPause_);
	    this.player_.on('seeking', this.onSeeking_);
	    this.player_.on('seeked', this.onSeeked_);
	    this.player_.on('ended', this.onEnded_);
	    this.player_.on('volumechange', this.onVolumeChanged_);
	    this.player_.on('dtci.caption.toggled', this.onCaptionToggled);
	    this.player_.on('waiting', this.onBuffering_);
	    this.player_.on('dispose', this.dispose_);
	  }
	  onEmbedded() {
	    super.onEmbedded();
	    this.videoElm_ = this.getVideoEL_();
	  }
	  onLoadeddata_() {
	    this.addCrumb(BREADCRUMBS.MP_L);
	    this.stats.loadedTimeStamp = Date.now();
	  }
	  onAdsStarted_() {
	    var _this$player_, _this$player_$ads;
	    this.addCrumb(BREADCRUMBS.MP_A_S);
	    this.currentAd_ = this.currentAd_ || this.getCurrentAd_();
	    this.videoElm_ = this.videoElm_ || this.getVideoEL_();
	    if (this.videoElm_) {
	      var _this$videoElm_;
	      this.videoElmSrc_ = (_this$videoElm_ = this.videoElm_) === null || _this$videoElm_ === void 0 ? void 0 : _this$videoElm_.src;
	    }
	    const currentTime = this.getPlayerCurrentTime_();
	    this.adType_ = typeof ((_this$player_ = this.player_) === null || _this$player_ === void 0 ? void 0 : (_this$player_$ads = _this$player_.ads) === null || _this$player_$ads === void 0 ? void 0 : _this$player_$ads.adType) === 'string' && this.player_.ads.adType.toLowerCase();
	    this.isPrerollAds_ = this.adType_ === 'preroll' || this.adType_ === 'midroll' && currentTime <= this.adProgress_;
	    this.adStartDuration_ = this.getCurrentAdDuration_(this.currentAd_);
	  }
	  getVideoEL_() {
	    if (this.player_) {
	      var _this$player_2, _this$player_2$el_;
	      const videoEl = (_this$player_2 = this.player_) === null || _this$player_2 === void 0 ? void 0 : (_this$player_2$el_ = _this$player_2.el_) === null || _this$player_2$el_ === void 0 ? void 0 : _this$player_2$el_.getElementsByTagName('video');
	      return videoEl && videoEl[0];
	    }
	    return null;
	  }
	  getCurrentAdDuration_(currentAd) {
	    let adsDuration = 0;
	    if (typeof (currentAd === null || currentAd === void 0 ? void 0 : currentAd.getDuration) === 'function') {
	      adsDuration = Math.round(currentAd.getDuration());
	    }
	    return adsDuration;
	  }
	  getCurrentAd_() {
	    const {
	      player_: {
	        ima
	      }
	    } = this;
	    if (typeof (ima === null || ima === void 0 ? void 0 : ima.getAdsManager) === 'function') {
	      const adsManager = ima.getAdsManager();
	      if (typeof (adsManager === null || adsManager === void 0 ? void 0 : adsManager.getCurrentAd) === 'function') {
	        return adsManager.getCurrentAd();
	      }
	    }
	    return null;
	  }
	  onAdEnd_() {
	    this.addCrumb(BREADCRUMBS.MP_A_E);
	    // on 'adend' event, player is done playing the ads for the duration of the ad from 'adstart' event
	    // when this.adProgress_ > 0, that means user is done watching one preroll ads
	    this.adProgress_ += this.adStartDuration_;

	    // if this.adProgress_ is equal to or greater than twice of this.adStartDuration_, midroll ads started
	    // reset this.adProgress_ since we only want to track preroll ads looping issue
	    if (this.adProgress_ >= this.adStartDuration_ * 2) {
	      this.adProgress_ = 0;
	    }
	  }
	  onAllAdsCompleted() {
	    this.addCrumb(BREADCRUMBS.MP_A_CO);
	  }
 }
	  onPlay_() {
	    super.onPlay_();
	    if (this.videoElm_) {
	      var _this$videoElm_2;
	      this.videoElmSrc_ = (_this$videoElm_2 = this.videoElm_) === null || _this$videoElm_2 === void 0 ? void 0 : _this$videoElm_2.src;
	    }
	  }
	  onContentplayback_() {
	    if (this.isInAdBreak_() && this.isPrerollAdsLooping_()) {
	      this.addCrumb(BREADCRUMBS.MP_A_F);
	      const error = this.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_MEDIA_ERR_SRC_NOT_SUPPORTED, 'Preroll ads looping');
	      this.mediaPlayerFlowEvent({
	        additionalData: {
	          prerollAdsLooping: true,
	          adProgress: this.adProgress_,
	          adsDuration: this.adStartDuration_,
	          adType: this.adType_,
	          'player.progress': this.getPlayerCurrentTime_()
	        }
	      }, error);
	      this.hasTrackedOnLoopingAds_ = true;
	    } else {
	      // if content playback started, that means looping ads is not happening, so we need to reset this.adProgress
	      // to ensure not counting additional preroll ads duration when clients don't dispose the player on content ended
	      this.adProgress = 0;
	    }
	  }
	  isInAdBreak_() {
	    var _this$player_3, _this$player_3$ads;
	    return typeof ((_this$player_3 = this.player_) === null || _this$player_3 === void 0 ? void 0 : (_this$player_3$ads = _this$player_3.ads) === null || _this$player_3$ads === void 0 ? void 0 : _this$player_3$ads.inAdBreak) === 'function' && !this.player_.ads.inAdBreak();
	  }
	  isPrerollAdsLooping_() {
	    return IS_IPHONE && !this.hasTrackedOnLoopingAds_ && this.isPrerollAds_ && this.adProgress_ > 0 && this.isPrerollAdsURL_(this.videoElmSrc_);
	  }
	  isPrerollAdsURL_(src) {
	    // only native player updates the video tag source url. On VHS or Dash player, it doesn't include player source url
	    if (src) {
	      return !includes(src).call(src, 'uplynk.com') && !includes(src).call(src, 'akamaized.net');
	    }
	    return false;
	  }
	  onPlaying_() {
	    this.addCrumb(BREADCRUMBS.MP_S);
	    if (this.videoElm_) {
	      var _this$videoElm_3;
	      this.videoElmSrc_ = (_this$videoElm_3 = this.videoElm_) === null || _this$videoElm_3 === void 0 ? void 0 : _this$videoElm_3.src;
	    }
	  }
 }
	  onSeek }
	  onEnded_() {
	    /**
	     * If this.hasTrackedOnLoopingAds_ is true, that means it had preroll ads looping issue,
	     * and we sent the tracking during onContentplayback_ event, so we don't need to sent it onEnded_
	     */
	    if (!this.hasTrackedOnLoopingAds_) {
	      this.addCrumb(BREADCRUMBS.MP_C_C);
	      this.stats.finishedTimeStamp = Date.now();
	      const message = 'playback session success';
	      this.playbackSessionFlowEvent(this.generatePlaybackSuccess(REASONS.PLAYBACK_COMPLETED, message), null);
	    }
	    this.dispose_();
	  }
	  onVolumeChanged_(e) {
	    const {
	      player
	    } = e.target;
	    const isVolumeMuted = player.muted() || !player.volume();
	    if (this.wasMuted !== isVolumeMuted) {
	      if (isVolumeMuted) {
	        this.addCrumb(BREADCRUMBS.MP_V_M);
	      } else {
	        this.addCrumb(BREADCRUMBS.MP_V_U);
	      }
	      this.wasMuted = !this.wasMuted;
	    }
	  }
	  onCaptionToggled(event, data) {
	    super.onCaptionToggled_(data.caption === 'enabled');
	  }
	  onBuffering_() {
	    if (!this.isSeeking) {
	      this.isBuffering = !this.isBuffering;
	      if (this.isBuffering) {
	        this.addCrumb(BREADCRUMBS.MP_S_S);
	      } else {
	        this.addCrumb(BREADCRUMBS.MP_S_E);
	      }
	    }
	  }
	  trackError(error) {
	    const {
	      code,
	      message
	    } = error || {};
	    if (!this.isHandledError && !this.isRecoverableError) {
	      const errorException = this.generatePlayerBundleUnexpectedError(code, message);
	      this.mediaPlayerFlowEvent({}, errorException);

	      // reset preroll ads var to prevent ads looping issue being tracked if user clicks on retry button
	      this.isPrerollAds_ = false;
	      this.adProgress_ = 0;
	      this.isHandledError = true;
	    }
	  }
	  dispose_() {
	    super.onDisposed();
	    this.isHandledError = false;
	    if (this.coordinator) {
	      this.coordinator.removeEventListener('dtci.embedded', this.onEmbedded);
	      this.coordinator.removeEventListener(CUSTOM_EVENTS.PLAYER_LOAD_COMPLETE, this.onLoadeddata_);
	      this.coordinator.removeEventListener(CUSTOM_EVENTS.FETCH_APP_CONFIG, this.onConfigFetch_);
	      this.coordinator.removeEventListener(CUSTOM_EVENTS.FETCH_APP_CONFIG_FINISHED, this.onConfigFetched);
	      this.coordinator.removeEventListener(CUSTOM_EVENTS.FETCH_MEDIA_ITEM, this.onMediaItemFetch_);
	      this.coordinator.removeEventListener(CUSTOM_EVENTS.FETCH_MEDIA_ITEM_FINISHED, this.onMediaItemFetched);
	    }
	    if (this.player_) {
	      this.player_.off('adstart', this.onAdsStarted_);
	      this.player_.off('adend', this.onAdEnd_);
	      this.player_.off('ads-allpods-completed', this.onAllAdsCompleted);
	      this.player_.off('adserror', this.onAdsError_);
	      this.player_.off('contentplayback', this.onContentplayback_);
	      this.player_.off('dtci.play', this.onPlay_);
	      this.player_.off('playing', this.onPlaying_);
	      this.player_.off('pause', this.onPause_);
	      this.player_.off('seeking', this.onSeeking_);
	      this.player_.off('seeked', this.onSeeked_);
	      this.player_.off('ended', this.onEnded_);
	      this.player_.off('volumechange', this.onVolumeChanged_);
	      this.player_.off('dtci.caption.toggled', this.onCaptionToggled);
	      this.player_.off('waiting', this.onBuffering_);
	      this.player_.off('dispose', this.dispose_);
	      this.player_ = null;
	    }
	    this.enabled_ = false;
	  }
	  playerBundleEvent(data, errorExceptionEvent) {
	    if (!this.enabled_) return;
	    this.sendEvent({
	      eventType: 'webPlayerBundlePlayback',
	      name: 'PlayerBundleEvent',
	      videoTagSrc: this.videoElmSrc_,
	      adProgress: this.adProgress_,
	      adsDuration: this.adStartDuration_,
	      'player.progress': this.getPlayerCurrentTime_(),
	      trail: data.breadcrumbs,
	      ...data.additionalData
	    }, errorExceptionEvent);
	  }
	  playbackAuthenticationFlowEvent(data, errorExceptionEvent) {
	    if (!this.enabled_) return;
	    let {
	      authN
	    } = data;
	    if (!authN) authN = this.adapterConfigs_.authorizationPayload;
	    this.sendEvent({
	      eventType: 'webPlayerBundlePlayback',
	      name: 'PlaybackAuthenticationFlow',
	      videoTagSrc: this.videoElmSrc_,
	      adProgress: this.adProgress_,
	      adsDuration: this.adStartDuration_,
	      'player.progress': this.getPlayerCurrentTime_(),
	      'authentication.type': authN ? authN.authenticationType : undefined,
	      'authentication.provider': authN && authN.authenticatedProvider ? authN.authenticatedProvider.id : undefined,
	      trail: data.breadcrumbs,
	      ...data.additionalData
	    }, errorExceptionEvent);
	  }
	  mediaItemFlowEvent(data, errorExceptionEvent) {
	    if (!this.enabled_) return;
	    this.sendEvent({
	      eventType: 'webPlayerBundlePlayback',
	      name: 'MediaItemFlow',
	      videoTagSrc: this.videoElmSrc_,
	      adProgress: this.adProgress_,
	      adsDuration: this.adStartDuration_,
	      'player.progress': this.getPlayerCurrentTime_(),
	      ...this.mediaItemFlowEventSpecific_(data.mediaItem),
	      trail: data.breadcrumbs,
	      ...data.additionalData
	    }, errorExceptionEvent);
	  }
	  playbackAccessFlowEvent(data, errorExceptionEvent) {
	    if (!this.enabled_) return;
	    this.sendEvent({
	      eventType: 'webPlayerBundlePlayback',
	      name: 'PlaybackAccessFlow',
	      videoTagSrc: this.videoElmSrc_,
	      adProgress: this.adProgress_,
	      'player.progress': this.getPlayerCurrentTime_(),
	      ...this.mediaItemFlowEventSpecific_(data.mediaItem),
	      ...this.playbackAccessFlowEventSpecific_(data.payloadOrBAM),
	      trail: data.breadcrumbs,
	      ...data.additionalData
	    }, errorExceptionEvent);
	  }
	  playbackSessionFlowEvent(data, errorExceptionEvent) {
	    if (!this.enabled_) return;
	    this.sendEvent({
	      eventType: 'webPlayerBundlePlayback',
	      name: 'PlaybackSessionFlow',
	      videoTagSrc: this.videoElmSrc_,
	      adProgress: this.adProgress_,
	      adsDuration: this.adStartDuration_,
	      'player.progress': this.getPlayerCurrentTime_(),
	      ...this.mediaItemFlowEventSpecific_(data.mediaItem),
	      ...this.playbackAccessFlowEventSpecific_(data.payloadOrBAM),
	      ...this.playbackSessionFlowEventSpecific_(data.session),
	      trail: data.breadcrumbs,
	      ...data.additionalData
	    }, errorExceptionEvent);
	  }
	  mediaPlayerFlowEvent(data, errorExceptionEvent) {
	    if (!this.enabled_) return;
	    this.sendEvent({
	      eventType: 'webPlayerBundlePlayback',
	      name: 'MediaPlayerFlow',
	      videoTagSrc: this.videoElmSrc_,
	      adProgress: this.adProgress_,
	      adsDuration: this.adStartDuration_,
	      'player.progress': this.getPlayerCurrentTime_(),
	      ...this.mediaItemFlowEventSpecific_(data.mediaItem),
	      ...this.playbackAccessFlowEventSpecific_(data.payloadOrBAM),
	      ...this.playbackSessionFlowEventSpecific_(data.session),
	      ...this.mediaPlayerFlowEventSpecific_(),
	      trail: data.breadcrumbs,
	      ...data.additionalData
	    }, errorExceptionEvent);
	  }
	  getPlayerCurrentTime_() {
	    var _this$player_4;
	    if (typeof ((_this$player_4 = this.player_) === null || _this$player_4 === void 0 ? void 0 : _this$player_4.currentTime) === 'function') {
	      return Math.round(this.player_.currentTime());
	    }
	    return 0;
	  }
	  isErrorException(err) {
	    if (err instanceof ErrorExceptionEvent) {
	      this.isHandledError = true;
	      return true;
	    }
	    return false;
	  }
	  parseAndSendPlaybackSessionError(mediaItem, err) {
	    let errorException = err;
	    if (!this.isErrorException(err)) {
	      const reasonsAccess = ['missingMediaSourceType', 'notAuthorized'];
	      const errorExceptionReasonsMap = {
	        concurrencyInitializationFailed: REASONS_NAMES$1[REASONS$1.CONCURRENCY_LIMIT_REACHED],
	        missingMediaSourceType: REASONS_NAMES$1[REASONS$1.DAMAGED_MEDIA_DATA],
	        notAuthorized: REASONS_NAMES$1[REASONS$1.NOT_ENTITLED],
	        noAuthButler: REASONS_NAMES$1[REASONS$1.DAMAGED_MEDIA_DATA],
	        noShieldFetchAPI: REASONS_NAMES$1[REASONS$1.DAMAGED_MEDIA_DATA],
	        startSessionFetchFailed: REASONS_NAMES$1[REASONS$1.INVALID_MEDIA],
	        entitlementFetchFailed: REASONS_NAMES$1[REASONS$1.INVALID_MEDIA],
	        shieldFetchFailed: REASONS_NAMES$1[REASONS$1.INVALID_MEDIA]
	      };
	      const featuresSession = {
	        [MediaItemSourceType$a.shield]: FEATURES$1.SHIELD,
	        [MediaItemSourceType$a.startSession]: FEATURES$1.SHIELD,
	        [MediaItemSourceType$a.none]: FEATURES$1.SHIELD,
	        [MediaItemSourceType$a.entitlement]: FEATURES$1.ENTITLEMENT
	      };
	      let errorReason = this.getErrorReason() || '';
	      let component = COMPONENTS$1.PLAYBACK_ACCESS;
	      let feature = FEATURES$1.PLAYBACK_ACCESS_MANAGER;
	      const isAccessFlowError = includes(reasonsAccess).call(reasonsAccess, errorReason);
	      if (isAccessFlowError) {
	        component = COMPONENTS$1.PLAYBACK_SESSION;
	        feature = FEATURES$1.SHIELD;
	        if (mediaItem && mediaItem.source && mediaItem.source.type && featuresSession[mediaItem.source.type]) {
	          feature = featuresSession[mediaItem.source.type];
	        }
	      }
	      errorReason = errorExceptionReasonsMap[errorReason] || REASONS_NAMES$1[REASONS$1.UNEXPECTED_ERROR];
	      errorException = ErrorExceptionService[errorReason]({
	        segment: SEGMENTS$1.PLAYER_CORE,
	        component,
	        feature,
	        errorCode: ERROR_CODES.PLAYER_UNKNOWN,
	        message: 'playback session failed',
	        cause: err
	      });
	      if (isAccessFlowError) {
	        this.playbackAccessFlowEvent({}, errorException);
	      } else {
	        this.playbackSessionFlowEvent({}, errorException);
	      }
	    }
	  }
	  generatePlayerBundleUnexpectedError(errorCode, message, cause) {
	    return ErrorExceptionService.unexpectedError({
	      segment: SEGMENTS$1.PLAYER_CORE,
	      component: COMPONENTS$1.MEDIA_PLAYER,
	      feature: FEATURES$1.PLAYER_ADAPTER_BUNDLE,
	      errorCode,
	      message,
	      cause
	    });
	  }
 }
 }
 }
 }
 }
 }
 }
 }
	  mediaPlayerFlowEventSpecific_() {
	    const {
	      player_
	    } = this;
	    if (player_) {
	      var _this$stats, _this$stats2, _this$stats3;
	      return {
	        'player.dateInstantiated': (_this$stats = this.stats) !== null && _this$stats !== void 0 && _this$stats.instantiatedTimeStamp ? new Date(this.stats.instantiatedTimeStamp).toUTCString() : undefined,
	        'player.dateLoaded': (_this$stats2 = this.stats) !== null && _this$stats2 !== void 0 && _this$stats2.loadedTimeStamp ? new Date(this.stats.loadedTimeStamp).toUTCString() : undefined,
	        'player.dateStarted': 'playTimestamp' in player_ ? new Date(player_.playTimestamp).toUTCString() : undefined,
	        'player.dateFinished': (_this$stats3 = this.stats) !== null && _this$stats3 !== void 0 && _this$stats3.finishedTimeStamp ? new Date(this.stats.finishedTimeStamp).toUTCString() : undefined
	      };
	    }
	    return {};
	  }
	  playbackSessionFlowEventSpecific_(data) {
	    let session = data;
	    if (!session) session = this.session_;
	    if (session) {
	      return {
	        'session.playbackUrl': session.playbackUrl,
	        'session.contentType': session.playbackConfig ? session.playbackConfig.contentType : undefined,
	        'session.keySystem': session.playbackConfig ? session.playbackConfig.keySystem : undefined,
	        'session.licenseUrl': session.playbackConfig ? session.playbackConfig.licenseUrl : undefined,
	        ...this.getPlayerInfo()
	      };
	    }
	    return {};
	  }
	  mediaItemFlowEventSpecific_(data) {
	    let mediaItem = data;
	    if (!mediaItem && this.player_) mediaItem = this.player_.mediaItem;
	    if (mediaItem) {
	      // valid for both - ESPN and pluto
	      return {
	        playbackIdentifier: this.adapterConfigs_.identifier,
	        'mediaItem.id': 'id' in mediaItem ? mediaItem.id : undefined,
	        'mediaItem.authenticationTypes': 'authenticationTypes' in mediaItem ? mediaItem.authenticationTypes : undefined,
	        'mediaItem.source.type': mediaItem.source && 'type' in mediaItem.source ? mediaItem.source.type : undefined,
	        'mediaItem.source.url': mediaItem.source && 'url' in mediaItem.source ? mediaItem.source.url : undefined,
	        'mediaItem.streamType': 'streamType' in mediaItem ? mediaItem.streamType : undefined,
	        'mediaItem.duration': 'duration' in mediaItem ? mediaItem.duration : undefined,
	        // Not listed, but may be usefull:
	        'mediaItem.brand': 'brand' in mediaItem ? mediaItem.brand : undefined,
	        'mediaItem.apiSource': 'apiSource' in mediaItem ? mediaItem.apiSource : undefined,
	        'mediaItem.entityType': 'entityType' in mediaItem ? mediaItem.entityType : undefined
	      };
	    }
	    return {};
	  }
	  playbackAccessFlowEventSpecific_(data) {
	    let payloadOrBAM = data;
	    if (!payloadOrBAM) payloadOrBAM = this.adapterConfigs_.authorizationPayload;
	    if (payloadOrBAM) {
	      return {
	        'payload.authenticationType': payloadOrBAM ? payloadOrBAM.authenticationType : undefined,
	        'payload.authenticatedIdentity': payloadOrBAM ? payloadOrBAM.authenticatedIdentity : undefined,
	        'payload.authenticatedProvider': payloadOrBAM && payloadOrBAM.authenticatedProvider ? payloadOrBAM.authenticatedProvider.id : undefined,
	        'payload.token': payloadOrBAM && payloadOrBAM.customData ? payloadOrBAM.customData.token : undefined,
	        'payload.tokenType': payloadOrBAM && payloadOrBAM.customData ? payloadOrBAM.customData.tokenType : undefined,
	        'payload.resource': payloadOrBAM && payloadOrBAM.customData ? payloadOrBAM.customData.resource : undefined
	      };
	    }
	    return {};
	  }
	  getPlayerInfo() {
	    const player = this.player_;
	    if (!player) return {};
	    const {
	      vhs,
	      dash
	    } = player;
	    if (vhs) {
	      return this.getPlayerInfoFromVHS_(vhs);
	    }
	    if (dash) {
	      const {
	        shakaPlayer,
	        mediaPlayer
	      } = dash;
	      if (shakaPlayer) {
	        return this.getPlayerInfoFromShaka_(shakaPlayer);
	      }
	      if (mediaPlayer) {
	        return this.getPlayerInfoFromMediaPlayer_(mediaPlayer);
	      }
	    }
	    return {};
	  }
	  getPlayerInfoFromVHS_(vhs = {}) {
	    const {
	      stats: {
	        bandwidth,
	        buffered,
	        currentSource: {
	          src
	        } = {},
	        currentTime,
	        mediaRequestsErrored,
	        playerDimensions: {
	          height,
	          width
	        } = {},
	        mediaSecondsLoaded,
	        videoPlaybackQuality: {
	          corruptedVideoFrames
	        } = {}
	      } = {}
	    } = vhs;
	    return {
	      currentSource: src,
	      bandwidth,
	      buffered: buffered ? buffered.length : undefined,
	      currentTime,
	      mediaRequestsErrored,
	      mediaSecondsLoaded,
	      corruptedVideoFrames,
	      playerHeight: height,
	      playerWidth: width,
	      mediaType: 'VHS'
	    };
	  }
	  getPlayerInfoFromShaka_(shakaPlayer) {
	    if (!shakaPlayer) return {};
	    const stats = typeof shakaPlayer.getStats === 'function' ? shakaPlayer.getStats() : {};
	    const buffered = typeof shakaPlayer.getBufferedInfo === 'function' ? shakaPlayer.getBufferedInfo() : {};
	    return {
	      currentSource: typeof shakaPlayer.getAssetUri === 'function' ? shakaPlayer.getAssetUri() : undefined,
	      bandwidth: stats.streamBandwidth,
	      buffered: buffered ? buffered.total : undefined,
	      currentTime: stats.playTime,
	      corruptedVideoFrames: stats.corruptedFrames,
	      playerHeight: stats.height,
	      playerWidth: stats.width,
	      loadLatency: stats.loadLatency,
	      mediaType: 'Dash: shakaPlayer'
	    };
	  }
	  getPlayerInfoFromMediaPlayer_(mediaPlayer) {
	    return {
	      currentSource: typeof mediaPlayer.getSource === 'function' ? mediaPlayer.getSource() : undefined,
	      mediaType: 'Dash: mediaPlayer'
	    };
	  }
	}
	var NewRelicService$1 = new NewRelicService();

	var $TypeError$2 = TypeError;

	var deletePropertyOrThrow$1	};

	var createProperty$1	};

	var createProperty = createProperty$1;

	var $Array$2 = Array;
	var max$2 = Math.max;

	var arraySliceSimple	};

	var arraySlice = arraySliceSimple;

	var floor$1 = Math.floor;

	var mergeSort	};

	var insertionSort	};

	var merge	};

	var arraySort = mergeSort;

	var arrayMethodIsStrict$1	};

	var firefox = userAgent.match(/firefox\/(\d+)/i);

	var engineFfVersion = !!firefox && +firefox[1];

	var engineIsIeOrEdge = /MSIE|Trident/.test(userAgent);

	var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

	var engineWebkitVersion = !!webkit && +webkit[1];

	var deletePropertyOrThrow = deletePropertyOrThrow$1;

	var internalSort = arraySort;

	var arrayMethodIsStrict = arrayMethodIsStrict$1;

	var FF = engineFfVersion;

	var IE_OR_EDGE = engineIsIeOrEdge;

	var WEBKIT = engineWebkitVersion;

	var test = [];
	var nativeSort = uncurryThis$1(test.sort);
	var push$3 = uncurryThis$1(test.push);

	// IE8-
	var FAILS_ON_UNDEFINED = fai	});
	// V8 bug
	var FAILS_ON_NULL = fai	});
	// Old WebKit
	var STRICT_METHOD = arrayMethodIsStrict('sort');

	var STABLE_SORT = !fai	});

	var FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

	var getSortCompare	};

	// `Array.prototype.sort` method
	// https://tc39.es/ecma262/#sec-array.prototype.sort
	$({ target: 'Array', proto: true, forced: FORCED$1 }, {
	  sor }
	});

	var sort$3 = entryVirtual('Array').sort;

	var method$6 = sort$3;

	var ArrayPrototype$5 = Array.prototype;

	var sort$2 = function (it) {
	  var own = it.sort;
	  return it === ArrayPrototype$5 || (isPrototypeOf(ArrayPrototype$5, it) && own === ArrayPrototype$5.sort) ? method$6 : own;
	};

	var parent$b = sort$2;

	var sort$1 = parent$b;

	var require$$0$f = sort$1;

	var sort = require$$0$f;

	function debounce$1(fn, delay = 0) {
	  let timeoutId;
	  return (...args) => {
	    clearTimeout(timeoutId);
	    timeoutId = setTimeo }, delay);
	  };
	}

	// `IsArray` abstract operation
	// https://tc39.es/ecma262/#sec-isarray
	// eslint-disable-next-line es/no-array-isarray -- safe
	var isArray$2 = Array.isArray 	};

	var isArray$1 = isArray$2;

	var SPECIES$2 = wellKnownSymbol('species');
	var $Array$1 = Array;

	// a part of `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate
	var arraySpeciesConstructor$1	};

	var arraySpeciesConstructor = arraySpeciesConstructor$1;

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate$1	};

	var arraySpeciesCreate = arraySpeciesCreate$1;

	var push$2 = uncurryThis$1([].push);

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
	var createMethod$2	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.es/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$2(0),
	  // `Array.prototype.map` method
	  // https://tc39.es/ecma262/#sec-array.prototype.map
	  map: createMethod$2(1),
	  // `Array.prototype.filter` method
	  // https://tc39.es/ecma262/#sec-array.prototype.filter
	  filter: createMethod$2(2),
	  // `Array.prototype.some` method
	  // https://tc39.es/ecma262/#sec-array.prototype.some
	  some: createMethod$2(3),
	  // `Array.prototype.every` method
	  // https://tc39.es/ecma262/#sec-array.prototype.every
	  every: createMethod$2(4),
	  // `Array.prototype.find` method
	  // https://tc39.es/ecma262/#sec-array.prototype.find
	  find: createMethod$2(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$2(6),
	  // `Array.prototype.filterReject` method
	  // https://github.com/tc39/proposal-array-filtering
	  filterReject: createMethod$2(7)
	};

	var SPECIES$1 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport$1	};

	var require$$0$e = arrayIteration;

	var arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$1;

	var $map = require$$0$e.map;


	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('map');

	// `Array.prototype.map` method
	// https://tc39.es/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
	  ma }
	});

	var map$3 = entryVirtual('Array').map;

	var method$5 = map$3;

	var ArrayPrototype$4 = Array.prototype;

	var map$2 = function (it) {
	  var own = it.map;
	  return it === ArrayPrototype$4 || (isPrototypeOf(ArrayPrototype$4, it) && own === ArrayPrototype$4.map) ? method$5 : own;
	};

	var parent$a = map$2;

	var map$1 = parent$a;

	var require$$0$d = map$1;

	var map = require$$0$d;

	/* jshint strict: false */

	const loadScript$1 = {
	  url: url => {
	    return new promise((resolve, reject) => {
	      try {
	        const script = document.createElement('script');
	        script.type = 'text/javascript';
	        script.src = url;
	        script.addEventListener('load', () => resolve(script), false);
	        script.addEventListener('errort), false);
	        document.body.appendChild(script);
	      } catch (error) {
	        reject(error);
	      }
	    });
	  },
	  urls: urls => {
	    return promise.allSettled(map(urls).call(urls, loadScript$1.url));
	  }
	};

	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');

	var SPECIES = wellKnownSymbol('species');
	var $Array = Array;
	var max$1 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.es/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
	  slic }
	});

	var slice$3 = entryVirtual('Array').slice;

	var method$4 = slice$3;

	var ArrayPrototype$3 = Array.prototype;

	var slice$2	};

	var parent$9 = slice$2;

	var slice$1 = parent$9;

	var require$$0$c = slice$1;

	var slice = require$$0$c;

	/* global Blob */
	// This file is generated. Do not edit this file directly.
	// Command: 'npm run generate' should be used to update the content.

	/**
	 * @type {Blob}
	 */
	var AUDIO = new Blob([new Uint8Array([255, 227, 24, 196, 0, 0, 0, 3, 72, 1, 64, 0, 0, 4, 132, 16, 31, 227, 192, 225, 76, 255, 67, 12, 255, 221, 27, 255, 228, 97, 73, 63, 255, 195, 131, 69, 192, 232, 223, 255, 255, 207, 102, 239, 255, 255, 255, 101, 158, 206, 70, 20, 59, 255, 254, 95, 70, 149, 66, 4, 16, 128, 0, 2, 2, 32, 240, 138, 255, 36, 106, 183, 255, 227, 24, 196, 59, 11, 34, 62, 80, 49, 135, 40, 0, 253, 29, 191, 209, 200, 141, 71, 7, 255, 252, 152, 74, 15, 130, 33, 185, 6, 63, 255, 252, 195, 70, 203, 86, 53, 15, 255, 255, 247, 103, 76, 121, 64, 32, 47, 255, 34, 227, 194, 209, 138, 76, 65, 77, 69, 51, 46, 57, 55, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 227, 24, 196, 73, 13, 153, 210, 100, 81, 135, 56, 0, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170])], { type: 'audio/mpeg' });

	/**
	 * @type {Blob}
	 */
	var VIDEO = new Blob([new Uint8Array([0, 0, 0, 28, 102, 116, 121, 112, 105, 115, 111, 109, 0, 0, 2, 0, 105, 115, 111, 109, 105, 115, 111, 50, 109, 112, 52, 49, 0, 0, 0, 8, 102, 114, 101, 101, 0, 0, 2, 239, 109, 100, 97, 116, 33, 16, 5, 32, 164, 27, 255, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 167, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 33, 16, 5, 32, 164, 27, 255, 192, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 167, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 112, 0, 0, 2, 194, 109, 111, 111, 118, 0, 0, 0, 108, 109, 118, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 232, 0, 0, 0, 47, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1, 236, 116, 114, 97, 107, 0, 0, 0, 92, 116, 107, 104, 100, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 101, 100, 116, 115, 0, 0, 0, 28, 101, 108, 115, 116, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 47, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 100, 109, 100, 105, 97, 0, 0, 0, 32, 109, 100, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 172, 68, 0, 0, 8, 0, 85, 196, 0, 0, 0, 0, 0, 45, 104, 100, 108, 114, 0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0, 0, 0, 1, 15, 109, 105, 110, 102, 0, 0, 0, 16, 115, 109, 104, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 100, 105, 110, 102, 0, 0, 0, 28, 100, 114, 101, 102, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1, 0, 0, 0, 211, 115, 116, 98, 108, 0, 0, 0, 103, 115, 116, 115, 100, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 87, 109, 112, 52, 97, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 16, 0, 0, 0, 0, 172, 68, 0, 0, 0, 0, 0, 51, 101, 115, 100, 115, 0, 0, 0, 0, 3, 128, 128, 128, 34, 0, 2, 0, 4, 128, 128, 128, 20, 64, 21, 0, 0, 0, 0, 1, 244, 0, 0, 1, 243, 249, 5, 128, 128, 128, 2, 18, 16, 6, 128, 128, 128, 1, 2, 0, 0, 0, 24, 115, 116, 116, 115, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 28, 115, 116, 115, 99, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 28, 115, 116, 115, 122, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 115, 0, 0, 1, 116, 0, 0, 0, 20, 115, 116, 99, 111, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 44, 0, 0, 0, 98, 117, 100, 116, 97, 0, 0, 0, 90, 109, 101, 116, 97, 0, 0, 0, 0, 0, 0, 0, 33, 104, 100, 108, 114, 0, 0, 0, 0, 0, 0, 0, 0, 109, 100, 105, 114, 97, 112, 112, 108, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 45, 105, 108, 115, 116, 0, 0, 0, 37, 169, 116, 111, 111, 0, 0, 0, 29, 100, 97, 116, 97, 0, 0, 0, 1, 0, 0, 0, 0, 76, 97, 118, 102, 53, 54, 46, 52, 48, 46, 49, 48, 49])], { type: 'video/mp4' });

	/* global URL *	}

	function startPlayback(_ref, elementCallback) {
	  var muted = _ref.muted,
	      timeout = _ref.timeout,
	      inline = _ref.inline;

	  var _elementCallback = elementCallback(),
	      element = _elementCallback.element,
	      source = _elementCallback.source;

	  var playResult = void 0;
	  var timeoutId = void 0;
	  var sendOutput = void 0;

	  element.muted = muted;
	  if (muted === true) {
	    element.setAttribute('muted', 'muted');
	  }
	  // indicates that the video is to be played "inline",
	  // that is within the element's playback area.
	  if (inline === true) {
	    element.setAttribute('playsinline', 'playsinline');
	  }

	  element.src = source;

	  return new Promise(function (resolve) {
	    playResult = element.play();
	    timeoutId = setTimeo }, timeout);
	    sendOutput = function sendOutput(result) {
	      var error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      // Clean up to avoid MediaElementLeak
	      element.remove();
	      element.srcObject = null;

	      clearTimeout(timeoutId);
	      resolve({ result: result, error: error });
	    };

	    if (playResult !== undefined) {
	      playResult.th }).cat });
	    } else {
	      sendOutput(true);
	    }
	  });
	}

	//
	// API
	//

	function video(options) {
	  options = setupDefaultValues(options);
	  return startPlayback(options, function () {
	    return {
	      element: document.createElement('video'),
	      source: URL.createObjectURL(VIDEO)
	    };
	  });
	}

	function audio(options) {
	  options = setupDefaultValues(options);
	  return startPlayback(option });
	}

	var index = { audio: audio, video: video };

	var StorageType;
	(function (StorageType) {
	    StorageType["localStorage"] = "LOCAL_STORAGE";
	    StorageType["sessionStorage"] = "SESSION_STORAGE";
	})(StorageType || (StorageType = {}));

	class AuthenticatedProvider {
	  }
	  }
	  }
	}

	var CustomDataKey;	})(CustomDataKey || (CustomDataKey = {}));
	class AuthorizationPayload {
	    constructor(authenticationType, authenticatedProvider, authenticatedIdentity, customData = {}) {
	        this.authenticationType = authenticationType;
	        this.authenticatedProvider = authenticatedProvider;
	        this.authenticatedIdentity = authenticatedIdentity;
	        this.customData = customData;
	    }
	}
	AuthorizationPayload.CustomDataKey = CustomDataKey;	}

	var AdProvider$1;
	(function (AdProvider) {
	    AdProvider["standard"] = "default";
	    AdProvider["googleAdManager"] = "gam";
	})(AdProvider$1 || (AdProvider$1 = {}));

	var AdEnvironment;	})(AdEnvironment || (AdEnvironment = {}));

	const EVT_LOAD = 'load';
	const EVT_ERROR = 'error';
	const LOAD_TIMEOUT = 4000;
	function loadScript(url, timeout = LOAD_TIMEOUT) {
	    const win = typeof window !== 'undefined' && window;
	    const doc = win && win.document;
	    const docHead = doc && doc.getElementsByTagName && doc.getElementsByTagName('head')[0];
	    const docBody = doc && doc.body;
	    const docTarget = docHead || docBody;
	    if (!(docTarget && url)) {
	        return Promise.reject();
	    }
	    return new Promise(function injectScript(resolve, reject) {
	        const script = document.createElement('script');
	        let disposers = [];
	        let loadTimeout = null;
	        const dispose = () => {
	            disposers.forEa());
	            disposers = null;
	            clearTimeout(loadTimeout);
	            loadTimeout = null;
	        };
	        const onLoad = function disposeAndResolve(evt) {
	            dispose();
	            resolve(evt);
	        };
	        const onError };
	        script.type = 'text/javascript';
	        script.src = url;
	        script.addEventListener(EVT_LOAD, onLoad);
	        disposers.push(() => script.removeEventListener(EVT_LOAD, onLoad));
	        script.addEventListener(EVT_ERROR, onError);
	        disposers.pur));
	        loadTimeout = setTimeo)), LOAD_TIMEOUT);
	        docTarget.appendChild(script);
	    });
	}

	const NO_PAL_FALLBACK = Object.freeze({});
	const EMPTY_STR$1 = Object.freeze('');
	const DEFAULT_PLAYER_SIZE = '640x480';
	const PAL_LOADER_SRC = 'https://imasdk.googleapis.com/pal/sdkloader/pal.js';
	const VIDEO_DELIVERY_METHOD_LIVE = 'vod';
	const win = typeof window !== 'undefined' && window;
	const logError	};
	let palSdkInstance;
	let nonceLoader;
	let cachedNonce;
	const loadPalDependencies = function embedPalLoader() {
	    return __awaiter(this, void 0, void 0, function* () {
	        let pal = palSdkInstance || (win.goog && win.goog.pal);
	        const hadBC = win && win.bc;
	        if (!pal) {
	            try {
	                yield loadScript(PAL_LOADER_SRC);
	            }
	            catch (err) {
	                logError(err);
	            }
	            pal = win.goog && win.goog.pal;
	            if (pal) {
	                palSdkInstance = pal;
	            }
	            if (!hadBC && win.bc) {
	                win.bc = null;
	            }
	        }
	        return pal || NO_PAL_FALLBACK;
	    });
	};
	function mapAdvertisingInfoToGoogleNonceRequestData(advertisingInfo) {
	    const [videoWidth, videoHeight] = String(advertisingInfo.videoPlayerSize || DEFAULT_PLAYER_SIZE).split('x');
	    return {
	        adWillAutoPlay: advertisingInfo.isAutoplay,
	        adWillPlayMuted: advertisingInfo.isMute,
	        continuousPlayback: advertisingInfo.videoDeliveryMethod === VIDEO_DELIVERY_METHOD_LIVE,
	        descriptionUrl: advertisingInfo.descriptionUrl || EMPTY_STR$1,
	        iconsSupported: advertisingInfo.vastIconsSupported,
	        playerType: advertisingInfo.videoPlayerType || EMPTY_STR$1,
	        playerVersion: advertisingInfo.videoPlayerVersion || EMPTY_STR$1,
	        ppid: advertisingInfo.ppid || advertisingInfo.swid || EMPTY_STR$1,
	        videoHeight: parseInt(videoHeight, 10),
	        videoWidth: parseInt(videoWidth, 10),
	    };
	}
	function generateNonce(advertisingInfo, maxLength = 3000, reinstantiateLoader = false, useSessionNonce = true, dependencyLoader = loadPalDependencies) {
	    return __awaiter(this, void 0, void 0, function* () {
	        let nonce = (useSessionNonce && cachedNonce) || EMPTY_STR$1;
	        if (!nonce) {
	            let NonceLoader, NonceRequest, ConsentSettings;
	            try {
	                const palSdk = yield dependencyLoader();
	                if (palSdk) {
	                    NonceLoader = palSdk.NonceLoader;
	                    NonceRequest = palSdk.NonceRequest;
	                    ConsentSettings = palSdk.ConsentSettings;
	                }
	            }
	            catch (err) {
	                logError(err);
	            }
	            if (!(useSessionNonce && cachedNonce) && NonceLoader && NonceRequest) {
	                let nonceManager;
	                try {
	                    const { storageConsent = false } = advertisingInfo;
	                    const consentSettings = new ConsentSettings();
	                    consentSettings.allowStorage = storageConsent;
	                    nonceLoader = !nonceLoader || reinstantiateLoader ? new NonceLoader(consentSettings) : nonceLoader;
	                    const nonceRequest = Object.assign(new NonceRequest(), mapAdvertisingInfoToGoogleNonceRequestData(advertisingInfo));
	                    nonceManager = yield nonceLoader.loadNonceManager(nonceRequest);
	                }
	                catch (err) {
	                    logError(err);
	                }
	                if (nonceManager) {
	                    nonce = yield nonceManager.getNonce();
	                    if (!nonce || (Number(maxLength) > 0 && String(nonce).length > maxLength)) {
	                        nonce = EMPTY_STR$1;
	                    }
	                    if (nonce) {
	                        cachedNonce = nonce;
	                    }
	                }
	            }
	        }
	        return nonce;
	    });
	}

	const optionalInt = (val) => {
	    if (val === null) {
	        return null;
	    }
	    return val ? '1' : '0';
	};
	const optionalBool = (first, second) => {
	    if (first !== null && first !== undefined) {
	        return first;
	    }
	    return second;
	};
	class AdvertisingInfo {
	    constructor(aff = null, alt = null, accessLevel = null, adRule = null, an = 'espn', beacType = null, collection = null, cbp = null, descriptionUrl = null, edition = null, fcap = null, hashedIp = null, hl = null, isAuth = null, idType = null, impl = null, isLat = false, iu = null, msid = null, npa = false, ltd = false, nlsnPlat = null, output = null, palNonce = null, storageConsent = false, playlist = null, ppid = null, rdid = null, tags = null, transId = null, tfcd = false, url = null, varResolution = null, vpa = null, vpi = null, vadFormat = null, vpmute = null, authenticationProvider = null, bundleId = null, deviceOS = null, deviceType = null, isAutoplay = null, isMute = null, language = null, nielsenAppId = null, nielsenDeviceGroup = null, noAds = null, objectId = null, pageType = null, platform = null, stitchingProvider = null, swid = null, testAdTargeting = null, tag = null, unid = null, vastIconsSupported = false, videoDeliveryMethod = null, videoPlayerSize = null, videoPlayerType = null, videoPlayerVersion = null, userInfo = {}, isDoNotTrackEnabled = null, pp = null, cmsid = null, vid = null, adEnvironment = AdEnvironment.standard, adProvider = AdProvider$1.standard, usPrivacy = null, additionalConsent = null, rdp = null, tvid = null, dmm = null, adTimedmeta = null, chan = null, userAgent = null) {
	        this.aff = aff;
	        this.alt = alt;
	        this.accessLevel = accessLevel;
	        this.adRule = adRule;
	        this.an = an;
	        this.beacType = beacType;
	        this.collection = collection;
	        this.cbp = cbp;
	        this.descriptionUrl = descriptionUrl;
	        this.edition = edition;
	        this.fcap = fcap;
	        this.hashedIp = hashedIp;
	        this.hl = hl;
	        this.isAuth = isAuth;
	        this.idType = idType;
	        this.impl = impl;
	        this.isLat = isLat;
	        this.iu = iu;
	        this.msid = msid;
	        this.npa = npa;
	        this.ltd = ltd;
	        this.nlsnPlat = nlsnPlat;
	        this.output = output;
	        this.palNonce = palNonce;
	        this.storageConsent = storageConsent;
	        this.playlist = playlist;
	        this.ppid = ppid;
	        this.rdid = rdid;
	        this.tags = tags;
	        this.transId = transId;
	        this.tfcd = tfcd;
	        this.url = url;
	        this.varResolution = varResolution;
	        this.vpa = vpa;
	        this.vpi = vpi;
	        this.vadFormat = vadFormat;
	        this.vpmute = vpmute;
	        this.authenticationProvider = authenticationProvider;
	        this.bundleId = bundleId;
	        this.deviceOS = deviceOS;
	        this.deviceType = deviceType;
	        this.isAutoplay = isAutoplay;
	        this.isMute = isMute;
	        this.language = language;
	        this.nielsenAppId = nielsenAppId;
	        this.nielsenDeviceGroup = nielsenDeviceGroup;
	        this.noAds = noAds;
	        this.objectId = objectId;
	        this.pageType = pageType;
	        this.platform = platform;
	        this.stitchingProvider = stitchingProvider;
	        this.swid = swid;
	        this.testAdTargeting = testAdTargeting;
	        this.tag = tag;
	        this.unid = unid;
	        this.vastIconsSupported = vastIconsSupported;
	        this.videoDeliveryMethod = videoDeliveryMethod;
	        this.videoPlayerSize = videoPlayerSize;
	        this.videoPlayerType = videoPlayerType;
	        this.videoPlayerVersion = videoPlayerVersion;
	        this.userInfo = userInfo;
	        this.isDoNotTrackEnabled = isDoNotTrackEnabled;
	        this.pp = pp;
	        this.cmsid = cmsid;
	        this.vid = vid;
	        this.adEnvironment = adEnvironment;
	        this.adProvider = adProvider;
	        this.usPrivacy = usPrivacy;
	        this.additionalConsent = additionalConsent;
	        this.rdp = rdp;
	        this.tvid = tvid;
	        this.dmm = dmm;
	        this.adTimedmeta = adTimedmeta;
	        this.chan = chan;
	        this.userAgent = userAgent;
	    }
	    merge(other) {
	        if (!other) {
	            return this;
	        }
	        this.adRule = other.adRule || this.adRule;
	        this.an = other.an || this.an;
	        this.descriptionUrl = other.descriptionUrl || this.descriptionUrl;
	        this.fcap = other.fcap || this.fcap;
	        this.hashedIp = other.hashedIp || this.hashedIp;
	        this.hl = other.hl || this.hl;
	        this.idType = other.idType || this.idType;
	        this.isLat = optionalBool(other.isLat, this.isLat);
	        this.iu = other.iu || this.iu;
	        this.msid = other.msid || this.msid;
	        this.npa = optionalBool(other.npa, this.npa);
	        this.ltd = optionalBool(other.ltd, this.ltd);
	        this.output = other.output || this.output;
	        this.ppid = other.ppid || this.ppid;
	        this.rdid = other.rdid || this.rdid;
	        this.rdp = other.rdp || this.rdp;
	        this.tfcd = other.tfcd || this.tfcd;
	        this.url = other.url || this.url;
	        this.vpa = other.vpa || this.vpa;
	        this.vpi = other.vpi || this.vpi;
	        this.vadFormat = other.vadFormat || this.vadFormat;
	        this.vpmute = optionalBool(other.vpmute, this.vpmute);
	        this.authenticationProvider = other.authenticationProvider || this.authenticationProvider;
	        this.bundleId = other.bundleId || this.bundleId;
	        this.deviceOS = other.deviceOS || this.deviceOS;
	        this.deviceType = other.deviceType || this.deviceType;
	        this.isAutoplay = optionalBool(other.isAutoplay, this.isAutoplay);
	        this.isMute = optionalBool(other.isMute, this.isMute);
	        this.language = other.language || this.language;
	        this.palNonce = other.palNonce || this.palNonce;
	        this.storageConsent = other.storageConsent || this.storageConsent;
	        this.nielsenAppId = other.nielsenAppId || this.nielsenAppId;
	        this.nielsenDeviceGroup = other.nielsenDeviceGroup || this.nielsenDeviceGroup;
	        this.noAds = optionalBool(other.noAds, this.noAds);
	        this.objectId = other.objectId || this.objectId;
	        this.platform = other.platform || this.platform;
	        this.stitchingProvider = other.stitchingProvider || this.stitchingProvider;
	        this.swid = other.swid || this.swid;
	        this.tags = other.tags || this.tags;
	        this.testAdTargeting = other.testAdTargeting || this.testAdTargeting;
	        this.unid = other.unid || this.unid;
	        this.alt = other.alt || this.alt;
	        this.beacType = other.beacType || this.beacType;
	        this.transId = other.transId || this.transId;
	        this.accessLevel = other.accessLevel || this.accessLevel;
	        this.varResolution = other.varResolution || this.varResolution;
	        this.nlsnPlat = other.nlsnPlat || this.nlsnPlat;
	        this.tag = other.tag || this.tag;
	        this.aff = other.aff || this.aff;
	        this.playlist = other.playlist || this.playlist;
	        this.cbp = other.cbp || this.cbp;
	        this.collection = other.collection || this.collection;
	        this.impl = other.impl || this.impl;
	        this.isAuth = other.isAuth || this.isAuth;
	        this.pageType = other.pageType || this.pageType;
	        this.vastIconsSupported = optionalBool(other.vastIconsSupported, this.vastIconsSupported);
	        this.videoDeliveryMethod = other.videoDeliveryMethod || this.videoDeliveryMethod;
	        this.videoPlayerSize = other.videoPlayerSize || this.videoPlayerSize;
	        this.videoPlayerType = other.videoPlayerType || this.videoPlayerType;
	        this.videoPlayerVersion = other.videoPlayerVersion || this.videoPlayerVersion;
	        this.isDoNotTrackEnabled = optionalBool(other.isDoNotTrackEnabled, this.isDoNotTrackEnabled);
	        this.pp = other.pp || this.pp;
	        this.cmsid = other.cmsid || this.cmsid;
	        this.usPrivacy = other.usPrivacy || this.usPrivacy;
	        this.additionalConsent = other.additionalConsent || this.additionalConsent;
	        this.vid = other.vid || this.vid;
	        this.tvid = other.tvid || this.tvid;
	        this.dmm = other.dmm || this.dmm;
	        this.adTimedmeta = other.adTimedmeta || this.adTimedmeta;
	        this.chan = other.chan || this.chan;
	        this.userAgent = other.userAgent || this.userAgent;
	        if (!this.userInfo) {
	            this.userInfo = other.userInfo;
	        }
	        else {
	            Object.assign(this.userInfo, other.userInfo);
	        }
	        this.adEnvironment = other.adEnvironment !== AdEnvironment.standard ? other.adEnvironment : this.adEnvironment;
	        this.adProvider = other.adProvider !== AdProvider$1.standard ? other.adProvider : this.adProvider;
	        return this;
	    }
	    dictionaryForStartSession() {
	        const info = {};
	        info['ad.tfcd'] = optionalInt(this.tfcd);
	        info['ad.is_lat'] = optionalInt(this.isLat);
	        info['ad.idtype'] = this.idType;
	        info['ad.rdid'] = this.rdid;
	        info['ad.ppid'] = this.ppid || this.swid;
	        info['ad.description_url'] = this.descriptionUrl;
	        info['ad.hl'] = this.hl;
	        info['ad.paln'] = this.palNonce;
	        info['ad.npa'] = optionalInt(this.npa);
	        info['ad.ltd'] = optionalInt(this.ltd);
	        info['ad.msid'] = this.msid;
	        info['ad.an'] = this.an;
	        info['ad.url'] = this.url;
	        info['ad.us_privacy'] = this.usPrivacy;
	        info['ad.cust_params.d_us_privacy'] = this.usPrivacy;
	        info['ad.cust_params.chan'] = this.chan;
	        info['ad.rdp'] = this.rdp !== null ? this.rdp : this.usPrivacy === '1YYY' ? '1' : null;
	        info['ad.timedmeta'] = this.adTimedmeta;
	        info['dmm.schema.ads'] = this.dmm;
	        info.authp = this.authenticationProvider;
	        info.bundleId = this.bundleId;
	        info.devOS = this.deviceOS;
	        info.devType = this.deviceType;
	        info.fcap = this.fcap;
	        info.isAutoplay = optionalInt(this.isAutoplay);
	        info.isMute = optionalInt(this.isMute);
	        info.nlsnAppID = this.nielsenAppId;
	        info.tvid = this.tvid;
	        info.plt = this.platform;
	        info.swid = this.swid;
	        info.unid = this.unid;
	        info.vps = this.videoPlayerSize;
	        this.userAgent = this.userAgent;
	        if (this.adEnvironment !== AdEnvironment.standard) {
	            info.adEnv = this.adEnvironment;
	        }
	        if (this.adProvider !== AdProvider$1.standard) {
	            info.adProvider = this.adProvider;
	        }
	        Object.assign(info, this.userInfo);
	        Object.keys(info).forEach(key => info[key] === null && delete info[key]);
	        return info;
	    }
	    dictionaryForBrightcove() {
	        const customParams = {};
	        customParams.bundleId = this.bundleId;
	        customParams.devOS = this.deviceOS;
	        customParams.devType = this.deviceType;
	        customParams.isAutoplay = optionalInt(this.isAutoplay);
	        customParams.isMute = optionalInt(this.isMute);
	        customParams.plt = this.platform;
	        customParams.swid = this.swid;
	        customParams.vps = this.videoPlayerSize;
	        customParams.d_id = this.rdid;
	        customParams.vdm = this.videoDeliveryMethod || 'vod';
	        customParams.stp = this.stitchingProvider || 'brightcove';
	        const customParamsString = Object.keys(customParams)
	            .filter(key => customParams[key] !== null)
	            .map(key => `${key}=${customParams[key]}`)
	            .join('&');
	        const info = {};
	        info.UMADPARAMiu = this.iu;
	        info.UMADPARAMis_lat = optionalInt(this.isLat);
	        info.UMADPARAMidtype = this.idType;
	        info.UMADPARAMrdid = this.rdid;
	        info.UMADPARAMppid = this.ppid || this.swid;
	        info.UMADPARAMdescription_url = this.descriptionUrl;
	        info.UMADPARAMhl = this.hl;
	        info.UMADPARAMnpa = optionalInt(this.npa);
	        info.UMADPARAMltd = optionalInt(this.ltd);
	        info.UMADPARAMmsid = this.msid;
	        info.UMADPARAMan = this.an;
	        info.UMADPARAMurl = this.url;
	        info.UMADPARAMvpa = optionalInt(this.vpa);
	        info.UMADPARAMvpmute = optionalInt(this.vpmute);
	        info.UMPTPARAMcust_params = customParamsString;
	        Object.assign(info, this.userInfo);
	        Object.keys(info).forEach(key => info[key] === null && delete info[key]);
	        return info;
	    }
	    dictionaryForAdEngine() {
	        const info = {};
	        info.sect = this.iu;
	        info.npa = optionalInt(this.npa);
	        info.ltd = optionalInt(this.ltd);
	        info.lat = optionalInt(this.isLat);
	        info.idtype = this.idType;
	        info.devId = this.rdid;
	        info.ppid = this.ppid || this.swid;
	        info.app = this.an;
	        info.tfcd = optionalInt(this.tfcd);
	        info.devOS = this.deviceOS;
	        info.devType = this.deviceType;
	        info.isAutoplay = optionalInt(this.isAutoplay);
	        info.isMute = optionalInt(this.isMute);
	        info.plt = this.platform;
	        info.swid = this.swid;
	        info.unid = this.unid;
	        info.vps = this.videoPlayerSize;
	        info.bundle = this.msid;
	        info.hl = this.hl;
	        info.UID = this.swid;
	        info.vdm = this.videoDeliveryMethod;
	        info.url = this.url;
	        switch (this.adEnvironment) {
	            case AdEnvironment.development:
	                info.env = 'qa';
	                break;
	            case AdEnvironment.prod:
	                info.env = 'prod';
	                break;
	            case AdEnvironment.standard:
	        }
	        switch (this.adProvider) {
	            case AdProvider$1.googleAdManager:
	                info.ads = 'google';
	                break;
	            case AdProvider$1.standard:
	        }
	        Object.assign(info, this.userInfo);
	        Object.keys(info).forEach(key => info[key] === null && delete info[key]);
	        return info;
	    }
	    dictionaryForImaSdk() {
	        const customParams = {};
	        customParams.authp = this.authenticationProvider;
	        customParams.d_us_privacy = this.usPrivacy;
	        customParams.devOS = this.deviceOS;
	        customParams.devType = this.deviceType;
	        customParams.ed = this.edition;
	        customParams.hip = this.hashedIp;
	        customParams.isAutoplay = optionalInt(this.isAutoplay);
	        customParams.isDnt = optionalInt(this.isDoNotTrackEnabled);
	        customParams.isMute = optionalInt(this.isMute);
	        customParams.lang = this.language;
	        customParams.nlsnAppID = this.nielsenAppId;
	        customParams.nlsnDevGrp = this.nielsenDeviceGroup;
	        customParams.noad = this.noAds;
	        customParams.objid = this.objectId;
	        customParams.plt = this.platform;
	        customParams.pgtyp = this.pageType;
	        customParams.swid = this.swid;
	        customParams.tag = this.tags;
	        customParams.tstAdTar = this.testAdTargeting;
	        customParams.unid = this.unid;
	        customParams.vdm = this.videoDeliveryMethod || 'vod';
	        customParams.vps = this.videoPlayerSize;
	        customParams.chan = this.chan;
	        const customParamsString = Object.keys(customParams)
	            .filter(key => customParams[key] !== null)
	            .map(key => `${key}=${customParams[key]}`)
	            .join('&');
	        const info = {};
	        info.ad_rule = this.adRule;
	        info.cmsid = this.cmsid;
	        info.description_url = this.descriptionUrl;
	        info.hl = this.hl;
	        info.iu = this.iu;
	        info.npa = optionalInt(this.npa);
	        info.output = this.output;
	        info.ltd = optionalInt(this.ltd);
	        info.pp = this.pp;
	        info.ppid = this.ppid;
	        info.rdp = this.rdp;
	        info.tfcd = optionalInt(this.tfcd);
	        info.us_privacy = this.usPrivacy;
	        info.addtl_consent = this.additionalConsent;
	        info.vid = this.vid;
	        info.vpa = optionalInt(this.vpa);
	        info.cust_params = customParamsString;
	        info.gdfp_req = '1';
	        info.env = 'vp';
	        info.sz = '640x480';
	        if (this.adEnvironment !== AdEnvironment.standard) {
	            info.adEnv = this.adEnvironment;
	        }
	        Object.keys(info).forEach(key => info[key] === null && delete info[key]);
	        return info;
	    }
	    dictionaryForEntertainment() {
	        const customParams = {};
	        customParams.ed = this.edition;
	        customParams.devOS = this.deviceOS;
	        customParams.devType = this.deviceType;
	        customParams.hip = this.hashedIp;
	        customParams.isAutoplay = optionalInt(this.isAutoplay);
	        customParams.isDnt = optionalInt(this.isDoNotTrackEnabled);
	        customParams.isMute = optionalInt(this.isMute);
	        customParams.lang = this.language;
	        customParams.nlsnAppID = this.nielsenAppId;
	        customParams.nlsnDevGrp = this.nielsenDeviceGroup;
	        customParams.nlsnPlat = this.nlsnPlat;
	        customParams.noad = this.noAds;
	        customParams.objid = this.objectId;
	        customParams.pgtyp = this.pageType;
	        customParams.plt = this.platform;
	        customParams.swid = this.swid || this.ppid;
	        customParams.tag = this.tags;
	        customParams.tstAdTar = this.testAdTargeting;
	        customParams.unid = this.unid;
	        customParams.vdm = this.videoDeliveryMethod || 'vod';
	        customParams.vps = this.videoPlayerSize;
	        customParams.alt = this.alt;
	        customParams.beacType = this.beacType;
	        customParams.transId = this.transId;
	        customParams.accesslevel = this.accessLevel;
	        customParams.isAuth = this.isAuth;
	        customParams.fcap = this.fcap;
	        customParams.var = this.varResolution;
	        customParams.tag = this.tag;
	        customParams.aff = this.aff;
	        customParams.authp = this.authenticationProvider;
	        customParams.playlist = this.playlist;
	        customParams.cbp = this.cbp;
	        customParams.collection = this.collection;
	        customParams.impl = this.impl;
	        customParams.chan = this.chan;
	        const customParamsString = Object.keys(customParams)
	            .filtll)
	            .m}`)
	            .join('&');
	        const info = {};
	        info.addtl_consent = this.additionalConsent;
	        info.ad_rule = this.adRule;
	        info.cmsid = this.cmsid;
	        info.description_url = this.descriptionUrl;
	        info.hl = this.hl;
	        info.iu = this.iu;
	        info.npa = optionalInt(this.npa);
	        info.output = this.output;
	        info.ltd = optionalInt(this.ltd);
	        info.pp = this.pp;
	        info.ppid = this.ppid;
	        info.tfcd = optionalInt(this.tfcd);
	        info.vid = this.vid;
	        info.vpa = optionalInt(this.vpa);
	        info.cust_params = customParamsString;
	        info.output = this.output;
	        info.vad_format = this.vadFormat;
	        info.vpi = this.vpi;
	        info.url = this.url;
	        info.us_privacy = this.usPrivacy;
	        info.gdfp_req = '1';
	        info.env = 'vp';
	        info.sz = '640x480';
	        Object.keys(info).forEach(key => info[key] === null && delete info[key]);
	        return info;
	    }
	  }
	}
	AdvertisingInfo.getGooglePalNonce = generateNonce;

	var AdConfigType;
	(function (AdConfigType) {
	    AdConfigType["immutable"] = "immutable";
	    AdConfigType["mutable"] = "mutable";
	})(AdConfigType || (AdConfigType = {}));

	var MediaItemMediaCommand$6;	})(MediaItemMediaCommand$6 || (MediaItemMediaCommand$6 = {}));

	var MediaItemNetworkType$6;
	(function (MediaItemNetworkType) {
	    MediaItemNetworkType["linear"] = "linear";
	    MediaItemNetworkType["event"] = "event";
	})(MediaItemNetworkType$6 || (MediaItemNetworkType$6 = {}));

	var MediaItemSourceVariant$6;	})(MediaItemSourceVariant$6 || (MediaItemSourceVariant$6 = {}));

	var MediaItemStreamType$8;
	(function (MediaItemStreamType) {
	    MediaItemStreamType["live"] = "live";
	    MediaItemStreamType["onDemand"] = "onDemand";
	})(MediaItemStreamType$8 || (MediaItemStreamType$8 = {}));

	var MediaItemTrackingType$6;
	(function (MediaItemTrackingType) {
	    MediaItemTrackingType["nielsen"] = "nielsen";
	    MediaItemTrackingType["comscore"] = "comscore";
	    MediaItemTrackingType["conviva"] = "conviva";
	    MediaItemTrackingType["heartbeats"] = "heartbeats";
	})(MediaItemTrackingType$6 || (MediaItemTrackingType$6 = {}));

	var MediaItemEntityType$7;
	(function (MediaItemEntityType) {
	    MediaItemEntityType["shortform"] = "shortform";
	    MediaItemEntityType["longform"] = "longform";
	})(MediaItemEntityType$7 || (MediaItemEntityType$7 = {}));
	var MediaItemEntityType$8 = MediaItemEntityType$7;

	var MediaItemType$6;	})(MediaItemType$6 || (MediaItemType$6 = {}));
	var MediaItemType$7 = MediaItemType$6;

	var ApiSource$a;	})(ApiSource$a || (ApiSource$a = {}));
	var ApiSource$b = ApiSource$a;

	var MediaItemAuthenticationType$a;
	(function (MediaItemAuthenticationType) {
	    MediaItemAuthenticationType["open"] = "OPEN";
	    MediaItemAuthenticationType["direct"] = "DIRECT";
	    MediaItemAuthenticationType["mvpd"] = "MVPD";
	    MediaItemAuthenticationType["isp"] = "ISP";
	    MediaItemAuthenticationType["none"] = "NONE";
	})(MediaItemAuthenticationType$a || (MediaItemAuthenticationType$a = {}));

	var MediaItemSourceType$8;	})(MediaItemSourceType$8 || (MediaItemSourceType$8 = {}));

	function QueryStringParser(identifier) {
	    const query = identifier.split('?')[1];
	    const result = {};
	    if (query) {
	        const vars = query.split('&');
	        for (let i = 0; i < vars.length; i += 1) {
	            const pair = vars[i].split('=');
	            result[pair[0]] = pair[1];
	        }
	    }
	    return result;
	}

	class MediaItemIdentifier {
	    constructor(identifier) {
	        const query = QueryStringParser(identifier);
	        this.original = identifier;
	        this.id = (query.videoID || query.playID || query.clip || query.externalId);
	        if (identifier.match('sportscenter')) {
	            this.gameId = query.playGameID;
	            this.channel = query.playChannel;
	            this.simulcastAiringId = query.simulcastAiringId;
	            const resumeTime = parseInt(query.resumeTime, 10);
	            if (!isNaN(resumeTime)) {
	                this.resumeTime = resumeTime;
	            }
	            this.eventId = query.eventId;
	        }
	        else if (identifier.match('abcnews')) {
	            this.channel = query.playChannel;
	            this.id = (query.videoID || query.id);
	        }
	        this.source = query['x-source'];
	        if (query.videoID) {
	            this.entityType = MediaItemEntityType$8.shortform;
	        }
	        else {
	            this.entityType = MediaItemEntityType$8.longform;
	        }
	        this.type = MediaItemType$7.video;
	    }
	    toString(source) {
	        if (source == ApiSource$b.graphQL) {
	            return `<MediaItemIdentifier id:${this.id}, gameId:${this.gameId}, channel:${this.channel}, source:${this.source}>`;
	        }
	        else {
	            return `<MediaItemIdentifier id:${this.id}, source:${this.source}>`;
	        }
	    }
	    static identifierStringForNetwork(id, source) {
	        switch (source) {
	            case ApiSource$b.cfa:
	                return `natgeo://playVideo?videoID=${id}`;
	            case ApiSource$b.itemFeed:
	                return `abcnews://playVideo?playChannel=${id}`;
	            case ApiSource$b.graphQL:
	            default:
	                return `sportscenter://x-callback-url/showWatchStream?playChannel=${id}`;
	        }
	    }
	}

	const defaultGraphQLServiceUrl$5 = 'https://watch.graph.api.espn.com/api';
	const defaultGraphQLApiKey$5 = 'd15c5790-7cb0-4fe1-8782-25f4698d0739';
	const defaultGraphQLNetworkSortOrder$5 = [
	    'espn_ppv',
	    'espn_dtc',
	    'espn1',
	    'espn2',
	    'espn3',
	    'espnu',
	    'sec',
	    'espnews',
	    'espndeportes',
	    'longhorn',
	    'goalline',
	    'buzzerbeater',
	    'secplus',
	    'acc',
	    'accextra',
	    'espn_free',
	    'bam_dtc',
	];
	const defaultItemFeedServiceUrl$5 = 'https://abcnews.go.com/video/itemfeed';
	class Configuration$7 {
	    constructor(apiSource, serviceUrl, apiKey, networkSortOrder) {
	        if (apiSource === ApiSource$b.graphQL) {
	            this.serviceUrl = serviceUrl || defaultGraphQLServiceUrl$5;
	            this.apiKey = apiKey || defaultGraphQLApiKey$5;
	            this.networkSortOrder = networkSortOrder || defaultGraphQLNetworkSortOrder$5;
	        }
	        else if (apiSource === ApiSource$b.cfa) {
	            this.apiSource = apiSource;
	            this.serviceUrl = serviceUrl;
	        }
	        else if (apiSource === ApiSource$b.itemFeed) {
	            this.serviceUrl = serviceUrl || defaultItemFeedServiceUrl$5;
	        }
	    }
	}

	new Configuration$7(ApiSource$b.graphQL);

	Object.freeze({});
	Object.freeze({});
	ApiSource$b.itemFeed;

	new Configuration$7(ApiSource$b.itemFeed);

	const DEFAULT_CONFIG$4 = {
	    interval: 60000,
	    watchProp: 'id',
	};
	const UNIVERSAL_API_SOURCES = {
	    [ApiSource$b.cfa]: true,
	    [ApiSource$b.pluto]: true,
	    [ApiSource$b.graphQL]: true,
	    [ApiSource$b.itemFeed]: true,
	};
	const DEFAULT_API_SOURCE = ApiSource$b.graphQL;
	class ProgramChangeMonitor {
	  }
	  }
	  }
	    start() {
	        if (!(this.mediaItem.isLinear && this.mediaItem.isLive)) {
	            return;
	        }
	        this.intervalId = setInterv }, this.configuration_.interval);
	    }
	    s }
	    checkProgramChange() {
	        if (!this.mediaItem || !this.mediaItemDataSource) {
	            return;
	        }
	        const { countryCode, configuration_: { watchProp }, } = this;
	        const { mediaItem, mediaItem: { network, apiSource, references = {} }, } = this;
	        const networkId = network === null || network === void 0 ? void 0 : network.id;
	        if (!networkId) {
	            loglevel.warn(`cannot monitor for program changes on network ${networkId}`);
	            return;
	        }
	        const source = apiSource in UNIVERSAL_API_SOURCES ? apiSource : DEFAULT_API_SOURCE;
	        const identifier = MediaItemIdentifier.identifierStringForNetwork(networkId, source);
	        this.mediaItemDataSource.getMediaItems([identifier], { countryCode }).then((mediaItems) => {
	            var _a;
	            const nextMediaItem = Array.isArray(mediaItems) && mediaItems[0];
	            if (!nextMediaItem) {
	                return;
	            }
	            const programDidChange = mediaItem[watchProp] !== nextMediaItem[watchProp] &&
	                (!(references === null || references === void 0 ? void 0 : references.simulcastAiringId) || references.simulcastAiringId !== ((_a = nextMediaItem.references) === null || _a === void 0 ? void 0 : _a.simulcastAiringId));
	            if (programDidChange) {
	                this.mediaItem = nextMediaItem;
	                this.onProgramChange(nextMediaItem);
	            }
	        });
	    }
	  }
	}	}

	E.prototype = {
	  o },

	  onc },

	  emi },

	  of }
	};

	var tinyEmitter = E;
	var TinyEmitter = E;
	tinyEmitter.TinyEmitter = TinyEmitter;

	var core = createCommonjsModule(function (module, exports) {	}(commonjsGlobal, function () {

		/**
		 * CryptoJS core components.
		 */
		var CryptoJS = CryptoJS || (function (Math, undefined$1) {
		    /*
		     * Local polyfil of Object.create
		     */
		    var create = Object.create | }());

		    /**
		     * CryptoJS namespace.
		     */
		    var C = {};

		    /**
		     * Library namespace.
		     */
		    var C_lib = C.lib = {};

		    /**
		     * Base object for prototypal inheritance.
		     */
		    var Base = C_lib.Base  }());

		    /**
		     * An array of 32-bit words.
		     *
		     * @property {Array} words The array of 32-bit words.
		     * @property {number} sigBytes The number of significant bytes in this word array.
		     */
		    var WordArray = C_lib.WordArray = Base.extend({
		        /**
		         * Initializes a newly created word array.
		         *
		         * @param {Array} words (Optional) An array of 32-bit words.
		         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.lib.WordArray.create();
		         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
		         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
		         */
		        ini },

		        /**
		         * Converts this word array to a string.
		         *
		         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
		         *
		         * @return {string} The stringified word array.
		         *
		         * @example
		         *
		         *     var string = wordArray + '';
		         *     var string = wordArray.toString();
		         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
		         */
		        toStrin },

		        /**
		         * Concatenates a word array to this word array.
		         *
		         * @param {WordArray} wordArray The word array to append.
		         *
		         * @return {WordArray} This word array.
		         *
		         * @example
		         *
		         *     wordArray1.concat(wordArray2);
		         */
		        conca },

		        /**
		         * Removes insignificant bits.
		         *
		         * @example
		         *
		         *     wordArray.clamp();
		         */
		        clam },

		        /**
		         * Creates a copy of this word array.
		         *
		         * @return {WordArray} The clone.
		         *
		         * @example
		         *
		         *     var clone = wordArray.clone();
		         */
		        clon },

		        /**
		         * Creates a word array filled with random bytes.
		         *
		         * @param {number} nBytes The number of random bytes to generate.
		         *
		         * @return {WordArray} The random word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.lib.WordArray.random(16);
		         */
		        rando }
		    });

		    /**
		     * Encoder namespace.
		     */
		    var C_enc = C.enc = {};

		    /**
		     * Hex encoding strategy.
		     */
		    var Hex = C_enc.Hex = {
		        /**
		         * Converts a word array to a hex string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The hex string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
		         */
		        stringif },

		        /**
		         * Converts a hex string to a word array.
		         *
		         * @param {string} hexStr The hex string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
		         */
		        pars }
		    };

		    /**
		     * Latin1 encoding strategy.
		     */
		    var Latin1 = C_enc.Latin1 = {
		        /**
		         * Converts a word array to a Latin1 string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The Latin1 string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
		         */
		        stringif },

		        /**
		         * Converts a Latin1 string to a word array.
		         *
		         * @param {string} latin1Str The Latin1 string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
		         */
		        pars }
		    };

		    /**
		     * UTF-8 encoding strategy.
		     */
		    var Utf8 = C_enc.Utf8 = {
		        /**
		         * Converts a word array to a UTF-8 string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The UTF-8 string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
		         */
		        stringif },

		        /**
		         * Converts a UTF-8 string to a word array.
		         *
		         * @param {string} utf8Str The UTF-8 string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
		         */
		        pars }
		    };

		    /**
		     * Abstract buffered block algorithm template.
		     *
		     * The property blockSize must be implemented in a concrete subtype.
		     *
		     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
		     */
		    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
		        /**
		         * Resets this block algorithm's data buffer to its initial state.
		         *
		         * @example
		         *
		         *     bufferedBlockAlgorithm.reset();
		         */
		        rese },

		        /**
		         * Adds new data to this block algorithm's buffer.
		         *
		         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
		         *
		         * @example
		         *
		         *     bufferedBlockAlgorithm._append('data');
		         *     bufferedBlockAlgorithm._append(wordArray);
		         */
		        _appen },

		        /**
		         * Processes available data blocks.
		         *
		         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
		         *
		         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
		         *
		         * @return {WordArray} The processed data.
		         *
		         * @example
		         *
		         *     var processedData = bufferedBlockAlgorithm._process();
		         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
		         */
		        _proces },

		        /**
		         * Creates a copy of this object.
		         *
		         * @return {Object} The clone.
		         *
		         * @example
		         *
		         *     var clone = bufferedBlockAlgorithm.clone();
		         */
		        clone: function () {
		            var clone = Base.clone.call(this);
		            clone._data = this._data.clone();

		            return clone;
		        },

		        _minBufferSize: 0
		    });

		    /**
		     * Abstract hasher template.
		     *
		     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
		     */
		    C_lib.Hasher = BufferedBlockAlgorithm.extend({
		        /**
		         * Configuration options.
		         */
		        cfg: Base.extend(),

		        /**
		         * Initializes a newly created hasher.
		         *
		         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
		         *
		         * @example
		         *
		         *     var hasher = CryptoJS.algo.SHA256.create();
		         */
		        ini },

		        /**
		         * Resets this hasher to its initial state.
		         *
		         * @example
		         *
		         *     hasher.reset();
		         */
		        rese },

		        /**
		         * Updates this hasher with a message.
		         *
		         * @param {WordArray|string} messageUpdate The message to append.
		         *
		         * @return {Hasher} This hasher.
		         *
		         * @example
		         *
		         *     hasher.update('message');
		         *     hasher.update(wordArray);
		         */
		        updat },

		        /**
		         * Finalizes the hash computation.
		         * Note that the finalize operation is effectively a destructive, read-once operation.
		         *
		         * @param {WordArray|string} messageUpdate (Optional) A final message update.
		         *
		         * @return {WordArray} The hash.
		         *
		         * @example
		         *
		         *     var hash = hasher.finalize();
		         *     var hash = hasher.finalize('message');
		         *     var hash = hasher.finalize(wordArray);
		         */
		        finaliz },

		        blockSize: 512/32,

		        /**
		         * Creates a shortcut function to a hasher's object interface.
		         *
		         * @param {Hasher} hasher The hasher to create a helper for.
		         *
		         * @return {Function} The shortcut function.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
		         */
		        _createHelpe },

		        /**
		         * Creates a shortcut function to the HMAC's object interface.
		         *
		         * @param {Hasher} hasher The hasher to use in this HMAC helper.
		         *
		         * @return {Function} The shortcut function.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
		         */
		        _createHmacHelpe }
		    });

		    /**
		     * Algorithm namespace.
		     */
		    var C_algo = C.algo = {};

		    return C;
		}(Math));


		return CryptoJS;

	}));
	});

	var encBase64 = createCommonjsModule(function (module, exports) {
	(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(core);
		}
	}(commonjsGlobal, function (CryptoJS) {

		(function () {
		    // Shortcuts
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var C_enc = C.enc;

		    /**
		     * Base64 encoding strategy.
		     */
		    C_enc.Base64 = {
		        /**
		         * Converts a word array to a Base64 string.
		         *
		         * @param {WordArray} wordArray The word array.
		         *
		         * @return {string} The Base64 string.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
		         */
		        stringif },

		        /**
		         * Converts a Base64 string to a word array.
		         *
		         * @param {string} base64Str The Base64 string.
		         *
		         * @return {WordArray} The word array.
		         *
		         * @static
		         *
		         * @example
		         *
		         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
		         */
		        pars },

		        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
		    };

		  }
		}());


		return CryptoJS.enc.Base64;

	}));
	});

	var encUtf8 = createCommonjsModule(function (module, exports) {
	(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(core);
		}
	}(commonjsGloba	}));
	});

	var AtvlPlayerEvent;
	(function (AtvlPlayerEvent) {
	    AtvlPlayerEvent["willStartPlaying"] = "atv.player.willStartPlaying";
	    AtvlPlayerEvent["didStopPlaying"] = "atv.player.didStopPlaying";
	    AtvlPlayerEvent["onTimedMetadataChanged"] = "atv.player.onTimedMetadataChanged";
	    AtvlPlayerEvent["playerStateChanged"] = "atv.player.playerStateChanged";
	    AtvlPlayerEvent["playerTimeDidChange"] = "atv.player.playerTimeDidChange";
	})(AtvlPlayerEvent || (AtvlPlayerEvent = {}));

	var ID3MetadataTag;
	(function (ID3MetadataTag) {
	    ID3MetadataTag["priv"] = "PRIV";
	    ID3MetadataTag["txxx"] = "TXXX";
	})(ID3MetadataTag || (ID3MetadataTag = {}));
	var ID3HeartbeatType;
	(function (ID3HeartbeatType) {
	    ID3HeartbeatType["program"] = "PROGRAM";
	    ID3HeartbeatType["commercial"] = "COMMERCIAL";
	    ID3HeartbeatType["slate"] = "SLATE";
	})(ID3HeartbeatType || (ID3HeartbeatType = {}));

	var PlayerAdaptorEvent;
	(function (PlayerAdaptorEvent) {
	    PlayerAdaptorEvent["start"] = "start";
	    PlayerAdaptorEvent["playing"] = "playing";
	    PlayerAdaptorEvent["pause"] = "pause";
	    PlayerAdaptorEvent["seeking"] = "seeking";
	    PlayerAdaptorEvent["stalled"] = "stalled";
	    PlayerAdaptorEvent["stop"] = "stop";
	    PlayerAdaptorEvent["timedMetadata"] = "timedMetadata";
	    PlayerAdaptorEvent["currentTime"] = "currentTime";
	    PlayerAdaptorEvent["loadedMetadata"] = "loadedMetadata";
	})(PlayerAdaptorEvent || (PlayerAdaptorEvent = {}));
	var PlayerAdaptorEvent$1 = PlayerAdaptorEvent;

	var TrilithiumPlayerEvent;	})(TrilithiumPlayerEvent || (TrilithiumPlayerEvent = {}));

	class WebPlayerBundleAdaptor {
	    construc }
	    createHandlerForCallback(callback) {
	        const handler = evtData => {
	            let currentTime = evtData && evtData.currentTime;
	            if (!currentTime && !evtData) {
	                currentTime = this.playerBundle.currentTime();
	            }
	            if (typeof currentTime === 'number') {
	                callback(currentTime);
	            }
	            else {
	                callback(evtData);
	            }
	        };
	        this.eventHandlers.push([callback, handler]);
	        return handler;
	    }
	    getIndexOfHandlerForCallback(findCallback) {
	        const { eventHandlers } = this;
	        const len = eventHandlers.length;
	        let index = -1;
	        for (let i = 0; i < len; i += 1) {
	            const [callback] = eventHandlers[i];
	            if (callback === findCallback) {
	                index = i;
	                break;
	            }
	        }
	        return index;
	    }
	    on(evtName, callback) {
	        const mappedEventName = this.getMappedEventName_(evtName);
	        const handler = this.createHandlerForCallback(callback);
	        this.playerBundle.coordinator.addEventListener(mappedEventName, handler);
	    }
	    off(evtName, callback) {
	        const { eventHandlers } = this;
	        const mappedEventName = this.getMappedEventName_(evtName);
	        const handlerIndex = this.getIndexOfHandlerForCallback(callback);
	        if (handlerIndex > -1) {
	            const [, handler] = eventHandlers[handlerIndex];
	            this.playerBundle.coordinator.removeEventListener(mappedEventName, handler);
	            eventHandlers.splice(handlerIndex, 1);
	        }
	    }
	    once(evtName, callback) {
	        const handler = evtData => {
	            callback(evtData);
	            this.off(evtName, handler);
	        };
	        this.on(evtName, handler);
	    }
	  }
	  }
	}
	WebPlayerBundleAdaptor.EVENT_NAME_MAP = {
	    start: 'dtci.play',
	    playing: 'dtci.playing',
	    pause: 'dtci.pause',
	    complete: 'dtci.contentEnded',
	    loadedMetadata: 'dtci.loadedMetadata',
	    seeked: 'dtci.seeked',
	    dispose: 'dtci.dispose',
	    currentTime: 'dtci.timeupdate',
	    buffer: 'dtci.buffer',
	    error: 'dtci.error',
	    adBreakStart: 'dtci.ads-ad-started',
	    adBreakEnd: 'dtci.ads-ad-ended',
	};

	const NielsenEnvironment = {
	    production: 'PROD',
	    testing: 'TESTING',
	};
	const serviceUrls = {};
	serviceUrls[NielsenEnvironment.production] = 'https://cloudapi.imrworldwide.com/nmapi/v2';
	serviceUrls[NielsenEnvironment.testing] = 'https://sandbox-cloudapi.imrworldwide.com/nmapi/v2';

	class PlayerPlugin {
	  }
	  }
	    firstPlay(position) {
	        this.didFirstPlay = true;
	    }
	  }
	    play(position) {
	        if (!this.didFirstPlay) {
	            this.firstPlay(position);
	        }
	        if (!this.didFirstPlayOfContent) {
	            this.firstPlayOfContent(position);
	        }
	    }
	    loadedMetadata(metadata) { }
	    pause(position) { }
	    complete(position) { }
	    seek(position) { }
	    release(position) { }
	    progressChange(position) { }
	    buffer(position) { }
	    error(position) { }
	    adBreakStart(position) { }
	    adBreakEnd(position) { }
	    dispose() {
	        this.delegate = null;
	        this.config = null;
	        this.mediaItem = null;
	    }
	}

	const EVENT_NAMES = {
	    PLAY: PlayerAdaptorEvent$1.start,
	    PLAYING: PlayerAdaptorEvent$1.playing,
	    PAUSE: PlayerAdaptorEvent$1.pause,
	    COMPLETE: 'complete',
	    LOADED_METADATA: 'loadedMetadata',
	    SEEK: 'seeked',
	    RELEASE: 'dispose',
	    PROGRESS_CHANGE: PlayerAdaptorEvent$1.currentTime,
	    BUFFER: 'buffer',
	    ERROR: 'error',
	    AD_BREAK_START: 'adBreakStart',
	    AD_BREAK_END: 'adBreakEnd',
	};
	function getCurrentTimeFromEvent(evt) {
	    let currentTime = NaN;
	    if (evt && typeof evt === 'object' && 'timeStamp' in evt) {
	        currentTime = evt.timeStamp;
	    }
	    else {
	        currentTime = parseInt(evt, 10);
	    }
	    return currentTime;
	}
	class PlayerPluginManager {
	    constructor(playerAdaptor, plugins, config) {
	        this.playerAdaptor = playerAdaptor;
	        this.plugins = [];
	        this.config = config;
	        this.play = this.play.bind(this);
	        this.playing = this.playing.bind(this);
	        this.loadedMetadata = this.loadedMetadata.bind(this);
	        this.pause = this.pause.bind(this);
	        this.complete = this.complete.bind(this);
	        this.seek = this.seek.bind(this);
	        this.release = this.release.bind(this);
	        this.progressChange = this.progressChange.bind(this);
	        this.buffer = this.buffer.bind(this);
	        this.error = this.error.bind(this);
	        this.adBreakStart = this.adBreakStart.bind(this);
	        this.adBreakEnd = this.adBreakEnd.bind(this);
	        this.addPlugins(plugins);
	        this.bindEventListeners();
	    }
	    setMediaItem(mediaItem) {
	        this.callOnPlugins('setMediaItem', mediaItem);
	    }
	    addPlugins(plugins) {
	        if (plugins && plugins.length) {
	            plugins.forEach(plugin => this.addPlugin(plugin));
	        }
	    }
	    addPlugin(Plugin) {
	        let pluginInstance;
	        if (Plugin instanceof PlayerPlugin || Plugin.delegate) {
	            pluginInstance = Plugin;
	        }
	        else {
	            pluginInstance = new Plugin(this.playerAdaptor, this.config);
	        }
	        this.plugins.push(pluginInstance);
	    }
	    play(evt) {
	        this.callOnPlugins('play', getCurrentTimeFromEvent(evt));
	    }
	    playing(evt) {
	        this.callOnPlugins('playing', getCurrentTimeFromEvent(evt));
	    }
	    pause(evt) {
	        this.callOnPlugins('pause', getCurrentTimeFromEvent(evt));
	    }
	    complete(evt) {
	        this.callOnPlugins('complete', getCurrentTimeFromEvent(evt));
	    }
	  }
	    seek(evt) {
	        this.callOnPlugins('seek', getCurrentTimeFromEvent(evt));
	    }
	    release(evt) {
	        this.callOnPlugins('release', getCurrentTimeFromEvent(evt));
	    }
	    progressChange(evt) {
	        this.callOnPlugins('progressChange', getCurrentTimeFromEvent(evt));
	    }
	    buffer(evt) {
	        this.callOnPlugins('buffer', getCurrentTimeFromEvent(evt));
	    }
	    error(evt) {
	        this.callOnPlugins('error', getCurrentTimeFromEvent(evt));
	    }
	    adBreakStart(evt) {
	        this.callOnPlugins('adBreakStart', getCurrentTimeFromEvent(evt));
	    }
	  }
	    bindEventListeners() {
	        this.playerAdaptor.on(EVENT_NAMES.PLAY, this.play);
	        this.playerAdaptor.on(EVENT_NAMES.PLAYING, this.playing);
	        this.playerAdaptor.on(EVENT_NAMES.PAUSE, this.pause);
	        this.playerAdaptor.on(EVENT_NAMES.COMPLETE, this.complete);
	        this.playerAdaptor.on(EVENT_NAMES.LOADED_METADATA, this.loadedMetadata);
	        this.playerAdaptor.on(EVENT_NAMES.SEEK, this.seek);
	        this.playerAdaptor.on(EVENT_NAMES.RELEASE, this.release);
	        this.playerAdaptor.on(EVENT_NAMES.PROGRESS_CHANGE, this.progressChange);
	        this.playerAdaptor.on(EVENT_NAMES.BUFFER, this.buffer);
	        this.playerAdaptor.on(EVENT_NAMES.ERROR, this.error);
	        this.playerAdaptor.on(EVENT_NAMES.AD_BREAK_START, this.adBreakStart);
	        this.playerAdaptor.on(EVENT_NAMES.AD_BREAK_END, this.adBreakEnd);
	    }
	    unbindEventListeners() {
	        this.playerAdaptor.off(EVENT_NAMES.PLAY, this.play);
	        this.playerAdaptor.off(EVENT_NAMES.PLAYING, this.playing);
	        this.playerAdaptor.off(EVENT_NAMES.PAUSE, this.pause);
	        this.playerAdaptor.off(EVENT_NAMES.COMPLETE, this.complete);
	        this.playerAdaptor.off(EVENT_NAMES.LOADED_METADATA, this.loadedMetadata);
	        this.playerAdaptor.off(EVENT_NAMES.SEEK, this.seek);
	        this.playerAdaptor.off(EVENT_NAMES.RELEASE, this.release);
	        this.playerAdaptor.off(EVENT_NAMES.PROGRESS_CHANGE, this.progressChange);
	        this.playerAdaptor.off(EVENT_NAMES.BUFFER, this.buffer);
	        this.playerAdaptor.off(EVENT_NAMES.ERROR, this.error);
	        this.playerAdaptor.off(EVENT_NAMES.AD_BREAK_START, this.adBreakStart);
	        this.playerAdaptor.off(EVENT_NAMES.AD_BREAK_END, this.adBreakEnd);
	    }
	    callOnPlugins(functionName, ...args) {
	        if (Array.isArray(this.plugins)) {
	            this.plugins.forEach(plugin => {
	                const func = plugin[functionName];
	                if (typeof func === 'function') {
	                    try {
	                        plugin[functionName].apply(plugin, args);
	                    }
	                    catch (err) {
	                        loglevel.error(err);
	                    }
	                }
	            });
	        }
	    }
	    dispose() {
	        this.unbindEventListeners();
	        this.plugins.forEach(plugin => plugin.dispose());
	        this.plugins = [];
	        this.playerAdaptor = null;
	        this.config = null;
	    }
	}

	async function fetchMediaItemFromApi(playLoad, coordinator) {
	  try {
	    coordinator.coordinate(CUSTOM_EVENTS.FETCH_MEDIA_ITEM);
	    const {
	      identifier,
	      mediaItemApi = new UniversalMediaItemAPI(),
	      contentApi = {}
	    } = playLoad;
	    const {
	      env,
	      apiSource,
	      serviceUrl
	    } = contentApi;
	    if (env === 'qa' && apiSource && serviceUrl) {
	      mediaItemApi.configuration = new Configuration$8(apiSource, serviceUrl);
	    }
	    const mediaItems = await mediaItemApi.getMediaItems([identifier], {});
	    let mediaItem;
	    if (mediaItems && Array.isArray(mediaItems)) {
	      mediaItem = mediaItems.shift();
	    }
	    if (mediaItem) {
	      coordinator.coordinate(CUSTOM_EVENTS.FETCH_MEDIA_ITEM_FINISHED, true);
	      return mediaItem;
	    }
	    throw NewRelicService$1.generateMediaItemTemporarilyUnavailable(identifier, ERROR_CODES.MEDIA_ITEM_MISSING, "There's a problem playing this video.");
	  } catch (err) {
	    coordinator.coordinate(CUSTOM_EVENTS.FETCH_MEDIA_ITEM_FINISHED, false);
	    let errorException = err;
	    if (!(err instanceof ErrorExceptionEvent)) {
	      errorException = NewRelicService$1.generateMediaItemTemporarilyUnavailable(playLoad.identifier, null, 'Get media items error', err);
	    }
	    throw errorException;
	  }
	}

	var lodash_mergewith = createCommonjsModule(function (module, exports) {
	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	    getPrototype = overArg(Object.getPrototypeOf, Object),
	    objectCreate = Object.create,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeMax = Math.max,
	    nativeNow = Date.now;

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map'),
	    nativeCreate = getNative(Object, 'create');

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate 	}());

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 *	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 *	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 *	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 *	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 *	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 *	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 *	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 *	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 *	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 *	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 *	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 *	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 *	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 *	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 *	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 *	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 *	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 *	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 *	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 *	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 *	}

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 *	}

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 *	}

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 *	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 *	}

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 *	}

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 *	}

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 *	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 *	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 *	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 *	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 *	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 *	}

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 *	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString.call(Ctor) == objectCtorString;
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 *	}

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	/**
	 * This method is like `_.merge` except that it accepts `customizer` which
	 * is invoked to produce the merged values of the destination and source
	 * properties. If `customizer` returns `undefined`, merging is handled by the
	 * method instead. The `customizer` is invoked with six arguments:
	 * (objValue, srcValue, key, object, source, stack).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} customizer The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   if (_.isArray(objValue)) {
	 *     return objValue.concat(srcValue);
	 *   }
	 * }
	 *
	 * var object = { 'a': [1], 'b': [2] };
	 * var other = { 'a': [3], 'b': [4] };
	 *
	 * _.mergeWith(object, other, customizer);
	 * // => { 'a': [1, 3], 'b': [2, 4] }
	 */
	var mergeWith = createAssign	});

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = mergeWith;
	});

	// prettier-ignore
	var config$1 = {
	  mailToLink: 'mailto:?subject={{subject}}&body={{body}}',
	  sendMailUrl: 'http://proxy.espn.com/videohub/player/sendMail?id={{id}}&clipName={{clipName}}&youremail={{youremail}}&friendemail={{friendemail}}&message={{message}}&videoImage={{videoImage}}',
	  embedCode: '<iframe width="640" height="360" src="http://www.espn.com/core/video/iframe?id={{ID}}&endcard=false" allowfullscreen frameborder="0"></iframe>',
	  deeplinking: true,
	  services: {
	    facebook: true,
	    google: false,
	    twitter: true,
	    tumblr: false,
	    pinterest: false,
	    linkedin: false,
	    email: true,
	    directlink: true,
	    embed: true
	  }
	};

	// eslint-disable-next-line consistent-return
	function mergeCustomizer$2(objValue, srcValue) {
	  if (srcValue === null) {
	    return objValue;
	  }
	}
	class Social {
	  constructor(mediainfo, options, brand) {
	    this.opts = null;
	    this.opts = lodash_mergewith({}, config$1, mergeCustomizer$2);
	    if (options && typeof options === 'object') {
	      lodash_mergewith(this.opts, options, mergeCustomizer$2);
	    }
	    if (brand) {
	      this.opts.brand = brand;
	    }
	    this.opts = this.updateOptions(mediainfo, this.opts);
	  }
	  updateOptions(mediainfo, options) {
	    options.id = options.id || mediainfo.id;
	    options.brand = options.brand || mediainfo.brand;
	    options.title = mediainfo.headline || mediainfo.pageTitle;
	    options.description = mediainfo.description;
	    options.url = mediainfo.webHref ? mediainfo.webHref : options.url && options.url.replace(/{{ID}}/g, mediainfo.id) || options.url || mediainfo.web;
	    options.poster = mediainfo.poster;
	    options.syndicatable = !!mediainfo.syndicatable;
	    options.embedCode = options.embedCode && options.embedCode.replace(/{{ID}}/g, mediainfo.id);
	    options.pauseOnOpen = true;
	    options.showOffset = true;
	    if (options.services && options.services.embed) {
	      options.services.embed = options.syndicatable;
	    }
	    if (mediainfo.type === 'live') {
	      options.pauseOnOpen = false;
	      options.showOffset = false;
	    }
	    return options;
	  }
	  get options() {
	    return this.opts;
	  }
	  set options(options) {
	    this.opts = options;
	  }
	}

	var push$1 = uncurryThis$1([].push);

	var getJsonReplacerFunction	};

	var getReplacerFunction = getJsonReplacerFunction;

	var $String = String;
	var $stringify = getBuiltIn('JSON', 'stringify');
	var exec = uncurryThis$1(/./.exec);
	var charAt = uncurryThis$1(''.charAt);
	var charCodeAt = uncurryThis$1(''.charCodeAt);
	var replace$1 = uncurryThis$1(''.replace);
	var numberToString = uncurryThis$1(1.0.toString);

	var tester = /[\uD800-\uDFFF]/g;
	var low = /^[\uD800-\uDBFF]$/;
	var hi = /^[\uDC00-\uDFFF]$/;

	var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fai	});

	// https://github.com/tc39/proposal-well-formed-stringify
	var ILL_FORMED_UNICODE = fai	});

	var stringifyWithSymbolsFix	};

	var fixIllFormed	};

	if ($stringify) {
	  // `JSON.stringify` method
	  // https://tc39.es/ecma262/#sec-json.stringify
	  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
	    // eslint-disable-next-line no-unused-vars -- required for `.length`
	    stringif }
	  });
	}

	// eslint-disable-next-line es/no-json -- safe
	if (!path.JSON) path.JSON = { stringify: JSON.stringify };

	// eslint-disable-next-line no-unused-vars -- required for `.length`
	var stringify$2	};

	var parent$8 = stringify$2;

	var stringify$1 = parent$8;

	var require$$0$b = stringify$1;

	var stringify = require$$0$b;

	// a string of all valid unicode whitespaces
	var whitespaces$1 = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
	  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespaces = whitespaces$1;

	var replace = uncurryThis$1(''.replace);
	var ltrim = RegExp('^[' + whitespaces + ']+');
	var rtrim = RegExp('(^|[^' + whitespaces + '])[' + whitespaces + ']+$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod$1	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
	  start: createMethod$1(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimend
	  end: createMethod$1(2),
	  // `String.prototype.trim` method
	  // https://tc39.es/ecma262/#sec-string.prototype.trim
	  trim: createMethod$1(3)
	};

	var PROPER_FUNCTION_NAME = require$$0$l.PROPER;



	var non = '\u200B\u0085\u180E';

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var stringTrimForced	};

	var require$$0$a = stringTrim;

	var forcedStringTrimMethod = stringTrimForced;

	var $trim = require$$0$a.trim;


	// `String.prototype.trim` method
	// https://tc39.es/ecma262/#sec-string.prototype.trim
	$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
	  tri }
	});

	var trim$3 = entryVirtual('String').trim;

	var method$3 = trim$3;

	var StringPrototype = String.prototype;

	var trim$2	};

	var parent$7 = trim$2;

	var trim$1 = parent$7;

	var require$$0$9 = trim$1;

	var trim = require$$0$9;

	/* eslint-disable no-plusplus */
	/* eslint-disable no-bitwise */

	/* globals videojs */

	// From https://edgecastcdn.net/00BB17/fiosmobile/develop/uplynk/web-player-test-app-1.0.8/app/components/utils/fairplay-utils.j	}
	function base64EncodeUint8Array(input) {
	  const keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	  let output = '';
	  let chr1;
	  let chr2;
	  let chr3;
	  let enc1;
	  let enc2;
	  let enc3;
	  let enc4;
	  let i = 0;
	  while (i < input.length) {
	    chr1 = input[i++];
	    chr2 = i < input.length ? input[i++] : Number.NaN; // Not sure if the index
	    chr3 = i < input.length ? input[i++] : Number.NaN; // checks are needed here

	    enc1 = chr1 >> 2;
	    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
	    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
	    enc4 = chr3 & 63;
	    if (isNaN(chr2)) {
	      enc3 = 64;
	      enc4 = 64;
	    } else if (isNaN(chr3)) {
	      enc4 = 64;
	    }
	    output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
	  }
	  return output;
	}
	function base64DecodeUint8Array(input) {
	  const raw = window.atob(input);
	  const rawLength = raw.length;
	  const array = new Uint8Array(new ArrayBuffer(rawLength));
	  for (let i = 0; i < rawLength; i++) {
	    array[i] = raw.charCodeAt(i);
	  }
	  return array;
	}
	let licenseURL;
	function getCertificate(emeOptions, callback) {
	  const requestCertUri = emeOptions.keySystems['com.apple.fps.1_0'].certificateUri;
	  videojs.xhr({
	    uri: requestCertUri,
	    responseType: 'arraybuffer'
	  }, (err, response) => {
	    if (err) {
	      callback(err);
	      return;
	    }
	    const certificate = new Uint8Array(response.body);
	    callback(null, certificate);
	  });
	}
	function getContentId(emeOptions, initData) {
	  const contentId = arrayToString(initData);
	  let spcurl = contentId.replace('skd://', 'https://');
	  spcurl = spcurl.substring(1, spcurl.length);
	  // split the url and use the query parameters as the license identifier.
	  let id = spcurl.split('?')[1];
	  if (id.length > 100) {
	    // content id's cannot be longer than 100 bytes or the license request never gets sent.
	    id = id.substring(0, 100);
	  }
	  // save the license URL in a global location with the content ID as a lookup key
	  // to be later used for posting the license
	  licenseURL = spcurl;
	  return id;
	}
	function getLicense(emeOptions, contentId, keyMessage, callback) {
	  const spcMessage = base64EncodeUint8Array(keyMessage);
	  const ckcRequest = {
	    spc: spcMessage
	  };
	  const payload = stringify(ckcRequest);
	  const xhr = new XMLHttpRequest();
	  xhr.addEventListener('readystatechange', () => {
	    if (xhr.readyState === 4) {
	      var _context;
	      const wrapped = JSON.parse(trim(_context = xhr.responseText).call(_context));
	      const key = base64DecodeUint8Array(wrapped.ckc);
	      callback(null, key);
	      // player.play();
	    }
	  });

	  xhr.open('POST', licenseURL);
	  xhr.send(payload);
	}

	function request(url) {
	  return new promise((resolve, reject) => {
	    const xhr = new XMLHttpRequest();
	    xhr.open('GET', url, true);
	    xhr.onreadystatechange = () => {
	      if (xhr.readyState === 4) {
	        if (xhr.status === 200) {
	          resolve(xhr.response);
	        } else {
	          reject(new Error(`Error, ${url}`));
	        }
	      }
	    };
	    xhr.send();
	  });
	}
	async function parseXML(mdpUrl) {
	  let parser;
	  let xmlDoc;
	  const data = await request(mdpUrl);
	  if (window.DOMParser) {
	    parser = new DOMParser();
	    xmlDoc = parser.parseFromString(data, 'text/xml');
	  }
	  return xmlDoc;
	}
	function b64ToUint6(nChr) {
	  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
	}
	function base64DecToArr(sBase64, nBlockSize) {
	  const sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, '');
	  const nInLen = sB64Enc.length;
	  const nOutLen = nBlockSize ? Math.ceil((nInLen * 3 + 1 >>> 2) / nBlockSize) * nBlockSize : nInLen * 3 + 1 >>> 2;
	  const aBytes = new Uint8Array(nOutLen);
	  for (let nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
	    nMod4 = nInIdx & 3;
	    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
	    if (nMod4 === 3 || nInLen - nInIdx === 1) {
	      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
	        aBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
	      }
	      nUint24 = 0;
	    }
	  }
	  return aBytes;
	}
	function decodeLicense(licenseElement, isPlayready) {
	  if (isPlayready) {
	    const decodePlayReadyData = String.fromCharCode.apply(null, new Uint16Array(base64DecToArr(licenseElement.textContent, 2).buffer));
	    const regex = new RegExp(/<LA_URL>(.*)<\/LA_URL>/);
	    return decodePlayReadyData.match(regex)[1];
	  }
	  const htmlValue = new DOMParser().parseFromString(licenseElement.outerHTML, 'text/xml');
	  return encodeURI(htmlValue.firstElementChild.attributes.licenseUrl.nodeValue);
	}
	async function getUplynkLicense(mdpUrl, keySystem) {
	  let license;
	  const isPlayready = keySystem === 'playready';
	  try {
	    const mdpData = await parseXML(mdpUrl);
	    if (mdpData) {
	      const tagName = isPlayready && IS_WINDOWS ? 'mspr:pro' : 'ms:laurl';
	      const licenseElement = (mdpData.getElementsByTagName(tagName) || [])[0];
	      if (licenseElement) {
	        license = decodeLicense(licenseElement, isPlayready && IS_WINDOWS);
	      } else {
	        license = (mdpData.getElementsByTagName('Location') || [])[0];
	      }
	    }
	  } catch (err) {
	    NewRelicService$1.playbackSessionFlowEvent({}, NewRelicService$1.generatePlayerDRMLicenseFailed('error fetching playreadylicense', err));
	  }
	  return license;
	}

	async function drmSourceBuilder(playbackSession) {
	  const {
	    playbackUrl: src,
	    playbackConfig,
	    mediaItem: {
	      source: mediaSource
	    } = {}
	  } = playbackSession || {};
	  const isEntertainment = mediaSource && mediaSource.type === 'entitlement' || false;
	  const {
	    contentType: type = null,
	    keySystem = null
	  } = playbackConfig || {};
	  let {
	    licenseUrl = null
	  } = playbackConfig || {};
	  const source = {
	    src,
	    type
	  };
	  if (isEntertainment && keySystem !== 'fairplay') {
	    licenseUrl = await getUplynkLicense(src, keySystem);
	  }
	  switch (keySystem) {
	    case keySystem === 'playready' && IS_WINDOWS:
	      source.keySystems = {
	        'com.microsoft.playready': licenseUrl
	      };
	      source.keySystemOptions = [{
	        name: 'com.microsoft.playready',
	        options: {
	          serverURL: licenseUrl
	        }
	      }];
	      break;
	    case 'fairplay':
	      source.keySystems = {
	        'com.apple.fps.1_0': {
	          certificateUri: licenseUrl,
	          getCertificate,
	          getContentId,
	          getLicense
	        }
	      };
	      break;
	    case 'widevine':
	      source.keySystems = {
	        'com.widevine.alpha': licenseUrl
	      };
	      source.keySystemOptions = [{
	        name: 'com.widevine.alpha',
	        options: {
	          serverURL: licenseUrl
	        }
	      }];
	  }
	  if (keySystem && keySystem !== 'none' && IS_EDGE_CHROMIUM && IS_WINDOWS) {
	    const playreadyLicense = isEntertainment ? licenseUrl : await getUplynkLicense(src, 'playready');
	    source.keySystems = {
	      'com.widevine.alpha': licenseUrl,
	      'com.microsoft.playready': playreadyLicense
	    };
	    source.keySystemOptions = [{
	      name: 'com.microsoft.playready',
	      options: {
	        serverURL: playreadyLicense
	      }
	    }, {
	      name: 'com.widevine.alpha',
	      options: {
	        serverURL: licenseUrl
	      }
	    }];
	  }
	  return source;
	}
	function drmSupportParam() {
	  let drmSupport; // Do not pass param for unsupported platforms

	  if (IS_WEBVIEW && !IS_ANDROID) {
	    drmSupport = 'HLS';
	  }
	  if (IS_ANDROID) {
	    drmSupport = null; // Explicitly force old Android, that doesn't support EME, to fail by passing an empty param
	  }

	  if (SUPPORTS_EME) {
	    if (IS_EDGE) {
	      drmSupport = 'DASH_PLAYREADY';
	    } else if (IE_VERSION) {
	      drmSupport = null; // Explicitly force IE to fail by passing an empty param
	    } else if (IS_FIREFOX || IS_CHROME && !IS_IOS /* exclude iOS Chrome */) {
	      drmSupport = 'DASH_WIDEVINE';
	    } else if (IS_SAFARI) {
	      drmSupport = 'HLS_FAIRPLAY';
	    }
	  } else {
	    console.warn('DTCIVideoPlayer: DRM was requested by configuration, but this browser does not support EME.');
	  }
	  return drmSupport;
	}
	function getDRMSupport(drmSupport, enabledDrmSupportValues = []) {
	  let drmSupport_ = drmSupport;
	  const enabledHLSDrmSupport = drmSupport === undefined || enabledDrmSupportValues.indexOf(drmSupport) === -1;
	  if (enabledHLSDrmSupport) {
	    drmSupport_ = 'HLS';
	  }
	  return drmSupport_;
	}

	var $TypeError$1 = TypeError;
	// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// Safari < 13 does not throw an error in this case
	var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS &	}();

	var arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET	}	};

	var $TypeError = TypeError;
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

	var doesNotExceedSafeInteger$1	};

	var setArrayLength = arraySetLength;

	var doesNotExceedSafeInteger = doesNotExceedSafeInteger$1;

	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('splice');

	var max = Math.max;
	var min = Math.min;

	// `Array.prototype.splice` method
	// https://tc39.es/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
	  splic }
	});

	var splice$3 = entryVirtual('Array').splice;

	var method$2 = splice$3;

	var ArrayPrototype$2 = Array.prototype;

	var splice$2 = function (it) {
	  var own = it.splice;
	  return it === ArrayPrototype$2 || (isPrototypeOf(ArrayPrototype$2, it) && own === ArrayPrototype$2.splice) ? method$2 : own;
	};

	var parent$6 = splice$2;

	var splice$1 = parent$6;

	var require$$0$8 = splice$1;

	var splice = require$$0$8;

	/*
	  If the video URL looks like:

	    http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_president_obama_bracket/dm_150318_ncb_feature_president_obama_bracket.m3u8

	  Then our thumbnail URLs should look like:

	    http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_president_obama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_{N}.jpg

	  Chapter thumbnails appear every 10 seconds, beginning at 0:00.

	  Builds an object like this:
	    {
	      "0": {
	        "src": "http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_presâ¦bama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_1.jpg"
	      },
	      "10": {
	        "src": "http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_presâ¦bama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_2.jpg"
	      },
	      "20": {
	        "src": "http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_presâ¦bama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_3.jpg"
	      },
	      "30": {
	        "src": "http://media.video-cdn.espn.com/motion/2015/0318/dm_150318_ncb_feature_presâ¦bama_bracket/chaptertn/dm_150318_ncb_feature_president_obama_bracket_4.jpg"
	      },
	    }
	 */
	function buildPrevewsFromVideoCDN(pathMatch, duration, imageConfig) {
	  const base = 'https://media.video-cdn.espn.com/motion/';
	  const parts = pathMatch.pop().split('/');
	  splice(parts).call(parts, -1, 0, 'chaptertn');

	  // Some playback URLs from MediaItem are suffixed with `_nolbr`, need to
	  // remove that to build a valid thumbnail URL
	  const path = parts.join('/').replace('_nolbr', '');
	  const numPreviews = Math.floor(duration / imageConfig.secondPerChapter);
	  const previews = {};
	  let i = 0;
	  while (i <= numPreviews) {
	    previews[`${i * 10}`] = {
	      src: `${base}${path}_${i += 1}.${imageConfig.extension}`,
	      width: imageConfig.width
	    };
	  }
	  return previews;
	}

	var global$1 =
	  (typeof globalThis !== 'undefined' && globalThis) ||
	  (typeof self !== 'undefined' && self) ||
	  (typeof global$1 !== 'undefined' && global$1);

	var support = {
	  searchParams: 'URLSearchParams' in global$1,
	  iterable: 'Symbol' in global$1 && 'iterator' in Symbol,
	  blob:
	    'FileReader' in global$1 &&
	    'Blob' in global$  }
	    })(),
	  formData: 'FormData' in global$1,
	  arrayBuffer: 'ArrayBuffer' in globOf(obj)
	}

	if (support.arrayBuffer) {
	  var viewClasses = [
	    '[object Int8Array]',
	    '[object Uint8Array]',
	    '[object Uint8ClampedArray]',
	    '[object Int16Array]',
	    '[object Uint16Array]',
	    '[object Int32Array]',
	    '[object Uint32Array]',
	    '[object Float32Array]',
	    '[object Float64Array]'
	  ];

	  var isArrayBufferView =
	    ArrayBuffer.isVi -1
	 rCn value
	}

	// Build a destructive iterator for the vte);
	  }
	}

	Headers.prototyp value;
	};

	Headers.prototype['name)];
	};

	Headers.proto : null
	};

	Headers.proto(name))
	};

	Headers.protovalue);
	};

	Headers.prototype }
	  }
	};

	Headers.protot(items)
	};

	Headers.prototyp(items)
	};

	Headers.prototype(items)
	};

	if (support.iterable) {
	  Headers.prototype[Symbol.iterator] = Headers.prototype.ent= ;
	  })
	}

	function readBlobAsArrayBuffer(blob) {
	  var reader = new FileReader();
	  var promise = fileReaderReady(reader);
	  reader.readAsArrayBuffer(blob);
	  return prproierrn this
	}

	// HTTP methods whose capitalization should be normalized
	var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', m }
	  }
	}

	Request.prototyyInrnheaders
	}

	Body.call(Request.proyInit);
	}

	Body.call(Response.prototype);

	Response.prototyl
	  })
	};

	Responesponse
	};

	var redirectStatuses = [301, 302, 303, 307, 308];

	Response. url}})
	};

	var DOMException = global$1.DOMException;
	try {
	  new DOMException();
	} catch (err) {
	  DOMEtack;
	  };
	  DOMException.prototype = Object.create(Error.prototype);
	  DOMException.prototype.constructor = DOMExcep;
	  })
	}

	fetch$1.polyfill = true;

	if (!global$1.fetch) {
	  global$1.fetch = fetch$1;
	  global$1.Headers = Headers;
	  global$1.Request = Request;
	  global$1.Response = Response;
	}

	async function fetchServices({
	  method,
	  postData,
	  headers,
	  url,
	  isAuthNeeded,
	  format
	}) {
	  const includeCredentials = isAuthNeeded ? {
	    credentials: 'include'
	  } : undefined;
	  const payload = {
	    ...includeCredentials,
	    method,
	    headers,
	    body: stringify(postData)
	  };
	  try {
	    const result = await fetch(url, payload);
	    if (!result.ok) {
	      throw new Error(`fetchServices failed with url: ${url}`);
	    }
	    let response;
	    if (format === 'VTT') {
	      response = await result.text();
	    } else {
	      response = await result.json();
	    }
	    return {
	      response,
	      success: true,
	      err: null
	    };
	  } catch (err) {
	    return {
	      response: null,
	      success: false,
	      err
	    };
	  }
	}

	async function buildPrevewsFromVDMS(idPath, imageConfig) {
	  const base = 'https://content.uplynk.com/player/assetinfo/ext/{id}.json';
	  const url = base.replace('{id}', idPath);
	  const result = await fetchServices({
	    url,
	    method: 'GET'
	  });
	  if (!result.success) {
	    return null;
	  }
	  const {
	    thumb_prefix: thumbBase,
	    duration,
	    slice_dur: sliceDur
	  } = result.response;
	  const secondPerChapter = sliceDur || imageConfig.secondPerChapter;
	  const numPreviews = Math.floor(duration / secondPerChapter);
	  const previews = {};
	  let i = 0;
	  while (i <= numPreviews) {
	    let hex = `0000000${i.toString(16)}`.toLocaleUpperCase();
	    hex = slice(hex).call(hex, hex.length - 8);
	    previews[`${i * secondPerChapter}`] = {
	      src: `${thumbBase}${hex}.${imageConfig.extension}`,
	      width: imageConfig.width
	    };
	    i += 1;
	  }
	  return previews;
	}

	const VIDEO_CDN_ASSET_PATH_REGEX = /motion\/(.+?)\./;
	const VDMS_ASSET_PATH_REGEX = /.\/ext\/(.+?)\.(m3u8|mpd).*/;
	const AKAMI_PACKAGER_ASSET_PATH_REGEX = /espn\/(.+?)\/playlist.m3u8/;
	const IMAGE_CONFIG = {
	  secondPerChapter: 10,
	  extension: 'jpg',
	  width: '150'
	};
	async function buildTimelinePreviewObject(videoURL, duration, brand) {
	  if (!videoURL) {
	    return null;
	  }
	  const pathMatch = videoURL.match(VIDEO_CDN_ASSET_PATH_REGEX) || videoURL.match(VDMS_ASSET_PATH_REGEX) || videoURL.match(AKAMI_PACKAGER_ASSET_PATH_REGEX);
	  if (!pathMatch) {
	    return null;
	  }
	  const isESPN = brand === 'espn';
	  let previews = null;
	  if (isESPN) {
	    previews = buildPrevewsFromVideoCDN(pathMatch, duration, IMAGE_CONFIG);
	  } else {
	    previews = await buildPrevewsFromVDMS(pathMatch[1], IMAGE_CONFIG);
	  }
	  return previews;
	}

	class Cookie {
	  /**
	   * @param {boolean} hasDocumentCookie
	   * --checks if we can get/set cookies on document.cookieokie;
	  }
	  get(key) {
	    if (this._hasDocumentCookie) {
	      const splat = document.cookie.split(/;\s*/);
	      for (let i = 0; i < splat.length; i += 1) {
	        const ps = splat[i].split('=');
	        const k = decodeURIComponent(ps[0]);
	        if (k === key) {
	          return decodeURIComponent(ps[1]);
	        }
	      }
	    }
	    return null;
	  }
	  set(key, value, opts = {}) {
	    if (this._hasDocumentCookie) {
	      const {
	        domain,
	        expires,
	        path,
	        secure
	      } = opts;
	      let s = `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
	      if (expires) {
	        s += `; expires=${expires}`;
	      }
	      if (path) {
	        s += `; path=${encodeURIComponent(path)}`;
	      }
	      if (domain) {
	        s += `; domain=${encodeURIComponent(domain)}`;
	      }
	      if (secure) {
	        s += '; secure';
	      }
	      document.cookie = s;
	      return s;
	    }
	    return null;
	  }
	}

	function hasDocumentCookie() {
	  // Can we get/set cookies on document.cookie?
	  return typeof document === 'object' && typeof document.cookie === 'string';
	}

	var FAILS_ON_PRIMITIVES$2 = fails(function () { objectKeys(1); });

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$2 }, it));
	  }
	});

	var keys$2 = path.Object.keys;

	var parent$5 = keys$2;

	var keys$1 = parent$5;

	var require$$0$7 = keys$1;

	var keys = require$$0$7;

	class St key;
	  }

	  /**
	   * @description get fan in localStorage
	   * @return {object} fan
	   */
	  getFan() {
	    const item = this.storage && this.storage.getItem(this._key);
	    if (item) {
	      return promise.resolve(JSON.parse(item));
	    }
	    return promise.reject(new Error('getFan from localstorage failed'));
	  }

	  /**
	   * @description set fan in localStorage
	   * @param {object} fan    }
	  }
	}

	const FAN_PRODUCT_PROD_HOST = 'https://fan.api.espn.com';
	const FAN_CORE_PROD_HOST = 'https://fan.core.api.espn.com';
	const DEFAULT_SOURCE_HEADER = 'espn-video-player'; // watchespn-web // ESPN.com - FAM
	const FAN_API_CACHE_MINUTES = 10;
	const FAN_STORAGE_KEY = 'fanapi_fan';
	const config = {
	  sourceHeader: DEFAULT_SOURCE_HEADER,
	  cacheDuration: FAN_API_CACHE_MINUTES,
	  fanProdHost: FAN_PRODUCT_PROD_HOST,
	  fanCoreHost: FAN_CORE_PROD_HOST,
	  storageKey: FAN_STORAGE_KEY
	};

	class FanAPI {
	  get storage() {
	    return this._storage;
	  }
	  constructor(sourceHeader = config.sourceHeader, cacheDuration = config.cacheDuration, storage = new Storage(window.localStorage, config.storageKey)) {
	    this._sourceHeader = null;
	    this._cacheDuration = 0;
	    this._storage = null;
	    this._sourceHeader = sourceHeader;
	    this._cacheDuration = cacheDuration;
	    this._storage = storage;
	  }
	  async fetchFan(url) {
	    const headers = {
	      'X-Personalization-Source': this._sourceHeader
	    };
	    const payload = {
	      method: 'GET',
	      headers,
	      credentials: 'include'
	    };
	    let res = null;
	    try {
	      const response = await fetch(url, payload);
	      const fan = await response.json();
	      if (fan.id) {
	        res = fan;
	        this.storage.setFan({
	          item: fan,
	          id: fan.id,
	          timestamp: Date.now()
	        });
	      }
	    } catch (err) {
	      console.error(`fetchFan error: ${err}`);
	    }
	    return res;
	  }
	  async getFanForId(id) {
	    let fan = null;
	    try {
	      const cache = await this.storage.getFan();
	      fan = cache && cache.item;
	      const cacheExpired = Date.now() - cache.timestamp > this._cacheDuration * 60 * 1000;
	      if (fan === null || fan.id !== id || cacheExpired) {
	        // not a valid fan, fetchFan from user profile
	        const url = `${config.fanProdHost}/apis/v2/fans/${id}`;
	        fan = this.fetchFan(url);
	      }
	    } catch (err) {
	      console.error(`getFanForId error: ${err}`);

	      // onError, fetchFan from user profile
	      const url = `${config.fanProdHost}/apis/v2/fans/${id}`;
	      fan = this.fetchFan(url);
	    }
	    return fan;
	  }
	  getAutoPlayOnCatch() {
	    const domestic = ['local.espn.com', 'www.espnqa.com', 'www.espn.com'];
	    let isDomestic = false;
	    const isGamepackage = window.localStorage.getItem('isGamepackageAutoPlay') === '1';
	    if (window && window.location && window.location.hostname) {
	      isDomestic = domestic.indexOf(window.location.hostname) > -1;
	    }
	    if (isDomestic && !isGamepackage) {
	      return false;
	    }
	    return true;
	  }
	  async getAutoStartForFanId(id, callback) {
	    let autoPlay = null;
	    try {
	      const fan = await this.getFanForId(id);
	      if (fan !== null) {
	        const {
	          profile
	        } = fan;
	        const settings = profile && profile.settings;
	        const videoAutoStartValue = settings && settings.videoAutoStart && settings.videoAutoStart.value;
	        autoPlay = videoAutoStartValue !== '2';
	      }
	    } catch (err) {
	      console.error(`getAutoStartForFanId failed: ${err}`);
	      autoPlay = this.getAutoPlayOnCatch();
	    }
	    if (autoPlay !== null && typeof callback === 'function') {
	      callback(autoPlay);
	    }
	  }
	  async updateSettingsForFanId(url, postData) {
	    const headers = {
	      'Content-Type': 'application/json',
	      'X-Personalization-Source': this._sourceHeader
	    };
	    const payload = {
	      method: 'POST',
	      headers,
	      credentials: 'include',
	      body: stringify(postData)
	    };
	    const response = await fetch(url, payload);
	    return response;
	  }
	  async updateAutoStartForFanId(id, autoStart) {
	    const videoAutoStartValue = (autoStart ? '1' : '2').toString();
	    const postData = {
	      settings: {
	        videoAutoStart: {
	          value: videoAutoStartValue,
	          lastUpdateSource: this._sourceHeader,
	          lastUpdateDate: Date.now()
	        }
	      }
	    };
	    try {
	      const url = `${config.fanCoreHost}/apis/v2/fans/${id}/profile/`;
	      await this.updateSettingsForFanId(url, postData);
	    } catch (err) {
	      console.error(`Update autoStart settings for fan failed: ${err}`);
	    } finally {
	      // update autoStart cache regardless of the update result
	      this.updateAutoStartCache(postData.settings);
	    }
	  }
	  async updateAutoStartCache(settings) {
	    const {
	      videoAutoStart
	    } = settings;
	    try {
	      const cache = await this.storage.getFan();
	      const fan = cache && cache.item;
	      if (fan) {
	        keys(videoAutoStar	        });
	        this.storage.setFan({
	          item: fan,
	          id: fan.id,
	          timestamp: Date.now()
	        });
	      }
	    } catch (err) {
	      console.error(`updateAutoStartCache failed: ${err}`);
	    }
	  }
	}

	class Fan {
	  set SWID(v) {
	    this._SWID = v;
	  }
	  get SWID() {
	    return this._SWID;
	  }
	  get UNID() {
	    return this._UNID;
	  }
	  constructor(api = new FanAPI(), c = new Cookie(hasDocumentCookie())) {
	    this._SWID = null;
	    this._UNID = null;
	    this.fanApi = api;
	    this.cookie = c;
	    this._SWID = this.cookie.get('SWID');
	    this._UNID = this.cookie.get('UNID');
	  }
	  (id);
	  }
	  async getAutoStart() {
	    let autoPlay = true;
	    const vas = this.cookie.get('VAS');
	    if (vas) {
	      autoPlay = parseInt(vas, 10) === 1;
	    }
	    if (this.isValidSwid(this.SWID)) {
	      await this.fanApi.getAutoStartForFanId(this.SWID, autoStart => {
	        autoPlay = autoStart === true || autoStart === false ? autoStart : autoPlay;
	        return autoPlay;
	      });
	    }
	    return autoPlay;
	  }
	  setAutoStart(value) {
	    let cbDomain;
	    if (window.location.hostname !== undefined) {
	      cbDomain = window.location.hostname.replace('www.', '');
	    } else {
	      cbDomain = 'espn.com';
	    }
	    if (value === true || value === false) {
	      this.cookie.set('VAS', value ? 1 : 2, {
	        domain: cbDomain,
	        expires: 365,
	        path: '/'
	      }); // support affinity sites
	      if (this.isValidSwid(this.SWID)) {
	        this.fanApi.updateAutoStartForFanId(this.SWID, value);
	      }
	    }
	  }
	}

	// prettier-ignore
	/* eslint-disable no-bitwise */

	// https://gist.github.com/jed/982883

	function uuid(a) {
	  return a // if the placeholder was passed, return
	  ? (
	  // a random number from 0 to 15
	  a ^
	  // unless b is 8,
	  Math.random() // in which case
	  * 16 // a random number from
	  >> a / 4 // 8 to 11
	  ).toString(16) // in hexadecimal
	  : (
	  // or otherwise a concatenated string:
	  [1e7] +
	  // 10000000 +
	  -1e3 +
	  // -1000 +
	  -4e3 +
	  // -4000 +
	  -8e3 +
	  // -80000000 +
	  -1e11 // -100000000000,
	  ).replace(
	  // replacing
	  /[018]/g,
	  // zeroes, ones, and eights with
	  uuid // random hex digits
	  );
	}

	const UNDEF = undefined;

	/**
	 * check if usprivacy cookie exist
	 * @returns
	 */
	function getCookie(name) {
	  const value = `; ${document.cookie}`;
	  const parts = value.split(`; ${name}=`);
	  let cookieValue;
	  if (parts.length === 2) {
	    cookieValue = parts.pop().split(';').shift();
	  }
	  return cookieValue;
	}
	function checkUsPrivacyCookie() {
	  const usPrivacyCookie = getCookie('usprivacy');
	  return usPrivacyCookie && usPrivacyCookie.length ? usPrivacyCookie : false;
	}

	/**
	 * add usprivacy params to GAM request
	 * @param {Object} [imaSdkDictionary={}]
	 * @param {Object} [advertisingInfo={}]
	 * @returns {Object} conditionally updated imaSdkDictionary based on CCPA cookie
	 */
	function addUsPrivacyCustomParams(imaSdkDictionary = {}, advertisingInfo = {}) {
	  const usPrivacyCookie = advertisingInfo.usPrivacy || checkUsPrivacyCookie();
	  let {
	    rdp
	  } = advertisingInfo;
	  if (usPrivacyCookie) {
	    if (usPrivacyCookie === '1YYY') {
	      rdp = 1;
	    }
	    if (rdp) {
	      imaSdkDictionary.rdp = rdp;
	    }
	    imaSdkDictionary.us_privacy = usPrivacyCookie;
	    imaSdkDictionary.cust_params = `${imaSdkDictionary.cust_params}&d_us_privacy=${usPrivacyCookie}`;
	  }
	  return imaSdkDictionary;
	}
	function isDoNotTrackEnabled() {
	  const doNotTrackOption = window.doNotTrack || window.navigator.doNotTrack || window.navigator.msDoNotTrack;
	  if (!doNotTrackOption) {
	    return false;
	  }
	  if (doNotTrackOption.charAt(0) === '1' || doNotTrackOption === 'yes') {
	    return true;
	  }
	  return false;
	}

	/**
	 * client generated user identifer value, new value is generated every 30 days,
	 * affiliate partners will use fcap for frequency capping
	 */
	function fcap() {
	  const storageKey = 'fcap';
	  const ageLimit = 2592000; // 30 days
	  const now = Date.now();
	  let fcap = JSON.parse(window.localStorage.getItem(storageKey));
	  if (!fcap || fcap.ts < now - ageLimit) {
	    fcap = {
	      id: uuid(),
	      ts: now
	    };
	    window.localStorage.setItem(storageKey, stringify(fcap));
	  }
	  return fcap.id;
	}
	function getCommonAdInfo(currentAdInfo, mediaItem, player, adapter) {
	  const advertisingInfo = new AdvertisingInfo();
	  const {
	    device,
	    webHref,
	    live: isLive,
	    id
	  } = mediaItem;
	  const {
	    SWID,
	    UNID
	  } = new Fan();
	  const {
	    height,
	    width
	  } = player.currentDimensions();
	  const isMobile = /mobile/i.test(device) || IS_MOBILE;
	  const isTablet = /tablet/i.test(device) || IS_TABLET;
	  const videoPlayerType = adapter.playerName;
	  const videoPlayerVersion = adapter.platformVersion;
	  const {
	    startType = ''
	  } = player.mediainfo || {};
	  const {
	    output,
	    adEnvironment,
	    an,
	    authp,
	    cmsid = '2495342',
	    hl,
	    iu,
	    nielsenAppId = 'P31187EE2-AC6E-46CB-BB54-D07591BED067',
	    npa = 0,
	    tfcd = 0,
	    vpa = 1,
	    usePlayerAutoplayHandling = true
	  } = currentAdInfo;
	  const {
	    ltd
	  } = currentAdInfo;
	  let {
	    additionalConsent,
	    rdp,
	    usPrivacy
	  } = currentAdInfo;
	  let platform = 'desktop';
	  let deviceOS;
	  let pp = 'espn-clips-desktop-csai';
	  if (IS_EDGE) {
	    deviceOS = 'Edge';
	  } else if (IS_CHROME) {
	    deviceOS = 'Chrome';
	  } else if (IS_SAFARI) {
	    deviceOS = 'Safari';
	  } else if (IS_FIREFOX) {
	    deviceOS = 'Firefox';
	  } else if (IS_OPERA) {
	    deviceOS = 'Opera';
	  }
	  if (IS_IOS) {
	    platform = `ios_${isTablet ? 'tablet' : 'handset'}`;
	    pp = 'espn-mweb-clips-ios-csai';
	  } else if (IS_ANDROID) {
	    platform = `android_${isTablet ? 'tablet' : 'handset'}`;
	    pp = 'espn-mweb-clips-android-csai';
	  }
	  if (authp) {
	    advertisingInfo.authenticationProvider = authp;
	  }
	  advertisingInfo.cmsid = cmsid;
	  advertisingInfo.descriptionUrl = webHref;
	  advertisingInfo.deviceOS = deviceOS;
	  advertisingInfo.deviceType = (device || (isTablet ? 'tablet' : isMobile ? 'mobile' : 'desktop')).toLowerCase();
	  advertisingInfo.fcap = fcap();
	  advertisingInfo.hl = hl || player.language() || 'en';
	  advertisingInfo.isAutoplay = player.autoplay() || !!startType.match(/continuous/i) ? '1' : '0';
	  advertisingInfo.isDoNotTrackEnabled = isDoNotTrackEnabled();
	  advertisingInfo.isMute = player.muted();
	  advertisingInfo.iu = iu;
	  advertisingInfo.nielsenAppId = nielsenAppId;
	  advertisingInfo.nielsenDeviceGroup = `devgrp,${isTablet ? 'TAB' : isMobile ? 'PHN' : 'DSK'}`;
	  advertisingInfo.npa = npa; // non-personalized ads
	  if (output) {
	    advertisingInfo.output = output;
	  }
	  if (adEnvironment) {
	    advertisingInfo.adEnvironment = adEnvironment;
	  }
	  advertisingInfo.platform = platform;
	  advertisingInfo.pp = pp;
	  advertisingInfo.ppid = SWID;
	  advertisingInfo.swid = SWID;
	  advertisingInfo.videoPlayerType = videoPlayerType;
	  advertisingInfo.videoPlayerVersion = videoPlayerVersion;
	  advertisingInfo.usePlayerAutoplayHandling = usePlayerAutoplayHandling;
	  if (an) {
	    advertisingInfo.an = an;
	  }

	  /**
	   * tfcd: Tag for Child Directed Treatment
	   * You can mark your ad requests to be treated as child-directed.
	   * The feature is designed to help facilitate compliance
	   * with the Children's Online Privacy Protection Act (COPPA)
	   */
	  advertisingInfo.tfcd = tfcd;
	  advertisingInfo.unid = UNID;
	  advertisingInfo.vdm = isLive ? 'live' : 'vod';
	  advertisingInfo.vid = id;
	  advertisingInfo.videoPlayerSize = `${Math.round(width)}x${Math.round(height)}`;
	  // vpa: Video play automatic, default to 1
	  advertisingInfo.vpa = vpa;

	  // Not an actual AdvertisingInfo prop, but ad-related just the same.
	  // Setting here so it is available where ever we expose `advertisingInfo` on the bundle.
	  advertisingInfo.moatPartnerCode = 'abcimavideo618769704984';

	  // DCF
	  usPrivacy = usPrivacy || checkUsPrivacyCookie();
	  if (usPrivacy) {
	    if (usPrivacy === '1YYY') {
	      rdp = 1;
	    }
	    advertisingInfo.usPrivacy = usPrivacy;
	  }
	  additionalConsent = additionalConsent || getCookie('OTAdditionalConsentString');
	  if (additionalConsent) {
	    advertisingInfo.additionalConsent = additionalConsent;
	  }
	  if (rdp !== UNDEF) {
	    advertisingInfo.rdp = rdp;
	  }
	  advertisingInfo.ltd = ltd !== UNDEF ? ltd : getCookie('_dcf') === '0';
	  return advertisingInfo;
	}
	function getAdditionalAdInfoForEntertainment(currentAdInfo, mediaItem, player, adapter) {
	  const advertisingInfo = getCommonAdInfo(currentAdInfo, mediaItem, player, adapter);
	  let {
	    pp = 'abc-web-desktop'
	  } = currentAdInfo;
	  const transUniqueId = uuid();
	  const {
	    // Parameters for entertainment only
	    vadFormat,
	    vpi,
	    adRule,
	    alt,
	    beacType = 'csai',
	    accesslevel,
	    isAuth,
	    varResolution,
	    nlsnPlat,
	    tag,
	    aff,
	    playlist,
	    cbp,
	    collection,
	    impl = 's',
	    transId = transUniqueId
	    // End params for entertainment only
	  } = currentAdInfo;
	  if (IS_IOS) {
	    pp = 'abc-web-mobile';
	  } else if (IS_ANDROID) {
	    pp = 'abc-web-mobile';
	  }
	  advertisingInfo.pp = pp;

	  // Params for entertainment only
	  advertisingInfo.vadFormat = vadFormat;
	  advertisingInfo.vpi = vpi;
	  advertisingInfo.adRule = adRule;
	  advertisingInfo.alt = alt;
	  advertisingInfo.beacType = beacType;
	  advertisingInfo.accessLevel = accesslevel;
	  advertisingInfo.isAuth = isAuth;
	  advertisingInfo.varResolution = varResolution;
	  advertisingInfo.nlsnPlat = nlsnPlat;
	  advertisingInfo.tag = tag;
	  advertisingInfo.aff = aff;
	  advertisingInfo.playlist = playlist;
	  advertisingInfo.cbp = cbp;
	  advertisingInfo.collection = collection;
	  advertisingInfo.impl = impl;
	  advertisingInfo.transId = transId;
	  // End params for entertainment only

	  return advertisingInfo;
	}
	function getChannel(brand) {
	  if (!brand) {
	    return null;
	  }
	  return getChannelMapping(brand);
	}
	function getAdvertisingInfo(currentAdInfo, player, mediaItem = {}, adapter = {}) {
	  let advertisingInfo = getCommonAdInfo(currentAdInfo, mediaItem, player, adapter);
	  const isESPN = !currentAdInfo.aff;
	  if (!isESPN) {
	    advertisingInfo = getAdditionalAdInfoForEntertainment(currentAdInfo, mediaItem, player, adapter);
	  }
	  advertisingInfo.chan = getChannel(mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.brand);
	  return advertisingInfo;
	}

	function initConcurrencyMonitor(session, concurrencyMonitorBuilder, coordinator) {
	  let monitor;
	  if (session.concurrencyMonitorSessionId) {
	    monitor = concurrencyMonitorBuilder.withSession(session).build();
	    if (monitor) {
	      monitor.startWithSession(session.concurrencyMonitorSessionId);
	    }
	  }
	  if (!monitor) {
	    return null;
	  }
	  monitor  });
	  };
	  return monitor;
	}

	var freezins({}));
	});

	/* eslint-disable es/no-object-getownpropertynames -- safe */


	var $getOwnPropertyNames = getOwnPropertyNamesModule.f;


	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWin);
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and windot(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f
	};

	// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it


	var arrayBufferNonExtensib);
	  }
	});

	var ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;

	// eslint-disable-next-line es/no-object-isextensible -- safe
	var $isExtensible = Object.isExtensible;
	var FAILS_ON_PRIMITIVES$1 = fails(function () { $isExtensible(1); });

	// `Object.isExtensible` method
	// https://tc39.es/ecma262/#sec-object.isextensible
	var objectIsExtensible = (FAILS_ON_PRIMITIVES$1 || ARRAY_BUFFER_NON_EXT: true;
	} : $isExtensible;

	var getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;

	var isExtensible = objectIsExtensible;

	var FREEZING = freezing;

	var internalMetadata = createCommonjsModule(function (module) {
	var defineProperty = require$$0$o.f;






	var REQUIRED = false;
	var METADATA = uid('meta');
	var id = 0;

	var set  } });
	};

	varjectID;
	};

	var getakData;
	};

	// add metadata on freeze-family methods calling
	var urn it;
	};

	va);
	  }
	};

	var meta = module.exports = {
	  enable: enable,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};

	hiddenKeys$1[METADATA] = true;
	});
	internalMetadata.enable;
	internalMetadata.fastKey;
	internalMetadata.getWeakData;
	internalMetadata.onFreeze;

	var require$$0$6 = internalMetadata;

	var onFreeze = require$$0$6.onFreeze;

	// eslint-disable-next-line es/no-object-freeze -- safe
	var $freeze = Object.freeze;
	var FAILS_ON_PRIMITIVeeze(1); });

	// `Object.freeze` method
	// https://tc39.es/ecma262/#sec-object.freeze
	$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
: it;
	  }
	});

	var freeze$2 = path.Object.freeze;

	var parent$4 = freeze$2;

	var freeze$1 = parent$4;

	var require$$0$5 = freeze$1;

	var freeze = require$$0$5;

	const DEFAULT_CONFIG$3 = {
	   s);
	    },
	};
	class CallbackStorg);
	    }
	    setMediaItem(mediaItem) {
	        this.mediaItem = mediaItem;
	        this.videoId = String(mediaItem.id);
	        this.sourceId = this.config.sourceId;
	));
	    }
	    dispose() {
	        this.config = null;
	        this.mediaItem = null;
	    }
	}

	var QueueMode;
	(function (QueueMode) {
	    QueueMode["first"] = "first";
	    QueueMode["last"] = "last";
	    QueueMode["all"] = "all";
	})(QueueMode || (QueueMode = {}));
	const DEFAULT_CONFIG$2 = {
	    maxAttempts: 3,
	    persistSession: true,
	    retryTimeout: 60000,
	    SESSION_KEY_PREFIX: 'ResilientRemoteStorage',
	    queueMode: QueueMode.all,
	};
	class ResilientRemoteStorage {
	    constructor(config) {
	        var _a;
	        this.failedAttempts = 0;
	        this.maxAttempts = NaN;
	        this.paused = false;
	        this.queuedFetchArgs = [];
	        this.waitForResume_ = null;
	        this.resumeTimeout_ = null;
	        this.retryTimestamp_ = NaN;
	        this.config = Object.assign(Object.assign({}, DEFAULT_CONFIG$2), config);
	        const { config: { maxAttempts, persistSession, SESSION_KEY_PREFIX, queueMode }, } = this;
	        const className = (_a = this === null || this === void 0 ? void 0 : this.constructor) === null || _a === void 0 ? void 0 : _a.name;
	        this.queueMode = queueMode;
	        this.maxAttempts = maxAttempts;
	        this.storageKey = `${SESSION_KEY_PREFIX}${className ? `-${className}` : ''}`;
	        if (persistSession) {
	            this.persistSession();
	        }
	    }
	    persistSession() {
	        let previousSession;
	        try {
	            const previousSessionData = sessionStorage.getItem(this.storageKey);
	            previousSession = JSON.parse(previousSessionData);
	        }
	        catch (err) { }
	        if (previousSession) {
	            const { failedAttempts, retryTimestamp_, queuedFetchArgs } = previousSession;
	            this.queuedFetchArgs = queuedFetchArgs;
	            this.failedAttempts = failedAttempts;
	            if (this.failedAttempts >= this.maxAttempts && retryTimestamp_ > 0) {
	                const resumeTimeout = Math.max(retryTimestamp_ - +new Date(), 0);
	                this.pauseFetching(resumeTimeout);
	                if (queuedFetchArgs && queuedFetchArgs.length) {
	                    this.drainQueueWhenResumed();
	                }
	            }
	        }
	        try {
	            this.saveSession = this.saveSession.bind(this);
	            window.addEventListener('beforeunload', this.saveSession);
	        }
	        catch (err) { }
	{ }
	    }
	    pauseFetching(pauseFor) {
	        const timeout = pauseFor || this.config.retryTimeout;
	        if (!this.waitForResume_) {
	            this.retryTimestamp_ = +new Date() + timeout;
	            this.waitForResume_ = new Promise(resolve => {
	                const resume = () => {
	                    this.waitForResume_ = null;
	                    this.failedAttempts = 0;
	                    this.retryTimestamp_ = NaN;
	                    resolve(true);
	                };
	                this.resumeTimeout_ = setTimeout(resume, timeout);
	            });
	        }
	    }
	    drainQueueWhenResumed() {
	        return this.waitForResume_.then(() => {
	            const { queuedFetchArgs } = this;
	            this.queuedFetchArgs = [];
	            return Promise.all(queuedFetchArgs.map(({ url, params }, i) => {
	                return new Promise(resolve => {
	                             }, i * 10);
	                });
	            }));
	        });
	    }
	    resilientFetch(url, params) {
	        return new Promise(resolve => {
	            const nl, params);
	            if (this.waitForResume_) {
	                const nextFetchArgs = { url, params };
	                if (this.queueMode === QueueMode.all) {
	                    this.queuedFetchArgs.push(nextFetchArgs);
	                }
	                else if ((this.queueMode === QueueMode.first && !this.queuedFetchArgs.length) || this.queueMode === QueueMode.last) {
	                    this.queuedFetchArgs[0] = nextFetchArgs;
	                }
	                return this.drainQueueWhenResumed().then(resolve);
	            }
	            else {
	                nextFetch()
	                    .then(resp => {
	                    if (resp && 'ok' in resp && !resp.ok) {
	                        return Promise.reject(new Error('Endpoint failed to save progress'));
	                    }
	                    else {
	                        this.failedAttempts = 0;
	                    }
	                    return resp;
	                })
	                    .then(resolve)
	                    .catch(err => {
	                    this.failedAttempts += 1;
	                    if (this.failedAttempts >= this.maxAttempts) {
	                        this.pauseFetching();
	                    }
	                    loglevel.error(err);
	                    return this.resilientFetch(url, params).then(resolve);
	                });
	            }
	        });
	    }
	    saveSession() {
	        if (this.config.persistSession) {
	            try {
	                sessionStorage.setItem(this.storageKey, JSON.stringify({
	                    queuedFetchArgs: this.queuedFetchArgs || [],
	                    retryTimestamp_: this.retryTimestamp_ || NaN,
	                    failedAttempts: this.failedAttempts,
	                }));
	            }
	            catch (err) { }
	        }
	    }
	    dispose() {
	        if (this.config.persistSession) {
	            this.saveSession();
	        }
	        clearTimeout(this.resumeTimeout_);
	        this.config = null;
	    }
	}

	const FUSE_FETCH_HEADERS = {
	    Accept: 'application/json',
	    'Cache-Control': 'no-cache',
	    'Content-Type': 'application/json',
	    Pragma: 'no-cache',
	};
	const DEFAULT_CONFIG$1 = {
	    swid: null,
	    bu: null,
	    contentSource: null,
	    s2: null,
	    source: null,
	    endpointTemplate: 'https://fan.core.api.espn.com/apis/v2/progress/{{SWID}}/{{BUSINESS_UNIT}}/{{CONTENT_SOURCE}}/{{CONTENT_ID}}',
	    completePercentThreshold: 97,
	    fetchCredentials: 'include',
	};
	const BUSINESS_UNIT_BY_BRAND = {
	    espn: 0,
	    marvel: 2,
	};
	const CONTENT_SOURCE_IDS = {
	    PCC: 0,
	};
	const CONTENT_SOURCE_ID_BY_BRAND_AND_ENTITY_TYPE = {
	    espn: {
	        longform: CONTENT_SOURCE_IDS.PCC,
	    },
	};

	class FuseStorage extends ResilientRemoteStorage {
	    constructor(config, fan) {
	        super(Object.assign(Object.assign({}, DEFAULT_CONFIG$1), config));
	        this.fan = fan;
	        this.handleFuseResponse = this.handleFuseResponse.bind(this);
	    }
	    setMediaItem(mediaItem) {
	        var _a;
	        const { config: { contentSource, bu, s2, swid, source, fetchCredentials }, fan, } = this;
	        const { id, brand, entityType } = mediaItem;
	        this.mediaItem = mediaItem;
	        this.contentId = String(id);
	        this.businessUnit = bu !== null ? bu : BUSINESS_UNIT_BY_BRAND[brand];
	        this.contentSource =
	            contentSource !== null ? contentSource : (_a = CONTENT_SOURCE_ID_BY_BRAND_AND_ENTITY_TYPE === null || CONTENT_SOURCE_ID_BY_BRAND_AND_ENTITY_TYPE === void 0 ? void 0 : CONTENT_SOURCE_ID_BY_BRAND_AND_ENTITY_TYPE[brand]) === null || _a === void 0 ? void 0 : _a[entityType];
	        this.swid = swid !== null ? swid : fan === null || fan === void 0 ? void 0 : fan.id;
	        this.s2 = s2;
	        this.source = source;
	        this.fetchCredentials = fetchCredentials;
	        this.updateApiEndpoint_();
	    }
	    updateApiEndpoint_() {
	        const { config: { endpointTemplate }, swid, businessUnit, contentSource, contentId, } = this;
	        let apiEndpoint = endpointTemplate;
	        if (swid && swid[0] === '{') {
	            apiEndpoint = apiEndpoint.replace('{{SWID}}', encodeURIComponent(swid));
	        }
	        if (businessUnit !== null) {
	            apiEndpoint = apiEndpoint.replace('{{BUSINESS_UNIT}}', businessUnit);
	        }
	        if (contentSource !== null) {
	            apiEndpoint = apiEndpoint.replace('{{CONTENT_SOURCE}}', contentSource);
	        }
	        if (contentId) {
	            apiEndpoint = apiEndpoint.replace('{{CONTENT_ID}}', contentId);
	        }
	        this.apiEndpoint = apiEndpoint;
	ld;
	    }
	    hideProgress(progress, percentComplete) {
	        return this.updateProgress(progress, percentComplete, true);
	e);
	    }
	    updateProgress(progress, percentComplete, hidden) {
	        var _a, _b;
	        const { apiEndpoint, businessUnit, contentId, contentSource, mediaItem, s2, source, swid } = this;
	        const seriesId = (_b = (_a = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.tracking) === null || _a === void 0 ? void 0 : _a.heartbeats) === null || _b === void 0 ? void 0 : _b['a.media.asset'];
	        const errors = [];
	        if (String(apiEndpoint).indexOf('{{') !== -1) {
	            errors.push('Missing required metadata, cannot determine endpoint');
	        }
	        const payload = {
	            id: swid,
	            bu: businessUnit,
	            contentId,
	            contentSource,
	            complete: this.computeCompleted(progress, percentComplete, mediaItem),
	            progress,
	            seriesId,
	            source,
	            hidden,
	        };
	        for (const p in payload) {
	            const val = payload[p];
	            if (val === null || val === undefined) {
	                errors.push(`Required payload param '${p}' not set`);
	            }
	        }
	        if (errors.length) {
	            return Promise.reject(new Error(errors.map(err => err).join('\n')));
	        }
	        let headers = FUSE_FETCH_HEADERS;
	        let { fetchCredentials } = this;
	        if (s2) {
	            headers = Object.assign(Object.assign({}, headers), { Cookie: `espn_s2=${s2}` });
	            fetchCredentials = 'omit';
	        }
	        return this.fetch(apiEndpoint, {
	            method: 'PUT',
	            mode: 'cors',
	            cache: 'no-cache',
	            credentials: fetchCredentials,
	            headers,
	            body: JSON.stringify(payload),
	        })
	            .then(resp => (resp === null || resp === void 0 ? void 0 : resp.json) && resp.json())
	            .then(this.handleFuseResponse);
	s);
	    }
	    handleFuseResponse(resp) {
	        return resp;
	ll;
	    }
	}

	function throttle$1(func, limit, context) {
	    let inThrottle;
	    return function throttled(...args) {
	        if (!inThrottle) {
	            func.apply(context, args);
	            inThrottle = true;
	                     }, limit);
	        }
	    };
	}
	function debounce(func, wait, immediate, context) {
	    let timeout;
	    return function debounced(...args) {
	        const later = () => {
	            timeout = null;
	            if (!immediate)
	                func.apply(context, args);
	        };
	        const callNow = immediate && !timeout;
	        clearTimeout(timeout);
	        timeout = setTimeout(later, wait);
	        if (callNow)
	            func.apply(context, args);
	    };
	}

	const DEFAULT_CONFIG = {
	    interval: 15000,
	    debounce: 250,
	    minimumProgressBeforeTrack: 30,
	};
	cons undefined;
	class ProgressTracker extends PlayerPlugin {
	    constructor(delegate, config) {
	        super(delegate, Object.assign(Object.assign({}, DEFAULT_CONFIG), config));
	        this.debouncedSaveProgress_ = noop$1;
	        this.throttledSaveProgress_ = noop$1;
	        this.contentDuration = NaN;
	        this.storages = [];
	        this.activeStorages = [];
	        this.doDebouncedSaveProgress_ = debounce(this.saveProgress, this.config.debounce, false, this);
	        this.doThrottledSaveProgress_ = throttle$1(this.doDebouncedSaveProgress_, this.config.interval, this);
	        this.progressChange = noop$1;
	    }
	    setMediaItem(mediaItem) {
	        super.setMediaItem(mediaItem);
	        this.contentDuration = NaN;
	        this.pauseTracking();
	        this.selectStorages_();
	    }
	    setStorage(progressStorage, rule) {
	        this.storages.push({
	            storage: progressStorage,
	            rule: rule,
	        });
	        if (this.mediaItem) {
	            this.selectStorages_();
	        }
	    }
	    selectStorages_() {
	        const { storages, mediaItem } = this;
	        const storagesCnt = storages.length;
	        const nextActiveStorages = [];
	        for (let i = 0; i < storagesCnt; i++) {
	            const { storage, rule } = storages[i];
	            if (rule(storage, mediaItem)) {
	                storage.setMediaItem(mediaItem);
	                nextActiveStorages.push(storage);
	            }
	        }
	        this.activeStorages = nextActiveStorages;
	    }
	    firstPlayOfContent(position) {
	        super.firstPlayOfContent(position);
	        if (this.config.minimumProgressBeforeTrack === 0) {
	            this.resumeTracking();
	        }
	    }
	    loadedMetadata(metadata) {
	        const duration = metadata === null || metadata === void 0 ? void 0 : metadata.duration;
	        if (duration) {
	            this.setContentDuration(duration);
	        }
	    }
	    setContentDuration(contentDuration) {
	        this.contentDuration = contentDuration;
	    }
	    play(position) {
	        super.play(position);
	        this.debouncedSaveProgress_(position);
	    }
	    pause(position) {
	        this.debouncedSaveProgress_(position);
	e);
	    }
	    seek(position) {
	        this.debouncedSaveProgress_(position);
	    }
	    release(position) {
	        this.debouncedSaveProgress_(position);
	    }
	    pausedProgressChange(position) {
	        const { config: { minimumProgressBeforeTrack }, didFirstPlayOfContent, } = this;
	        if (minimumProgressBeforeTrack !== 0 && position >= minimumProgressBeforeTrack && didFirstPlayOfContent) {
	            this.resumeTracking();
	            this.debouncedSaveProgress_(position);
	        }
	    }
	    resumedProgressChange(position) {
	        this.throttledSaveProgress_(position);
	n);
	    }
	    a();
	    }
	   n);
	    }
	    pauseTracking() {
	        this.debouncedSaveProgress_ = this.throttledSaveProgress_ = noop$1;
	        this.progressChange = this.pausedProgressChange;
	    }
	    resge;
	    }
	    saveProgress(position, complete) {
	        const { mediaItem, activeStorages, contentDuration } = this;
	        const duration = contentDuration || (mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.duration);
	        if (position > -1 && activeStorages.length) {
	            let storeResult;
	            let percentComplete;
	            if (complete === true) {
	                percentComplete = 100;
	            }
	            else if (duration > 0 && position >= 0) {
	                percentComplete = (parseFloat(String(position)) / parseFloat(String(duration))) * 100;
	            }
	            else {
	                percentComplete = NaN;
	            }
	            if (activeStorages.length) {
	                storeResult = Promise.all(activeStorages.map(storage => {
	                    return new Promise(resolve => {
	                        let promise;
	                        try {
	                            promise = storage.saveProgress(position, percentComplete).then(resolve);
	                        }
	                        catch (err) {
	                            loglevel.error(err);
	                            promise = Promise.resolve();
	                        }
	                        return promise;
	                    });
	                }));
	            }
	            else {
	                storeResult = Promise.reject('No storages available');
	            }
	            storeRe         });
	        }
	    }
	    dispose() {
	        super.dispose();
	        this.storag.dispose());
	        this.storages = [];
	        this.activeStorages = [];
	        this.mediaItem = null;
	        this.throttledSaveProgress_ = null;
	        this.debouncedSaveProgress_ = null;
	    }
	}

	const EMPTY_OBJ$1 = freeze({});
	const TRACK_PROGRESS_EVENT_NAME = 'dtci.trackProgress';
	const DEFAULT_RULE = (storage, mediaItem) => {
	  var _storage$fan;
	  // only track when...
	  const swid = storage === null || storage === void 0 ? void 0 : (_storage$fan = storage.fan) === null || _storage$fan === void 0 ? void 0 : _storage$fan.id;
	  return (!swid || swid[0] === '{') &&
	  // if we have a user swid, require they're logged in
	  mediaItem && mediaItem.entityType === 'longform' && mediaItem.streamType !== 'live'; // only apply to longform
	};

	const DEFAULT_STORAGE = {
	  storage: {
	    name: 'callback'
	  },
	  rule: DEFAULT_RULE
	};
	function getConfiguredCallbackStorage(config, coordinator) {
	  const callbackStorage = new CallbackStorage({
	    callback: function callCoordinator(contentId, progress, sourceId, percentCompleted, mediaItem) {
	      if (coordinator) {
	        coordinator.coordinate(TRACK_PROGRESS_EVENT_NAME, {
	          contentId,
	          progress,
	          sourceId,
	          completion: percentCompleted / 100,
	          mediaItem
	        });
	      }
	    },
	    ...config
	  });
	  return callbackStorage;
	}
	function getConfiguredFuseStorage(config) {
	  let {
	    swid
	  } = config;
	  if (!swid) {
	    const fan = new Fan();
	    swid = fan.SWID;
	  }
	  const fan = {
	    id: swid
	  };
	  return new FuseStorage({
	    ...config,
	    source: 'web',
	    queueMode: QueueMode.last
	  }, fan);
	}
	function getConfiguredProgressTracker(playerAdaptor, configs, coordinator) {
	  const pluginConfig = (configs === null || configs === void 0 ? void 0 : configs.progressTracker) || EMPTY_OBJ$1;
	  const {
	    enabled,
	    // @deprecated
	    storages = []
	  } = pluginConfig;
	  let progressTracker;
	  if (enabled && !storages.length) {
	    storages.push(DEFAULT_STORAGE);
	  }
	  if (storages.length) {
	    progressTracker = new ProgressTracker(playerAdaptor, pluginConfig);
	    storages.forEach(async ({
	      storage,
	      rule
	    }) => {
	      const {
	        instance,
	        name
	      } = typeof storage === 'function' ? await storage() : storage;
	      const storageRule = rule || DEFAULT_RULE;
	      let storageInstance;
	      if (instance) {
	        // clients can define their own storages
	        storageInstance = instance;
	      } else if (name === 'callback') {
	        storageInstance = getConfiguredCallbackStorage(pluginConfig, coordinator);
	      } else if (name === 'fuse') {
	        storageInstance = getConfiguredFuseStorage(pluginConfig);
	      }
	      if (storageInstance) {
	        progressTracker.setStorage(storageInstance, storageRule);
	      }
	    });
	  }
	  return progressTracker;
	}

	const shouldInitThumbnails = mediaItem => {
	  const {
	    entityType,
	    streamType,
	    source
	  } = mediaItem;
	  return streamType !== 'live' && (entityType === 'shortform' || entityType === 'longform' && source.type === 'entitlement');
	};
	const isMediaItemTvRatingSet = (player, tvrating) => {
	  return player && typeof player.tvRating === 'function' && tvrating && tvrating !== 'NR';
	};

	var getBrandName = (brand => {
	  return getBrandNames(brand) || 'Entertainment';
	});

	const getMediaItemPosterHref = images => {
	  var _images$;
	  return Array.isArray(images) && ((_images$ = images[0]) === null || _images$ === void 0 ? void 0 : _images$.url) || '';
	};

	var getMediainfoData = ((mediaItem, isEntertainment = false) => {
	  const {
	    description,
	    duration,
	    id,
	    isSyndicatable,
	    network,
	    references: {
	      cerebroId,
	      eventId,
	      simulcastAiringId
	    } = {},
	    source: {
	      commercialReplacement
	    } = {},
	    streamType,
	    title,
	    tvrating,
	    tracking: {
	      comscore: {
	        c6: comscoreC6,
	        ns_st_ct: comscoreContentType,
	        ns_st_pu: publisher
	      } = {},
	      heartbeats: {
	        CMSID: cmsidAssetName,
	        League: leagueName,
	        PublishDate,
	        PublishTime,
	        ShowCode: showcode = 'Not Applicable',
	        Sport: sportName,
	        VideoTypeDetail: mediaType
	      } = {},
	      nielsen: {
	        program,
	        crossId1: nielsenCrossId1,
	        crossId2: nielsenCrossId2
	      } = {},
	      conviva: {
	        assetName: convivaAssetName
	      } = {}
	    } = {},
	    webHref
	  } = mediaItem;
	  const live = streamType === 'live';
	  const originalPublishDate = PublishDate && PublishTime ? `${PublishDate}T${PublishTime}` : null;
	  const assetName = cmsidAssetName || mediaItem.name || convivaAssetName;
	  const data = {
	    cerebroId,
	    commercialReplacement,
	    comscoreC6,
	    comscoreContentType,
	    custom_fields: {},
	    description,
	    duration,
	    eventId,
	    headline: title,
	    id,
	    leagueName,
	    live,
	    name: assetName,
	    program,
	    nielsenCrossId1,
	    nielsenCrossId2,
	    originalPublishDate,
	    tvrating,
	    pageTitle: document.title || title,
	    publisher,
	    showcode,
	    simulcastAiringId,
	    sourceId: network && network.id,
	    sourceType: network && network.type,
	    sportName,
	    status: streamType,
	    syndicatable: isSyndicatable,
	    webHref
	  };
	  if (mediaType) {
	    data.custom_fields.mediaType = mediaType;
	  }
	  if (!isEntertainment) {
	    const {
	      images,
	      source: {
	        hasEspnId3Heartbeats,
	        hasNielsenWatermarks,
	        hasPassThroughAds
	      } = {},
	      tracking: {
	        heartbeats: {
	          'a.media.asset': asset,
	          'a.media.show': show,
	          'a.media.genre': genre
	        } = {},
	        conviva: {
	          tags
	        } = {}
	      } = {}
	    } = mediaItem;
	    const posterHref = getMediaItemPosterHref(images);
	    data.hasEspnId3Heartbeats = hasEspnId3Heartbeats;
	    data.hasNielsenWatermarks = hasNielsenWatermarks;
	    data.hasPassThroughAds = hasPassThroughAds;
	    data.posterHref = posterHref;
	    data.asset = asset;
	    data.show = show;
	    data.genre = genre;
	    data.tags = tags;
	  }
	  return data;
	});

	var getTrackMediaItem = ((mediaItem, mediainfoData = {}, playlistId = null) => {
	  const {
	    name,
	    headline,
	    status,
	    live,
	    program,
	    publisher,
	    showcode,
	    simulcastAiringId,
	    leagueName,
	    sportName,
	    startType,
	    originalPublishDate,
	    custom_fields: mediaType
	  } = mediainfoData;
	  return {
	    ...mediaItem,
	    name,
	    headline,
	    status,
	    live,
	    program,
	    publisher,
	    showcode,
	    simulcastAiringId,
	    leagueName,
	    sportName,
	    startType,
	    originalPublishDate,
	    mediaType,
	    adIdSource: 'GAM',
	    playlistId
	  };
	});

	var MediaItemMediaCommand$4;
	(function (MediaItemMediaCommand) {
	    MediaItemMediaCommand[MediaItemMediaCommand["all"] = 0] = "all";
	    MediaItemMediaCommand[MediaItemMediaCommand["linearPlayback"] = 1] = "linearPlayback";
	})(MediaItemMediaCommand$4 || (MediaItemMediaCommand$4 = {}));
	var MediaItemMediaCommand$5 = MediaItemMediaCommand$4;

	var MediaItemNetworkType$4;
	(function (MediaItemNetworkType) {
	    MediaItemNetworkType["linear"] = "linear";
	    MediaItemNetworkType["event"] = "event";
	})(MediaItemNetworkType$4 || (MediaItemNetworkType$4 = {}));
	var MediaItemNetworkType$5 = MediaItemNetworkType$4;

	var MediaItemSourceVariant$5;
	(function (MediaItemSourceVariant) {
	    MediaItemSourceVariant["stitchedPreroll"] = "stitchedPreroll";
	})(MediaItemSourceVariant$5 || (MediaItemSourceVariant$5 = {}));

	var MediaItemStreamType$6;
	(function (MediaItemStreamType) {
	    MediaItemStreamType["live"] = "live";
	    MediaItemStreamType["onDemand"] = "onDemand";
	})(MediaItemStreamType$6 || (MediaItemStreamType$6 = {}));
	var MediaItemStreamType$7 = MediaItemStreamType$6;

	var MediaItemTrackingType$5;
	(function (MediaItemTrackingType) {
	    MediaItemTrackingType["nielsen"] = "nielsen";
	    MediaItemTrackingType["comscore"] = "comscore";
	    MediaItemTrackingType["conviva"] = "conviva";
	    MediaItemTrackingType["heartbeats"] = "heartbeats";
	})(MediaItemTrackingType$5 || (MediaItemTrackingType$5 = {}));

	var MediaItemEntityType$5;
	(function (MediaItemEntityType) {
	    MediaItemEntityType["shortform"] = "shortform";
	    MediaItemEntityType["longform"] = "longform";
	})(MediaItemEntityType$5 || (MediaItemEntityType$5 = {}));
	var MediaItemEntityType$6 = MediaItemEntityType$5;

	var MediaItemType$4;
	(function (MediaItemType) {
	    MediaItemType["audio"] = "audio";
	    MediaItemType["video"] = "video";
	})(MediaItemType$4 || (MediaItemType$4 = {}));
	var MediaItemType$5 = MediaItemType$4;

	var ApiSource$8;
	(function (ApiSource) {
	    ApiSource["pluto"] = "pluto";
	    ApiSource["graphQL"] = "graphQL";
	    ApiSource["cfa"] = "cfa";
	    ApiSource["itemFeed"] = "itemFeed";
	})(ApiSource$8 || (ApiSource$8 = {}));
	var ApiSource$9 = ApiSource$8;

	var MediaItemAuthenticationType$8;
	(function (MediaItemAuthenticationType) {
	    MediaItemAuthenticationType["open"] = "OPEN";
	    MediaItemAuthenticationType["direct"] = "DIRECT";
	    MediaItemAuthenticationType["mvpd"] = "MVPD";
	    MediaItemAuthenticationType["isp"] = "ISP";
	    MediaItemAuthenticationType["none"] = "NONE";
	})(MediaItemAuthenticationType$8 || (MediaItemAuthenticationType$8 = {}));
	var MediaItemAuthenticationType$9 = MediaItemAuthenticationType$8;

	var MediaItemSourceType$6;
	(function (MediaItemSourceType) {
	    MediaItemSourceType["none"] = "none";
	    MediaItemSourceType["startSession"] = "startSession";
	    MediaItemSourceType["bam"] = "bam";
	    MediaItemSourceType["shield"] = "shield";
	    MediaItemSourceType["entitlement"] = "entitlement";
	})(MediaItemSourceType$6 || (MediaItemSourceType$6 = {}));
	var MediaItemSourceType$7 = MediaItemSourceType$6;

	class MediaItemSource {
	    constructor(url, type, hasEspnId3Heartbeats, hasNielsenWatermarks, hasPassThroughAds, commercialReplacement, startSessionUrl, variant) {
	        this.url = url;
	        this.type = type;
	        this.hasEspnId3Heartbeats = hasEspnId3Heartbeats;
	        this.hasNielsenWatermarks = hasNielsenWatermarks;
	        this.hasPassThroughAds = hasPassThroughAds;
	        this.commercialReplacement = commercialReplacement;
	        this.startSessionUrl = startSessionUrl;
	        this.variant = variant;
	    }
	    static fromObject(object) {
	        if (!object) {
	            return null;
	        }
	        const { url, type, hasEspnId3Heartbeats, hasNielsenWatermarks, hasPassThroughAds, commercialReplacement, startSessionUrl, variant, } = object;
	        const sourceType = MediaItemSourceType$7[type] || MediaItemSourceType$7.none;
	        return new MediaItemSource(url, sourceType, hasEspnId3Heartbeats, hasNielsenWatermarks, hasPassThroughAds, commercialReplacement, startSessionUrl, variant);
	    }
	}

	class MediaItemNetwork {
	    constructor(id, type, name, resource, affiliate = null) {
	        this.id = id;
	        this.type = type;
	        this.name = name;
	        this.resource = resource;
	        this.affiliate = affiliate;
	    }
	    static fromObject(object) {
	        if (!object) {
	            return null;
	        }
	        const type = MediaItemNetworkType$5[object.type];
	        return new MediaItemNetwork(object.id, type, object.name, object.resource, object.affiliate);
	    }
	}

	class MediaItemImage {
	    constructor(url, ratio) {
	        this.url = url;
	        this.ratio = ratio;
	    }
	    static fromObject(object) {
	        if (object === null || object === void 0 ? void 0 : object.url) {
	            const { url, ratio } = object;
	            return new MediaItemImage(url, ratio);
	        }
	        return null;
	    }
	}

	class MediaItemPackage {
	    constructor(name) {
	        this.name = name;
	    }
	    get logoUrl() {
	        return `https://secure.espncdn.com/watchespn/images/espnplus/packages/${this.name}.png`;
	    }
	    static fromObject(object) {
	        if (!object) {
	            return null;
	        }
	        return new MediaItemPackage(object.name);
	    }
	}

	class MediaItem {
	    constructor(id, title, duration, language, source) {
	        this.id = id;
	        this.title = title;
	        this.duration = duration;
	        this.language = language || 'en';
	        this.source = source;
	        this.description = null;
	        this.authenticationTypes = [];
	        this.mrss = null;
	        this.seekInSeconds = null;
	        this.tracking = {};
	        this.references = {};
	        this.network = null;
	        this.streamType = null;
	        this.supportedMediaCommands = MediaItemMediaCommand$5.all;
	        this.images = [];
	        this.type = MediaItemType$5.video;
	        this.packages = [];
	        this.tier = null;
	        this.entityType = null;
	        this.isSyndicatable = null;
	        this.brand = null;
	        this.siteBrandId = null;
	        this.apiSource = null;
	        this.adUnitId = null;
	        this.cues = null;
	        this.adTarget = null;
	        this.show = null;
	        this.remoteTextTrack = null;
	        this.advertisingInfo = null;
	        this.schedule = null;
	    }
	    get isLinear() {
	        return !!this.network && this.network.type === MediaItemNetworkType$5.linear;
	    }
	    get isLive() {
	        return this.streamType === MediaItemStreamType$7.live;
	    }
	    static fromObject(json) {
	        const source = MediaItemSource.fromObject(json.source);
	        const mediaItem = new MediaItem(json.id, json.title, json.duration, json.language, source);
	        mediaItem.airDate = json.airDate;
	        mediaItem.apiSource = json.apiSource;
	        mediaItem.authenticationTypes = json.authenticationTypes;
	        mediaItem.description = json.description;
	        mediaItem.images = (json.images || []).map(img => MediaItemImage.fromObject(img));
	        mediaItem.mrss = json.mrss;
	        mediaItem.network = MediaItemNetwork.fromObject(json.network);
	        mediaItem.seekInSeconds = json.seekInSeconds;
	        mediaItem.streamType = MediaItemStreamType$7[json.streamType];
	        mediaItem.supportedMediaCommands = json.supportedMediaCommands;
	        mediaItem.tracking = json.tracking;
	        mediaItem.references = json.references;
	        mediaItem.packages = (json.packages || []).map(pkg => MediaItemPackage.fromObject(pkg));
	        mediaItem.tier = json.tier;
	        mediaItem.type = MediaItemType$5[json.type];
	        mediaItem.entityType = MediaItemEntityType$6[json.entityType];
	        mediaItem.isSyndicatable = json.isSyndicatable;
	        mediaItem.brand = json.brand;
	        mediaItem.siteBrandId = json.siteBrandId;
	        mediaItem.adUnitId = json.adUnitId;
	        mediaItem.cues = json.cues;
	        mediaItem.show = json.show;
	        mediaItem.adTarget = json.adTarget;
	        mediaItem.seekBarThumbnails = json.seekBarThumbnails;
	        mediaItem.availableDate = json.availableDate;
	        mediaItem.episodeNumber = json.episodeNumber;
	        mediaItem.locale = json.locale;
	        mediaItem.seasonNumber = json.seasonNumber;
	        mediaItem.tmsid = json.tmsid;
	        mediaItem.videoShowGenre = json.videoShowGenre;
	        mediaItem.remoteTextTrack = json.remoteTextTrack;
	        mediaItem.advertisingInfo = json.advertisingInfo;
	        mediaItem.schedule = json.schedule;
	        return mediaItem;
	    }
	    toString() {
	        return `<MediaItem id:${this.id}, title:${this.title}, streamType:${this.streamType}>`;
	    }
	}

	const defaultGraphQLServiceUrl$4 = 'https://watch.graph.api.espn.com/api';
	const defaultGraphQLApiKey$4 = 'd15c5790-7cb0-4fe1-8782-25f4698d0739';
	const defaultGraphQLNetworkSortOrder$4 = [
	    'espn_ppv',
	    'espn_dtc',
	    'espn1',
	    'espn2',
	    'espn3',
	    'espnu',
	    'sec',
	    'espnews',
	    'espndeportes',
	    'longhorn',
	    'goalline',
	    'buzzerbeater',
	    'secplus',
	    'acc',
	    'accextra',
	    'espn_free',
	    'bam_dtc',
	];
	const defaultItemFeedServiceUrl$4 = 'https://abcnews.go.com/video/itemfeed';
	class Configuration$6 {
	    constructor(apiSource, serviceUrl, apiKey, networkSortOrder) {
	        if (apiSource === ApiSource$9.graphQL) {
	            this.serviceUrl = serviceUrl || defaultGraphQLServiceUrl$4;
	            this.apiKey = apiKey || defaultGraphQLApiKey$4;
	            this.networkSortOrder = networkSortOrder || defaultGraphQLNetworkSortOrder$4;
	        }
	        else if (apiSource === ApiSource$9.cfa) {
	            this.apiSource = apiSource;
	            this.serviceUrl = serviceUrl;
	        }
	        else if (apiSource === ApiSource$9.itemFeed) {
	            this.serviceUrl = serviceUrl || defaultItemFeedServiceUrl$4;
	        }
	    }
	}

	new Configuration$6(ApiSource$9.graphQL);

	Object.freeze({});
	Object.freeze({});
	ApiSource$9.itemFeed;

	new Configuration$6(ApiSource$9.itemFeed);

	class Configuration$5 {
	    constructor(serviceUrl, appVersion) {
	        this.serviceUrl = serviceUrl;
	        this.appVersion = appVersion;
	    }
	}
	const defaultServiceUrl$2 = 'https://prod.gatekeeper.us-abc.symphony.edgedatg.com/api/ws/pluto/v1/layout';
	const defaultAppVersion$1 = '1.0.0';
	const defaultConfiguration$1 = new Configuration$5(defaultServiceUrl$2, defaultAppVersion$1);

	class PlutoAPI {
	    constructor(configuration = defaultConfiguration$1) {
	        this.configuration_ = configuration;
	});
	    }
	    getMediaItem(identifier, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const layoutURL = this.getLayoutURLFromParams(Object.assign(Object.assign({}, options), { identifier: identifier }));
	            const layoutResponse = yield this.getLayout(layoutURL);
	            const videoPlayerModuleResource = layoutResponse.modules.filter(module => {
	                return module.type == 'videoplayer';
	            })[0];
	            if (!videoPlayerModuleResource) {
	                throw new Error('Layout is missing Video Player module');
	            }
	            if (options.type === 'live_player') {
	                videoPlayerModuleResource.resource = videoPlayerModuleResource.resource.replace('{affiliate}', identifier);
	            }
	            const videoPlayer = yield this.getVideoPlayerModule(videoPlayerModuleResource.resource);
	            const mediaItem = this.getMediaItemFromVideoPlayer(videoPlayer);
	            return mediaItem;
	        });
	    }
	    getLayoutURLFromParams(params) {
	        if (!params.brand || !params.device || !params.type) {
	            throw new Error('Cannot create layout url, missing parameters');
	        }
	        const queryParameters = {
	            brand: params.brand,
	            device: params.device,
	        };
	        if (params.type == 'vod_player') {
	            if (!params.identifier) {
	                throw new Error('Cannot create layout url, missing video id');
	            }
	            queryParameters['type'] = 'vod_player';
	            queryParameters['video'] = params.identifier;
	        }
	        if (params.type == 'live_player') {
	            queryParameters['type'] = 'live_player';
	            queryParameters['authlevel'] = '1';
	            queryParameters['affiliate'] = params.identifier || '';
	            params.channel ? (queryParameters['channel'] = params.channel) : null;
	            params.video ? (queryParameters['video'] = params.video) : null;
	        }
	        const query = Object.keys(queryParameters)
	      ey] || ''))
	            .join('&');
	        const sep = this.configuration_.serviceUrl.indexOf('?') === -1 ? '?' : '&';
	        return `${this.configuration_.serviceUrl}${sep}${query}`;
	    }
	    getMediaItemFromVideoPlayer(videoPlayerResponse) {
	        if (videoPlayerResponse.video) {
	            return this.getMediaItemForVOD(videoPlayerResponse);
	        }
	        else if (videoPlayerResponse.channels) {
	            return this.getMediaItemForChannel(videoPlayerResponse);
	        }
	    }
	    getMediaItemForChannel(videoPlayerResponse) {
	        var _a;
	        if (videoPlayerResponse.channels.length == 0) {
	            throw new Error('Live video player module has no channels');
	        }
	        const channel = videoPlayerResponse.channels[0];
	        const mediaItem = new MediaItem(channel.id, channel.title, 0, 'en', null);
	        mediaItem.description = channel.description;
	        mediaItem.authenticationTypes =
	            channel.accesslevel == '0' ? [MediaItemAuthenticationType$9.none] : [MediaItemAuthenticationType$9.mvpd];
	        const brand = getBrandFromString(channel.brand);
	        mediaItem.brand = brand;
	        mediaItem.mrss = this.getAdobeMRSS(mediaItem.id, mediaItem.title, brandResourceId(brand), channel.tvrating);
	        mediaItem.streamType = MediaItemStreamType$7.live;
	        mediaItem.type = MediaItemType$5.video;
	        mediaItem.apiSource = ApiSource$9.pluto;
	        mediaItem.availableDate = channel.availdate;
	        mediaItem.network = new MediaItemNetwork(channel.aff, MediaItemNetworkType$5.linear, channel.title, brandResourceId(brand));
	        mediaItem.images = (_a = channel.previews) === null || _a === void 0 ? void 0 : _a.map(image => {
	            return new MediaItemImage(image.value);
	        });
	        return mediaItem;
	    }
	    getMediaItemForVOD(videoPlayerResponse) {
	        const mediaItem = new MediaItem(videoPlayerResponse.video.id, videoPlayerResponse.video.title, videoPlayerResponse.video.duration, videoPlayerResponse.video.show.language, null);
	        mediaItem.description = videoPlayerResponse.video.description;
	        mediaItem.authenticationTypes =
	            videoPlayerResponse.video.accesslevel == '0' ? [MediaItemAuthenticationType$9.none] : [MediaItemAuthenticationType$9.mvpd];
	        const brand = getBrandFromString(videoPlayerResponse.video.brand);
	        mediaItem.brand = brand;
	        mediaItem.mrss = this.getAdobeMRSS(mediaItem.id, mediaItem.title, brandResourceId(brand), videoPlayerResponse.video.rating.value);
	        mediaItem.show = videoPlayerResponse.video.show;
	        mediaItem.cues = videoPlayerResponse.video.cues;
	        mediaItem.adTarget = videoPlayerResponse.video.adTarget;
	        mediaItem.adUnitId = videoPlayerResponse.adUnitId;
	        mediaItem.streamType = MediaItemStreamType$7.onDemand;
	        mediaItem.type = MediaItemType$5.video;
	        mediaItem.apiSource = ApiSource$9.pluto;
	        mediaItem.entityType = videoPlayerResponse.video.type == 'lf' ? MediaItemEntityType$6.longform : MediaItemEntityType$6.shortform;
	        mediaItem.seasonNumber = videoPlayerResponse.video.seasonnumber;
	        mediaItem.episodeNumber = videoPlayerResponse.video.episodenumber;
	        mediaItem.videoShowGenre = videoPlayerResponse.video.show.genre;
	        mediaItem.tmsid = videoPlayerResponse.video.tmsid;
	        mediaItem.availableDate = videoPlayerResponse.video.availableDate;
	        mediaItem.airDate = videoPlayerResponse.video.displayAirtime;
	        if (Array.isArray(videoPlayerResponse.images)) {
	            mediaItem.images = videoPlayerResponse.images.map(image => {
	                return new MediaItemImage(image.value);
	            });
	        }
	        return mediaItem;
	    }
	    getLayout(url) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const headers = {
	                appversion: this.configuration_.appVersion,
	            };
	            const options = {
	                headers,
	            };
	            return fetch(url, options)
	                .then(response => {
	                if (!response.ok) {
	                    throw response;
	                }
	                return response.json();
	            })
	                .then(json => {
	                return json;
	            });
	        });
	    }
	    getVideoPlayerModule(url) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const headers = {
	                appversion: this.configuration_.appVersion,
	            };
	            const options = {
	                headers,
	            };
	            return fetch(url, options)
	                .then(response => {
	                if (!response.ok) {
	                    throw response;
	                }
	                return response.json();
	            })
	                    });
	        });
	    }
	    getAdobeMRSS(mediaId, mediaTitle, resourceId, mediaRating) {
	        let urn = 'urn:mpaa';
	        if (!mediaRating || mediaRating.length === 0) {
	            mediaRating = 'TV-Y';
	        }
	        if (mediaRating.indexOf('TV-') === 0) {
	            urn = 'urn:v-chip';
	        }
	        const sanitizedMediaId = this.xmlSanitize(mediaId);
	        const sanitizedMediaTitle = this.xmlSanitize(mediaTitle);
	        const sanitizedResourceId = this.xmlSanitize(resourceId);
	        const sanitizedUrn = this.xmlSanitize(urn);
	        const sanitizedMediaRating = this.xmlSanitize(mediaRating);
	        let resource = '<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel>';
	        resource += '<title>' + sanitizedResourceId + '</title>';
	        resource += '<item>';
	        resource += '<title><![CDATA[' + sanitizedMediaTitle + ']]></title>';
	        resource += '<guid>' + sanitizedMediaId + '</guid>';
	        resource += '<media:rating scheme="' + sanitizedUrn + '">' + sanitizedMediaRating + '</media:rating>';
	        resource += '</item></channel></rss>';
	        return resource;
	    }
	    xmlSanitize(string) {
	        let xmlString = string.replace('&', '&amp;');
	        xmlString = xmlString.replace('<', '&lt;');
	        xmlString = xmlString.replace('>', '&gt;');
	        xmlString = xmlString.replace('"', '&quot;');
	        xmlString = xmlString.replace("'", '&apos;');
	        return xmlString;
	    }
	}

	var getMediaItemDataSource = (mediaItem => {
	  switch (mediaItem.apiSource) {
	    case ApiSource$d.pluto:
	      return new PlutoAPI();
	    case ApiSource$d.graphQL:
	    case ApiSource$d.itemFeed:
	    case ApiSource$d.cfa:
	      return new UniversalMediaItemAPI();
	  }
	  return null;
	});

	/**
	 * @param {Object|null} bootstrapConfig
	 * @param {Object} configuration
	 * @return {{shield: (boolean|void), entertainment: (boolean|void)}}
	 */
	const getPalConfig = (bootstrapConfig = {}, configuration = {}) => {
	  let bootstrapConfig_ = bootstrapConfig;
	  if (bootstrapConfig_ === null) {
	    bootstrapConfig_ = {};
	  }
	  const {
	    webservices: {
	      shield = {},
	      entertainment = {}
	    } = {}
	  } = bootstrapConfig_;
	  const {
	    api = {}
	  } = configuration;
	  return {
	    shield: api.palEnabled === undefined ? shield.palEnabled : api.palEnabled,
	    entertainment: api.palEnabled === undefined ? entertainment.palEnabled : api.palEnabled
	  };
	};

	function getAuthenticationType(mediaItem, tokenType) {
	  let authenticationType = null;
	  if (mediaItem.authenticationTypes.length === 1) {
	    authenticationType = mediaItem.authenticationTypes[0].toString();
	  } else if (mediaItem.authenticationTypes.length > 1) {
	    if (mediaItem.authenticationTypes.indexOf('MVPD') !== -1 && tokenType === 'ADOBEPASS') {
	      authenticationType = MediaItemAuthenticationType$c.mvpd;
	    } else if (mediaItem.authenticationTypes.indexOf('ISP') !== -1 && tokenType !== 'ADOBEPASS') {
	      authenticationType = MediaItemAuthenticationType$c.isp;
	    }
	  }
	  return authenticationType;
	}

	const DEFAULT_CONFIGS = {
	  authButler: {
	    partner: 'watchespn',
	    platform: 'web'
	  },
	  concurrencyMonitor: {
	    messages: null,
	    serviceUrl: null,
	    platform: 'web',
	    applicationId: '3bfbbbdf-be8e-40be-9540-97a73469ada2',
	    programmer: 'ESPN'
	  },
	  endcard: true,
	  loop: false,
	  seekStep: VIDEO_SEEK_STEP,
	  skipInitialFocus: true,
	  volume: {
	    namespace: 'dtci'
	  },
	  disableAdobe: true,
	  disableComscore: true,
	  disableChartbeat: true,
	  disableNielsen: true,
	  disableConviva: true,
	  enableQoe: false
	};
	const AKAMAI_REGEX = new RegExp(['espn.go.com', 'linearhlsls-i.akamaihd.net', 'linearhlsls2-i.akamaihd.net', 'espn3hlsint-i.akamaihd.net', 'espn-int-hls.akamaized.net', 'espn3hlsls.akamaized.net'].join('|'));
	const AD_PROVIDER_DEFAULT_SRC = 'data:video/mp4;base64,AAAAIGZ0eXBpc29tAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAAA79tZGF0AAAC9AYF///w3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9MTIgbG9va2FoZWFkX3RocmVhZHM9MSBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxhY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHlyYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3ZWlnaHRwPTEga2V5aW50PTI0MCBrZXlpbnRfbWluPTI0IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9MTAgcmM9Y3JmIG1idHJlZT0xIGNyZj01MS4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT0yMDAwMCB2YnZfYnVmc2l6ZT0yNTAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAADFliIQAbwTYb+YMExstjI/2DFAAAAMAAA94QCcYYsAAASkAtD1oHHXQk/QgAAADAHxBAAAACUGaJBiL/wAA/wAAAAhBnkJCfwAB6QAAAAgBnmFF/wAB8wAAAAgBnmNF/wAB8wAAAApBmmg0TET/AAEPAAAACkGehkURLP8AAekAAAAIAZ6lRf8AAfMAAAAIAZ6nRf8AAfMAAAAJQZqrNExfAAFTAAAACEGeykJfAAHpAAAACAGe6UX/AAHzAAADym1vb3YAAABsbXZoZAAAAADTQ/Pq00Pz6gAAA+gAAAHLAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAL1dHJhawAAAFx0a2hkAAAAD9ND8+rTQ/PqAAAAAQAAAAAAAAHLAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAGsAAAA8AAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAABAAABywAAHVQAAQAAAAACbW1kaWEAAAAgbWRoZAAAAADTQ/Pq00Pz6gABX5AAAKFMVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAAAAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAAAhhtaW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAAAMdXJsIAAAAAEAAAHYc3RibAAAAJhzdHNkAAAAAAAAAAEAAACIYXZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAGsAPAASAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAAADJhdmNDAU1AKP/hABpnTUAo7KDY/3zUBAQFAAADAAEAAr8gDxgxlgEABWjvgZcgAAAAQHN0dHMAAAAAAAAABgAAAAUAAA6qAAAAAQAADqkAAAADAAAOqgAAAAEAAA6pAAAAAQAADqoAAAABAAAAAAAAABRzdHNzAAAAAAAAAAEAAAABAAAAcGN0dHMAAAAAAAAADAAAAAEAAB1UAAAAAQAASVEAAAABAAAdVAAAAAEAAAAAAAAAAQAADqoAAAABAABJUAAAAAEAAB1UAAAAAQAAAAAAAAABAAAOqgAAAAEAADqnAAAAAQAAHVQAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAADAAAAAEAAABEc3RzegAAAAAAAAAAAAAADAAAAy0AAAANAAAADAAAAAwAAAAMAAAADgAAAA4AAAAMAAAADAAAAA0AAAAMAAAADAAAABRzdGNvAAAAAAAAAAEAAAAwAAAAYXVkdGEAAABZbWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcmFwcGwAAAAAAAAAAAAAAAAsaWxzdAAAACSpdG9vAAAAHGRhdGEAAAABAAAAAExhdmY1NC42LjEwMA==';

	// black poster image
	const DEFAULT_POSTER_IMG = 'data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=';
	class ConfigurationService {
	  constructor(type, configuration) {
	    this.configuration_ = null;
	    this.coordinator_ = null;
	    this.type = null;
	    this.bootstrapResponse = null;
	    this.type = type;
	    this.configuration = configuration;
	    this.combineAndMassageConfigsForLoad = this.combineAndMassageConfigsForLoad.bind(this);
	    this.loadBootstrapConfig = this.loadBootstrapConfig.bind(this);
	    this.mergeNewRelicConfig = this.mergeNewRelicConfig.bind(this);
	    this.getNewRelicConfig = this.getNewRelicConfig.bind(this);
	  }
	  get configuration() {
	    return this.configuration_;
	  }
	  set configuration(v) {
	    this.configuration_ = v;
	  }
	  set coordinator(coord) {
	    this.coordinator_ = coord;
	  }
	  updateAutoPlaySetting_(autoplay) {
	    if (autoplay !== undefined) {
	      return autoplay;
	    }
	    return localStorage.getItem('user_selected_autoplay') === 'true';
	  }
	  combineAndMassageConfigsForLoad(loadRequest) {
	    var _authorizationPayload;
	    const {
	      advertisingInfo,
	      configuration = {},
	      identifier,
	      mediaItem,
	      playbackSession
	    } = loadRequest;
	    let {
	      authorizationPayload = {}
	    } = loadRequest;

	    // Fix for AdobeCM on entertainment.
	    // Client has to pass swid(unique id for user) and mvpd if the user is logued
	    if (!((_authorizationPayload = authorizationPayload) !== null && _authorizationPayload !== void 0 && _authorizationPayload.provider)) {
	      var _authorizationPayload2, _authorizationPayload3;
	      authorizationPayload.provider = ((_authorizationPayload2 = authorizationPayload) === null || _authorizationPayload2 === void 0 ? void 0 : (_authorizationPayload3 = _authorizationPayload2.customData) === null || _authorizationPayload3 === void 0 ? void 0 : _authorizationPayload3.mvpd) || null;
	    }
	    if (!(authorizationPayload instanceof AuthorizationPayload)) {
	      authorizationPayload = this.buildAuthorizationPayload({
	        ...authorizationPayload
	      }, {
	        ...mediaItem
	      });
	    }
	    const combinedConfig = {
	      ...configuration,
	      mediaItem: mediaItem ? {
	        ...mediaItem
	      } : null,
	      advertisingInfo: advertisingInfo ? {
	        ...advertisingInfo
	      } : null,
	      identifier,
	      type: this.type,
	      authorizationPayload,
	      playbackSession
	    };

	    // Prevents duplicated tracks,
	    // html5 is used by videojs to set some user configurations for UX, for more info please go to
	    // https://docs.videojs.com/tutorial-text-tracks.html#emulated-text-tracks
	    if (!combinedConfig.html5) {
	      combinedConfig.html5 = {
	        nativeTextTracks: true
	      };
	    }
	    if (combinedConfig.mediaItem) {
	      combinedConfig.isAudio = combinedConfig.mediaItem.type === 'audio';
	      if (!combinedConfig.brand) {
	        combinedConfig.brand = combinedConfig.mediaItem.brand;
	      }
	    }
	    combinedConfig.autoplay = this.updateAutoPlaySetting_(combinedConfig.autoplay);
	    return combinedConfig;
	  }
	  mergeBootstrapConfig_(combinedConfig) {
	    const {
	      bootstrapResponse
	    } = this;
	    const {
	      api = {}
	    } = combinedConfig;
	    let bootstrappedConfig = combinedConfig;
	    api.pal = getPalConfig(bootstrapResponse, combinedConfig);
	    if (bootstrapResponse) {
	      bootstrappedConfig = this.mergeNewRelicConfig(bootstrapResponse);
	    }
	    return bootstrappedConfig;
	  }
	  async loadBootstrapConfig(combinedConfig) {
	    this.configuration_ = combinedConfig;
	    this.coordinator_.coordinate(CUSTOM_EVENTS.FETCH_APP_CONFIG);
	    try {
	      var _this$bootstrapRespon;
	      this.bootstrapResponse = await this.getBootstrapConfig();
	      this.coordinator_.coordinate(CUSTOM_EVENTS.FETCH_APP_CONFIG_FINISHED, true);
	      combinedConfig.brandConfig = (_this$bootstrapRespon = this.bootstrapResponse) === null || _this$bootstrapRespon === void 0 ? void 0 : _this$bootstrapRespon.brands[combinedConfig.brand];
	      const {
	        api = {}
	      } = combinedConfig;
	      api.pal = getPalConfig(this.bootstrapResponse, combinedConfig);
	      const bootstrappedConfig = this.mergeBootstrapConfig_(combinedConfig);
	      return bootstrappedConfig;
	    } catch (e) {
	      this.coordinator_.coordinate(CUSTOM_EVENTS.FETCH_APP_CONFIG_FINISHED, false);
	      throw new Error(e.message);
	    }
	  }
	  async getBootstrapConfig() {
	    let response = null;
	    const url = this.getBootstrapConfigUrl_();
	    const result = await fetchServices({
	      url,
	      method: 'GET'
	    });
	    if (result && result.success) {
	      response = result.response;
	    }
	    return response;
	  }
	  getBootstrapConfigUrl_() {
	    const isApiForQA = this.isApiForQA_();
	    const url = isApiForQA ? PLAYER_CONFIG_URL_QA : PLAYER_CONFIG_URL_PROD;
	    return url;
	  }
	  isApiForQA_() {
	    const {
	      api: {
	        apienv = ''
	      } = {}
	    } = this.configuration || {};
	    let isQA = false;
	    if (apienv.toLowerCase() === 'qa') {
	      isQA = true;
	    } else {
	      const regex = /(?=.*apienv=qa)/i;
	      const url = window && window.location && window.location.href;
	      isQA = !!(url && url.match(regex) !== null);
	    }
	    return isQA;
	  }
	  mergeNewRelicConfig(bootstrapConfig) {
	    const newRelicConfig = this.getNewRelicConfig(bootstrapConfig);
	    if (this.configuration.analytics) {
	      this.configuration.analytics = {
	        ...this.configuration.analytics,
	        newRelic: {
	          ...newRelicConfig,
	          ...this.configuration.analytics.newRelic
	        }
	      };
	    } else {
	      this.configuration.analytics = {
	        newRelic: newRelicConfig
	      };
	    }
	    return this.configuratioelic;
	  }
	  getMergedConfigs(currentConfigs = {}, configs = {}) {
	    currentConfigs.seekStep = configs.isAudio ? AUDIO_SEEK_STEP : VIDEO_SEEK_STEP;
	    const mergedConfigs = {
	      ...currentConfigs,
	      ...configs
	    };
	    if (configs.concurrencyMonitor) {
	      mergedConfigs.concurrencyMonitor = {
	        ...currentConfigs.concurrencyMonitor,
	        ...configs.concurrencyMonitor
	      };
	    }
	    if (configs.volume) {
	      mergedConfigs.volume = {
	        ...currentConfigs.volume,
	        ...configs.volume
	      };
	    }
	    return mergedConfigs;
	  }
	  buildAuthorizationPayload(payload, mediaItem) {
	    const {
	      accountId,
	      authenticationType,
	      customData: {
	        resource,
	        token,
	        tokenType,
	        zipcode,
	        mvpd
	      } = {},
	      provider
	    } = payload || {};
	    const customData = {
	      resource,
	      token,
	      tokenType,
	      zipcode,
	      mvpd
	    };
	    const authenticatedProvider = new AuthenticatedProvider(provider, provider, null, null);
	    let authType = authenticationType;
	    if (mediaItem && mediaItem.authenticationTypes) {
	      authType = getAuthenticationType(mediaItem, tokenType);
	    }
	    return new AuthorizationPayload(authType, authenticatedProvider, accountId, customData);
	  }
	}

	var floor = Math.floor;

	// `IsIntegralNumber` abstract operation
	// https://tc39.es/ecma262/#sec-isintegralnumber
	// eslint-disable-next-line es/no-number-isinteger -- safe
	var isIntegralNumber$1 = Number.is=== it;
	};

	var isIntegralNumber = isIntegralNumber$1;

	// `Number.isInteger` method
	// https://tc39.es/ecma262/#sec-number.isinteger
	$({ target: 'Number', stat: true }, {
	  isInteger: isIntegralNumber
	});

	var isInteger$2 = path.Number.isInteger;

	var parent$3 = isInteger$2;

	var isInteger$1 = parent$3;

	var require$$0$4 = isInteger$1;

	var isInteger = require$$0$4;

	class BlankEndcard {
	  constructor(config) {
	    this.secondsRemaining_ = null;
	    this.config = config;
	    this.duration_ = this.config.duration || 1000is));
	  }
	  setNextContent(mediaItem) {
	    this.nextContent_ = mediaItem;
	  }
	  onPlayNext() {
	    clearInterval(this.countdownInterval_);
	    this.config.coordinator.coordinate('dtci.endcard.playNext');
	  }
	  show(updateFn = () => {}) {
	    this.config.coordinator.coordinate('dtci.endcard.show');
	    this.secondsRemaining_ = this.duration_ / 1000;
	    updateFn(this.secondsRemaining_ * 1000);
	    if (this.countdownInterval_) {
	      clearInterval(this.countdownInterval_);
	    }
	    this.countdownInterval_ = setInterval(() => {
	      if (this.secondsRemaining_ <= 0) {
	        this.secondsRemaining_ = null;
	        clearInterval(this.countdownInterval_);
	        this.onPlayNext(false);
	        return;
	      }
	      this.secondsRemaining_ -= 1;
	      updateFn(this.secondsRemaining_ * 1000);
	    }, 1000);
	  }
	  hide() {
	    this.config.coordinator.coordinate('dtci.endcard.hide');
	    clearInterval(this.countdownInterval_);
	  }
	  onDispose_() {
	    clearInterval(this.countdownInterval_);
	    this.config.coordinator.removeEventListener('dtci.dispose', this.onDispose);
	  }
	}

	class ChromelessEndcard extends BlankEndcard {
	  constructor(...args) {
	    super(...args);
	    this.onPlayNext = wasManual => {
	      super.onPlayNext(wasManual);
	      this.config.onPlayNextContent(this.nextContent_, wasManual);
	    };
	  }
	}

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 array;
	});

	var isConcatSpy$1(O);
	};

	var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

	// `Array.prototype.concat` method
	// https://tc39.es/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
rn A;
	  }
	});

	var concat$3 = entryVirtual('Array').concat;

	var method$1 = concat$3;

	var ArrayPrototype$1 = Array.prototype;

	var concat$2 = function (it) {
	  var own = it.concat;
	  return it === ArrayPrototype$1 || (isPrototypeOf(ArrayPrototype$1, it) && own === ArrayPrototype$1.concat) ? method$1 : own;
	};

	var parent$2 = concat$2;

	var concat$1 = parent$2;

	var require$$0$3 = concat$1;

	var concat = require$$0$3;

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used to match template delimiters. */
	var reInterpolate = /<%=([\s\S]+?)%>/g;

	var lodash__reinterpolate = reInterpolate;

	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */


	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]';

	/** Used to match HTML entities and HTML characters. */
	var reUnescapedHtml = /[&<>"']/g,
	    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	/** Used to match template delimiters. */
	var reEscape = /<%-([\s\S]+?)%>/g,
	    reEvaluate = /<%([\s\S]+?)%>/g;

	/** Used to map characters to HTML entities. */
	var htmlEscapes = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;'
	};

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.propertyOf` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Function} Returns the new accessor funct;
	  };
	}

	/**
	 * Used by `_.escape` to convert characters to HTML entities.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped character.
	 */
	var escapeHtmlChar = basePropertyOf(htmlEscapes);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var Symbol$1 = root.Symbol,
	    symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * By default, the template delimiters used by lodash are like those in
	 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	 * following template settings to use alternative delimiters.
	 *
	 * @static
	 * @memberOf _
	 * @type {Object}
	 */
	var templateSettings = {

	  /**
	   * Used to detect `data` property values to be HTML-escaped.
	   *
	   * @memberOf _.templateSettings
	   * @type {RegExp}
	   */
	  'escape': reEscape,

	  /**
	   * Used to detect code to be evaluated.
	   *
	   * @memberOf _.templateSettings
	   * @type {RegExp}
	   */
	  'evaluate': reEvaluate,

	  /**
	   * Used to detect `data` property values to inject.
	   *
	   * @memberOf _.templateSettings
	   * @type {RegExp}
	   */
	  'interpolate': lodash__reinterpolate,

	  /**
	   * Used to reference the data object in the template text.
	   *
	   * @memberOf _.templateSettings
	   * @type {string}
	   */
	  'variable': '',

	  /**
	   * Used to import variables into the compiled template.
	   *
	   * @memberOf _.templateSettings
	   * @type {Object}
	   */
	  'imports': {

	    /**
	     * A reference to the `lodash` function.
	     *
	     * @memberOf _.templateSettings.imports
	     * @type {Function}
	     */
	    '_': { 'escape': escape$1 }
	  }
	};

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	 * corresponding HTML entities.
	 *
	 * **Note:** No other characters are escaped. To escape additional
	 * characters use a third-party library like [_he_](https://mths.be/he).
	 *
	 * Though the ">" character is escaped for symmetry, characters like
	 * ">" and "/" don't need escaping in HTML and have no special meaning
	 * unless they're part of a tag or unquoted attribute value. See
	 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	 * (under "semi-related fun fact") for more details.
	 *
	 * When working with HTML you should always
	 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	 * XSS vectors.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escape('fred, barney, & pebbles');
	 * // => 'fred, barney, &amp; pebbstring;
	}

	var lodash_templatesettings = templateSettings;

	var lodash_template = createCommonjsModule(function (module, exports) {
	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */


	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    domExcTag = '[object DOMException]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to match empty string literals in compiled template source. */
	var reEmptyStringLeading = /\b__p \+= '';/g,
	    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/**
	 * Used to match
	 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	 */
	var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to ensure capturing order of template delimiters. */
	var reNoMatch = /($^)/;

	/** Used to match unescaped characters in compiled string literals. */
	var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Used to escape characters for inclusion in compiled string literals. */
	var stringEscapes = {
	  '\\': '\\',
	  "'": "'",
	  '\n': 'n',
	  '\r': 'r',
	  '\u2028': 'u2028',
	  '\u2029': 'u2029'
	};

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var n (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `fu args);
	}

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped arresult;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of resuresult;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped funct;
	  };
	}

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property val
	  });
	}

	/**
	 * Used by `_.template` to escape characters for inclusion in compiled string literals.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped characs[chr];
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property vat[key];
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new funct;
	  };
	}

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var mas) : '';
	}());

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString.call(Object);

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    getPrototype = overArg(Object.getPrototypeOf, Object),
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	var defineP (e) {}
	}());

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object),
	    nativeMax = Math.max,
	    nativeNow = Date.now;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property naresult;
	}

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to ass);
	  }
	}

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to asse;
	  }
	}

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTvalue);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` objrgsTag;
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `falalue));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `falalue)];
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property naresult;
	}

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property naresult;
	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new funct + '');
	}

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? 
	  });
	};

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the strresult;
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `objeobject;
	}

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner funct
	  });
	}

	/**
	 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	 * of source objects to the destination object for all destination properties
	 * that resolve to `undefined`.
	 *
	 * @private
	 * @param {*} objValue The destination value.
	 * @param {*} srcValue The source value.
	 * @param {string} key The key of the property to assign.
	 * @param {Object} object The parent object of `objValue`.
	 * @returns {*} Returns the value to assjValue;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefinefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTresult;
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `falength);
	}

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `fal false;
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `fal func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `fal proto;
	}

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property naresult;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new funct;
	  };
	}

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable funct;
	  };
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source curn '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsAllee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => fvalue);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	 * `SyntaxError`, `TypeError`, or `URIError` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	 * @example
	 *
	 * _.isError(new Error);
	 * // => true
	 *
	 * _.isError(Error);
	 * // => falue));
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => foxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => fNTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => ftion');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => fbject';
	}

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => String;
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => folTag);
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,value);
	}

	/**
	 * This method is like `_.assignIn` except that it accepts `customizer`
	 * which is invoked to produce the assigned values. If `customizer` returns
	 * `undefined`, assignment is handled by the method instead. The `customizer`
	 * is invoked with five arguments: (objValue, srcValue, key, object, source).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extendWith
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @see _.assignWith
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   return _.isUndefined(objValue) ? srcValue : objValue;
	 * }
	 *
	 * var defaults = _.partialRight(_.assignInWith, customizer);
	 *
	 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var assignInWith = creamizer);
	});

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', bject);
	}

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guarantbject);
	}

	/**
	 * Creates a compiled template function that can interpolate data properties
	 * in "interpolate" delimiters, HTML-escape interpolated data properties in
	 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	 * properties may be accessed as free variables in the template. If a setting
	 * object is given, it takes precedence over `_.templateSettings` values.
	 *
	 * **Note:** In the development build `_.template` utilizes
	 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	 * for easier debugging.
	 *
	 * For more information on precompiling templates see
	 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	 *
	 * For more information on Chrome extension sandboxes see
	 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The template string.
	 * @param {Object} [options={}] The options object.
	 * @param {RegExp} [options.escape=_.templateSettings.escape]
	 *  The HTML "escape" delimiter.
	 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	 *  The "evaluate" delimiter.
	 * @param {Object} [options.imports=_.templateSettings.imports]
	 *  An object to import into the template as free variables.
	 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	 *  The "interpolate" delimiter.
	 * @param {string} [options.sourceURL='templateSources[n]']
	 *  The sourceURL of the compiled template.
	 * @param {string} [options.variable='obj']
	 *  The data object variable name.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Function} Returns the compiled template function.
	 * @example
	 *
	 * // Use the "interpolate" delimiter to create a compiled template.
	 * var compiled = _.template('hello <%= user %>!');
	 * compiled({ 'user': 'fred' });
	 * // => 'hello fred!'
	 *
	 * // Use the HTML "escape" delimiter to escape data property values.
	 * var compiled = _.template('<b><%- value %></b>');
	 * compiled({ 'value': '<script>' });
	 * // => '<b>&lt;script&gt;</b>'
	 *
	 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	 * compiled({ 'users': ['fred', 'barney'] });
	 * // => '<li>fred</li><li>barney</li>'
	 *
	 * // Use the internal `print` function in "evaluate" delimiters.
	 * var compiled = _.template('<% print("hello " + user); %>!');
	 * compiled({ 'user': 'barney' });
	 * // => 'hello barney!'
	 *
	 * // Use the ES template literal delimiter as an "interpolate" delimiter.
	 * // Disable support by replacing the "interpolate" delimiter.
	 * var compiled = _.template('hello ${ user }!');
	 * compiled({ 'user': 'pebbles' });
	 * // => 'hello pebbles!'
	 *
	 * // Use backslashes to treat delimiters as plain text.
	 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	 * compiled({ 'value': 'ignored' });
	 * // => '<%- value %>'
	 *
	 * // Use the `imports` option to import `jQuery` as `jq`.
	 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	 * compiled({ 'users': ['fred', 'barney'] });
	 * // => '<li>fred</li><li>barney</li>'
	 *
	 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	 * compiled(data);
	 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	 *
	 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	 * compiled.source;
	 * // => function(data) {
	 * //   var __t, __p = '';
	 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	 * //   return __p;
	 * // }
	 *
	 * // Use custom template delimiters.
	 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	 * var compiled = _.template('hello {{ user }}!');
	 * compiled({ 'user': 'mustache' });
	 * // => 'hello mustache!'
	 *
	 * // Use the `source` property to inline compiled templates for meaningful
	 * // line numbers in error messages and stack traces.
	 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	 *   var JST = {\
	 *     "main": ' + _.template(mainText).source + '\
	 *   };\
	 * ');
	 */
	function template(string, options, guard) {
	  // Based on John Resig's `tmpl` implementation
	  // (http://ejohn.org/blog/javascript-micro-templating/)
	  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	  var settings = lodash_templatesettings.imports._.templateSettings || lodash_templatesettings;

	  if (guard && isIterateeCall(string, options, guard)) {
	    options = undefined;
	  }
	  string = toString(string);
	  options = assignInWith({}, options, settings, customDefaultsAssignIn);

	  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	      importsKeys = keys(imports),
	      importsValues = baseValues(imports, importsKeys);

	  var isEscaping,
	      isEvaluating,
	      index = 0,
	      interpolate = options.interpolate || reNoMatch,
	      source = "__p += '";

	  // Compile the regexp to match each delimiter.
	  var reDelimiters = RegExp(
	    (options.escape || reNoMatch).source + '|' +
	    interpolate.source + '|' +
	    (interpolate === lodash__reinterpolate ? reEsTemplate : reNoMatch).source + '|' +
	    (options.evaluate || reNoMatch).source + '|$'
	  , 'g');

	  // Use a sourceURL for easier debugging.
	  // The sourceURL gets injected into the source that's eval-ed, so be careful
	  // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
	  // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
	  var sourceURL = hasOwnProperty.call(options, 'sourceURL')
	    ? ('//# sourceURL=' +
	       (options.sourceURL + '').replace(/[\r\n]/g, ' ') +
	       '\n')
	    : '';

	  string.replace(reDatch;
	  });

	  source += "';\n";

	  // If `variable` is not specified wrap a with-statement around the generated
	  // code to add the data object to the top of the scope chain.
	  // Like with sourceURL, we take care to not check the option's prototype,
	  // as this configuration is a code injection vector.
	  var variable = hasOwnProperty.call(options, 'variable') && options.variable;
	  if (!variable) {
	    source = 'with (obj) {\n' + source + '\n}\n';
	  }
	  // Cleanup code by stripping empty strings.
	  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	    .replace(reEmptyStringMiddle, '$1')
	    .replace(reEmptyStringTrailing, '$1;');

	  // Frame code as the function body.
	  source = 'function(' + (variable || 'obj') + ') {\n' +
	    (variable
	      ? ''
	      : 'obj || (obj = {});\n'
	    ) +
	    "var __t, __p = ''" +
	    (isEscaping
	       ? ', __e = _.escape'
	       : ''
	    ) +
	    (isEvaluating
	      ? ', __j = Array.prototype.join;\n' +
	        "function print() { __p += __j.call(arguments, '') }\n"
	      : ';\n'
	    ) +
	    source +
	    'return __p\n}';

	  var resultues);
	  });

	  // Provide the compiled function's source by its `toString` method or
	  // the `source` property as a convenience for inlining compiled templates.
	  result.source = source;
	  if (isError(result)) {
	    throw result;
	  }
	  return result;
	}

	/**
	 * Attempts to invoke `func`, returning either the result or the caught error
	 * object. Any additional arguments are provided to `func` when it's invoked.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Util
	 * @param {Function} func The function to attempt.
	 * @param {...*} [args] The arguments to invoke `func` with.
	 * @returns {*} Returns the `func` result or error object.
	 * @example
	 *
	 * // Avoid throwing errors for invalid selectors.
	 * var elements = _.attempt(function(selector) {
	 *   return document.querySelectorAll(selector);
	 * }, '>_>');
	 *
	 * if (_.isError(elements)) {
	 *   elements = [];
	 * }
	 */
	var attempt );
	  }
	});

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => ;
	  };
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // =>  value;
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, fa false;
	}

	module.exports = template;
	});

	const HOURS = 'hours';
	const HOUR = 'hour';
	const MINUTES = 'minutes';
	const MINUTE = 'minute';
	const SECONDS = 'seconds';
	const SECOND = 'second';
	const SECONDS_TEMPLATE = '<%= seconds %>';
	const SECONDS_FORMAT = ['seconds', 'format'];
	const defaultLabels = {
	  hours: HOURS,
	  hour: HOUR,
	  minutes: MINUTES,
	  minute: MINUTE,
	  seconds: SECONDS,
	  second: SECOND,
	  hours_minutes_seconds_format: '<%= hours %>, <%= minutes %> and <%= seconds %>',
	  minutes_seconds_format: '<%= minutes %> and <%= seconds %>'
	};
	var humanizeDuration = ((ms, labels = defaultLabels) => {
	  let seconds = ms / 1000;
	  let minutes = seconds / 60;
	  let hours = minutes / 60;
	  let templateParts = [];
	  seconds = Math.floor(seconds) % 60;
	  minutes = Math.floor(minutes) % 60;
	  hours = Math.floor(hours);
	  if (hours > 0) {
	    templateParts.push(HOURS);
	  }
	  if (minutes > 0 || hours > 0) {
	    templateParts.push(MINUTES);
	  }
	  templateParts = concat(templateParts).call(templateParts, SECONDS_FORMAT);
	  const compiled = lodash_template(labels[templateParts.join('_')] || SECONDS_TEMPLATE);
	  return compiled({
	    hours: `${hours} ${labels[hours === 1 ? HOUR : HOURS]}`,
	    minutes: `${minutes} ${labels[minutes === 1 ? MINUTE : MINUTES]}`,
	    seconds: `${seconds} ${labels[seconds === 1 ? SECOND : SECONDS]}`
	  });
	});

	class UniversalEndcard extends ChromelessEndcard {
	  constructor(...args) {
	    super(...args);
	    this.containerEl_ = document.createElement('div');
	    this.contentEl_ = document.createElement('div');
	    this.playNextBtn_ = document.createElement('button');
	    this.dismissBtn_ = document.createElement('button');
	    this.buttonsContainer_ = document.createElement('div');
	    this.timerEl_ = document.createElement('div');
	    this.timerMessageEl_ = document.createElement('span');
	    this.timerCountdownEl_ = document.createElement('span');
	    this.titleEl_ = document.createElement('span');
	    this.labelsEl_ = document.createElement('div');
	    this.descriptionContainer_ = document.createElement('div');
	    this.textContentContainer_ = document.createElement('div');
	    this.thumbnailEl_ = document.createElement('img');
	    this.secondsRemaining_ = null;
	    this.init = () => {
	      super.init();
	      this.setTextContent_();
	      this.setClassNames_();
	      this.constructTree_();
	      this.playNextBtn_.addEventListener('click', this.onPlayNextClick);
	      this.dismissBtn_.addEventListener('click', this.onDismiss);
	      this.config.videoEl.appendChild(this.containerEl_);
	    };
	    this.setNextContent = mediaItem => {
	      super.setNextContent(mediaItem);
	      const {
	        images: [{
	          url: posterHref,
	          value
	        }]
	      } = mediaItem;
	      this.titleEl_.textContent = mediaItem.title;
	      this.labelsEl_.textContent = mediaItem.brand;
	      this.thumbnailEl_.setAttribute('src', posterHref || value);
	    };
	    this.setTextContent_ = () => {
	      const {
	        messages
	      } = this.config;
	      this.timerCountdownEl_.setAttribute('id', 'countdown-timer');
	      this.setTimerTextContent_(this.duration_);
	      this.timerMessageEl_.textContent = messages.countdownMessage;
	      this.playNextBtn_.textContent = messages.playNext;
	      this.dismissBtn_.textContent = messages.dismiss;
	    };
	    this.setTimerTextContent_ = ms => {
	      this.timerCountdownEl_.textContent = humanizeDuration(ms, this.config.messages.timerLabels);
	    };
	    this.setClassNames_ = () => {
	      this.containerEl_.setAttribute('class', 'universal-endcard-container hidden');
	      this.contentEl_.setAttribute('class', 'universal-endcard-content');
	      this.playNextBtn_.setAttribute('class', 'universal-endcard-btn universal-endcard-btn-play-next');
	      this.dismissBtn_.setAttribute('class', 'universal-endcard-btn universal-endcard-btn-dismiss');
	      this.timerEl_.setAttribute('class', 'universal-endcard-timer');
	      this.titleEl_.setAttribute('class', 'universal-endcard-title');
	      this.labelsEl_.setAttribute('class', 'universal-endcard-labels');
	      this.buttonsContainer_.setAttribute('class', 'universal-endcard-btn-container');
	      this.descriptionContainer_.setAttribute('class', 'universal-endcard-description-container');
	      this.textContentContainer_.setAttribute('class', 'universal-endcard-text-content-container');
	      this.thumbnailEl_.setAttribute('class', 'universal-endcard-thumbnail');
	    };
	    this.constructTree_ = () => {
	      this.buttonsContainer_.appendChild(this.dismissBtn_);
	      this.buttonsContainer_.appendChild(this.playNextBtn_);
	      this.timerEl_.appendChild(this.timerMessageEl_);
	      this.timerEl_.appendChild(this.timerCountdownEl_);
	      this.textContentContainer_.appendChild(this.timerEl_);
	      this.textContentContainer_.appendChild(this.titleEl_);
	      this.textContentContainer_.appendChild(this.labelsEl_);
	      this.descriptionContainer_.appendChild(this.textContentContainer_);
	      this.descriptionContainer_.appendChild(this.buttonsContainer_);
	      this.contentEl_.appendChild(this.thumbnailEl_);
	      this.contentEl_.appendChild(this.descriptionContainer_);
	      this.containerEl_.append(this.contentEl_);
	    };
	    this.onDismiss = () => {
	      this.config.coordinator.coordinate('dtci.endcard.dismiss');
	      this.hide();
	    };
	    this.onPlayNextClick = () => {
	      super.onPlayNext();
	      this.config.onPlayNextContent(this.nextContent_, true);
	    };
	    this.show = () => {
	      super.show(this.setTimerTextContent_);
	      this.containerEl_.classList.remove('hidden');
	    };
	    this.hide = () => {
	      super.hide();
	      this.containerEl_.classList.add('hidden');
	    };
	    this.onDispose_ = () => {
	      super.onDispose_();
	      this.playNextBtn_.removeEventListener('click', this.onPlayNext);
	      this.dismissBtn_.removeEventListener('click', this.onDismiss);
	      this.containerEl_.remove();
	    };
	  }
	}

	const ENDCARD_TYPES = {
	  universal: UniversalEndcard,
	  blank: BlankEndcard,
	  chromeless: ChromelessEndcard
	};
	class EndCardService {
	  constructor(config) {
	    this.initEndcard = mediaItem => {
	      const endcardType = this.mergedConfig.type;
	      this.getNextContent = this.config.getNextContent(mediaItem);
	      if (!endcardType || !ENDCARD_TYPES[endcardType]) {
	        this.initLegacyEndcard_(mediaItem);
	        this.endCard = {
	          setNextContent: this.warnIncorrectUsage_,
	          show: this.warnIncorrectUsage_,
	          hide: this.warnIncorrectUsage_
	        };
	      } else {
	        this.initUniversalEndcard_(mediaItem, endcardType);
	      }
	    };
	    this.setNexm);
	    };
	    this.showEndcard = () => {
	      this.endCard.show();
	    };
	    this.hid();
	    };
	    this.warnIncorre');
	    };
	    this.initLegacyEndcard_ = mediaItem => {
	      const {
	        adapterConfigs,
	        endcardLegacyPluginFn
	      } = this.config;
	      if (mediaItem.streamType === 'live') {
	        return;
	      }
	      if (adapterConfigs.endcard && typeof endcardLegacyPluginFn === 'function') {
	        endcardLegacyPluginFn(mediaItem, adapterConfigs.endcard);
	      }
	    };
	    this.initUniversalEndcard_ = (mediaItem, endcardType) => {
	      this.player.off('timeupdate', this.onContentPlayback_);
	      this.player.off('timeupdate', this.onContentTimeChange_);
	      const {
	        coordinator,
	        videoEl,
	        localize = () => {}
	      } = this.config;
	      const {
	        remaining,
	        countdown
	      } = this.mergedConfig;
	      const configTimings = {
	        remaining: parseInt(remaining, 10),
	        countdown: parseInt(countdown, 10)
	      };
	      if (isInteger(configTimings.remaining) && isInteger(configTimings.countdown)) {
	        this.timings = configTimings;
	      } else {
	        this.timings = ENDCARD_TIMINGS[mediaItem.entityType];
	      }
	      // TODO: remove this when we get consistent measurements
	      const durationInSeconds = this.guessDuration_(mediaItem);
	      this.endCardCue = Math.floor(durationInSeconds - this.timings.remaining);
	      const endCardConfig = {
	        coordinator,
	        messages: {
	          countdownMessage: localize('Up Next In '),
	          playNext: localize('Play Next'),
	          dismiss: localize('Dismiss')
	        },
	        videoEl,
	        onPlayNextContent: this.onPlayNextContent_,
	        duration: this.timings.countdown * 1000 // convert to ms
	      };

	      if (!this.endCard) {
	        this.endCard = new ENDCARD_TYPES[endcardType](endCardConfig);
	      }
	      this.endCard.init();
	      ;
	      }, 0);
	    };
	    this.guessDuration_ = mediaItem => {
	      if (mediaItem.entityType === 'shortform') {
	        return mediaItem.duration;
	      }
	      if (mediaItem.duration > 10000) {
	        // likely in ms
	        return mediaItem.duration / 1000;
	      }
	      return mediaItem.duration;
	    };
	    this.onPlayNextContent_ = (mediaItem, wasManual) => {
	      if (!mediaItem) {
	        return;
	      }
	      const {
	        player,
	        config: {
	          adapterConfigs: {
	            disableAdobe,
	            disableNielsen
	          } = {},
	          updateS= () => {}
	        }
	      } = this;
	      const playerAutoplay = !!(player && typeof player.autoplay === 'function' && player.autoplay());
	      const analyticsEnabled = !disableAdobe && !disableNielsen;
	      const startType = wasManual ? PLAYER_START_TYPE.ENDCARD_MANUAL : PLAYER_START_TYPE.ENDCARD_AUTOSTART;
	      updateStartType(startType);
	      mediaItem.startType = startType;
	      if (mediaItem.link && mediaItem.link.id) {
	        localStorage.setItem('endcardNextItem', mediaItem.link.id);
	        if (mediaItem.link.urlValue) {
	          this.config.coordinator.coordinate('dtci.contentEnded');
	          setTimeout(() => {
	            const nextUrl = document.location.hostname === 'local.espn.com' ? `${document.location.origin}/entertainment.html?origin=endcard&tech=videojs` // Origin for test harness is different
	            : document.location.origin + mediaItem.link.urlValue;
	            window.top.location.assign(nextUrl);
	          }, 1000);
	        }
	      }
	      if (analyticsEnabled) {
	        this.config.analytics.adobeDCR({
	          ESPN_CUSTOM_METADATA: {
	            startType
	          }
	        });
	        this.config.analytics.conviva({
	          startType
	        });
	      }
	      if (mediaItem.entityType !== 'shortform') {
	        // The client provides a new `mediaItem` in `getNextContent` interceptor without knowing
	        // if and when the video player will actually play it. Here we know the player is about
	        // to play this next `mediaItem`, so let the client know, so it can do updates outside
	        // of the player if needed
	        // This happens already in the playNextShorftorm method
	        this.config.coordinator.coordinate('dtci.loaded', mediaItem);
	      }
	      if (!mediaItem.link) {
	        this.playNextContent_(mediaItem);
	      }
	      if (!playerAutoplay) {
	        // if autoplay was off, but endcard.autoplay was true, set player.autoplay to true the rest of continuous play
	        player.autoplay(true);
	      }
	    };
	    this.playNextContent_ = mediaItem => {
	      if (mediaItem.entityType === 'shortform' && mediaItem.streamType !== 'live') {
	        // Setting second argument to true so that it can go down a road that does not use autoplay
	        // as the player defines it when you set autoplay to true.
	        // The ad plugin sees autoplay and mutes the player, if it deosn't it let's it continue
	        // playing at the previously set volume level.
	        this.config.playNextShorftorm(mediaItem, true);
	      } else {
	        this.config.playNextLongform(mediaItem);
	      }
	      this.player.trigger('ended');
	    };
	    this.onContentPlayback_ = () => {
	      if (!this.isInAdPlayback_ && Math.ceil(this.player.currentTime()) >= this.endCardCue) {
	        this.getNextContent().then(this.setNextContent).then(this.showEndcard);
	        this.player.off('timeupdate', this.onContentPlayback_);
	        this.player.on('timeupdate', this.onContentTimeChange_);
	      }
	    };
	    this.onContentTimeChange_ = () => {
	      if (!this.isInAdPlayback_ && Math.ceil(this.player.currentTime()) < this.endCardCue) {
	        this.hideEndcard();
	        this.player.off('timeupdate', this.onContentTimeChange_);
	        this.player.on('timeupdate', this.onContentPlayback_);
	      }
	    };
	    const {
	      player: _player,
	      adapterConfigs: {
	        endcard = {},
	        brandConfig = {}
	      }
	    } = config;
	    this.config = config;
	    this.player = _player;
	    this.mergedConfig = {
	      ...endcard,
	      ...brandConfig.endcard
	    };
	    this.onContentPlayback_ = debounce$1(this.onContentPlayback_, 250);
	    this.onContentTimeChange_ = debounce$1(this.onContentTimeChange_, 250);
	  }
	  get isInAdPlayback_() {
	    return this.player && this.player.ads && this.player.ads.state === 'ad-playback';
	  }
	}

	class DTCILoadingSpinner {
	  constructor(options) {
	    /**
	     * Create a LoadingSpinner instance.
	     *
	     * @param  {Player} player
	     *         A Video.js Player instance.
	     *
	     * @param  {Object} [options]
	     *         An optional options object.
	     */
	    this.containerEl_ = document.createElement('div');
	    this.options_ = options;
	    this.isWaiting_ = false;
	    this.timeWaitingStarted_ = null;
	    this.listening_ = false;
	    this.onDispose_ = this.onDispose_.bind(this);
	    this.show = this.show.bind(this);
	    this.hide = this.hide.bind(this);
	    this.onTimeUpdate_ = this.onTimeUpdate_.bind(this);
	    this.init_();
	  }
	  setPlayer(player) {
	    var _this$player_;
	    if (this.player_) {
	      this.unlisten_();
	      this.containerEl_.remove();
	    }
	    this.player_ = player;
	    (_this$player_ = this.player_) === null || _this$player_ === void 0 ? void 0 : _this$player_.el_.appendChild(this.containerEl_);
	    this.listen_();
	  }
	  setElement(element) {
	    if (this.element_) {
	      this.containerEl_.remove();
	    }
	    this.element_ = element;
	    this.element_.appendChild(this.containerEl_);
	  }
	  init_() {
	    const {
	      className,
	      innerHTML
	    } = this.buildLoaderDomElementByConfig_();
	    this.containerEl_.setAttribute('class', className);
	    this.containerEl_.innerHTML = innerHTML;
	  }
	  listen_() {
	    var _this$player_2, _this$player_3, _this$player_4;
	    (_this$player_2 = this.player_) === null || _this$player_2 === void 0 ? void 0 : _this$player_2.on('dispose', this.onDispose_);
	    (_this$player_3 = this.player_) === null || _this$player_3 === void 0 ? void 0 : _this$player_3.on('waiting', this.show);
	    (_this$player_4 = this.player_) === null || _this$player_4 === void 0 ? void 0 : _this$player_4.on(['canplay', 'canplaythrough', 'playing'], this.hide);
	    this.listening_ = true;
	  }
	  unlisten_() {
	    var _this$player_5, _this$player_6, _this$player_7, _this$player_8;
	    (_this$player_5 = this.player_) === null || _this$player_5 === void 0 ? void 0 : _this$player_5.off('dispose', this.onDispose_);
	    (_this$player_6 = this.player_) === null || _this$player_6 === void 0 ? void 0 : _this$player_6.off('waiting', this.show);
	    (_this$player_7 = this.player_) === null || _this$player_7 === void 0 ? void 0 : _this$player_7.off(['canplay', 'canplaythrough', 'playing'], this.hide);
	    (_this$player_8 = this.player_) === null || _this$player_8 === void 0 ? void 0 : _this$player_8.off('timeupdate', this.onTimeUpdate_);
	  }
	  buildLoaderDomElementByConfig_() {
	    const {
	      brand,
	      hideDefaultLoadingIndicator
	    } = this.options_;
	    if (hideDefaultLoadingIndicator) {
	      return {
	        className: 'vjs-loader dtci-custom hidden active',
	        innerHTML: '<div class="empty-loader" />'
	      };
	    }
	    switch (brand) {
	      case 'abcnews':
	        return {
	          className: 'vjs-loader dtci-custom active abcnews',
	          innerHTML: '<span class="abc-news-loader" />'
	        };
	      default:
	        return {
	          className: 'vjs-loader dtci-custom active',
	          innerHTML: `
            <div class="spinner-layer">
                <div class="circle-clipper left">
                    <div class="circle"></div>
                </div>
                <div class="gap-patch">
                    <div class="circle"></div>
                </div>
                <div class="circle-clipper right">
                    <div class="circle"></div>
                </div>
            </div>
          `
	        };
	    }
	  }
	  show(evt) {
	    if (!this.isWaiting_) {
	      var _this$player_9, _this$player_10, _this$player_11;
	      this.isWaiting_ = true;
	      this.timeWaitingStarted_ = (_this$player_9 = this.player_) === null || _this$player_9 === void 0 ? void 0 : _this$player_9.currentTime();
	      (_this$player_10 = this.player_) === null || _this$player_10 === void 0 ? void 0 : _this$player_10.on('timeupdate', this.onTimeUpdate_);
	      (_this$player_11 = this.player_) === null || _this$player_11 === void 0 ? void 0 : _this$player_11.trigger('vjs-waiting.start', {
	        originalEvent: evt
	      });
	    }
	  }
	  hide(evt) {
	    if (this.isWaiting_) {
	      var _this$player_12, _this$player_13;
	      this.isWaiting_ = false;
	      (_this$player_12 = this.player_) === null || _this$player_12 === void 0 ? void 0 : _this$player_12.off('timeupdate', this.onTimeUpdate_);
	      this.timeWaitingStarted_ = null;
	      (_this$player_13 = this.player_) === null || _this$player_13 === void 0 ? void 0 : _this$player_13.trigger('vjs-waiting.end', {
	        originalEvent: evt
	      });
	    }
	  }
	  onTimeUpdate_(evt) {
	    var _this$player_14;
	    if (this.timeWaitingStarted_ !== null && this.timeWaitingStarted_ !== ((_this$player_14 = this.player_) === null || _this$player_14 === void 0 ? void 0 : _this$player_14.currentTime())) {
	      this.hide(evt);
	    }
	  }
	  onDispose_() {
	    this.unlisten_();
	    this.player_ = null;
	    this.containerEl_.remove();
	    this.containerEl_ = null;
	  }
	}

	class BasePlayerAdapter {
	  constructor(el, configs, coordinator, mediaManager) {
	    this.player_ = undefined;
	    this.programChangeMonitor_ = null;
	    this.adobeMonitor_ = null;
	    this.playlistId_ = null;
	    this.savedVolume = parseFloat(localStorage.getItem(this.volumeStorageKey));
	    this.configs_ = null;
	    this.isPlaying_ = false;
	    this.isEntertainment = false;
	    this.prevAdId_ = null;
	    this.autoplayPolicy = null;
	    this.loadedData = false;
	    this.startType_ = null;
	    this.showLoadingState = () => {
	      const hideControlBar = !this.player.hasStarted();
	      if (hideControlBar) {
	        this.controlBarHidden = true;
	        this.player.controlBar.hide();
	      }
	      this.player.bigPlayButton.hide();
	      this.player.addClass('vjs-waiting');
	      this.player.loadingSpinner.show();
	    };
	    this.hideLoadingState = () => {
	      this.player.removeClass('vjs-waiting');
	      this.player.loadingSpinner.hide();
	      if (this.controlBarHidden) {
	        this.controlsHidden = false;
	        this.player.controlBar.show();
	      }
	    };
	    this.configEl_ = el;
	    this.configurationService = new ConfigurationService(this.type);
	    this.configs_ = this.getMergedConfiguration(DEFAULT_CONFIGS, configs);
	    const {
	      brand,
	      hideDefaultLoadingIndicator = false
	    } = this.configs_ || {};
	    this.initPlayer = this.initPlayer.bind(this);
	    this.renderPlayer = this.renderPlayer.bind(this);
	    this.loadContent = this.loadContent.bind(this);
	    this.initContent = this.initContent.bind(this);
	    this.onSpaceBarKeydown = this.onSpaceBarKeydown.bind(this);
	    this.onTabKeyDown = this.onTabKeyDown.bind(this);
	    this.onRetryRequested = this.onRetryRequested.bind(this);
	    this.getMergedConfiguration = this.getMergedConfiguration.bind(this);
	    this.onAdsManagerLoaded_ = this.onAdsManagerLoaded_.bind(this);
	    const {
	      configs_: {
	        advertisingInfo
	      } = {}
	    } = this;
	    this.coordinator = coordinator || new EventCoordinator();
	    this.configurationService.coordinator = coordinator;
	    this.advertisingInfo = advertisingInfo || new AdvertisingInfo();
	    this.mediaManager = mediaManager;
	    this.updateAnalytics = this.mediaManager.analyticsService.updateAnalytics; // method used in 'src/index.js'

	    this.loadingSpinner = new DTCILoadingSpinner({
	      brand,
	      hideDefaultLoadingIndicator
	    });
	  }
	  get element() {
	    return this.mediaManager.domHelperService.element;
	  }
	  set analytics(value) {
	    this.mediaManager.analyticsService.analytics = value;
	  }
	  get analytics() {
	    return this.mediaManager.analyticsService.analyticaluiva_;
	  }
	  set player(value) {
	    this.player_ = value;
	  }
	  get player() {
	    return this.player_;
	  }
	  set isPlaying(value) {
	    this.isPlaying_ = value;
	  }
	  get isPlaying() {
	    var _this$player;
	    return this.isPlaying_ || ((_this$player = this.player) === null || _this$player === void 0 ? void 0 : _this$player.isPlaying);
	  }
	  get isInAdMode() {
	    const {
	      ads
	    } = this.player || {};
	    return ads && typeof ads.isInAdMode === 'function' && ads.isInAdMode();
	  }
	  get adId() {
	    const {
	      player: {
	        ads,
	        ima
	      }
	    } = this;
	    let id;
	    if (ads && ads.ad) {
	      id = ads.ad.id;
	    } else if (ima) {
	      const adsManager = typeof ima.getAdsManager === 'function' && ima.getAdsManager();
	      if (adsManager && typeof adsManager.getCurrentAd === 'function') {
	        const currentAd = adsManager.getCurrentAd();
	        id = currentAd && typeof currentAd.getAdId === 'function' && currentAd.getAdId();
	      }
	    }
	    this.prevAdId_ = id || this.prevAdId_;
	    return id || 'null;
	  }
	  set playerCurrentDimensions(value) {
	    this.currentDimensions_ = value;
	  }
	  get playerCurrentDimensions() {
	    if (typeof this.player.currentDimensions === 'function') {
	      const {
	        width,
	        height
	      } = this.player.currentDimensions();
	      return `${width}, ${height}`;
	    }
	    return null;
	  }
	  set startType(v) {
	    this.startType_ = v;
	  }
	  get startType() {
	    return this.startType_;
	  }
	  prepareForPlayer_() {
	    const {
	      configs_: {
	        wasUserInitiated,
	        isLiveInPlaylist
	      } = {}
	    } = this;
	    const isAutoplay = this.isAutoplayInConfig_();
	    if (isLiveInPlaylist) {
	      this.startType = isAutoplay ? PLAYER_START_TYPE.ENDCARD_AUTOSTART : PLAYER_START_TYPE.ENDCARD_MANUAL;
	    } else {
	      this.startType = isAutoplay ? PLAYER_START_TYPE.AUTOSTART : PLAYER_START_TYPE.MANUAL;
	    }

	    // If playback was initiated by the user, force the player to unmute.
	    if (wasUserInitiated) {
	      this.configs_.volume.muted = false;
	    }
	    this.mediaManager.analyticsService.configureAnalytics(this.configs_);
	  }
	  isAutoplayInConfig_() {
	    const {
	      configs_: {
	        wasUserInitiated,
	        autoplay = false
	      } = {}
	    } = this;
	    return wasUserInitiated === false || autoplay === 'on' || autoplay === true;
	  }
	  createPlayer_() {
	    try {
	      if (typeof this.tech !== 'function') {
	        throw new Error('BasePlayerAdapter: `tech()` MUST be a valid constructor');
	      }
	      const {
	        brand,
	        playsinline,
	        iphoneplaysinline
	      } = this.configs_ || {};

	      /**
	       * Pass brand config to playerOptions to handle custom logo in LoadingSpinner plugin
	       * If it has reomote textTracks, pass false to html5.nativeTextTracks to prevent Safari modifies
	       * textTrack kind from captions/subtitles to metadata
	       */
	      this.player = this.tech(this.element, {
	        brand,
	        playsinline: playsinline || iphoneplaysinline
	      });
	      this.loadingSpinner.setPlayer(this.player);
	      this.adProvider_ = this.mediaManager.advertisementService.initAdProvider(this.player);
	      this.player.NewRelicService = NewRelicService$1;
	    } catch (err) {
	      const errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_BUNDLE_FAILED_TO_CREATE, 'Player failed to create ', err);
	      NewRelicService$1.playerBundleEvent({}, errorException);
	      throw errorException;
	   r_();
	  }
	  renderPlayer(el) {
	    this.configEl_ = el || this.configEl_;
	    let {
	      configEl_: element
	    } = this;
	    if (typeof element === 'string') {
	      if (element.indexOf('#') === 0) {
	        element = slice(element).call(element, 1);
	      }
	      element = document.getElementById(element);
	    }
	    if (!element || !element.nodeName) {
	      throw new TypeError('The element or ID supplied is not valid.');
	    }
	    this.loadingSpinner.setElement(element);
	    this.mediaManager.domHelperService.createEl(element);
	    this.createPlayer_();
	    this.coordinator.coordinate(CUSTOM_EVENTS.PLAYER_LOAD_COMPLETE);
	  }
	  async loadContent(identifier_ = null, contentApi_ = null) {
	    var _this$player2;
	    let newMediaItem = null;
	    this.showLoadingState();
	    if ((_this$player2 = this.player) !== null && _this$player2 !== void 0 && _this$player2.one) {
	      this.player.one('ads-manager-loaded', this.onAdsManagerLoaded_);
	    }
	    try {
	      this.adProvider_.shouldRequestAds = await this.shouldRequestPrerollAds_();
	      await this.adProvider_.loadDependencies(this.adProvider_.shouldRequestAds, this.configs_);
	      this.configs_.identifier = identifier_ || this.configs_.identifier;
	      if (contentApi_) {
	        this.configs_.api = this.configs_.api || {};
	        this.configs_.api.contentApi = contentApi_;
	      }
	      this.autoplayPolicy = await this.getAutoplayPolicy_();
	      this.configs_.autoplay = this.updateAutoplayConfig_();
	      this.configs_.volume = this.updateVolumeConfig_();
	      this.configurePlayer();
	      const {
	        identifier,
	        mediaItem,
	        api: {
	          contentApi
	        } = {}
	      } = this.configs_;
	      newMediaItem = !mediaItem && identifier ? await fetchMediaItemFromApi({
	        identifier,
	        contentApi
	      }, this.coordinator) : null;
	    } catch (err) {
	      let errorException = err;
	      if (!NewRelicService$1.isErrorException(err)) {
	        errorException = NewRelicService$1.generateMediaItemInvalid(this.configs_.identifier, ERROR_CODES.MEDIA_ITEM_MISSING, "There's a problem playing this video.", err);
	      }
	      if (this.player && typeof this.player.error === 'function') {
	        this.player.error({
	          code: -3,
	          errorException
	        });
	      }
	    }
	    return newMediaItem;
	  }
	  async shouldRequestPrerollAds_() {
	    var _this$adProvider_, _this$adProvider_$opt, _document;
	    const isBackgrounded = ((_this$adProvider_ = this.adProvider_) === null || _this$adProvider_ === void 0 ? void 0 : (_this$adProvider_$opt = _this$adProvider_.options) === null || _this$adProvider_$opt === void 0 ? void 0 : _this$adProvider_$opt.disableAdRequestOnBackgroundedVideo) === true && ((_document = document) === null || _document === void 0 ? void 0 : _document.hidden);
	    const shouldRequestAds = isBackgrounded ? false : await this.coordinator.coordinate('dtci.adProvider.shouldRequestAds', true);
	    return shouldRequestAds;
	  }
	  onAdsManagerLoaded_() {
	    this.adsManagerLoaded = true;
	    if (this.adsManagerLoadedQueue && this.adsManagerLoadedQueue.length > 0) {
	      for (let i = 0; i < this.adsManagerLoadedQueue.length; i += 1) {
	        const callback = this.adsManagerLoadedQueue[i];
	        if (typeof callback === 'function') {
	          callback();
	        }
	      }
	      this.adsManagerLoadedQueue = [];
	    }
	    this.hideLoadingState();
	    this.player.bigPlayButton.show();
	  }
	  updateAutoplayConfig_() {
	    const {
	      wasUserInitiated,
	      bypassBrowserAutoPlayPolicies,
	      autoplay
	    } = this.configs_;
	    const isAutoPlayBlocked = this.autoplayPolicy === AUTOPLAY_ALLOW_TYPE.BLOCKED;
	    const isUnableToAutoPlay = isAutoPlayBlocked && !wasUserInitiated;
	    let autoplayValue = autoplay === true;
	    if (document.hidden || isUnableToAutoPlay) {
	      autoplayValue = false;
	    }
	    if (bypassBrowserAutoPlayPolicies) {
	      autoplayValue = true;
	    }
	    this.autoplay(autoplayValue);
	    return autoplayValue;
	  }
	  updateVolumeConfig_() {
	    var _this$configs_, _this$configs_$volume, _this$configs_2, _this$configs_3;
	    const namespace = ((_this$configs_ = this.configs_) === null || _this$configs_ === void 0 ? void 0 : (_this$configs_$volume = _this$configs_.volume) === null || _this$configs_$volume === void 0 ? void 0 : _this$configs_$volume.namespace) || 'dtci';
	    const isChromeless = (_this$configs_2 = this.configs_) === null || _this$configs_2 === void 0 ? void 0 : _this$configs_2.chromeless;
	    const volumeStorageKey = `${namespace}-volume`;
	    const muteStorageKey = `${namespace}-mute`;
	    const volumeConfig = {
	      namespace
	    };
	    const volumeFromlocalStorage = window.localStorage && window.localStorage.getItem ? parseFloat(window.localStorage.getItem(volumeStorageKey)) : null;
	    const mutedFromlocalStorage = window.localStorage && window.localStorage.getItem ? window.localStorage.getItem(muteStorageKey) === 'true' : null;
	    const {
	      value,
	      muted
	    } = ((_this$configs_3 = this.configs_) === null || _this$configs_3 === void 0 ? void 0 : _this$configs_3.volume) || {};
	    if (this.shouldMutePlayer_()) {
	      volumeConfig.muted = true;
	    } else if (this.configs_.bypassBrowserAutoPlayPolicies) {
	      volumeConfig.muted = this.autoplayPolicy !== AUTOPLAY_ALLOW_TYPE.UNMUTED || mutedFromlocalStorage;
	    } else if (isChromeless) {
	      volumeConfig.muted = !!muted;
	    } else {
	      volumeConfig.muted = !!(mutedFromlocalStorage || muted);
	    }
	    if (!isChromeless && volumeFromlocalStorage || volumeFromlocalStorage === 0) {
	      volumeConfig.value = volumeFromlocalStorage;
	    } else if (value || value === 0) {
	      volumeConfig.value = value;
	    } else {
	      volumeConfig.value = 1;
	    }
	    if (isChromeless) {
	      this.player.muted(volumeConfig.muted);
	      this.player.volume(volumeConfig.volume);
	    } else {
	      this.player.volumeMenuButton(volumeConfig);
	    }
	    return volumeConfig;
	  }
	  shouldMutePlayer_() {
	    return this.configs_.autoplay && this.autoplayPolicy !== AUTOPLAY_ALLOW_TYPE.UNMUTED && !this.configs_.wasUserInitiated && !this.configs_.bypassBrowserAutoPlayPolicies || this.configs_.forceBrowserMute === true;
	  }
	  async getAutoplayPolicy_() {
	    const autoplayWithUnmuted = await index.video({
	      timeout: 1000,
	      muted: false,
	      inline: true
	    });
	    if (autoplayWithUnmuted !== null && autoplayWithUnmuted !== void 0 && autoplayWithUnmuted.result) {
	      return AUTOPLAY_ALLOW_TYPE.UNMUTED;
	    }
	    const autoplayWithMuted = await index.video({
	      timeout: 1000,
	      muted: true,
	      inline: true
	    });
	    if (autoplayWithMuted !== null && autoplayWithMuted !== void 0 && autoplayWithMuted.result) {
	      return AUTOPLAY_ALLOW_TYPE.MUTED;
	    }
	    return AUTOPLAY_ALLOW_TYPE.BLOCKED;
	  }
	  async initContent(newMediaItem) {
	    this.configs_.mediaItem = newMediaItem || this.configs_.mediaItem;
	    const {
	      error,
	      adOnly,
	      mediaItem
	    } = this.configs_;
	    if (error) {
	      this.mediaManager.analyticsService.initQoeOrConviva(this.configs_.mediaItem, this);
	      const errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_CONFIGURATION_ERR, 'Config error', error);
	      this.player.error({
	        code: -8,
	        errorException
	      });
	    } else if (adOnly) {
	      await this.playOnlyAd_();
	    } else {
	      try {
	        this.preparePlayback_(mediaItem);
	        if (mediaItem.entityType === 'shortform' && mediaItem.streamType !== 'live') {
	          await this.clipLoadedCallback(mediaItem);
	        } else {
	          await this.initPlaybackSession(mediaItem);
	        }
	      } catch (err) {
	        let errorException = err;
	        if (!NewRelicService$1.isErrorException(err)) {
	          errorException = NewRelicService$1.generateMediaItemInvalid(this.configs_.identifier, ERROR_CODES.MEDIA_ITEM_MISSING, "There's a problem playing this video.", err);
	        }
	        if (this.player && typeof this.player.error === 'function') {
	          this.player.error({
	            code: -3,
	            errorException
	          });
	        }
	      }
	    }
	  }
	  updateConfiguration(configs) {
	    this.configs_ = this.getMergedConfiguration(configs);
	    const {
	      configs_: {
	        advertisingInfo,
	        authorizationPayload
	      } = {}
	    } = this;
	    this.advertisingInfo = advertisingInfo || new AdvertisingInfo();
	    this.mediaManager.authorizationService.setAuthorizationPayload(authorizationPayload);
	  }
	  getMergedConfiguration(defaultConfigs, clientConfigs) {
	    const mergedConfigs = this.configurationService.getMergedConfigs(defaultConfigs, clientConfigs);
	    NewRelicService$1.setAdapterConfig(mergedConfigs);
	    return mergedConfigs;
	  }
	  tech() {
	    // tech is a placeholder here. It will get overloaded in the child class
	    return nulrride
	  }
	  initPlugins_() {
	    const {
	      configs_,
	      coordinator
	    } = this;
	    if (configs_.progressTracker) {
	      const playerAdaptor = new WebPlayerBundleAdaptor(this);
	      const pluginManager = new PlayerPluginManager(playerAdaptor, [], configs_);
	      const progressTracker = getConfiguredProgressTracker(playerAdaptor, configs_, coordinator);
	      if (progressTracker) {
	        pluginManager.addPlugin(progressTracker);
	      }
	      this.pluginManager_ = pluginManager;
	    }
	  }
	  initSocial(mediainfo, socialConfig) {
	    if (socialConfig !== false) {
	      const brand = this.configs_.brand || mediainfo.brand || 'espn';
	      const brandName = getBrandName(brand);
	      this.socialConfig = new Social(mediainfo, socialConfig, brandName);
	      this.social(this.socialConfig.options);
	    }
	  }
	  async clipLoadedCallback(mediaItem, doesPlayOnSrcLoad = false) {
	    await this.initializePlayback(mediaItem, doesPlayOnSrcLoad);
	    this.initializeEndcardIfNeeded_(mediaItem);
	  }
	  async initializePlayback(mediaItem, doesPlayOnSrcLoad) {
	    const {
	      player,
	      pluginManager_
	    } = this;
	    try {
	      const authenticationManager = this.mediaManager.authorizationService.getAuthenticationManager(mediaItem, this.configs_);
	      const playbackSession = await this.getPlaybackSession(mediaItem, authenticationManager);
	      if (playbackSession) {
	        const {
	          cues,
	          tvrating,
	          duration,
	          images
	        } = mediaItem;
	        const posterHref = getMediaItemPosterHref(images);
	        if (this.adProvider_) {
	          await this.mediaManager.advertisementService.loadAds(this.adProvider_, this.advertisingInfo, mediaItem, this.autoplayPolicy);
	          const {
	            configs_
	          } = this;
	          if (typeof this.mediainfo === 'function') {
	            this.mediainfo(mediaItem);
	          }
	          if (posterHref && !this.autoplay()) {
	            this.poster(posterHref);
	          } else {
	            this.poster(DEFAULT_POSTER_IMG);
	          }
	          this.initTVRatingIfMediaItemTvRatingIsSet(tvrating);
	          this.initMidrollAdPodsIndicator(cues, duration);
	          if (typeof player.social === 'function' || typeof player.brandedSocial === 'function') {
	            this.initSocial(player.mediainfo, configs_.social);
	          }
	          if (pluginManager_) {
	            pluginManager_.setMediaItem(mediaItem);
	          }
	          this.mediaManager.analyticsService.updateConvivaCustomMetadata({
	            playbackMediaItem: playbackSession.mediaItem || mediaItem,
	            drmProtectionType: 'none',
	            streamProtocol: 'HLS'
	          }, this);
	          this.handleRemoteTextTrack_(mediaItem);
	          let source = null;
	          if (this.isEntertainment) {
	            source = await drmSourceBuilder(playbackSession);
	          } else {
	            source = playbackSession.playbackUrl;
	          }
	          if (doesPlayOnSrcLoad) {
	            // This bypasses internal player and plugin rules around autoplay
	            // It was created for switching a video once the player is already
	            // inititated either on user click or on next content.
	            // If various parts of the player see that autoplay is set to true,
	            // they might not know that the video is being loaded after user
	            // interaction and go with the browser autoplay rules.
	            this.player.autoplay(false);
	            this.src(source);
	            this.coordinator.coordinate('dtci.loaded', mediaItem);
	            this.player.play();
	          } else if (this.adsManagerLoaded) {
	            this.src(source);
	          } else {
	            this.adsManagerLoadedQueue = this.adsManagerLoadedQueue || [];
	            this.adsManagerLoadedQueue.push(() => {
	              this.src(source);
	            });
	          }
	          this.initThumbnails(mediaItem, playbackSession);
	          this.mediaManager.analyticsService.initAnalytics(null, player, configs_);
	        }
	      }
	    } catch (err) {
	      let errorException = err;
	      if (!NewRelicService$1.isErrorException(err)) {
	        errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_UNKNOWN, 'clipLoadedCallback failed', err);
	      }
	      if (player && typeof player.error === 'function') {
	        player.error({
	          code: -4,
	          errorException
	        });
	      }
	    }
	  }
	  async initThumbnails(mediaItem, playbackSession) {
	    if (!shouldInitThumbnails(mediaItem)) return;
	    const {
	      player,
	      configs_ = {}
	    } = this;
	    const {
	      duration,
	      source: {
	        url: srcUrl
	      },
	      type,
	      brand,
	      seekBarThumbnails
	    } = mediaItem;
	    if (typeof this.thumbnails === 'function' && configs_.disableTimelinePreview !== true) {
	      if (type === 'audio' && typeof player.timeDisplay === 'function') {
	        player.timeDisplay();
	      } else if (seekBarThumbnails) {
	        this.thumbnails(seekBarThumbnails);
	      } else {
	        const source = brand === 'espn' ? srcUrl : playbackSession.playbackUrl;
	        const previews = await buildTimelinePreviewObject(source, duration, brand);
	        if (previews) {
	          const seekBarThumbnails = {
	            type: 'multiAsset',
	            config: previews
	          };
	          this.thumbnails(seekBarThumbnails);
	        }
	      }
	    }
	  }
	  upda    }
	  }
	  initializeEndcardIfNeeded_(mediaItem) {
	    const {
	      endcard,
	      brandConfig: {
	        disableEndCard,
	        endcard: brandEndcard
	      } = {}
	    } = this.configs_;
	    const missingEndcardConfig = !endcard && !brandEndcard;
	    if (disableEndCard || missingEndcardConfig) {
	      return;
	    }
	    if (!this.endCardService) {
	      this.endCardService = new EndCardService({
	        coordinator: this.coordinator,
	        videoEl: this.player.el_,
	        player: this.player,
	        getNextContent: this.getNextContent.bind(this),
	        localize: this.player.localize && this.player.localize.bind(this.player),
	        playNextShorftorm: this.clipLoadedCallback.bind(this),
	        playNextLongform: this.initPlaybackSession.bind(this),
	        updateStartType: this.updateStartType.bind(this),
	        adapterConfigs: this.configs_,
	        analytics: this.analytics,
	        endcardLegacyPluginFn: this.endcard && this.endcard.bind(this)
	      });
	    }
	    this.endCardService.initEndcard(mediaItem);
	  }
	  async initPlaybackSession(mediaItem) {
	    const {
	      player,
	      pluginManager_
	    } = this;
	    try {
	      const authenticationManager = this.mediaManager.authorizationService.getAuthenticationManager(mediaItem, this.configs_);
	      const playbackSession = await this.getPlaybackSession(mediaItem, authenticationManager);
	      if (playbackSession) {
	        const {
	          tvrating,
	          cues,
	          duration,
	          type
	        } = mediaItem;
	        if (authenticationManager.concurrencyMonitorBuilder) {
	          this.adobeMonitor_ = initConcurrencyMonitor(playbackSession, authenticationManager.concurrencyMonitorBuilder, this.coordinator);
	        }
	        this.initTVRatingIfMediaItemTvRatingIsSet(tvrating);
	        this.initMidrollAdPodsIndicator(cues, duration);
	        this.initProgramChangeMonitor(mediaItem);
	        if (pluginManager_) {
	          pluginManager_.setMediaItem(mediaItem);
	        }
	        await this.watchLoadedCallback(mediaItem, playbackSession);
	        this.initializeEndcardIfNeeded_(mediaItem);
	        if (type === 'audio') {
	          if (typeof player.timeDisplay === 'function') {
	            player.timeDisplay();
	          }
	        }
	      }
	      // Remove item for local.espn.com (This will not impact other environments)
	      localStorage.removeItem('endcardNextItem');
	    } catch (err) {
	      let errorException = err;
	      if (!NewRelicService$1.isErrorException(err)) {
	        errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_UNKNOWN, 'initPlaybackSession failed', err);
	        NewRelicService$1.playbackSessionFlowEvent({}, errorException);
	      }
	      if (player && typeof player.error === 'function') {
	        player.error({
	          code: -5,
	          errorException
	        });
	      }
	      this.cleanUp();
	    }
	  }
	  initProgramChangeMonitor(mediaItem) {
	    const {
	      configs_: {
	        countryCode,
	        programChangeMonitor: programChangeMonitorConfig = {}
	      } = {},
	      coordinator
	    } = this;
	    const {
	      source = 'mediaItemDataSource'
	    } = programChangeMonitorConfig;
	    const mediaItemDataSource = getMediaItemDataSource(mediaItem);
	    const programChangeMonitor = new ProgramChangeMonitor(mediaItem, mediaItemDataSource, countryCode);
	    programChangeMonitor.configuration = {
	      ...programChangeMonitor.configuration,
	      ...programChangeMonitorConfig
	    };
	    if (source === 'interceptor') {
	      programChangeMonitor.checkProgramChange = async () => {
	        const {
	          mediaItem,
	          configuration: {
	            watchProp
	          }
	        } = programChangeMonitor;
	        let nextMediaItem;
	        try {
	          nextMediaItem = await coordinator.coordinate('dtci.checkProgramChange', mediaItem);
	        } catch (err) {
	          const errorException = NewRelicService$1.generatePluginBundleUnexpectedError(ERROR_CODES.PLAYER_PROGRAM_CHANGE_FAILED, 'failed to check program change', err);
	          NewRelicService$1.playbackSessionFlowEvent({}, errorException);
	        }
	        if (nextMediaItem && nextMediaItem[watchProp] !== mediaItem[watchProp]) {
	          programChangeMonitor.onProgramChange(nextMediaItem);
	        }
	      };
	    }
	    programChangeMonitor.onProgramChange = async mediaItem => {
	      const {
	        source,
	        source: {
	          url
	        } = {}
	      } = mediaItem || {};
	      if (this.adobeMonitor_) {
	        this.adobeMonitor_.stop();
	      }
	      if (this.programChangeMonitor_) {
	        this.programChangeMonitor_.stop();
	      }
	      if (url && String(url).indexOf('http:') === 0) {
	        source.url = url.replace('http:', 'https:');
	      }

	      // give clients a hook to re-configure player if needed prior to playback session change
	      try {
	        await this.coordinator.coordinate('dtci.programChange', mediaItem);
	      } catch (err) {
	        // eslint resolve
	      }
	      this.initPlaybackSession(mediaItem);
	    };

	    // if we have a previous program change monitor
	    // clean it up before replacing with new one
	    if (this.programChangeMonitor_) {
	      this.programChangeMonitor_.stop();
	    }
	    this.programChangeMonitor_ = programChangeMonitor;
	    this.programChangeMonitor_.start();
	  }
	  handlePlayButtonOnLiveStream(streamType) {
	    const {
	      configs_,
	      player
	    } = this;
	    if (configs_) {
	      const {
	        brandConfig: {
	          disablePlayButtonOnLiveStream
	        } = {}
	      } = configs_;
	      const noPlayButtonOnLiveStream = streamType === 'live' && disablePlayButtonOnLiveStream;
	      if (noPlayButtonOnLiveStream) {
	        player.addClass('hide-play-button');
	      } else {
	        // toggle play and pause video when users press on spacebar
	        this.isKeydownEventEnabled = true;
	        document.addEventListener('keydown', this.onSpaceBarKeydown);
	      }
	      document.addEventListener('keydown', this.onTabKeyDown);
	    }
	  }
	  async onSpaceBarKeydown(event) {
	    const {
	      keyCode,
	      target
	    } = event || {};
	    const {
	      player,
	      player: {
	        isPlaying
	      }
	    } = this;
	    const {
	      configs_: {
	        disableSpacebarPlayToggle
	      } = {}
	    } = this;
	    const spaceBar = 32;
	    const playerElm = player && player.el();
	    const targetIsBodyOrPlayer = target === document.body || target === playerElm;
	    const keyCodeIsSpaceBar = keyCode === spaceBar;
	    if (disableSpacebarPlayToggle || !event || !targetIsBodyOrPlayer || !keyCodeIsSpaceBar) {
	      return;
	    }

	    // Prevent scrolling the page, DTCIMMP-1174
	    event.preventDefault();
	    if (isPlaying) {
	      this.pause();
	    } else {
	      this.play();
	    }
	  }
	  onRetryRequested() {
	    this.mediaManager.analyticsService.retryRequested();
	    this.mediaManager.errorHandlerService.updatePlayerError(false);
	    this.player.errorDisplay.close();
	    this.updateConfiguration(this.configs_);
	    this.initPlaybackSession(this.configs_.mediaItem);
	  }

	  /**
	   Making control bar visible when 'Tab' key is used to navigate and mouse cursor is NOT over the video element
	   When the mouse cursor enters video element and then leaves 'not-hover' class is added to video element container
	   This class hides control bar and causes an accessibility issue - https://jira.disney.com/browse/CPSF-1388
	   * @param {KeyboardEvent} event
	   */
	  onTabKeyDown({
	    keyCode
	  }) {
	    const tab = 9;
	    if (keyCode === tab) {
	      this.player.removeClass('not-hover');
	    }
	  }
	  async watchLoadedCallback(mediaItem, playbackSession) {
	    let player;
	    try {
	      player = this.player;
	      const {
	        configs_
	      } = this;
	      const {
	        images
	      } = mediaItem;
	      const posterHref = getMediaItemPosterHref(images);
	      if (this.adProvider_) {
	        this.mediainfo(mediaItem, this.isEntertainment);
	        const source = await drmSourceBuilder(playbackSession);
	        this.poster(posterHref);
	        const isSocial = typeof player.social === 'function' || typeof player.brandedSocial === 'function';
	        if (isSocial) {
	          this.initSocial(player.mediainfo, configs_.social);
	        }
	        this.advertisingInfo = getAdvertisingInfo(this.advertisingInfo, this.player, mediaItem, this);
	        await this.mediaManager.advertisementService.loadAds(this.adProvider_, this.advertisingInfo, mediaItem, this.autoplayPolicy);
	        const {
	          playbackConfig,
	          mediaItem: playbackMediaItem
	        } = playbackSession || {};
	        const keySystem = playbackConfig && playbackConfig.keySystem || 'none';
	        this.initTVRatingIfMediaItemTvRatingIsSet(mediaItem.tvrating);
	        this.mediaManager.analyticsService.updateConvivaCustomMetadata({
	          playbackMediaItem,
	          drmProtectionType: keySystem,
	          streamProtocol: super.drmSupport_
	        }, this);
	        this.handleRemoteTextTrack_(mediaItem);
	        if (this.adsManagerLoaded) {
	          this.src(source);
	        } else {
	          this.adsManagerLoadedQueue = this.adsManagerLoadedQueue || [];
	          this.adsManagerLoaded         });
	        }
	        this.initThumbnails(mediaItem, playbackSession);
	        this.mediaManager.analyticsService.initAnalytics(mediaItem.tracking, player, configs_);
	      }
	    } catch (err) {
	      let errorException = err;
	      if (!NewRelicService$1.isErrorException(err)) {
	        errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_UNKNOWN, `watchLoadedCallback error`, err);
	        NewRelicService$1.playbackSessionFlowEvent({}, errorException);
	      }
	      if (player && player.error) {
	        player.error({
	          code: -6,
	          errorException
	        });
	      }
	       }
	  }

	  /*
	    Set the `mediainfo` prop on the player with mediaItem data.
	  */
	  mediainfo(mediaItem, isEntertainment = false) {
	    const {
	      player,
	      configs_: {
	        affiliate
	      } = {}
	    } = this;
	    if (mediaItem) {
	      const data = getMediainfoData(mediaItem, isEntertainment);
	      data.affiliate = affiliate;
	      data.startType = this.startType;
	      data.videoSize = this.playerCurrentDimensions;
	      player.mediainfo = data;

	      /**
	       Short-term: exposing mediaItem publicly for DTCIMMP-1417.
	       Longer-term: we need to convert mediainfo into MediaItem instance;
	       Some plugins need to be tweaked because they look for specific data on mediainfo
	       */
	      player.mediaItem = getTrackMediaItem(mediaItem, data, this.playlistId_);
	      this.coordinator.coordinate('dtci.loaded', mediaItem);
	    }
	    return player.mediainfo;
	  }
	  src(src) {
	    const {
	      player
	    } = this;
	    let sources = src;
	    if (Array.isArray(sources) === false) {
	      sources = [sources];
	    }
	    const currentSrc = sources[0];
	    // use CORS for Akamai only (HLS auth uses cookie)
	    // multiple sources are currently passed for non-auth VOD only in which case `useCORS` will be both `false`.
	    const useCORS = AKAMAI_REGEX.test(currentSrc);
	    this.mediaManager.domHelperService.updateCrossOrigin(useCORS);
	    if (player && player.src) {
	      this.mediaManager.errorHandlerService.reportPlayerErrorEvent = this.reportPlayerErrorEvent;
	      this.mediaManager.errorHandlerService.subscribeOnErrors(player);
	      player.src(sources);
	    }
	  }
	  autoplay(value) {
	    const {
	      player
	    } = this;
	    if (player && player.autoplay) {
	      return player.autoplay(value);
	    }
	    return this;
	  }
	  play() {
	    const {
	      player
	    } = this;
	    if (player) {
	      return player.play();
	    }
	    return promise.reject(new Error('play failed'));
	  }
	  pause() {
	    const {
	      player
	    } = this;
	    if (player) {
	      player.pause();
	    }
	    return this;
	  }
	  muted(value) {
	    const {
	      player
	    } = this;
	    if (player) {
	      return player.muted(value);
	    }
	    return null;
	  }
	  currentTime(value) {
	    const {
	      player
	    } = this;

	    // calling player.currentTime() throws an error when video is embed yet
	    if (!(player !== null && player !== void 0 && player.el_)) {
	      return this;
	    }
	    if (player !== null && player !== void 0 && player.currentTime) {
	      if (typeof value === 'undefined') {
	        return player.currentTime();
	      }
	      player.currentTime(value);
	    }
	    return this;
	  }
	  currentType() {
	    const {
	      player
	    } = this;
	    if (player) {
	      return player.currentType();
	    }
	    return null;
	  }
	  playbackRate() {
	    const {
	      player
	    } = this;
	    if (player) {
	      return player.playbackRate();
	    }
	    return null;
	  }
	  duration() {
	    const {
	      player
	    } = this;
	    if (player) {
	      return player.duration();
	    }
	    return null;
	  }
	  language() {
	    const {
	      player
	    } = this;
	    if (player) {
	      return player.language();
	    }
	    return null;
	  }
	  requestFullscreen() {
	    const {
	      player
	    } = this;
	    if (player) {
	      player.requestFullscreen();
	    }
	    return this;
	  }
	  exitFullscreen() {
	    const {
	      player
	    } = this;
	    if (player) {
	      player.exitFullscreen();
	    }
	    return this;
	  }

	  /**
	   * Set caption display state
	   * @param {Boolean}   [showCaptions=false]
	   */
	  captions(showCaptions) {
	    const {
	      player
	    } = this;
	    if (player) {
	      if (typeof player.captionController !== 'function') {
	        console.warn('DTCIVideoPlayer: This player tech does not implement this method.');
	        return this;
	      }
	      if (typeof showCaptions === 'boolean' && showCaptions !== player.captionController().tracksEnabled) {
	        player.captionController().toggleTracks();
	      } else {
	        // eslint-disable-next-line no-console
	        console.log(`DTCIVideoPlayer: Captions already ${showCaptions ? 'on' : 'off'}`);
	      }
	      return player.captionController().tracksEnabled;
	    }
	    return thi    }
	  }

	  /*
	    This will listen for the player event and returns the function to detach the listener
	   */
	  listen(type, callback) {
	    const {
	      player
	    } = this;
	    const fn = callback.bind(this);
	    player.on(type, fn);
	    return function unlisten() {
	      try {
	        player.off(type, fn);
	      } catch (err) {
	        const errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_UNKNOWN, 'Player unlisten error: ', err);
	        NewRelicService$1.playerBundleEvent({}, errorException);
	      }
	    };
	  }

	  // eslint-disable-next-line no-unused-vars
	  handleRemoteTextTrack_(mediaItem) {} // implement in Tech-specific adapters

	  error(value, content, showRetryButton) {
	    const {
	      player
	    } = this;
	    const {
	      errorHandlerService
	    } = this.mediaManager;
	    const err = errorHandlerService.getErrorObject(value, showRetryButton);
	    const sendError = () => {
	      player.error(err);
	      this.reportPlayerErrorEvent(content, value, showRetryButton);
	    };

	    // Errors can sometimes occur before the player is ready...
	    errorHandlerService.executeOnReady(player, sendError);
	  }
	  dispose() {
	    super.adobeNielsen_ = null;
	    this.cleanUp();
	    if (this.configs_.disposeBundleCSS) {
	      this.mediaManager.domHelperService.removePlayerCSSFromDom();
	    }
	    if (this.pluginManager_) {
	      this.pluginManager_.dispose();
	      this.pluginManager_ = null;
	    }
	    if (this.dmedConviva) {
	      this.dmedConviva = null;
	    }
	    if (this.isKeydownEventEnabled) {
	      document.removeEventListener('keydown', this.onSpaceBarKeydown);
	    }
	    document.removeEventListener('keydown', this.onTabKeyDown);
	    if (this.player) {
	      this.mediaManager.errorHandlerService.unsubrsibeOnErrors(this.player);
	      this.player.dispose();
	    }
	    if (this.liveAnalyticsWatcher) {
	      this.liveAnalyticsWatcher.dispose();
	      this.liveAnalyticsWatcher = null;
	    }
	  }
	  getNextContent(currentMediaItem) {
	    return async () => {
	      try {
	        const nextContent = await this.coordinator.coordinate('dtci.getNextContent', currentMediaItem);
	        if (!nextContent || this.isEntertainment && !nextContent.link) {
	          return null;
	        }

	        /**
	         * this.playlistId_ is the ID of the playlist from which the video was initiated.
	         * There are two cases in which this value should be populated.
	         * First, when a user triggers a video by clicking on it in a playlist and,
	         * second, when a video is auto played from a playlist. see comment in DDA-1018.
	         * Not sure if this is where we can get playlistId. We need to confirm with clients
	         * since they will be providing getNextContent function on player init.
	         */

	        if (typeof nextContent === 'string') {
	          const mediaItem = await fetchMediaItemFromApi({
	            identifier: nextContent
	          }, this.coordinator);
	          if (mediaItem) {
	            this.playlistId_ = mediaItem.id;
	            this.coordinator.coordinate('load', mediaItem);
	            return mediaItem;
	          }
	        }
	        this.playlistId_ = nextContent.id;
	        return promise.resolve(nextContent);
	      } catch (err) {
	        let errorException = err;
	        if (!NewRelicService$1.isErrorException(err)) {
	          errorException = NewRelicService$1.generateMediaItemTemporarilyUnavailable('', ERROR_CODES.END_CARD_ERR, 'getNextContent failed', err);
	        }
	        NewRelicService$1.mediaItemFlowEvent({}, errorException);
	      }
	      return promise.resolve();
	    };
	  }
	  async playOnlyAd_() {
	    try {
	      const {
	        player
	      } = this;
	      this.autoplay(true);
	      if (player.preload) {
	        player.preload('metadata');
	      }
	      this.startType = PLAYER_START_TYPE.AUTOSTART;
	      this.analytics.adobeDCR({
	        ESPN_CUSTOM_METADATA: {
	          startType: this.startType
	        }
	      });
	      if (this.adProvider_) {
	        this.advertisingInfo = getAdvertisingInfo(this.advertisingInfo, player, {}, this);
	        await this.mediaManager.advertisementService.loadAds(this.adProvider_, this.advertisingInfo);
	        this.src({
	          src: AD_PROVIDER_DEFAULT_SRC,
	          type: 'video/mp4'
	        });
	      }
	    } catch (err) {
	      const errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.AD_ONLY_FAILED, 'init playOnlyAd_ failed ', err);
	      if (this.player && typeof this.player.error === 'function') {
	        this.player.error({
	          code: -3,
	          errorException
	        });
	      }
	    }
	  }
	  handlehis);
	  }
	  isMidrollAdPodsIndicatorEnabled(midrollPodCues) {
	    const {
	      player,
	      configs_: {
	        brandConfig: {
	          enableMidrollPods = false
	        } = {}
	      }
	    } = this;
	    const isMidrollAdPodsIndicatorEnabled = midrollPodCues && enableMidrollPods && typeof player.midrollPods === 'function';
	    return !!isMidrollAdPodsIndicatorEnabled;
	  }
	  initMidrollAdPodsIndicator(midrollPodCues, duration) {
	    if (this.isMidrollAdPodsIndicatorEnabled(midrollPodCues)) {
	      this.player.midrollPods({
	        midrollPodCues,
	        duration
	      });
	    }
	  }
	  async getPlaybackSession(mediaItem, authenticationManager) {
	    let playbackSession = null;
	    const {
	      player
	    } = this;
	    this.advertisingInfo = getAdvertisingInfo(this.advertisingInfo, player, mediaItem, this);
	    await this.coordinator.coordinate('dtci.adProvider.getAdvertisingInfo', this.advertisingInfo);
	    if (this.configs_.playbackSession) {
	      playbackSession = this.configs_.playbackSession;
	    } else {
	      try {
	        playbackSession = await authenticationManager.initPlaybackSession(mediaItem, this.advertisingInfo);
	        NewRelicService$1.setPlaybackSession(playbackSession);

	        // Commented due to avoiding spaming new relic service with not-error events
	        // NewRelicService.addCrumb(BREADCRUMBS.FINISH);
	        // NewRelicService.playbackSessionFlowEvent({});
	      } catch (err) {
	        if (err && err.message === STREAM_LIMIT_ERROR_MSG) {
	          this.coordinator.coordinate('dtci.concurrencyMonitor.limitReached', err);
	        } else if (player && player.errorDisplay && player.errorDisplay.show) {
	          NewRelicService$1.parseAndSendPlaybackSessionError(mediaItem, err);
	          this.player.errorDisplay.show();
	          this.error(err, err.message, false);
	        }
	      }
	    }
	    return playbackSession;
	  }
	  initTVRatingIfMediaItemTvRatingIsSet(tvrating) {
	    if (isMediaItemTvRatingSet(this.player, tvrating)) {
	      var _this$configs_4;
	      this.player.tvRating({
	        tvRating: tvrating,
	        ratingConfigs: (_this$configs_4 = this.configs_) === null || _this$configs_4 === void 0 ? void 0 : _this$configs_4.rating
	      });
	    }
	  }
	  reportPlayerErrorEvent(content, value, showRetryButton = true) {
	    const {
	      coordinator
	    } = this;
	    this.mediaManager.errorHandlerService.updatePlayerError(true);
	    coordinator.coordinate(SHOW_CUSTOM_ERROR_CONTENT_EVENT, {
	      content,
	      value,
	      showRetryButton,
	      context: this
	    });
	  }
	  preparePlayback_(mediaItem) {
	    const {
	      type,
	      entityType,
	      source,
	      streamType,
	      seekInSeconds
	    } = mediaItem;
	    if (mediaItem) {
	      if (type === 'audio') {
	        if (entityType === 'longform') {
	          this.player.controlBar.seekToLive.el_.removeAttribute('title');
	          this.player.controlBar.seekToLive.show();
	        } else {
	          this.player.controlBar.seekToLive.hide();
	        }
	      }
	      if (source.type === 'entitlement') {
	        this.isEntertainment = true;
	      }
	      this.mediaManager.analyticsService.initQoeOrConviva(mediaItem, this);
	      this.handlePlayButtonOnLiveStream(streamType);
	    } else {
	      throw new Error('mediaItem is null');
	    }
	    this.player.one('seeking', this.showLoadingState);
	    this.player.one('seeked', this.hideLoadingState);
	    this.player.one('loadeddata', () => {
	      const shouldSeek = entityType !== 'shortform' || streamType === 'live';
	      this.loadedData = true;
	      if (shouldSeek && seekInSeconds) {
	        this.player.currentTime(seekInSeconds);
	      }
	      this.hideLoadingState();
	      this.player.bigPlayButton.show();
	    });
	  }
	}

	var DRM_REQUIRED$u = "We're sorry, but this browser is no longer supported.  Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.";
	var EMBARGOED$u = "Video is not yet available.";
	var EXPIRED$u = "Video has expired.";
	var EXPIRED_CONTENT$u = "Video has expired.";
	var Fullscreen$u = "Full Screen";
	var GEOLOCATION_NOT_ALLOWED$u = "Video is not available in your country.";
	var NOT_FOUND$u = "This video is unavailable.";
	var STREAM_LIMITED$u = "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.";
	var STREAM_LIMIT_ERROR$u = "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.";
	var hours_minutes_seconds_format$a = "<%= hours %>, <%= minutes %> and <%= seconds %>";
	var minutes_seconds_format$a = "<%= minutes %> and <%= seconds %>";
	var retry_error_button = "Retry";
	var DEFAULT_ERROR_MSG = "An error has occurred. Please try at a later time or contact us for further assistance.";
	var DEFAULT_ERROR_RETRY_MSG = "An error has occurred. Please try again or contact us for further assistance.";
	var en = {
		"com.espn.watch.api.AccessDeniedException": "This content is not available for your package or region.",
		"Could not download the video": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		DRM_REQUIRED: DRM_REQUIRED$u,
		EMBARGOED: EMBARGOED$u,
		EXPIRED: EXPIRED$u,
		EXPIRED_CONTENT: EXPIRED_CONTENT$u,
		Fullscreen: Fullscreen$u,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$u,
		NOT_FOUND: NOT_FOUND$u,
		"Non-Fullscreen": "Exit Full Screen",
		STREAM_LIMITED: STREAM_LIMITED$u,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$u,
		hours_minutes_seconds_format: hours_minutes_seconds_format$a,
		minutes_seconds_format: minutes_seconds_format$a,
		retry_error_button: retry_error_button,
		DEFAULT_ERROR_MSG: DEFAULT_ERROR_MSG,
		DEFAULT_ERROR_RETRY_MSG: DEFAULT_ERROR_RETRY_MSG
	};

	var Ad$t = "Ø¥Ø¹ÙØ§Ù";
	var Autoplay$t = "ØªØ´ØºÙÙ ØªÙÙØ§Ø¦Ù";
	var Background$t = "Ø§ÙØ®ÙÙÙØ©";
	var Black$t = "Ø³ÙØ¯Ø§Ø¡";
	var Blue$t = "Ø²Ø±ÙØ§Ø¡";
	var Button$t = "Ø§ÙØ²Ø±";
	var Captions$t = "Ø§ÙØªØ±Ø¬ÙØ© Ø§ÙÙØµÙØ©";
	var Casual$t = "Ø¹Ø§Ø¯Ù";
	var Chapters$t = "Ø£Ø¬Ø²Ø§Ø¡";
	var Copied$t = "ØªÙ Ø§ÙÙØ³Ø®";
	var Copy$t = "ÙØ³Ø®";
	var Cyan$t = "Ø£Ø²Ø±Ù Ø³ÙØ§ÙÙ";
	var Default$t = "Ø§ÙØªØ±Ø§Ø¶Ù";
	var Depressed$t = "Ø§ÙØ²Ø± ÙØ¶ØºÙØ· Ø¹ÙÙÙ";
	var Done$t = "ØªÙ";
	var DRM_REQUIRED$t = "DRM_REQUIRED";
	var Email$t = "Ø§ÙØ¨Ø±ÙØ¯ Ø§ÙØ¥ÙÙØªØ±ÙÙÙ";
	var EMBARGOED$t = "EMBARGOED";
	var EXPIRED$t = "EXPIRED";
	var EXPIRED_CONTENT$t = "EXPIRED_CONTENT";
	var Foreground$t = "Ø§ÙÙÙØ¯ÙØ©";
	var From$t = "ÙÙ";
	var Fullscreen$t = "ÙÙØ¡ Ø§ÙØ´Ø§Ø´Ø©";
	var GEOLOCATION_NOT_ALLOWED$t = "GEOLOCATION_NOT_ALLOWED";
	var Green$t = "Ø£Ø®Ø¶Ø±";
	var hour$t = "Ø³Ø§Ø¹Ø©";
	var hours$t = "Ø³Ø§Ø¹Ø§Øª";
	var LIVE$t = "ÙØ¨Ø§Ø´Ø±";
	var Loaded$t = "ØªÙ ØªØ­ÙÙÙ";
	var Magenta$t = "Ø£Ø±Ø¬ÙØ§ÙÙ";
	var Menu$t = "Ø§ÙÙØ§Ø¦ÙØ©";
	var Message$t = "Ø±Ø³Ø§ÙØ©";
	var minute$t = "Ø¯ÙÙÙØ©";
	var minutes$t = "Ø¯ÙØ§Ø¦Ù";
	var More$t = "Ø§ÙÙØ²ÙØ¯";
	var Mute$t = "ÙØªÙ Ø§ÙØµÙØª";
	var NOT_FOUND$t = "NOT_FOUND";
	var None$t = "ÙØ§ ÙÙØ¬Ø¯";
	var OK$t = "Ø­Ø³ÙÙØ§";
	var Opaque$t = "ÙØ¹ØªÙ";
	var Pause$t = "Ø¥ÙÙØ§Ù ÙØ¤ÙØª";
	var Pausing$t = "ÙØªÙÙÙ ÙØ¤ÙØªÙØ§";
	var Play$t = "ØªØ´ØºÙÙ";
	var Playing$t = "ÙÙØ¯ Ø§ÙØªØ´ØºÙÙ";
	var Progress$t = "Ø§ÙØªÙØ¯Ù";
	var Purchased$t = "Ø§ÙØªÙÙ Ø§ÙØ´Ø±Ø§Ø¡";
	var Raised$t = "ÙØ±ÙÙØ¹";
	var Red$t = "Ø£Ø­ÙØ±";
	var Replay$t = "Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙÙ";
	var Rewind$t = "Ø¥Ø±Ø¬Ø§Ø¹";
	var Script$t = "Ø§ÙÙØµ";
	var second$t = "Ø«Ø§ÙÙØ©";
	var seconds$t = "Ø«ÙØ§ÙÙ";
	var Send$t = "Ø¥Ø±Ø³Ø§Ù";
	var Settings$t = "Ø§ÙØ¥Ø¹Ø¯Ø§Ø¯Ø§Øª";
	var Share$t = "ÙØ´Ø§Ø±ÙØ©";
	var Stop$t = "Ø¥ÙÙØ§Ù";
	var STREAM_LIMITED$t = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$t = "STREAM_LIMIT_ERROR";
	var Subtitles$t = "Ø§ÙØªØ±Ø¬ÙØ©";
	var To$t = "Ø¥ÙÙ";
	var Transparent$t = "Ø´ÙØ§Ù";
	var Uniform$t = "ÙÙØªØ¸Ù";
	var Unmute$t = "Ø¥ÙØºØ§Ø¡ ÙØªÙ Ø§ÙØµÙØª";
	var Unmuted$t = "ØªÙ Ø¥ÙØºØ§Ø¡ ÙØªÙ Ø§ÙØµÙØª";
	var Watch$t = "ÙØ´Ø§ÙØ¯Ø©";
	var White$t = "Ø£Ø¨ÙØ¶";
	var Window$t = "ÙØ§ÙØ°Ø©";
	var Yellow$t = "Ø£ØµÙØ±";
	var ar = {
		"A network error caused the media download to fail part-way.": "ØªØ³Ø¨Ø¨ Ø®Ø·Ø£ ÙÙ Ø§ÙØ´Ø¨ÙØ© ÙÙ ÙØ´Ù ØªÙØ²ÙÙ Ø§ÙÙÙØ¯ÙÙ Ø¬Ø²Ø¦ÙÙØ§.",
		Ad: Ad$t,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«ÙØ§Ø¡ Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙÙ Ø§ÙÙÙØ¯ÙÙØ Ø±Ø¨ÙØ§ Ø¨Ø³Ø¨Ø¨ Ø§ØªØµØ§Ù Ø§ÙØ´Ø¨ÙØ© Ø£Ù ÙØ¬ÙØ¯ Ø¹ÙØ§ÙØ© ØªØ¨ÙÙØ¨ ÙØªØµÙØ­ ÙÙ Ø§ÙØ®ÙÙÙØ©. ÙÙØ±Ø¬Ù Ø§ÙÙØ­Ø§ÙÙØ© ÙØ±Ø© Ø£Ø®Ø±Ù.",
		"An unanticipated problem was encountered, check back soon and try again": "Ø®ÙØ§Ø±Ø§Øª Ø§ÙØµÙØª",
		"Audio Options": "Audio Options",
		Autoplay: Autoplay$t,
		"Back to video": "Ø±Ø¬ÙØ¹ Ø¥ÙÙ Ø§ÙÙÙØ¯ÙÙ",
		"Close share": "Close share",
		Background: Background$t,
		Black: Black$t,
		Blue: Blue$t,
		Button: Button$t,
		"Buy PPV": "Ø´Ø±Ø§Ø¡ Ø§ÙØ¯ÙØ¹ Ø¹ÙÙ ÙÙ ÙØ´Ø§ÙØ¯Ø©",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§ÙØªØ±Ø¬ÙØ© Ø§ÙÙØµÙØ©",
		Captions: Captions$t,
		"captions off": "Ø¥ÙÙØ§Ù Ø§ÙØªØ±Ø¬ÙØ© Ø§ÙÙØµÙØ©",
		"Captions Preview": "Ø¹Ø±Ø¶ Ø§ÙØªØ±Ø¬ÙØ© Ø§ÙÙØµÙØ©",
		Casual: Casual$t,
		Chapters: Chapters$t,
		"Check out this video on ESPN": "ØªÙÙØ¯ ÙØ°Ø§ Ø§ÙÙÙØ¯ÙÙ Ø¹ÙÙ ESPN",
		"Choose Broadcast": "Ø§Ø®ØªÙØ§Ø± ÙÙØµØ© Ø¨Ø«",
		"Choose TV Provider": "Ø§Ø®ØªÙØ§Ø± ÙÙØ¯Ù Ø®Ø¯ÙØ© Ø§ÙØ¨Ø«",
		"Closed Caption": "ØªØ±Ø¬ÙØ© ÙØµÙØ© ÙØºÙÙØ©",
		"Closed Captions": "ØªØ±Ø¬ÙØ© ÙØµÙØ© ÙØºÙÙØ©",
		Copied: Copied$t,
		Copy: Copy$t,
		"Copy Embed Link": "ÙØ³Ø® Ø±Ø§Ø¨Ø· Ø§ÙØªØ¶ÙÙÙ",
		"Copy Link": "ÙØ³Ø® Ø§ÙØ±Ø§Ø¨Ø·",
		"Could not download the video": "Could not download the video",
		"Current Time": "Ø§ÙÙÙØª Ø§ÙØ­Ø§ÙÙ",
		"currently behind live": "Ø§ÙØªÙÙ Ø§ÙØ¨Ø« Ø§ÙÙØ¨Ø§Ø´Ø±",
		Cyan: Cyan$t,
		Default: Default$t,
		Depressed: Depressed$t,
		Done: Done$t,
		DRM_REQUIRED: DRM_REQUIRED$t,
		"Drop shadow": "ÙØ¶Ø¹ Ø¸Ù",
		"Duration Time": "Ø§ÙÙØ¯Ø©",
		Email: Email$t,
		"Email Video": "Ø¥Ø±Ø³Ø§Ù Ø§ÙÙÙØ¯ÙÙ Ø¹Ø¨Ø± Ø§ÙØ¨Ø±ÙØ¯ Ø§ÙØ¥ÙÙØªØ±ÙÙÙ",
		EMBARGOED: EMBARGOED$t,
		"Embed Code": "Ø±ÙØ² Ø§ÙØªØ¶ÙÙÙ",
		"Error Code": "Ø±ÙØ² Ø§ÙØ®Ø·Ø£",
		"Exit Full Screen": "Ø§ÙØ®Ø±ÙØ¬ ÙÙ ÙØ¶Ø¹ ÙÙØ¡ Ø§ÙØ´Ø§Ø´Ø©",
		EXPIRED: EXPIRED$t,
		EXPIRED_CONTENT: EXPIRED_CONTENT$t,
		"Fast Forward": "ØªÙØ¯ÙÙ Ø³Ø±ÙØ¹",
		"Font Family": "Ø¹Ø§Ø¦ÙØ© Ø§ÙØ®Ø·ÙØ·",
		"Font Size": "Ø­Ø¬Ù Ø§ÙØ®Ø·",
		Foreground: Foreground$t,
		From: From$t,
		Fullscreen: Fullscreen$t,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$t,
		"Get ESPN+": "Ø§ÙØ§Ø´ØªØ±Ø§Ù ÙÙ ESPN+",
		"Get MLB.TV": "Ø§ÙØ§Ø´ØªØ±Ø§Ù ÙÙ MLB.TV",
		Green: Green$t,
		hour: hour$t,
		hours: hours$t,
		"Language Settings": "Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§ÙÙØºØ©",
		"Learn More": "ÙØ¹Ø±ÙØ© Ø§ÙÙØ²ÙØ¯",
		LIVE: LIVE$t,
		Loaded: Loaded$t,
		"Logged Into TV Provider": "ØªÙ ØªØ³Ø¬ÙÙ Ø§ÙØ¯Ø®ÙÙ Ø¥ÙÙ ÙÙØ¯Ù Ø®Ø¯ÙØ© Ø§ÙØ¨Ø«",
		Magenta: Magenta$t,
		Menu: Menu$t,
		Message: Message$t,
		minute: minute$t,
		minutes: minutes$t,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$t,
		Mute: Mute$t,
		NOT_FOUND: NOT_FOUND$t,
		"No compatible source was found for this media.": "ÙÙ ÙØªÙ Ø§ÙØ¹Ø«ÙØ± Ø¹ÙÙ ÙØµØ¯Ø± ÙØªÙØ§ÙÙ ÙÙØ°Ø§ Ø§ÙÙÙØ¯ÙÙ.",
		"No video has been loaded": "ÙÙ ÙØªÙ ØªØ­ÙÙÙ Ø£Ù ÙÙØ¯ÙÙ",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$t,
		"Now Playing": "ÙÙØ¹Ø±Ø¶ Ø§ÙØ¢Ù",
		OK: OK$t,
		Opaque: Opaque$t,
		Pause: Pause$t,
		Pausing: Pausing$t,
		Play: Play$t,
		"Playback Rate": "ÙØ¹Ø¯Ù Ø¥Ø¹Ø§Ø¯Ø© Ø§ÙØªØ´ØºÙÙ",
		"Playback Speed": "Ø³Ø±Ø¹Ø© Ø¥Ø¹Ø§Ø¯Ø© Ø§ÙØªØ´ØºÙÙ",
		Playing: Playing$t,
		"please confirm you are connected to the internet": "ÙÙØ±Ø¬Ù Ø§ÙØªØ£ÙØ¯ ÙÙ Ø§ÙØ§ØªØµØ§Ù Ø¨Ø§ÙØ¥ÙØªØ±ÙØª",
		Progress: Progress$t,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$t,
		Raised: Raised$t,
		Red: Red$t,
		"Remaining Time": "Ø§ÙÙÙØª Ø§ÙÙØªØ¨ÙÙ",
		Replay: Replay$t,
		"Reset to Defaults": "Ø¥Ø¹Ø§Ø¯Ø© Ø§ÙØªØ¹ÙÙÙ Ø¥ÙÙ Ø§ÙØ¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§ÙØ§ÙØªØ±Ø§Ø¶ÙØ©",
		Rewind: Rewind$t,
		Script: Script$t,
		second: second$t,
		seconds: seconds$t,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "ÙÙØ¹Ø±Ø¶ Ø¨Ø« Seek to live Ø§ÙÙØ¨Ø§Ø´Ø± Ø§ÙØ¢Ù",
		"Select Broadcast": "ØªØ­Ø¯ÙØ¯ ÙÙØµØ© Ø¨Ø«",
		"Semi-Opaque": "Ø´Ø¨Ù ÙØ¹ØªÙ",
		"Semi-Transparent": "Ø´Ø¨Ù Ø´ÙØ§Ù",
		Send: Send$t,
		Settings: Settings$t,
		Share: Share$t,
		"Skip Ad": "ØªØ®Ø·Ù Ø§ÙØ¥Ø¹ÙØ§Ù",
		"Small Caps": "Ø£Ø­Ø±Ù ØµØºÙØ±Ø©",
		"Start at": "Ø§ÙØ¨Ø¯Ø¡ ÙÙ",
		Stop: Stop$t,
		STREAM_LIMITED: STREAM_LIMITED$t,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$t,
		"Stream Type": "ÙÙØ¹ Ø§ÙØ¨Ø«",
		"Subscribed to ESPN+": "ÙÙØ´ØªØ±Ù ÙÙ ESPN+",
		Subtitles: Subtitles$t,
		"subtitles off": "Ø¥ÙÙØ§Ù Ø§ÙØªØ±Ø¬ÙØ©",
		"Technical details": "ØªÙØ§ØµÙÙ ØªÙÙÙØ©",
		"Text Edge Style": "ÙÙØ· Ø­Ø§ÙØ© Ø§ÙÙØµ",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "ÙØµÙØª Ø¥ÙÙ Ø§ÙØ­Ø¯ Ø§ÙØ£ÙØµÙ ÙØ¹Ø¯Ø¯ Ø§ÙØ¨Ø« Ø§ÙÙØªØ²Ø§ÙÙ ÙÙ Ø­Ø³Ø§Ø¨Ù. Ø¥Ø°Ø§ ÙØ§Ù ÙØ¯ÙÙ Ø£Ù Ø£Ø³Ø¦ÙØ© Ø£Ù ÙÙØª Ø¨Ø­Ø§Ø¬Ø© Ø¥ÙÙ ÙØ³Ø§Ø¹Ø¯Ø©Ø ÙÙØ±Ø¬Ù Ø²ÙØ§Ø±Ø© es.pn/watchfaq Ø£Ù Ø§ÙØ§ØªØµØ§Ù Ø¨Ø§ÙØ±ÙÙ 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "ØªØ¹Ø°Ø± ØªØ­ÙÙÙ Ø§ÙÙØ³Ø§Ø¦Ø· Ø¥ÙØ§ Ø¨Ø³Ø¨Ø¨ ÙØ´Ù Ø§ÙØ®Ø§Ø¯Ù Ø£Ù Ø§ÙØ´Ø¨ÙØ© Ø£Ù ÙØ£Ù Ø§ÙØµÙØºØ© ØºÙØ± ÙØ¯Ø¹ÙÙØ©.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "Ø§ÙÙØ·Ø¹ Ø§ØªØµØ§Ù Ø§ÙÙÙØ¯ÙÙ",
		"The video download was cancelled": "ØªÙ Ø¥ÙØºØ§Ø¡ ØªÙØ²ÙÙ Ø§ÙÙÙØ¯ÙÙ",
		"The video is bad or in a format that cannot be played on your browser": "Ø§ÙÙÙØ¯ÙÙ ØºÙØ± ØµØ§ÙØ­ ÙÙØªØ´ØºÙÙ Ø£Ù ÙØªØ¹Ø°Ø± ØªØ´ØºÙÙ ØµÙØºØªÙ Ø¹ÙÙ ÙØªØµÙØ­Ù",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "ØªÙ Ø¥ÙÙØ§Ù ØªØ´ØºÙÙ Ø§ÙÙÙØ¯ÙÙ Ø¨Ø³Ø¨Ø¨ ÙØ´ÙÙØ© ØªÙÙ Ø£Ù ÙØ£Ù Ø§ÙÙÙØ¯ÙÙ Ø§Ø³ØªØ®Ø¯Ù ÙÙØ²Ø§Øª ÙØ§ ÙØ¯Ø¹ÙÙØ§ ÙØªØµÙØ­Ù.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Ø§ÙÙÙØ¯ÙÙ Ø§ÙØ°Ù ØªØ­Ø§ÙÙ ÙØ´Ø§ÙØ¯ØªÙ ÙÙØ´ÙØ± ÙÙØ§ ÙØ¹Ø±Ù ÙÙÙÙØ© ÙÙ ØªØ´ÙÙØ±Ù",
		"This content is not available for your package or region.": "ÙØ°Ø§ Ø§ÙÙØ­ØªÙÙ ØºÙØ± ÙØªÙÙØ± ÙØ­Ø²ÙØªÙ Ø£Ù ÙÙØ·ÙØªÙ.",
		"This video is either unavailable or not supported in this browser": "ÙØ°Ø§ Ø§ÙÙÙØ¯ÙÙ Ø¥ÙØ§ ØºÙØ± ÙØªÙÙØ± Ø£Ù ØºÙØ± ÙØ¯Ø¹ÙÙ ÙÙ ÙØ°Ø§ Ø§ÙÙØªØµÙØ­",
		"This video is unavailable": "ÙØ°Ø§ Ø§ÙÙÙØ¯ÙÙ ØºÙØ± ÙØªØ§Ø­.",
		To: To$t,
		Transparent: Transparent$t,
		Uniform: Uniform$t,
		Unmute: Unmute$t,
		Unmuted: Unmuted$t,
		"Up Next": "Ø§ÙØªØ§ÙÙ",
		"Video has expired.": "Ø§ÙØªÙØª ØµÙØ§Ø­ÙØ© Ø§ÙÙÙØ¯ÙÙ.",
		"Video is not available in your country.": "Ø§ÙÙÙØ¯ÙÙ ØºÙØ± ÙØªØ§Ø­ ÙÙ Ø¯ÙÙØªÙ.",
		"Video is not yet available.": "Ø§ÙÙÙØ¯ÙÙ ØºÙØ± ÙØªØ§Ø­ Ø§ÙØ¢Ù.",
		"Video Player": "ÙØ´ØºÙ ÙÙØ¯ÙÙ",
		Watch: Watch$t,
		"WATCH NOW": "ÙØ´Ø§ÙØ¯Ø© Ø§ÙØ¢Ù",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "ÙØ£Ø³ÙØ ÙÙÙ ÙØ°Ø§ Ø§ÙÙØªØµÙØ­ ÙÙ ÙØ¹Ø¯ ÙØ¯Ø¹ÙÙÙØ§. ÙÙØ±Ø¬Ù Ø§ÙØªØ±ÙÙØ© Ø¥ÙÙ Ø£Ø­Ø¯Ø« Ø¥ØµØ¯Ø§Ø± ÙÙ Google Chrome Ø£Ù FireFox Ø£Ù Microsoft Edge ÙÙØ´Ø§ÙØ¯Ø© ÙØ°Ø§ Ø§ÙÙØ­ØªÙÙ.",
		White: White$t,
		Window: Window$t,
		Yellow: Yellow$t,
		"You aborted the media playback": "Ø£ÙÙÙØª Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙÙ Ø§ÙÙÙØ¯ÙÙ",
		"elapsed out of": "Ø§ÙÙØ¶Ù ÙÙ"
	};

	var Ad$s = "Ð ÐµÐºÐ»Ð°Ð¼Ð°";
	var Autoplay$s = "ÐÐ²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐ½Ð¾ Ð¸Ð·Ð¿ÑÐ»Ð½ÐµÐ½Ð¸Ðµ";
	var Background$s = "Ð¤Ð¾Ð½";
	var Black$s = "Ð§ÐµÑÐµÐ½";
	var Blue$s = "Ð¡Ð¸Ð½";
	var Button$s = "ÐÑÑÐ¾Ð½";
	var Captions$s = "ÐÐ°Ð´Ð¿Ð¸ÑÐ¸";
	var Casual$s = "ÐÐ±Ð¸ÐºÐ½Ð¾Ð²ÐµÐ½";
	var Chapters$s = "ÐÑÐºÑÑÐ¸";
	var Copied$s = "ÐÐ¾Ð¿Ð¸ÑÐ°Ð½Ð¾";
	var Copy$s = "ÐÐ¾Ð¿Ð¸ÑÐ°Ð¹";
	var Cyan$s = "Ð¦Ð¸Ð°Ð½";
	var Default$s = "ÐÐ¾ Ð¿Ð¾Ð´ÑÐ°Ð·Ð±Ð¸ÑÐ°Ð½Ðµ";
	var Depressed$s = "ÐÐ°ÑÐ¸ÑÐ½Ð°Ñ Ð±ÑÑÐ¾Ð½";
	var Done$s = "ÐÐ¾ÑÐ¾Ð²Ð¾";
	var DRM_REQUIRED$s = "DRM_REQUIRED";
	var Email$s = "ÐÐ». Ð¿Ð¾ÑÐ°";
	var EMBARGOED$s = "EMBARGOED";
	var EXPIRED$s = "EXPIRED";
	var EXPIRED_CONTENT$s = "EXPIRED_CONTENT";
	var Foreground$s = "ÐÑÐµÐ´ÐµÐ½ Ð¿Ð»Ð°Ð½";
	var From$s = "ÐÑ";
	var Fullscreen$s = "Ð¦ÑÐ» ÐµÐºÑÐ°Ð½";
	var GEOLOCATION_NOT_ALLOWED$s = "GEOLOCATION_NOT_ALLOWED";
	var Green$s = "ÐÐµÐ»ÐµÐ½Ð¾";
	var hour$s = "ÑÐ°Ñ";
	var hours$s = "ÑÐ°ÑÐ¾Ð²Ðµ";
	var LIVE$s = "ÐÐ ÐÐÐÐ";
	var Loaded$s = "ÐÐ°ÑÐµÐ´ÐµÐ½Ð¾";
	var Magenta$s = "ÐÐ°Ð³ÐµÐ½ÑÐ°";
	var Menu$s = "ÐÐµÐ½Ñ";
	var Message$s = "Ð¡ÑÐ¾Ð±ÑÐµÐ½Ð¸Ðµ";
	var minute$s = "Ð¼Ð¸Ð½ÑÑÐ°";
	var minutes$s = "Ð¼Ð¸Ð½ÑÑÐ¸";
	var More$s = "ÐÑÐµ";
	var Mute$s = "ÐÐµÐ· Ð·Ð²ÑÐº";
	var NOT_FOUND$s = "NOT_FOUND";
	var None$s = "ÐÐ¸ÑÐ¾ ÐµÐ´Ð¸Ð½";
	var OK$s = "ÐÐº";
	var Opaque$s = "ÐÐµÐ¿ÑÐ¾Ð·ÑÐ°ÑÐµÐ½";
	var Pause$s = "ÐÐ°ÑÐ·Ð°";
	var Pausing$s = "ÐÐ° Ð¿Ð°ÑÐ·Ð°";
	var Play$s = "ÐÑÐ·Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð°Ð½Ðµ";
	var Playing$s = "ÐÑÐ·Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð°Ð½Ðµ";
	var Progress$s = "ÐÐ°Ð¿ÑÐµÐ´ÑÐº";
	var Purchased$s = "ÐÑÐ¿ÐµÐ½Ð¾";
	var Raised$s = "Ð£Ð²ÐµÐ»Ð¸ÑÐµÐ½Ð¾";
	var Red$s = "Ð§ÐµÑÐ²ÐµÐ½Ð¾";
	var Replay$s = "ÐÐ¾Ð²ÑÐ¾ÑÐµÐ½Ð¸Ðµ";
	var Rewind$s = "ÐÑÐµÐ²ÑÑÑÐ°Ð½Ðµ Ð½Ð°Ð·Ð°Ð´";
	var Script$s = "Ð¡ÐºÑÐ¸Ð¿Ñ";
	var second$s = "ÑÐµÐºÑÐ½Ð´Ð°";
	var seconds$s = "ÑÐµÐºÑÐ½Ð´Ð¸";
	var Send$s = "ÐÐ·Ð¿ÑÐ°ÑÐ°Ð½Ðµ";
	var Settings$s = "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸";
	var Share$s = "Ð¡Ð¿Ð¾Ð´ÐµÐ»ÑÐ½Ðµ";
	var Stop$s = "Ð¡ÑÐ¾Ð¿";
	var STREAM_LIMITED$s = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$s = "STREAM_LIMIT_ERROR";
	var Subtitles$s = "Ð¡ÑÐ±ÑÐ¸ÑÑÐ¸";
	var To$s = "ÐÑÐ¼";
	var Transparent$s = "ÐÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾";
	var Uniform$s = "ÐÐ´Ð½Ð°ÐºÑÐ²";
	var Unmute$s = "ÐÐºÐ»ÑÑÐ²Ð°Ð½Ðµ Ð½Ð° Ð·Ð²ÑÐºÐ°";
	var Unmuted$s = "ÐÐ²ÑÐº Ð²ÐºÐ»ÑÑÐµÐ½";
	var Watch$s = "ÐÐ»ÐµÐ´Ð°Ð¹";
	var White$s = "ÐÑÐ»Ð¾";
	var Window$s = "ÐÑÐ¾Ð·Ð¾ÑÐµÑ";
	var Yellow$s = "ÐÑÐ»ÑÐ¾";
	var bg = {
		"A network error caused the media download to fail part-way.": "ÐÑÐµÐ¶Ð¾Ð²Ð° Ð³ÑÐµÑÐºÐ° Ð´Ð¾Ð²ÐµÐ´Ðµ Ð´Ð¾ Ð½ÐµÑÑÐ¿ÐµÑÐ½Ð¾ ÑÐ°ÑÑÐ¸ÑÐ½Ð¾ Ð¸Ð·ÑÐµÐ³Ð»ÑÐ½Ðµ Ð½Ð° Ð²Ð¸Ð´ÐµÐ¾ÑÐ¾.",
		Ad: Ad$s,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "ÐÑÐ·Ð½Ð¸ÐºÐ½Ð° Ð³ÑÐµÑÐºÐ° Ð¿Ð¾ Ð²ÑÐµÐ¼Ðµ Ð½Ð° Ð²ÑÐ·Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð°Ð½Ðµ Ð½Ð° Ð²Ð¸Ð´ÐµÐ¾, Ð²ÐµÑÐ¾ÑÑÐ½Ð¾ Ð¿Ð¾ÑÐ°Ð´Ð¸ Ð¼ÑÐµÐ¶Ð¾Ð²Ð° Ð²ÑÑÐ·ÐºÐ° Ð¸Ð»Ð¸ Ð¿Ð¾ÑÐ°Ð´Ð¸ ÑÐ¾Ð²Ð°, ÑÐµ ÑÐµ Ð½Ð°Ð¼Ð¸ÑÐ° Ð²ÑÐ² ÑÐ¾Ð½Ð¾Ð² ÑÐ°Ð·Ð´ÐµÐ» Ð½Ð° Ð±ÑÐ°ÑÐ·ÑÑÐ°. ÐÐ¾Ð»Ñ, Ð¾Ð¿Ð¸ÑÐ°Ð¹ÑÐµ Ð¾ÑÐ½Ð¾Ð²Ð¾.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "ÐÐ¿ÑÐ¸Ð¸ Ð·Ð° Ð°ÑÐ´Ð¸Ð¾",
		Autoplay: Autoplay$s,
		"Back to video": "ÐÐ±ÑÐ°ÑÐ½Ð¾ ÐºÑÐ¼ Ð²Ð¸Ð´ÐµÐ¾ÑÐ¾",
		"Close share": "Close share",
		Background: Background$s,
		Black: Black$s,
		Blue: Blue$s,
		Button: Button$s,
		"Buy PPV": "ÐÐ»Ð°ÑÐµÑÐµ Ð·Ð° Ð´Ð° Ð³Ð»ÐµÐ´Ð°ÑÐµ",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸ Ð·Ð° Ð½Ð°Ð´Ð¿Ð¸ÑÐ¸",
		Captions: Captions$s,
		"captions off": "Ð½Ð°Ð´Ð¿Ð¸ÑÐ¸ÑÐµ ÑÐ° Ð¸Ð·ÐºÐ»ÑÑÐµÐ½Ð¸",
		"Captions Preview": "Ð¿ÑÐµÐ³Ð»ÐµÐ´ Ð½Ð° Ð½Ð°Ð´Ð¿Ð¸ÑÐ¸ÑÐµ",
		Casual: Casual$s,
		Chapters: Chapters$s,
		"Check out this video on ESPN": "ÐÐ¸Ð¶ÑÐµ ÑÐ¾Ð²Ð° Ð²Ð¸Ð´ÐµÐ¾ Ð¿Ð¾ ESPN",
		"Choose Broadcast": "ÐÐ·Ð±ÐµÑÐµÑÐµ Ð¸Ð·Ð»ÑÑÐ²Ð°Ð½Ðµ",
		"Choose TV Provider": "ÐÐ·Ð±ÐµÑÐµÑÐµ Ð´Ð¾ÑÑÐ°Ð²ÑÐ¸Ðº Ð½Ð° ÑÐµÐ»ÐµÐ²Ð¸Ð·Ð¸Ñ",
		"Closed Caption": "ÐÐ°ÑÐ²Ð¾ÑÐµÐ½ Ð½Ð°Ð´Ð¿Ð¸Ñ",
		"Closed Captions": "ÐÐ°ÑÐ²Ð¾ÑÐµÐ½Ð¸ Ð½Ð°Ð´Ð¿Ð¸ÑÐ¸",
		Copied: Copied$s,
		Copy: Copy$s,
		"Copy Embed Link": "ÐÐ¾Ð¿Ð¸ÑÐ°Ð½Ðµ Ð½Ð° Ð²Ð³ÑÐ°Ð´ÐµÐ½Ð°ÑÐ° Ð²ÑÑÐ·ÐºÐ°",
		"Copy Link": "ÐÐ¾Ð¿Ð¸ÑÐ°Ð½Ðµ Ð½Ð° Ð²ÑÑÐ·ÐºÐ°",
		"Could not download the video": "Could not download the video",
		"Current Time": "Ð¢ÐµÐºÑÑÐ¾ Ð²ÑÐµÐ¼Ðµ",
		"currently behind live": "Ð² Ð¼Ð¾Ð¼ÐµÐ½ÑÐ° Ð½Ðµ Ð³Ð»ÐµÐ´Ð°ÑÐµ Ð½Ð° Ð¶Ð¸Ð²Ð¾",
		Cyan: Cyan$s,
		Default: Default$s,
		Depressed: Depressed$s,
		Done: Done$s,
		DRM_REQUIRED: DRM_REQUIRED$s,
		"Drop shadow": "Ð¥Ð²ÑÑÐ»ÐµÐ½Ð° ÑÑÐ½ÐºÐ°",
		"Duration Time": "ÐÑÐµÐ¼ÐµÑÑÐ°ÐµÐ½Ðµ",
		Email: Email$s,
		"Email Video": "ÐÐ¸Ð´ÐµÐ¾ Ð¿Ð¾ Ð¸Ð¼ÐµÐ¹Ð»",
		EMBARGOED: EMBARGOED$s,
		"Embed Code": "ÐÐ¾Ð´ Ð·Ð° Ð²Ð³ÑÐ°Ð¶Ð´Ð°Ð½Ðµ",
		"Error Code": "ÐÐ¾Ð´ Ð·Ð° Ð³ÑÐµÑÐºÐ°",
		"Exit Full Screen": "ÐÐ·Ð»Ð¸Ð·Ð°Ð½Ðµ Ð¾Ñ ÑÑÐ» ÐµÐºÑÐ°Ð½",
		EXPIRED: EXPIRED$s,
		EXPIRED_CONTENT: EXPIRED_CONTENT$s,
		"Fast Forward": "ÐÑÐµÐ²ÑÑÑÐ°Ð½Ðµ Ð½Ð°Ð¿ÑÐµÐ´",
		"Font Family": "Ð¡ÐµÐ¼ÐµÐ¹ÑÑÐ²Ð¾ ÑÑÐ¸ÑÑÐ¾Ð²Ðµ",
		"Font Size": "Ð Ð°Ð·Ð¼ÐµÑ Ð½Ð° ÑÑÐ¸ÑÑÐ°",
		Foreground: Foreground$s,
		From: From$s,
		Fullscreen: Fullscreen$s,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$s,
		"Get ESPN+": "ÐÐ·ÐµÐ¼Ð¸ ESPN+",
		"Get MLB.TV": "ÐÐ·ÐµÐ¼Ð¸ MLB.TV",
		Green: Green$s,
		hour: hour$s,
		hours: hours$s,
		"Language Settings": "ÐÐ·Ð¸ÐºÐ¾Ð²Ð¸ Ð½Ð°ÑÑÑÐ¾Ð¹ÐºÐ¸",
		"Learn More": "ÐÐ°ÑÑÐ¸ Ð¿Ð¾Ð²ÐµÑÐµ",
		LIVE: LIVE$s,
		Loaded: Loaded$s,
		"Logged Into TV Provider": "ÐÐ»ÐµÐ·Ð»Ð¸ ÑÑÐµ Ð² Ð´Ð¾ÑÑÐ°Ð²ÑÐ¸Ðº Ð½Ð° ÑÐµÐ»ÐµÐ²Ð¸Ð·Ð¸Ñ",
		Magenta: Magenta$s,
		Menu: Menu$s,
		Message: Message$s,
		minute: minute$s,
		minutes: minutes$s,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$s,
		Mute: Mute$s,
		NOT_FOUND: NOT_FOUND$s,
		"No compatible source was found for this media.": "ÐÐµ Ð±ÐµÑÐµ Ð½Ð°Ð¼ÐµÑÐµÐ½ ÑÑÐ²Ð¼ÐµÑÑÐ¸Ð¼ Ð¸Ð·ÑÐ¾ÑÐ½Ð¸Ðº Ð·Ð° ÑÐ¾Ð²Ð° Ð²Ð¸Ð´ÐµÐ¾.",
		"No video has been loaded": "ÐÑÐ¼Ð° Ð·Ð°ÑÐµÐ´ÐµÐ½Ð¾ Ð²Ð¸Ð´ÐµÐ¾",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$s,
		"Now Playing": "ÐÐ·Ð»ÑÑÐ²Ð° ÑÐµ Ð² Ð¼Ð¾Ð¼ÐµÐ½ÑÐ°",
		OK: OK$s,
		Opaque: Opaque$s,
		Pause: Pause$s,
		Pausing: Pausing$s,
		Play: Play$s,
		"Playback Rate": "Ð¡ÑÐ¾Ð¹Ð½Ð¾ÑÑ Ð½Ð° Ð²ÑÐ·Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð°Ð½Ðµ",
		"Playback Speed": "Ð¡ÐºÐ¾ÑÐ¾ÑÑ Ð½Ð° Ð²ÑÐ·Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð°Ð½Ðµ",
		Playing: Playing$s,
		"please confirm you are connected to the internet": "Ð¼Ð¾Ð»Ñ, Ð¿Ð¾ÑÐ²ÑÑÐ´ÐµÑÐµ, ÑÐµ ÑÑÐµ ÑÐ²ÑÑÐ·Ð°Ð½Ð¸ Ñ Ð¸Ð½ÑÐµÑÐ½ÐµÑ",
		Progress: Progress$s,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$s,
		Raised: Raised$s,
		Red: Red$s,
		"Remaining Time": "ÐÑÑÐ°Ð²Ð°ÑÐ¾ Ð²ÑÐµÐ¼Ðµ",
		Replay: Replay$s,
		"Reset to Defaults": "ÐÑÐ·ÑÑÐ°Ð½Ð¾Ð²ÑÐ²Ð°Ð½Ðµ Ð½Ð° Ð½Ð°ÑÑÑÐ¾Ð¹ÐºÐ¸ÑÐµ Ð¿Ð¾ Ð¿Ð¾Ð´ÑÐ°Ð·Ð±Ð¸ÑÐ°Ð½Ðµ",
		Rewind: Rewind$s,
		Script: Script$s,
		second: second$s,
		seconds: seconds$s,
		"Seek to live": "Ð¢ÑÑÑÐµÐ½Ðµ Ð½Ð° Ð¿ÑÐµÐ´Ð°Ð²Ð°Ð½Ðµ Ð½Ð° Ð¶Ð¸Ð²Ð¾",
		"Seek to live, currently playing live": "Ð¢ÑÑÑÐµÐ½Ðµ Ð½Ð° Ð¿ÑÐµÐ´Ð°Ð²Ð°Ð½Ðµ Ð½Ð° Ð¶Ð¸Ð²Ð¾, Ð² Ð¼Ð¾Ð¼ÐµÐ½ÑÐ° ÑÐµ Ð¿ÑÐµÐ´Ð°Ð²Ð° Ð½Ð° Ð¶Ð¸Ð²Ð¾",
		"Select Broadcast": "ÐÐ·Ð±ÐµÑÐµÑÐµ Ð¸Ð·Ð»ÑÑÐ²Ð°Ð½Ðµ",
		"Semi-Opaque": "ÐÐ¾Ð»Ñ-Ð½ÐµÐ¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾",
		"Semi-Transparent": "ÐÐ¾Ð»Ñ-Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾",
		Send: Send$s,
		Settings: Settings$s,
		Share: Share$s,
		"Skip Ad": "ÐÑÐ¾Ð¿ÑÑÐ½Ð¸ Ð¾Ð±ÑÐ²Ð°ÑÐ°",
		"Small Caps": "ÐÐ°Ð»ÐºÐ¸ Ð±ÑÐºÐ²Ð¸",
		"Start at": "ÐÐ°Ð¿Ð¾ÑÐ½Ð¸ Ð¾Ñ",
		Stop: Stop$s,
		STREAM_LIMITED: STREAM_LIMITED$s,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$s,
		"Stream Type": "Ð¢Ð¸Ð¿ Ð¿ÑÐµÐ´Ð°Ð²Ð°Ð½Ðµ",
		"Subscribed to ESPN+": "ÐÐ±Ð¾Ð½Ð¸ÑÐ°Ð½Ðµ Ð·Ð° ESPN+",
		Subtitles: Subtitles$s,
		"subtitles off": "ÑÑÐ±ÑÐ¸ÑÑÐ¸ Ð¸Ð·ÐºÐ»ÑÑÐµÐ½Ð¸",
		"Technical details": "Ð¢ÐµÑÐ½Ð¸ÑÐµÑÐºÐ¸ Ð´ÐµÑÐ°Ð¹Ð»Ð¸",
		"Text Edge Style": "Ð¡ÑÐ¸Ð» Text Edge",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "ÐÐ¾ÑÑÐ¸Ð³Ð½Ð°Ñ Ðµ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»Ð½Ð¸ÑÑ Ð±ÑÐ¾Ð¹ ÐµÐ´Ð½Ð¾Ð²ÑÐµÐ¼ÐµÐ½Ð½Ð¸ Ð¸Ð·Ð»ÑÑÐ²Ð°Ð½Ð¸Ñ Ð²ÑÐ² Ð²Ð°ÑÐ¸Ñ Ð°ÐºÐ°ÑÐ½Ñ. ÐÐºÐ¾ Ð¸Ð¼Ð°ÑÐµ Ð²ÑÐ¿ÑÐ¾ÑÐ¸ Ð¸Ð»Ð¸ ÑÐµ Ð½ÑÐ¶Ð´Ð°ÐµÑÐµ Ð¾Ñ Ð¿Ð¾Ð¼Ð¾Ñ, Ð¿Ð¾ÑÐµÑÐµÑÐµ es.pn/watchfaq Ð¸Ð»Ð¸ ÑÐµ Ð¾Ð±Ð°Ð´ÐµÑÐµ Ð½Ð° 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "ÐÐµÐ´Ð¸Ð¸ÑÐµ Ð½Ðµ Ð¼Ð¾Ð¶Ð°ÑÐ° Ð´Ð° Ð±ÑÐ´Ð°Ñ Ð·Ð°ÑÐµÐ´ÐµÐ½Ð¸, Ð·Ð°ÑÐ¾ÑÐ¾ ÑÑÑÐ²ÑÑÑÑ Ð¸Ð»Ð¸ Ð¼ÑÐµÐ¶Ð°ÑÐ° Ð´Ð°Ð´Ð¾ÑÐ° Ð³ÑÐµÑÐºÐ°, Ð¸Ð»Ð¸ Ð·Ð°ÑÐ¾ÑÐ¾ ÑÐ¾ÑÐ¼Ð°ÑÑÑ Ð½Ðµ ÑÐµ Ð¿Ð¾Ð´Ð´ÑÑÐ¶Ð°.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "ÐÐ¸Ð´ÐµÐ¾Ð²ÑÑÐ·ÐºÐ°ÑÐ° Ð±ÐµÑÐµ Ð¸Ð·Ð³ÑÐ±ÐµÐ½Ð°",
		"The video download was cancelled": "ÐÐ·ÑÐµÐ³Ð»ÑÐ½ÐµÑÐ¾ Ð½Ð° Ð²Ð¸Ð´ÐµÐ¾ÑÐ¾ Ðµ Ð°Ð½ÑÐ»Ð¸ÑÐ°Ð½Ð¾",
		"The video is bad or in a format that cannot be played on your browser": "ÐÐ¸Ð´ÐµÐ¾ÑÐ¾ Ðµ Ð¿Ð¾Ð²ÑÐµÐ´ÐµÐ½Ð¾ Ð¸Ð»Ð¸ Ð²ÑÐ² ÑÐ¾ÑÐ¼Ð°Ñ, ÐºÐ¾Ð¹ÑÐ¾ Ð½Ðµ Ð¼Ð¾Ð¶Ðµ Ð´Ð° ÑÐµ Ð²ÑÐ·Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð° Ð² Ð±ÑÐ°ÑÐ·ÑÑÐ° Ð²Ð¸",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "ÐÑÐ·Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð°Ð½ÐµÑÐ¾ Ð½Ð° Ð²Ð¸Ð´ÐµÐ¾ÑÐ¾ Ð±ÐµÑÐµ Ð¿ÑÐµÐºÑÐ°ÑÐµÐ½Ð¾ Ð¿Ð¾ÑÐ°Ð´Ð¸ Ð¿Ð¾Ð²ÑÐµÐ´Ð° Ð¸Ð»Ð¸ Ð·Ð°ÑÐ¾ÑÐ¾ Ð²Ð¸Ð´ÐµÐ¾ÑÐ¾ Ð¸Ð·Ð¿Ð¾Ð»Ð·Ð²Ð° ÑÑÐ½ÐºÑÐ¸Ð¸, ÐºÐ¾Ð¸ÑÐ¾ Ð½Ðµ ÑÐµ Ð¿Ð¾Ð´Ð´ÑÑÐ¶Ð°Ñ Ð¾Ñ Ð±ÑÐ°ÑÐ·ÑÑÑÑ Ð²Ð¸.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "ÐÐ¸Ð´ÐµÐ¾ÑÐ¾, ÐºÐ¾ÐµÑÐ¾ ÑÐµ Ð¾Ð¿Ð¸ÑÐ²Ð°ÑÐµ Ð´Ð° Ð³Ð»ÐµÐ´Ð°ÑÐµ, Ðµ ÐºÑÐ¸Ð¿ÑÐ¸ÑÐ°Ð½Ð¾ Ð¸ Ð½Ð¸Ðµ Ð½Ðµ Ð·Ð½Ð°ÐµÐ¼ ÐºÐ°Ðº Ð´Ð° Ð³Ð¾ Ð´ÐµÑÐ¸ÑÑÐ¸ÑÐ°Ð¼Ðµ",
		"This content is not available for your package or region.": "Ð¡ÑÐ´ÑÑÐ¶Ð°Ð½Ð¸ÐµÑÐ¾ Ð½Ðµ Ðµ Ð½Ð°Ð»Ð¸ÑÐ½Ð¾ Ð·Ð° Ð²Ð°ÑÐ¸Ñ Ð¿Ð°ÐºÐµÑ Ð¸Ð»Ð¸ ÑÐµÐ³Ð¸Ð¾Ð½.",
		"This video is either unavailable or not supported in this browser": "ÐÐ¸Ð´ÐµÐ¾ÑÐ¾ Ð¸Ð»Ð¸ Ð½Ðµ Ðµ Ð½Ð°Ð»Ð¸ÑÐ½Ð¾, Ð¸Ð»Ð¸ Ð½Ðµ ÑÐµ Ð¿Ð¾Ð´Ð´ÑÑÐ¶Ð° Ð¾Ñ ÑÐ¾Ð·Ð¸ Ð±ÑÐ°ÑÐ·ÑÑ",
		"This video is unavailable": "ÐÐ¸Ð´ÐµÐ¾ÑÐ¾ Ð½Ðµ Ðµ Ð½Ð°Ð»Ð¸ÑÐ½Ð¾.",
		To: To$s,
		Transparent: Transparent$s,
		Uniform: Uniform$s,
		Unmute: Unmute$s,
		Unmuted: Unmuted$s,
		"Up Next": "Ð¡Ð»ÐµÐ´Ð²Ð°",
		"Video has expired.": "ÐÐ¸Ð´ÐµÐ¾ÑÐ¾ Ðµ Ð¸Ð·ÑÐµÐºÐ»Ð¾.",
		"Video is not available in your country.": "ÐÐ¸Ð´ÐµÐ¾ÑÐ¾ Ð½Ðµ Ðµ Ð½Ð°Ð»Ð¸ÑÐ½Ð¾ Ð²ÑÐ² Ð²Ð°ÑÐ°ÑÐ° ÑÑÑÐ°Ð½Ð°.",
		"Video is not yet available.": "ÐÐ¸Ð´ÐµÐ¾ÑÐ¾ Ð²ÑÐµ Ð¾ÑÐµ Ð½Ðµ Ðµ Ð½Ð°Ð»Ð¸ÑÐ½Ð¾.",
		"Video Player": "ÐÐ¸Ð´ÐµÐ¾ Ð¿Ð»ÐµÑÑ",
		Watch: Watch$s,
		"WATCH NOW": "ÐÐÐÐÐÐ Ð¡ÐÐÐ",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Ð¡ÑÐ¶Ð°Ð»ÑÐ²Ð°Ð¼Ðµ, Ð½Ð¾ ÑÐ¾Ð·Ð¸ Ð±ÑÐ°ÑÐ·ÑÑ Ð²ÐµÑÐµ Ð½Ðµ ÑÐµ Ð¿Ð¾Ð´Ð´ÑÑÐ¶Ð°. ÐÐ¾Ð»Ñ, Ð¸Ð½ÑÑÐ°Ð»Ð¸ÑÐ°Ð¹ÑÐµ Ð½Ð°Ð¹-Ð½Ð¾Ð²Ð°ÑÐ° Ð²ÐµÑÑÐ¸Ñ Ð½Ð° Google Chrome, FireFox Ð¸Ð»Ð¸ Microsoft Edge, Ð·Ð° Ð´Ð° Ð³Ð»ÐµÐ´Ð°ÑÐµ ÑÐ¾Ð²Ð° ÑÑÐ´ÑÑÐ¶Ð°Ð½Ð¸Ðµ.",
		White: White$s,
		Window: Window$s,
		Yellow: Yellow$s,
		"You aborted the media playback": "ÐÑÐµÐºÑÑÐ½Ð°ÑÑÐµ Ð²ÑÐ·Ð¿ÑÐ¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð°Ð½ÐµÑÐ¾ Ð½Ð° Ð²Ð¸Ð´ÐµÐ¾",
		"elapsed out of": "ÐÐ·Ð¼Ð¸Ð½Ð°Ð»Ð¾ Ð²ÑÐµÐ¼Ðµ Ð¾Ñ"
	};

	var Ad$r = "Reklama";
	var Autoplay$r = "AutomatickÃ© pÅehrÃ¡vÃ¡nÃ­";
	var Background$r = "PozadÃ­";
	var Black$r = "ÄernÃ¡";
	var Blue$r = "ModrÃ¡";
	var Button$r = "TlaÄÃ­tko";
	var Captions$r = "SkrytÃ© titulky";
	var Casual$r = "NenÃ¡roÄnÃ©";
	var Chapters$r = "Kapitoly";
	var Copied$r = "ZkopÃ­rovÃ¡no";
	var Copy$r = "KopÃ­rovat";
	var Cyan$r = "ModrozelenÃ¡";
	var Default$r = "VÃ½chozÃ­";
	var Depressed$r = "Deprese";
	var Done$r = "Hotovo";
	var DRM_REQUIRED$r = "";
	var Email$r = "E-mail";
	var EMBARGOED$r = "";
	var EXPIRED$r = "";
	var EXPIRED_CONTENT$r = "";
	var Foreground$r = "PopÅedÃ­";
	var From$r = "Od";
	var Fullscreen$r = "CelÃ¡ obrazovka";
	var GEOLOCATION_NOT_ALLOWED$r = "";
	var Green$r = "ZelenÃ¡";
	var hour$r = "hod.";
	var hours$r = "hod.";
	var LIVE$r = "Å½IVÄ";
	var Loaded$r = "NaÄteno";
	var Magenta$r = "ÄervenorudÃ¡";
	var Menu$r = "NabÃ­dka";
	var Message$r = "ZprÃ¡va";
	var minute$r = "min.";
	var minutes$r = "min.";
	var More$r = "DalÅ¡Ã­";
	var Mute$r = "Ztlumit";
	var NOT_FOUND$r = "";
	var None$r = "Nic";
	var OK$r = "OK";
	var Opaque$r = "NeprÅ¯hlednÃ©";
	var Pause$r = "Pozastavit";
	var Pausing$r = "PozastavenÃ­";
	var Play$r = "PÅehrÃ¡t";
	var Playing$r = "PÅehrÃ¡vÃ¡nÃ­";
	var Progress$r = "Postup";
	var Purchased$r = "Zakoupeno";
	var Raised$r = "VybrÃ¡no";
	var Red$r = "ÄervenÃ¡";
	var Replay$r = "Opakovat";
	var Rewind$r = "PÅetoÄit zpÄt";
	var Script$r = "Skript";
	var second$r = "sek.";
	var seconds$r = "sek.";
	var Send$r = "Odeslat";
	var Settings$r = "NastavenÃ­";
	var Share$r = "SdÃ­let";
	var Stop$r = "Stop";
	var STREAM_LIMITED$r = "";
	var STREAM_LIMIT_ERROR$r = "";
	var Subtitles$r = "Titulky";
	var To$r = "Na";
	var Transparent$r = "PrÅ¯hlednÃ©";
	var Uniform$r = "UniformnÃ­";
	var Unmute$r = "ZruÅ¡it ztlumenÃ­";
	var Unmuted$r = "ZruÅ¡eno ztlumenÃ­";
	var Watch$r = "Sledovat";
	var White$r = "BÃ­lÃ¡";
	var Window$r = "Okno";
	var Yellow$r = "Å½lutÃ¡";
	var cs = {
		"A network error caused the media download to fail part-way.": "StahovÃ¡nÃ­ videa bylo kvÅ¯li sÃ­Å¥ovÃ© chybÄ pÅeruÅ¡eno.",
		Ad: Ad$r,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "BÄhem pÅehrÃ¡vÃ¡nÃ­ videa doÅ¡lo k chybÄ, nejspÃ­Å¡ kvÅ¯li pÅipojenÃ­ k sÃ­ti nebo kvÅ¯li tomu, Å¾e se pÅehrÃ¡valo v zÃ¡loÅ¾ce prohlÃ­Å¾eÄe na pozadÃ­. Zkuste to znovu.",
		"An unanticipated problem was encountered, check back soon and try again": "",
		"Audio Options": "NastavenÃ­ zvuku",
		Autoplay: Autoplay$r,
		"Back to video": "ZpÄt na video",
		"Close share": "Close share",
		Background: Background$r,
		Black: Black$r,
		Blue: Blue$r,
		Button: Button$r,
		"Buy PPV": "Koupit PPV",
		"com.espn.watch.api.AccessDeniedException": "",
		"Caption Settings": "NastavenÃ­ skrytÃ½ch titulkÅ¯",
		Captions: Captions$r,
		"captions off": "skrytÃ© titulky vypnutÃ©",
		"Captions Preview": "NÃ¡hled skrytÃ½ch titulkÅ¯",
		Casual: Casual$r,
		Chapters: Chapters$r,
		"Check out this video on ESPN": "PodÃ­vejte se na toto video na ESPN",
		"Choose Broadcast": "Vybrat vysÃ­lÃ¡nÃ­",
		"Choose TV Provider": "Vybrat poskytovatele TV",
		"Closed Caption": "Titulky pro neslyÅ¡Ã­cÃ­",
		"Closed Captions": "Titulky pro neslyÅ¡Ã­cÃ­",
		Copied: Copied$r,
		Copy: Copy$r,
		"Copy Embed Link": "ZkopÃ­rovat odkaz pro vloÅ¾enÃ­",
		"Copy Link": "ZkopÃ­rovat odkaz",
		"Could not download the video": "",
		"Current Time": "AktuÃ¡lnÃ­ Äas",
		"currently behind live": "aktuÃ¡lnÄ za Å¾ivÃ½m pÅenosem",
		Cyan: Cyan$r,
		Default: Default$r,
		Depressed: Depressed$r,
		Done: Done$r,
		DRM_REQUIRED: DRM_REQUIRED$r,
		"Drop shadow": "StÃ­n",
		"Duration Time": "DÃ©lka",
		Email: Email$r,
		"Email Video": "Poslat video e-mailem",
		EMBARGOED: EMBARGOED$r,
		"Embed Code": "VloÅ¾it kÃ³d",
		"Error Code": "KÃ³d chyby",
		"Exit Full Screen": "UkonÄit celou obrazovku",
		EXPIRED: EXPIRED$r,
		EXPIRED_CONTENT: EXPIRED_CONTENT$r,
		"Fast Forward": "PÅetoÄit vpÅed",
		"Font Family": "Skupina fontu",
		"Font Size": "Velikost fontu",
		Foreground: Foreground$r,
		From: From$r,
		Fullscreen: Fullscreen$r,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$r,
		"Get ESPN+": "ZÃ­skat ESPN+",
		"Get MLB.TV": "ZÃ­skat MLB.TV",
		Green: Green$r,
		hour: hour$r,
		hours: hours$r,
		"Language Settings": "NastavenÃ­ jazyka",
		"Learn More": "Podrobnosti",
		LIVE: LIVE$r,
		Loaded: Loaded$r,
		"Logged Into TV Provider": "PÅihlÃ¡Å¡eno k poskytovateli TV",
		Magenta: Magenta$r,
		Menu: Menu$r,
		Message: Message$r,
		minute: minute$r,
		minutes: minutes$r,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$r,
		Mute: Mute$r,
		NOT_FOUND: NOT_FOUND$r,
		"No compatible source was found for this media.": "Pro toto video nebyl nalezen kompatibilnÃ­ zdroj.",
		"No video has been loaded": "Å½Ã¡dnÃ© video nebylo naÄteno",
		"Non-Fullscreen": "",
		None: None$r,
		"Now Playing": "NynÃ­ hraje",
		OK: OK$r,
		Opaque: Opaque$r,
		Pause: Pause$r,
		Pausing: Pausing$r,
		Play: Play$r,
		"Playback Rate": "MÃ­ra pÅehrÃ¡vÃ¡nÃ­",
		"Playback Speed": "Rychlost pÅehrÃ¡vÃ¡nÃ­",
		Playing: Playing$r,
		"please confirm you are connected to the internet": "potvrÄte, Å¾e jste pÅipojeni k internetu",
		Progress: Progress$r,
		"Proportional Sans-Serif": "ProporÄnÃ­ Sans-Serif",
		"Proportional Serif": "ProporÄnÃ­ Serif",
		Purchased: Purchased$r,
		Raised: Raised$r,
		Red: Red$r,
		"Remaining Time": "ZbÃ½vajÃ­cÃ­ Äas",
		Replay: Replay$r,
		"Reset to Defaults": "Obnovit vÃ½chozÃ­",
		Rewind: Rewind$r,
		Script: Script$r,
		second: second$r,
		seconds: seconds$r,
		"Seek to live": "Vyhledat Å¾ivÄ",
		"Seek to live, currently playing live": "Vyhledat Å¾ivÄ, aktuÃ¡lnÄ hraje Å¾ivÄ",
		"Select Broadcast": "Vybrat vysÃ­lÃ¡nÃ­",
		"Semi-Opaque": "PoloprÅ¯hlednÃ©",
		"Semi-Transparent": "PoloprÅ¯hlednÃ©",
		Send: Send$r,
		Settings: Settings$r,
		Share: Share$r,
		"Skip Ad": "PÅeskoÄit reklamu",
		"Small Caps": "MalÃ¡ pÃ­smena",
		"Start at": "ZaÄÃ­t na",
		Stop: Stop$r,
		STREAM_LIMITED: STREAM_LIMITED$r,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$r,
		"Stream Type": "Typ streamu",
		"Subscribed to ESPN+": "PÅedplacenÃ© ESPN+",
		Subtitles: Subtitles$r,
		"subtitles off": "titulky vypnutÃ©",
		"Technical details": "TechnickÃ© detaily",
		"Text Edge Style": "Styl okraje textu",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Na vaÅ¡em ÃºÄtu bylo dosaÅ¾eno maximÃ¡lnÃ­ho poÄtu soubÄÅ¾nÃ½ch streamÅ¯. Pokud mÃ¡te nÄjakÃ© otÃ¡zky nebo potÅebujete pomoc, navÅ¡tivtees.pn/watchfaq nebo volejte 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "MÃ©dia nelze naÄÃ­st buÄ kvÅ¯li chybÄ serveru nebo sÃ­tÄ, nebo kvÅ¯li nepodporovanÃ©mu formÃ¡tu.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "",
		"The video connection was lost": "PÅipojenÃ­ k videu bylo pÅeruÅ¡eno",
		"The video download was cancelled": "StahovÃ¡nÃ­ videa bylo zruÅ¡eno",
		"The video is bad or in a format that cannot be played on your browser": "Video je poÅ¡kozenÃ© nebo ve formÃ¡tu, kterÃ½ ve vaÅ¡em prohlÃ­Å¾eÄi nelze pÅehrÃ¡t",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "PÅehrÃ¡vÃ¡nÃ­ videa bylo pÅeruÅ¡eno kvÅ¯li poÅ¡kozenÃ­ nebo kvÅ¯li tomu, Å¾e video pouÅ¾Ã­vÃ¡ funkce, kterÃ© vÃ¡Å¡ prohlÃ­Å¾eÄ nepodporuje.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Video, kterÃ© se snaÅ¾Ã­te pÅehrÃ¡t, je Å¡ifrovanÃ© a my ho neumÃ­me deÅ¡ifrovat.",
		"This content is not available for your package or region.": "Tento obsah nenÃ­ dostupnÃ½ pro vÃ¡Å¡ balÃ­Äek Äi vÃ¡Å¡ region.",
		"This video is either unavailable or not supported in this browser": "Toto video je buÄ nedostupnÃ©, nebo ho tento prohlÃ­Å¾eÄ nepodporuje",
		"This video is unavailable": "Toto video je nedostupnÃ©",
		To: To$r,
		Transparent: Transparent$r,
		Uniform: Uniform$r,
		Unmute: Unmute$r,
		Unmuted: Unmuted$r,
		"Up Next": "DalÅ¡Ã­",
		"Video has expired.": "Video vyprÅ¡elo.",
		"Video is not available in your country.": "Video nenÃ­ dostupnÃ© ve vaÅ¡Ã­ zemi.",
		"Video is not yet available.": "Video jeÅ¡tÄ nenÃ­ dostupnÃ©.",
		"Video Player": "Video pÅehrÃ¡vaÄ",
		Watch: Watch$r,
		"WATCH NOW": "SLEDOVAT",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Je nÃ¡m lÃ­to, ale tento prohlÃ­Å¾eÄ uÅ¾ nenÃ­ podporovÃ¡n. PÅejdÄte prosÃ­m na nejnovÄjÅ¡Ã­ verzi Google Chrome, FireFox Äi Microsoft Edge, abyste tento obsah mohli sledovat.",
		White: White$r,
		Window: Window$r,
		Yellow: Yellow$r,
		"You aborted the media playback": "PÅeruÅ¡ili jste pÅehrÃ¡vÃ¡nÃ­ videa",
		"elapsed out of": "uplynulo z"
	};

	var Ad$q = "Reklame";
	var Autoplay$q = "Autoafspilning";
	var Background$q = "Baggrund";
	var Black$q = "Sort";
	var Blue$q = "BlÃ¥";
	var Button$q = "Knap";
	var Captions$q = "Undertekster";
	var Casual$q = "Let";
	var Chapters$q = "Kapitler";
	var Copied$q = "Kopieret";
	var Copy$q = "Kopier";
	var Cyan$q = "CyanblÃ¥";
	var Default$q = "Standard";
	var Depressed$q = "Trykket ned";
	var Done$q = "FÃ¦rdig";
	var DRM_REQUIRED$q = "DRM_REQUIRED";
	var Email$q = "E-mail";
	var EMBARGOED$q = "EMBARGOED";
	var EXPIRED$q = "EXPIRED";
	var EXPIRED_CONTENT$q = "EXPIRED_CONTENT";
	var Foreground$q = "Forgrund";
	var From$q = "Fra";
	var Fullscreen$q = "Fuld skÃ¦rm";
	var GEOLOCATION_NOT_ALLOWED$q = "GEOLOCATION_NOT_ALLOWED";
	var Green$q = "GrÃ¸n";
	var hour$q = "time";
	var hours$q = "timer";
	var LIVE$q = "LIVE";
	var Loaded$q = "IndlÃ¦st";
	var Magenta$q = "Magenta";
	var Menu$q = "Menu";
	var Message$q = "Meddelelse";
	var minute$q = "minut";
	var minutes$q = "minutter";
	var More$q = "Mere";
	var Mute$q = "DeaktivÃ©r lyd";
	var NOT_FOUND$q = "NOT_FOUND";
	var None$q = "Ingen";
	var OK$q = "Okay";
	var Opaque$q = "Uigennemsigtig";
	var Pause$q = "Pause";
	var Pausing$q = "SÃ¦tter pÃ¥ pause";
	var Play$q = "Afspil";
	var Playing$q = "Afspiller";
	var Progress$q = "Afspillet";
	var Purchased$q = "KÃ¸bt";
	var Raised$q = "HÃ¦vet";
	var Red$q = "RÃ¸d";
	var Replay$q = "Afspil igen";
	var Rewind$q = "Spol tilbage";
	var Script$q = "Script";
	var second$q = "sekund";
	var seconds$q = "sekunder";
	var Send$q = "Send";
	var Settings$q = "Indstillinger";
	var Share$q = "Del";
	var Stop$q = "Stop";
	var STREAM_LIMITED$q = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$q = "STREAM_LIMIT_ERROR";
	var Subtitles$q = "Undertekster";
	var To$q = "Til";
	var Transparent$q = "Gennemsigtig";
	var Uniform$q = "Ensartet";
	var Unmute$q = "AktivÃ©r lyd";
	var Unmuted$q = "Lyd aktiveret";
	var Watch$q = "Se";
	var White$q = "Hvid";
	var Window$q = "Vindue";
	var Yellow$q = "Gul";
	var da = {
		"A network error caused the media download to fail part-way.": "En netvÃ¦rksfejl afbrÃ¸d download af video.",
		Ad: Ad$q,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Der opstod en fejl under afspilning af videoen. Dette skyldes muligvis en netvÃ¦rksfejl, eller at videoen er placeret pÃ¥ en browserfane, der kÃ¸rer i baggrunden.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Lydindstillinger",
		Autoplay: Autoplay$q,
		"Back to video": "Tilbage til video",
		Background: Background$q,
		"Close share": "Close share",
		Black: Black$q,
		Blue: Blue$q,
		Button: Button$q,
		"Buy PPV": "KÃ¸b PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Undertekstindstillinger",
		Captions: Captions$q,
		"captions off": "undertekster slÃ¥et fra",
		"Captions Preview": "ForhÃ¥ndsvisning af undertekster",
		Casual: Casual$q,
		Chapters: Chapters$q,
		"Check out this video on ESPN": "Se denne video pÃ¥ ESPN",
		"Choose Broadcast": "VÃ¦lg udsendelse",
		"Choose TV Provider": "VÃ¦lg TV-udbyder",
		"Closed Caption": "Undertekst",
		"Closed Captions": "Undertekster",
		Copied: Copied$q,
		Copy: Copy$q,
		"Copy Embed Link": "Kopier link til indlejring",
		"Copy Link": "Kopier link",
		"Could not download the video": "Could not download the video",
		"Current Time": "Tidspunkt",
		"currently behind live": "vises med forsinkelse",
		Cyan: Cyan$q,
		Default: Default$q,
		Depressed: Depressed$q,
		Done: Done$q,
		DRM_REQUIRED: DRM_REQUIRED$q,
		"Drop shadow": "Dropskygge",
		"Duration Time": "Varighed",
		Email: Email$q,
		"Email Video": "Send video via e-mail",
		EMBARGOED: EMBARGOED$q,
		"Embed Code": "Indlejringskode",
		"Error Code": "Fejlkode",
		"Exit Full Screen": "Forlad fuld skÃ¦rm",
		EXPIRED: EXPIRED$q,
		EXPIRED_CONTENT: EXPIRED_CONTENT$q,
		"Fast Forward": "Spol frem",
		"Font Family": "Font",
		"Font Size": "FontstÃ¸rrelse",
		Foreground: Foreground$q,
		From: From$q,
		Fullscreen: Fullscreen$q,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$q,
		"Get ESPN+": "FÃ¥ ESPN+",
		"Get MLB.TV": "FÃ¥ MLB.TV",
		Green: Green$q,
		hour: hour$q,
		hours: hours$q,
		"Language Settings": "Sprogindstillinger",
		"Learn More": "LÃ¦s mere",
		LIVE: LIVE$q,
		Loaded: Loaded$q,
		"Logged Into TV Provider": "Logget ind pÃ¥ TV-udbyder",
		Magenta: Magenta$q,
		Menu: Menu$q,
		Message: Message$q,
		minute: minute$q,
		minutes: minutes$q,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$q,
		Mute: Mute$q,
		NOT_FOUND: NOT_FOUND$q,
		"No compatible source was found for this media.": "Kunne ikke finde en kompatibel kilde til videoen.",
		"No video has been loaded": "Ingen video er blevet indlÃ¦st",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$q,
		"Now Playing": "Afspiller",
		OK: OK$q,
		Opaque: Opaque$q,
		Pause: Pause$q,
		Pausing: Pausing$q,
		Play: Play$q,
		"Playback Rate": "Afspilningshastighed",
		"Playback Speed": "Afspilningshastighed",
		Playing: Playing$q,
		"please confirm you are connected to the internet": "tjek, om du har forbindelse til internettet",
		Progress: Progress$q,
		"Proportional Sans-Serif": "Proportionel Sans-Serif",
		"Proportional Serif": "Proportionel Serif",
		Purchased: Purchased$q,
		Raised: Raised$q,
		Red: Red$q,
		"Remaining Time": "Tid tilbage",
		Replay: Replay$q,
		"Reset to Defaults": "Nulstil til standard",
		Rewind: Rewind$q,
		Script: Script$q,
		second: second$q,
		seconds: seconds$q,
		"Seek to live": "GÃ¥ til live",
		"Seek to live, currently playing live": "GÃ¥ til live, afspiller live",
		"Select Broadcast": "VÃ¦lg udsendelse",
		"Semi-Opaque": "Delvis uigennemsigtig",
		"Semi-Transparent": "Delvis gennemsigtig",
		Send: Send$q,
		Settings: Settings$q,
		Share: Share$q,
		"Skip Ad": "Spring over",
		"Small Caps": "SmÃ¥ bogstaver",
		"Start at": "Begynd ved",
		Stop: Stop$q,
		STREAM_LIMITED: STREAM_LIMITED$q,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$q,
		"Stream Type": "Streamtype",
		"Subscribed to ESPN+": "Abonnerer pÃ¥ ESPN+",
		Subtitles: Subtitles$q,
		"subtitles off": "undertekster slÃ¥et fra",
		"Technical details": "Tekniske oplysninger",
		"Text Edge Style": "Tekstkanten",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Du har nÃ¥et det maksimale antal sidelÃ¸bende streams pÃ¥ din konto. Hvis du har spÃ¸rgsmÃ¥l eller har brug for hjÃ¦lp, kan du gÃ¥ til es.pn/watchfaq eller ringe til 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Medieindholdet kunne ikke indlÃ¦ses. Dette skyldes enten en netvÃ¦rksfejl eller et ikke-understÃ¸ttet format.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "Videoforbindelsen gik tabt",
		"The video download was cancelled": "Download af videoen blev annulleret",
		"The video is bad or in a format that cannot be played on your browser": "Videoen er i dÃ¥rlig kvalitet eller i et format, som ikke kan afspilles i din browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Afspilning af videoen blev afbrudt pÃ¥ grund af korruption, eller fordi videoen benytter sig af funktioner, som din browser ikke understÃ¸tter.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Den valgte video er krypteret, og vi ved ikke, hvordan man dekrypterer den",
		"This content is not available for your package or region.": "Indholdet er ikke tilgÃ¦ngeligt i din pakke eller region.",
		"This video is either unavailable or not supported in this browser": "Videoen er enten ikke tilgÃ¦ngelig eller understÃ¸ttes ikke af din browser.",
		"This video is unavailable": "Denne video er ikke tilgÃ¦ngelig.",
		To: To$q,
		Transparent: Transparent$q,
		Uniform: Uniform$q,
		Unmute: Unmute$q,
		Unmuted: Unmuted$q,
		"Up Next": "NÃ¦ste",
		"Video has expired.": "Videoen er udlÃ¸bet.",
		"Video is not available in your country.": "Videoen er ikke tilgÃ¦ngelig i dit land.",
		"Video is not yet available.": "Videoen er ikke tilgÃ¦ngelig endnu.",
		"Video Player": "Videoafspiller",
		Watch: Watch$q,
		"WATCH NOW": "Se nu",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Vi beklager, men denne browser understÃ¸ttes ikke lÃ¦ngere. OpdatÃ©r venligst til den nyeste version af Google Chrome, FireFox eller Microsoft Edge for at se indholdet.",
		White: White$q,
		Window: Window$q,
		Yellow: Yellow$q,
		"You aborted the media playback": "Du forlod videoafspilningen",
		"elapsed out of": "vist ud af"
	};

	var Ad$p = "Werbung";
	var Autoplay$p = "Autom. abspielen";
	var Background$p = "Hintergrund";
	var Black$p = "Schwarz";
	var Blue$p = "Blau";
	var Button$p = "SchaltflÃ¤che";
	var Captions$p = "Untertitel";
	var Casual$p = "Zwanglos";
	var Chapters$p = "Kapitel";
	var Copied$p = "Kopiert";
	var Copy$p = "Kopieren";
	var Cyan$p = "Cyan";
	var Default$p = "Standard";
	var Depressed$p = "GedrÃ¼ckt";
	var Done$p = "Fertig";
	var DRM_REQUIRED$p = "DRM_REQUIRED";
	var Email$p = "E-Mail";
	var EMBARGOED$p = "EMBARGOED";
	var EXPIRED$p = "EXPIRED";
	var EXPIRED_CONTENT$p = "EXPIRED_CONTENT";
	var Foreground$p = "Vordergrund";
	var From$p = "Von";
	var Fullscreen$p = "Vollbild";
	var GEOLOCATION_NOT_ALLOWED$p = "GEOLOCATION_NOT_ALLOWED";
	var Green$p = "GrÃ¼n";
	var hour$p = "Stunde";
	var hours$p = "Stunden";
	var LIVE$p = "LIVE";
	var Loaded$p = "Geladen";
	var Magenta$p = "Magenta";
	var Menu$p = "MenÃ¼";
	var Message$p = "Nachricht";
	var minute$p = "Minute";
	var minutes$p = "Minuten";
	var More$p = "Mehr";
	var Mute$p = "Stumm";
	var NOT_FOUND$p = "NOT_FOUND";
	var None$p = "Keine";
	var OK$p = "OK";
	var Opaque$p = "Undurchsichtig";
	var Pause$p = "Pause";
	var Pausing$p = "Wird pausiert";
	var Play$p = "Abspielen";
	var Playing$p = "Wird abgespielt";
	var Progress$p = "Fortschritt";
	var Purchased$p = "Gekauft";
	var Raised$p = "ErhÃ¶ht";
	var Red$p = "Rot";
	var Replay$p = "Wiederholung";
	var Rewind$p = "ZurÃ¼ckspulen";
	var Script$p = "Text";
	var second$p = "Sekunde";
	var seconds$p = "Sekunden";
	var Send$p = "Senden";
	var Settings$p = "Einstellungen";
	var Share$p = "Teilen";
	var Stop$p = "Stoppen";
	var STREAM_LIMITED$p = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$p = "STREAM_LIMIT_ERROR";
	var Subtitles$p = "Untertitel";
	var To$p = "An";
	var Transparent$p = "Transparent";
	var Uniform$p = "Uniform";
	var Unmute$p = "Stummschaltung aufheben";
	var Unmuted$p = "Stummschaltung aufgehoben";
	var Watch$p = "Ansehen";
	var White$p = "WeiÃ";
	var Window$p = "Fenster";
	var Yellow$p = "Gelb";
	var de = {
		"A network error caused the media download to fail part-way.": "Aufgrund eines Netzwerkfehlers ist das Herunterladen des Videos teilweise fehlgeschlagen.",
		Ad: Ad$p,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Beim Abspielen des Videos ist ein Fehler aufgetretenÂ â mÃ¶glicherweise aufgrund eingeschrÃ¤nkter Netzwerk-KonnektivitÃ¤t oder Abspielen in einem minimierten Browser-Tab. Bitte versuche es erneut.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio-Optionen",
		Autoplay: Autoplay$p,
		"Back to video": "ZurÃ¼ck zum Video",
		"Close share": "Close share",
		Background: Background$p,
		Black: Black$p,
		Blue: Blue$p,
		Button: Button$p,
		"Buy PPV": "PPV kaufen",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Untertitel-Einstellungen",
		Captions: Captions$p,
		"captions off": "Untertitel aus",
		"Captions Preview": "Untertitel-Voransicht",
		Casual: Casual$p,
		Chapters: Chapters$p,
		"Check out this video on ESPN": "Dieses Video auf ESPN ansehen",
		"Choose Broadcast": "Ãbertragung auswÃ¤hlen",
		"Choose TV Provider": "TV-Anbieter auswÃ¤hlen",
		"Closed Caption": "Geschlossener Untertitel",
		"Closed Captions": "Geschlossener Untertitel",
		Copied: Copied$p,
		Copy: Copy$p,
		"Copy Embed Link": "Eingebetteten Link kopieren",
		"Copy Link": "Link kopieren",
		"Could not download the video": "Could not download the video",
		"Current Time": "Aktuelle Zeit",
		"currently behind live": "aktuell nicht live",
		Cyan: Cyan$p,
		Default: Default$p,
		Depressed: Depressed$p,
		Done: Done$p,
		DRM_REQUIRED: DRM_REQUIRED$p,
		"Drop shadow": "Schlagschatten",
		"Duration Time": "Dauer",
		Email: Email$p,
		"Email Video": "Video per Mail versenden",
		EMBARGOED: EMBARGOED$p,
		"Embed Code": "Code einbetten",
		"Error Code": "Fehlercode",
		"Exit Full Screen": "Vollbild beenden",
		EXPIRED: EXPIRED$p,
		EXPIRED_CONTENT: EXPIRED_CONTENT$p,
		"Fast Forward": "Vorspulen",
		"Font Family": "Schriftart",
		"Font Size": "SchriftgrÃ¶Ãe",
		Foreground: Foreground$p,
		From: From$p,
		Fullscreen: Fullscreen$p,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$p,
		"Get ESPN+": "Hol dir ESPN+",
		"Get MLB.TV": "Hol dir MLB.TV",
		Green: Green$p,
		hour: hour$p,
		hours: hours$p,
		"Language Settings": "Spracheinstellungen",
		"Learn More": "Mehr erfahren",
		LIVE: LIVE$p,
		Loaded: Loaded$p,
		"Logged Into TV Provider": "Bei TV-Anbieter angemeldet",
		Magenta: Magenta$p,
		Menu: Menu$p,
		Message: Message$p,
		minute: minute$p,
		minutes: minutes$p,
		"Monospace Sans-Serif": "Monospace, ohne Serifen",
		"Monospace Serif": "Monospace, mit Serifen",
		More: More$p,
		Mute: Mute$p,
		NOT_FOUND: NOT_FOUND$p,
		"No compatible source was found for this media.": "FÃ¼r dieses Video wurde keine kompatible Quelle gefunden.",
		"No video has been loaded": "Es wurde kein Video geladen",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$p,
		"Now Playing": "Wird jetzt abgespielt",
		OK: OK$p,
		Opaque: Opaque$p,
		Pause: Pause$p,
		Pausing: Pausing$p,
		Play: Play$p,
		"Playback Rate": "Wiedergaberate",
		"Playback Speed": "Wiedergabegeschwindigkeit",
		Playing: Playing$p,
		"please confirm you are connected to the internet": "Bitte bestÃ¤tige, dass du mit dem Internet verbunden bist",
		Progress: Progress$p,
		"Proportional Sans-Serif": "Proportional, ohne Serifen",
		"Proportional Serif": "Proportional, mit Serifen",
		Purchased: Purchased$p,
		Raised: Raised$p,
		Red: Red$p,
		"Remaining Time": "Verbleibende Zeit",
		Replay: Replay$p,
		"Reset to Defaults": "Standard wiederherstellen",
		Rewind: Rewind$p,
		Script: Script$p,
		second: second$p,
		seconds: seconds$p,
		"Seek to live": "Live abspielen",
		"Seek to live, currently playing live": "Live abspielen, wird aktuell live abgespielt",
		"Select Broadcast": "Ãbertragung wÃ¤hlen",
		"Semi-Opaque": "Halb-undurchsichtig",
		"Semi-Transparent": "Halbtransparent",
		Send: Send$p,
		Settings: Settings$p,
		Share: Share$p,
		"Skip Ad": "Werbung Ã¼berspringen",
		"Small Caps": "KapitÃ¤lchen",
		"Start at": "Beginnen bei",
		Stop: Stop$p,
		STREAM_LIMITED: STREAM_LIMITED$p,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$p,
		"Stream Type": "Streaming-Art",
		"Subscribed to ESPN+": "ESPN+ abonniert",
		Subtitles: Subtitles$p,
		"subtitles off": "Untertitel aus",
		"Technical details": "Technische Details",
		"Text Edge Style": "Text-Kantenstil",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "FÃ¼r dein Konto wurde die maximal mÃ¶gliche Anzahl gleichzeitiger Streams erreicht. Falls du Fragen haben solltest oder UnterstÃ¼tzung benÃ¶tigst, besuche bitte es.pn/watchfaq oder rufe 888-549-ESPN an.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Medien konnten nicht geladen werden. Es gibt entweder einen Server- oder Netzwerkfehler oder das Format wird nicht unterstÃ¼tzt.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "Videoverbindung wurde getrennt",
		"The video download was cancelled": "Der Ladevorgang des Videos wurde abgebrochen",
		"The video is bad or in a format that cannot be played on your browser": "Das Video ist beschÃ¤digt oder das Format kann in deinem Browser nicht abgespielt werden",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Das Abspielen des Videos wurde entweder aufgrund eines beschÃ¤digten oder eines von deinem Browser nicht unterstÃ¼tzten Formats abgebrochen.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Das Video ist verschlÃ¼sselt und wir wissen nicht, wie es entschlÃ¼sselt werden kann",
		"This content is not available for your package or region.": "Dieser Inhalt ist fÃ¼r dein Paket oder deine Region nicht verfÃ¼gbar.",
		"This video is either unavailable or not supported in this browser": "Dieses Video ist entweder nicht verfÃ¼gbar oder wird in diesem Browser nicht unterstÃ¼tzt",
		"This video is unavailable": "Dieses Video ist nicht verfÃ¼gbar.",
		To: To$p,
		Transparent: Transparent$p,
		Uniform: Uniform$p,
		Unmute: Unmute$p,
		Unmuted: Unmuted$p,
		"Up Next": "Es folgt",
		"Video has expired.": "Das Video ist nicht mehr verfÃ¼gbar.",
		"Video is not available in your country.": "Das Video ist in deinem Land nicht verfÃ¼gbar.",
		"Video is not yet available.": "Das Video ist noch nicht verfÃ¼gbar.",
		"Video Player": "Video-Player",
		Watch: Watch$p,
		"WATCH NOW": "JETZT ANSEHEN",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Tut uns leid, dieser Browser wird nicht mehr unterstÃ¼tzt. Bitte aktualisiere auf die neueste Version von Google Chrome, FireFox oder Microsoft Edge, um diesen Inhalt ansehen zu kÃ¶nnen.",
		White: White$p,
		Window: Window$p,
		Yellow: Yellow$p,
		"You aborted the media playback": "Du hast das Abspielen des Videos abgebrochen",
		"elapsed out of": "vergangen von"
	};

	var Ad$o = "ÎÎ¹Î±ÏÎ®Î¼Î¹ÏÎ·";
	var Autoplay$o = "ÎÏÏÏÎ¼Î±ÏÎ· Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î®";
	var Background$o = "Î¦ÏÎ½ÏÎ¿";
	var Black$o = "ÎÎ±ÏÏÎ¿";
	var Blue$o = "ÎÏÎ»Îµ";
	var Button$o = "ÎÎ¿ÏÎ¼ÏÎ¯";
	var Captions$o = "Î¥ÏÏÏÎ¹ÏÎ»Î¿Î¹";
	var Casual$o = "ÎÎ±Î¸Î·Î¼ÎµÏÎ¹Î½Ï ÏÏÏÎ»";
	var Chapters$o = "ÎÎµÏÎ¬Î»Î±Î¹Î±";
	var Copied$o = "ÎÎ½ÏÎ¹Î³ÏÎ¬ÏÎ·ÎºÎµ";
	var Copy$o = "ÎÎ½ÏÎ¹Î³ÏÎ±ÏÎ®";
	var Cyan$o = "ÎÏÎ±Î½Ï";
	var Default$o = "Î ÏÎ¿ÎµÏÎ¹Î»Î¿Î³Î®";
	var Depressed$o = "Î Î±ÏÎ·Î¼Î­Î½Î¿";
	var Done$o = "ÎÎ½ÏÎ¬Î¾ÎµÎ¹";
	var DRM_REQUIRED$o = "DRM_REQUIRED";
	var Email$o = "Email";
	var EMBARGOED$o = "EMBARGOED";
	var EXPIRED$o = "EXPIRED";
	var EXPIRED_CONTENT$o = "EXPIRED_CONTENT";
	var Foreground$o = "Î ÏÎ¿ÏÎºÎ®Î½Î¹Î¿";
	var From$o = "ÎÏÏ";
	var Fullscreen$o = "Î Î»Î®ÏÎ·Ï Î¿Î¸ÏÎ½Î·";
	var GEOLOCATION_NOT_ALLOWED$o = "GEOLOCATION_NOT_ALLOWED";
	var Green$o = "Î ÏÎ¬ÏÎ¹Î½Î¿";
	var hour$o = "ÏÏÎ±";
	var hours$o = "ÏÏÎµÏ";
	var LIVE$o = "ÎÎ©ÎÎ¤ÎÎÎ";
	var Loaded$o = "Î¦Î¿ÏÏÏÎ¸Î·ÎºÎµ";
	var Magenta$o = "ÎÎ±ÏÎ¶Î­Î½ÏÎ±";
	var Menu$o = "ÎÎµÎ½Î¿Ï";
	var Message$o = "ÎÎ®Î½ÏÎ¼Î±";
	var minute$o = "Î»ÎµÏÏÏ";
	var minutes$o = "Î»ÎµÏÏÎ¬";
	var More$o = "Î ÎµÏÎ¹ÏÏÏÏÎµÏÎ±";
	var Mute$o = "Î£Î¯Î³Î±ÏÎ·";
	var NOT_FOUND$o = "NOT_FOUND";
	var None$o = "ÎÎ±Î½Î­Î½Î±";
	var OK$o = "OK";
	var Opaque$o = "ÎÎ´Î¹Î±ÏÎ±Î½Î­Ï";
	var Pause$o = "Î Î±ÏÏÎ·";
	var Pausing$o = "Î Î±ÏÏÎ·";
	var Play$o = "ÎÎ½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î®";
	var Playing$o = "ÎÎ½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î® ÏÎµ ÎµÎ¾Î­Î»Î¹Î¾Î·";
	var Progress$o = "Î ÏÏÎ¿Î´Î¿Ï";
	var Purchased$o = "ÎÎ³Î¿ÏÎ¬ÏÏÎ·ÎºÎµ";
	var Raised$o = "ÎÎ½Î±ÏÎ·ÎºÏÎ¼Î­Î½Î¿";
	var Red$o = "ÎÏÎºÎºÎ¹Î½Î¿";
	var Replay$o = "ÎÏÎ±Î½Î¬Î»Î·ÏÎ· Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î®Ï";
	var Rewind$o = "ÎÏÎ±Î½Î±ÏÎ¿ÏÎ¬";
	var Script$o = "Script";
	var second$o = "Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ¿";
	var seconds$o = "Î´ÎµÏÏÎµÏÏÎ»ÎµÏÏÎ±";
	var Send$o = "ÎÏÎ¿ÏÏÎ¿Î»Î®";
	var Settings$o = "Î¡ÏÎ¸Î¼Î¯ÏÎµÎ¹Ï";
	var Share$o = "ÎÎ¿Î¹Î½Î® ÏÏÎ®ÏÎ·";
	var Stop$o = "ÎÎ¹Î±ÎºÎ¿ÏÎ®";
	var STREAM_LIMITED$o = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$o = "STREAM_LIMIT_ERROR";
	var Subtitles$o = "Î¥ÏÏÏÎ¹ÏÎ»Î¿Î¹";
	var To$o = "ÎÏÏ";
	var Transparent$o = "ÎÎ¹Î±ÏÎ±Î½Î­Ï";
	var Uniform$o = "ÎÎ½Î¹Î±Î¯Î¿";
	var Unmute$o = "ÎÎ±ÏÎ¬ÏÎ³Î·ÏÎ· ÏÎ¯Î³Î±ÏÎ·Ï";
	var Unmuted$o = "Î ÏÎ¯Î³Î±ÏÎ· ÎºÎ±ÏÎ±ÏÎ³Î®Î¸Î·ÎºÎµ";
	var Watch$o = "Î Î±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î®ÏÏÎµ";
	var White$o = "ÎÎµÏÎºÏ";
	var Window$o = "Î Î±ÏÎ¬Î¸ÏÏÎ¿";
	var Yellow$o = "ÎÎ¯ÏÏÎ¹Î½Î¿";
	var el = {
		"A network error caused the media download to fail part-way.": "Î Î»Î®ÏÎ· Î¿Î»ÏÎºÎ»Î·ÏÎ¿Ï ÏÎ¿Ï Î²Î¯Î½ÏÎµÎ¿ Î±ÏÎ­ÏÏÏÎµ Î»ÏÎ³Ï ÎºÎ¬ÏÎ¿Î¹Î¿Ï ÏÏÎ¬Î»Î¼Î±ÏÎ¿Ï Î´Î¹ÎºÏÏÎ¿Ï.",
		Ad: Ad$o,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Î ÏÎ¿Î­ÎºÏÏÎµ ÏÏÎ¬Î»Î¼Î± ÎºÎ±ÏÎ¬ ÏÎ· Î´Î¹Î¬ÏÎºÎµÎ¹Î± ÏÎ·Ï Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î®Ï ÏÎ¿Ï Î²Î¯Î½ÏÎµÎ¿, ÏÎ¹Î¸Î±Î½ÏÏ Î»ÏÎ³Ï ÏÎ·Ï ÏÏÎ½Î´ÎµÏÎ·Ï Î´Î¹ÎºÏÏÎ¿Ï Î® ÎµÏÎµÎ¹Î´Î® Î· Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î® ÏÏÎ±Î³Î¼Î±ÏÎ¿ÏÎ¿Î¹Î®Î¸Î·ÎºÎµ ÏÎµ ÎºÎ±ÏÏÎ­Î»Î± ÏÎ¿Ï ÏÏÎ¿Î³ÏÎ¬Î¼Î¼Î±ÏÎ¿Ï ÏÎµÏÎ¹Î®Î³Î·ÏÎ·Ï ÏÎ¿Ï ÎµÎ¯ÏÎµ ÏÎµÎ¸ÎµÎ¯ ÏÏÎ¿ ÏÎ±ÏÎ±ÏÎºÎ®Î½Î¹Î¿. ÎÎ¿ÎºÎ¹Î¼Î¬ÏÏÎµ Î¾Î±Î½Î¬.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "ÎÏÎ¹Î»Î¿Î³Î­Ï Î®ÏÎ¿Ï",
		Autoplay: Autoplay$o,
		"Back to video": "ÎÏÎ¹ÏÏÏÎ¿ÏÎ® ÏÏÎ¿ Î²Î¯Î½ÏÎµÎ¿",
		"Close share": "Close share",
		Background: Background$o,
		Black: Black$o,
		Blue: Blue$o,
		Button: Button$o,
		"Buy PPV": "ÎÎ³Î¿ÏÎ¬ PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Î¡ÏÎ¸Î¼Î¯ÏÎµÎ¹Ï ÏÏÎ¿ÏÎ¯ÏÎ»ÏÎ½",
		Captions: Captions$o,
		"captions off": "ÏÏÏÏÎ¹ÏÎ»Î¿Î¹ Î±Î½ÎµÎ½ÎµÏÎ³Î¿Î¯",
		"Captions Preview": "Î ÏÎ¿ÎµÏÎ¹ÏÎºÏÏÎ·ÏÎ· ÏÏÎ¿ÏÎ¯ÏÎ»ÏÎ½",
		Casual: Casual$o,
		Chapters: Chapters$o,
		"Check out this video on ESPN": "ÎÎµÎ¯ÏÎµ Î±ÏÏÏ ÏÎ¿ Î²Î¯Î½ÏÎµÎ¿ ÏÏÎ¿ ESPN",
		"Choose Broadcast": "ÎÏÎ¹Î»Î¿Î³Î® ÎµÎºÏÎ¿Î¼ÏÎ®Ï",
		"Choose TV Provider": "ÎÏÎ¹Î»Î¿Î³Î® ÏÎ·Î»ÎµÎ¿ÏÏÎ¹ÎºÎ¿Ï ÏÎ±ÏÏÏÎ¿Ï",
		"Closed Caption": "Î¥ÏÏÏÎ¹ÏÎ»Î¿Ï",
		"Closed Captions": "Î¥ÏÏÏÎ¹ÏÎ»Î¿Î¹",
		Copied: Copied$o,
		Copy: Copy$o,
		"Copy Embed Link": "ÎÎ½ÏÎ¹Î³ÏÎ±ÏÎ® ÏÏÎ½Î´Î­ÏÎ¼Î¿Ï ÎµÎ½ÏÏÎ¼Î¬ÏÏÏÎ·Ï",
		"Copy Link": "ÎÎ½ÏÎ¹Î³ÏÎ±ÏÎ® ÏÏÎ½Î´Î­ÏÎ¼Î¿Ï",
		"Could not download the video": "Could not download the video",
		"Current Time": "Î¤ÏÎ­ÏÏÎ½ ÏÏÏÎ½Î¿Ï",
		"currently behind live": "ÏÏÎ¿Ï ÏÎ¿ ÏÎ±ÏÏÎ½ ÏÏÎ¿Î»ÎµÎ¯ÏÎµÏÎ±Î¹ ÏÎ¿Ï Î¶ÏÎ½ÏÎ±Î½Î¿Ï ÏÎ®Î¼Î±ÏÎ¿Ï",
		Cyan: Cyan$o,
		Default: Default$o,
		Depressed: Depressed$o,
		Done: Done$o,
		DRM_REQUIRED: DRM_REQUIRED$o,
		"Drop shadow": "Î£ÎºÎ¯Î±ÏÎ·",
		"Duration Time": "ÎÎ¹Î¬ÏÎºÎµÎ¹Î±",
		Email: Email$o,
		"Email Video": "ÎÏÎ¿ÏÏÎ¿Î»Î® Î²Î¯Î½ÏÎµÎ¿ Î¼Îµ email",
		EMBARGOED: EMBARGOED$o,
		"Embed Code": "ÎÏÎ´Î¹ÎºÎ±Ï ÎµÎ½ÏÏÎ¼Î¬ÏÏÏÎ·Ï",
		"Error Code": "ÎÏÎ´Î¹ÎºÏÏ ÏÏÎ¬Î»Î¼Î±ÏÎ¿Ï",
		"Exit Full Screen": "ÎÎ¾Î¿Î´Î¿Ï Î±ÏÏ ÏÎ»Î®ÏÎ· Î¿Î¸ÏÎ½Î·",
		EXPIRED: EXPIRED$o,
		EXPIRED_CONTENT: EXPIRED_CONTENT$o,
		"Fast Forward": "ÎÏÎ®Î³Î¿ÏÎ· ÏÏÎ¿ÏÎ¸Î·ÏÎ·",
		"Font Family": "ÎÎ¹ÎºÎ¿Î³Î­Î½ÎµÎ¹Î± Î³ÏÎ±Î¼Î¼Î±ÏÎ¿ÏÎµÎ¹ÏÏÎ½",
		"Font Size": "ÎÎ­Î³ÎµÎ¸Î¿Ï Î³ÏÎ±Î¼Î¼Î±ÏÎ¿ÏÎµÎ¹ÏÎ¬Ï",
		Foreground: Foreground$o,
		From: From$o,
		Fullscreen: Fullscreen$o,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$o,
		"Get ESPN+": "ÎÎ®ÏÎ· ESPN+",
		"Get MLB.TV": "ÎÎ®ÏÎ· MLB.TV",
		Green: Green$o,
		hour: hour$o,
		hours: hours$o,
		"Language Settings": "Î¡ÏÎ¸Î¼Î¯ÏÎµÎ¹Ï Î³Î»ÏÏÏÎ±Ï",
		"Learn More": "ÎÎ¬Î¸ÎµÏÎµ ÏÎµÏÎ¹ÏÏÏÏÎµÏÎ±",
		LIVE: LIVE$o,
		Loaded: Loaded$o,
		"Logged Into TV Provider": "ÎÎ³Î¹Î½Îµ ÏÏÎ½Î´ÎµÏÎ· ÏÏÎ¿Î½ ÏÎ·Î»ÎµÎ¿ÏÏÎ¹ÎºÏ ÏÎ¬ÏÎ¿ÏÎ¿",
		Magenta: Magenta$o,
		Menu: Menu$o,
		Message: Message$o,
		minute: minute$o,
		minutes: minutes$o,
		"Monospace Sans-Serif": "Sans-Serif ÏÏÎ±Î¸ÎµÏÎ¿Ï ÏÎ»Î¬ÏÎ¿ÏÏ",
		"Monospace Serif": "Serif ÏÏÎ±Î¸ÎµÏÎ¿Ï ÏÎ»Î¬ÏÎ¿ÏÏ",
		More: More$o,
		Mute: Mute$o,
		NOT_FOUND: NOT_FOUND$o,
		"No compatible source was found for this media.": "ÎÎµÎ½ Î²ÏÎ­Î¸Î·ÎºÎµ ÏÏÎ¼Î²Î±ÏÎ® ÏÎ·Î³Î® Î³Î¹Î± Î±ÏÏÏ ÏÎ¿ Î²Î¯Î½ÏÎµÎ¿.",
		"No video has been loaded": "ÎÎµÎ½ Î­Î³Î¹Î½Îµ ÏÏÏÏÏÏÎ· Î²Î¯Î½ÏÎµÎ¿",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$o,
		"Now Playing": "ÎÎ½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î® ÏÏÏÎ±",
		OK: OK$o,
		Opaque: Opaque$o,
		Pause: Pause$o,
		Pausing: Pausing$o,
		Play: Play$o,
		"Playback Rate": "Î¡ÏÎ¸Î¼ÏÏ Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î®Ï",
		"Playback Speed": "Î¤Î±ÏÏÏÎ·ÏÎ± Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î®Ï",
		Playing: Playing$o,
		"please confirm you are connected to the internet": "Î²ÎµÎ²Î±Î¹ÏÎ¸ÎµÎ¯ÏÎµ ÏÏÎ¹ ÏÏÎ¬ÏÏÎµÎ¹ ÏÏÎ½Î´ÎµÏÎ· ÏÏÎ¿ Î´Î¹Î±Î´Î¯ÎºÏÏÎ¿",
		Progress: Progress$o,
		"Proportional Sans-Serif": "ÎÎ½Î±Î»Î¿Î³Î¹ÎºÎ® Sans-Serif",
		"Proportional Serif": "ÎÎ½Î±Î»Î¿Î³Î¹ÎºÎ® Serif",
		Purchased: Purchased$o,
		Raised: Raised$o,
		Red: Red$o,
		"Remaining Time": "Î¥ÏÏÎ»Î¿Î¹ÏÎ¿ ÏÏÏÎ½Î¿Ï",
		Replay: Replay$o,
		"Reset to Defaults": "ÎÏÎ±Î½Î±ÏÎ¿ÏÎ¬ ÏÏÎ¹Ï ÏÏÎ¿ÎµÏÎ¹Î»Î¿Î³Î­Ï",
		Rewind: Rewind$o,
		Script: Script$o,
		second: second$o,
		seconds: seconds$o,
		"Seek to live": "ÎÎµÏÎ¬Î²Î±ÏÎ· ÏÎµ Î¶ÏÎ½ÏÎ±Î½Ï ÏÎ®Î¼Î±",
		"Seek to live, currently playing live": "ÎÎµÏÎ¬Î²Î±ÏÎ· ÏÎµ Î¶ÏÎ½ÏÎ±Î½Ï ÏÎ®Î¼Î±, Î¶ÏÎ½ÏÎ±Î½Î® Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î® Î±ÏÏÎ®Î½ ÏÎ· ÏÏÎ¹Î³Î¼Î®",
		"Select Broadcast": "ÎÏÎ¹Î»Î¿Î³Î® ÎµÎºÏÎ¿Î¼ÏÎ®Ï",
		"Semi-Opaque": "ÎÎ¼Î¹Î±Î´Î¹Î±ÏÎ±Î½Î­Ï",
		"Semi-Transparent": "ÎÎ¼Î¹Î´Î¹Î±ÏÎ±Î½Î­Ï",
		Send: Send$o,
		Settings: Settings$o,
		Share: Share$o,
		"Skip Ad": "Î Î±ÏÎ¬Î»ÎµÎ¹ÏÎ· Î´Î¹Î±ÏÎ®Î¼Î¹ÏÎ·Ï",
		"Small Caps": "ÎÎ¹ÎºÏÎ¬ ÎºÎµÏÎ±Î»Î±Î¯Î±",
		"Start at": "ÎÎ½Î±ÏÎ¾Î· Î±ÏÏ",
		Stop: Stop$o,
		STREAM_LIMITED: STREAM_LIMITED$o,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$o,
		"Stream Type": "Î¤ÏÏÎ¿Ï ÏÎ¿Î®Ï",
		"Subscribed to ESPN+": "ÎÎ³Î¹Î½Îµ ÎµÎ³Î³ÏÎ±ÏÎ® ÏÏÎ¿ ESPN+",
		Subtitles: Subtitles$o,
		"subtitles off": "ÏÏÏÏÎ¹ÏÎ»Î¿Î¹ Î±Î½ÎµÎ½ÎµÏÎ³Î¿Î¯",
		"Technical details": "Î¤ÎµÏÎ½Î¹ÎºÎ­Ï Î»ÎµÏÏÎ¿Î¼Î­ÏÎµÎ¹ÎµÏ",
		"Text Edge Style": "Î£ÏÏÎ» ÏÎµÏÎ¹Î³ÏÎ¬Î¼Î¼Î±ÏÎ¿Ï ÎºÎµÎ¹Î¼Î­Î½Î¿Ï",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Î£ÏÎ¼ÏÎ»Î·ÏÏÎ¸Î·ÎºÎµ Î¿ Î¼Î­Î³Î¹ÏÏÎ¿Ï Î±ÏÎ¹Î¸Î¼ÏÏ ÏÎ±ÏÏÏÏÏÎ¿Î½ÏÎ½ ÏÎ¿ÏÎ½ Î³Î¹Î± ÏÎ¿Î½ Î»Î¿Î³Î±ÏÎ¹Î±ÏÎ¼Ï ÏÎ±Ï. ÎÎ¹Î± ÏÏÏÏÎ½ Î±ÏÎ¿ÏÎ¯ÎµÏ Î® ÎµÎ¬Î½ ÏÏÎµÎ¹Î¬Î¶ÎµÏÏÎµ Î²Î¿Î®Î¸ÎµÎ¹Î±, ÎµÏÎ¹ÏÎºÎµÏÏÎµÎ¯ÏÎµ ÏÎ¿ es.pn/watchfaq Î® ÎºÎ±Î»Î­ÏÏÎµ ÏÏÎ¿ 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "ÎÎµÎ½ Î®ÏÎ±Î½ Î´ÏÎ½Î±ÏÎ® Î· ÏÏÏÏÏÏÎ· ÏÎ¿Ï Î±ÏÏÎµÎ¯Î¿Ï ÏÎ¿Î»ÏÎ¼Î­ÏÏÎ½ ÎµÎ¯ÏÎµ Î»ÏÎ³Ï ÏÏÎ¿Î²Î»Î®Î¼Î±ÏÎ¿Ï Î¼Îµ ÏÎ¿Î½ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏÏÎ® Î® ÏÎ¿ Î´Î¯ÎºÏÏÎ¿ ÎµÎ¯ÏÎµ ÎµÏÎµÎ¹Î´Î® Î±ÏÏÎ® Î· Î¼Î¿ÏÏÎ® ÏÎ¿Ï Î±ÏÏÎµÎ¯Î¿Ï Î´ÎµÎ½ ÏÏÎ¿ÏÏÎ·ÏÎ¯Î¶ÎµÏÎ±Î¹.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "Î§Î¬Î¸Î·ÎºÎµ Î· ÏÏÎ½Î´ÎµÏÎ· Î¼Îµ ÏÎ¿ Î²Î¯Î½ÏÎµÎ¿",
		"The video download was cancelled": "Î Î»Î®ÏÎ· ÏÎ¿Ï Î²Î¯Î½ÏÎµÎ¿ Î±ÎºÏÏÏÎ¸Î·ÎºÎµ",
		"The video is bad or in a format that cannot be played on your browser": "Î¤Î¿ Î²Î¯Î½ÏÎµÎ¿ ÎµÎ¯Î½Î±Î¹ ÏÏÎ¿Î²Î»Î·Î¼Î±ÏÎ¹ÎºÏ Î® ÏÎµ Î¼Î¿ÏÏÎ® ÏÎ¿Ï Î´ÎµÎ½ Î¼ÏÎ¿ÏÎµÎ¯ Î½Î± Î±Î½Î±ÏÎ±ÏÎ±Î³Î¬Î³ÎµÎ¹ ÏÎ¿ ÏÏÏÎ³ÏÎ±Î¼Î¼Î± ÏÎµÏÎ¹Î®Î³Î·ÏÎ·Ï ÏÎ¿Ï ÏÏÎ·ÏÎ¹Î¼Î¿ÏÎ¿Î¹ÎµÎ¯ÏÎµ",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Î Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î® ÏÎ¿Ï Î²Î¯Î½ÏÎµÎ¿ Î±ÎºÏÏÏÎ¸Î·ÎºÎµ Î»ÏÎ³Ï ÎºÎ¬ÏÎ¿Î¹Î¿Ï ÏÏÎ¿Î²Î»Î®Î¼Î±ÏÎ¿Ï Î¼Îµ ÏÎ·Î½ ÏÎ¿Î¹ÏÏÎ·ÏÎ± ÏÎ¿Ï Î±ÏÏÎµÎ¯Î¿Ï Î® ÎµÏÎµÎ¹Î´Î® ÏÎ¿ Î²Î¯Î½ÏÎµÎ¿ ÏÏÎ·ÏÎ¹Î¼Î¿ÏÎ¿Î¹ÎµÎ¯ Î»ÎµÎ¹ÏÎ¿ÏÏÎ³Î¯ÎµÏ ÏÎ¿Ï Î´ÎµÎ½ ÏÏÎ¿ÏÏÎ·ÏÎ¯Î¶Î¿Î½ÏÎ±Î¹ Î±ÏÏ ÏÎ¿ ÏÏÏÎ³ÏÎ±Î¼Î¼Î± ÏÎµÏÎ¹Î®Î³Î·ÏÎ®Ï ÏÎ±Ï.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Î¤Î¿ Î²Î¯Î½ÏÎµÎ¿ ÏÎ¿Ï ÎµÏÎ¹ÏÎµÎ¹ÏÎµÎ¯ÏÎµ Î½Î± ÏÎ±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î®ÏÎµÏÎµ ÎµÎ¯Î½Î±Î¹ ÎºÏÏÏÏÎ¿Î³ÏÎ±ÏÎ·Î¼Î­Î½Î¿ ÎºÎ±Î¹ Î´ÎµÎ½ Î¾Î­ÏÎ¿ÏÎ¼Îµ ÏÏÏ Î½Î± ÏÎ¿ Î±ÏÎ¿ÎºÏÏÏÏÎ¿Î³ÏÎ±ÏÎ®ÏÎ¿ÏÎ¼Îµ.",
		"This content is not available for your package or region.": "ÎÏÏÏ ÏÎ¿ ÏÎµÏÎ¹ÎµÏÏÎ¼ÎµÎ½Î¿ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏÎ¹Î¼Î¿ Î³Î¹Î± ÏÎ¿ ÏÎ±ÎºÎ­ÏÎ¿ Î® ÏÎ·Î½ ÏÎµÏÎ¹Î¿ÏÎ® ÏÎ±Ï.",
		"This video is either unavailable or not supported in this browser": "ÎÏÏÏ ÏÎ¿ Î²Î¯Î½ÏÎµÎ¿ ÎµÎ¯ÏÎµ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏÎ¹Î¼Î¿ ÎµÎ¯ÏÎµ Î´ÎµÎ½ ÏÏÎ¿ÏÏÎ·ÏÎ¯Î¶ÎµÏÎ±Î¹ ÏÎµ Î±ÏÏÏ ÏÎ¿ ÏÏÏÎ³ÏÎ±Î¼Î¼Î± ÏÎµÏÎ¹Î®Î³Î·ÏÎ·Ï",
		"This video is unavailable": "ÎÏÏÏ ÏÎ¿ Î²Î¯Î½ÏÎµÎ¿ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏÎ¹Î¼Î¿",
		To: To$o,
		Transparent: Transparent$o,
		Uniform: Uniform$o,
		Unmute: Unmute$o,
		Unmuted: Unmuted$o,
		"Up Next": "ÎÏÏÎ¼ÎµÎ½Î· ÎµÎºÏÎ¿Î¼ÏÎ®",
		"Video has expired.": "Î¤Î¿ Î²Î¯Î½ÏÎµÎ¿ Î­Î»Î·Î¾Îµ.",
		"Video is not available in your country.": "Î¤Î¿ Î²Î¯Î½ÏÎµÎ¿ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Î¹Î±Î¸Î­ÏÎ¹Î¼Î¿ ÏÏÎ· ÏÏÏÎ± ÏÎ±Ï.",
		"Video is not yet available.": "Î¤Î¿ Î²Î¯Î½ÏÎµÎ¿ Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î±ÎºÏÎ¼Î± Î´Î¹Î±Î¸Î­ÏÎ¹Î¼Î¿.",
		"Video Player": "ÎÏÎ±ÏÎ¼Î¿Î³Î® Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î®Ï Î²Î¯Î½ÏÎµÎ¿",
		Watch: Watch$o,
		"WATCH NOW": "Î ÎÎ¡ÎÎÎÎÎÎ¥ÎÎÎ£Î Î¤Î©Î¡Î",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "ÎÏÏÏÏÏÏÏ, Î±ÏÏÏ ÏÎ¿ ÏÏÏÎ³ÏÎ±Î¼Î¼Î± ÏÎµÏÎ¹Î®Î³Î·ÏÎ·Ï Î´ÎµÎ½ ÏÏÎ¿ÏÏÎ·ÏÎ¯Î¶ÎµÏÎ±Î¹ ÏÎ»Î­Î¿Î½. ÎÎ½Î±Î²Î±Î¸Î¼Î¯ÏÏÎµ ÏÏÎ·Î½ ÏÎ¹Î¿ ÏÏÏÏÏÎ±ÏÎ· Î­ÎºÎ´Î¿ÏÎ· Google Chrome, FireFox Î® Microsoft Edge, Î³Î¹Î± Î½Î± ÏÎ±ÏÎ±ÎºÎ¿Î»Î¿ÏÎ¸Î®ÏÎµÏÎµ Î±ÏÏÏ ÏÎ¿ ÏÎµÏÎ¹ÎµÏÏÎ¼ÎµÎ½Î¿.",
		White: White$o,
		Window: Window$o,
		Yellow: Yellow$o,
		"You aborted the media playback": "ÎÎºÏÏÏÏÎ±ÏÎµ ÏÎ·Î½ Î±Î½Î±ÏÎ±ÏÎ±Î³ÏÎ³Î® ÏÎ¿Ï Î²Î¯Î½ÏÎµÎ¿",
		"elapsed out of": "Î±ÏÏ ÏÏÎ½Î¿Î»Î¹ÎºÎ® Î´Î¹Î¬ÏÎºÎµÎ¹Î±"
	};

	var Ad$n = "Anuncio";
	var Autoplay$n = "ReproducciÃ³n automÃ¡tica";
	var Background$n = "Fondo";
	var Black$n = "Negro";
	var Blue$n = "Azul";
	var Button$n = "BotÃ³n";
	var Captions$n = "SubtÃ­tulos especiales";
	var Casual$n = "Informal";
	var Chapters$n = "CapÃ­tulos";
	var Copied$n = "Copiado";
	var Copy$n = "Copiar";
	var Cyan$n = "Cian";
	var Default$n = "Default";
	var Depressed$n = "Hundido";
	var Done$n = "Finalizado";
	var DRM_REQUIRED$n = "Lo siento su navegador ya no es compatible. Por favor descarga la Ãºltima versiÃ³n de Google Chrome FireFox o Microsoft Edge para disfrutar de este contenido.";
	var Email$n = "Enviar por correo";
	var EMBARGOED$n = "El vÃ­deo no estÃ¡ disponible todavÃ­a.";
	var EXPIRED$n = "El video ha expirado.";
	var EXPIRED_CONTENT$n = "El video ha expirado.";
	var Foreground$n = "Primer plano";
	var From$n = "De";
	var Fullscreen$n = "Maximizar video";
	var GEOLOCATION_NOT_ALLOWED$n = "El vÃ­deo no estÃ¡ disponible en tu paÃ­s.";
	var Green$n = "Verde";
	var hour$n = "hora";
	var hours$n = "horas";
	var LIVE$n = "En Vivo";
	var Loaded$n = "Cargado";
	var Magenta$n = "Magenta";
	var Menu$n = "MenÃº";
	var Message$n = "Mensaje";
	var minute$n = "minuto";
	var minutes$n = "minutes";
	var More$n = "MÃ¡s";
	var Mute$n = "Silenciador";
	var NOT_FOUND$n = "Este vÃ­deo no estÃ¡ disponible.";
	var None$n = "Ninguno";
	var OK$n = "Aprobar";
	var Opaque$n = "Opaco";
	var Pause$n = "Pausa";
	var Pausing$n = "Pausar";
	var Play$n = "Reproducir";
	var Playing$n = "Reproduciendo";
	var Progress$n = "Progreso";
	var Purchased$n = "Comprado";
	var Raised$n = "Levantado";
	var Red$n = "Rojo";
	var Replay$n = "Reproducir de nuevo";
	var Rewind$n = "Retroceder";
	var Script$n = "Cursiva";
	var second$n = "segundo";
	var seconds$n = "segundos";
	var Send$n = "Enviar";
	var Settings$n = "ConfiguraciÃ³n";
	var Share$n = "Compartir";
	var Stop$n = "Detener";
	var STREAM_LIMITED$n = "El mÃ¡ximo nÃºmero de transmisiones de vÃ­deo simultÃ¡neas ha sido alcanzado en su cuenta.";
	var STREAM_LIMIT_ERROR$n = "El mÃ¡ximo nÃºmero de transmisiones de vÃ­deo simultÃ¡neas ha sido alcanzado en su cuenta.";
	var Subtitles$n = "SubtÃ­tulos";
	var To$n = "A";
	var Transparent$n = "Transparente";
	var Uniform$n = "Uniforme";
	var Unmute$n = "Eliminar silenciador";
	var Unmuted$n = "Eliminar silenciador";
	var Watch$n = "Ver";
	var White$n = "Blanco";
	var Window$n = "Ventana";
	var Yellow$n = "Amarillo";
	var hours_minutes_seconds_format$9 = "<%= hours %> <%= minutes %> y <%= seconds %>";
	var minutes_seconds_format$9 = "<%= minutes %> y <%= seconds %>";
	var es = {
		"A network error caused the media download to fail part-way.": "Un error de red ha interrumpido la descarga del vÃ­deo.",
		Ad: Ad$n,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Opciones de audio",
		Autoplay: Autoplay$n,
		"Back to video": "Volver al video",
		"Close share": "Close share",
		Background: Background$n,
		Black: Black$n,
		Blue: Blue$n,
		Button: Button$n,
		"Buy PPV": "Comprar PPV",
		"com.espn.watch.api.AccessDeniedException": "Este contenido no estÃ¡ disponible para su regiÃ³n o para el paquete que tiene contratado.",
		"Caption Settings": "Opciones de subtÃ­tulos",
		Captions: Captions$n,
		"captions off": "SubtÃ­tulos especiales desactivados",
		"Captions Preview": "Vista previa de subtÃ­tulos",
		Casual: Casual$n,
		Chapters: Chapters$n,
		"Check out this video on ESPN": "Echa un vistazo a este video en ESPN Play",
		"Choose Broadcast": "Elige tu transmisiÃ³n",
		"Choose TV Provider": "Elegir Su Proveedor",
		"Closed Caption": "SubtÃ­tulos",
		"Closed Captions": "SubtÃ­tulos",
		Copied: Copied$n,
		Copy: Copy$n,
		"Copy Embed Link": "Obtener cÃ³digo",
		"Copy Link": "Obtener URL",
		"Could not download the video": "No se ha podido descargar el vÃ­deo.",
		"Current Time": "Tiempo reproducido",
		"currently behind live": "currently behind live",
		Cyan: Cyan$n,
		Default: Default$n,
		Depressed: Depressed$n,
		Done: Done$n,
		DRM_REQUIRED: DRM_REQUIRED$n,
		"Drop shadow": "Sombra paralela",
		"Duration Time": "DuraciÃ³n total",
		Email: Email$n,
		"Email Video": "Enviar por Email",
		EMBARGOED: EMBARGOED$n,
		"Embed Code": "Insertar cÃ³digo",
		"Error Code": "CÃ³digo De Error",
		"Exit Full Screen": "Exit Full Screen",
		EXPIRED: EXPIRED$n,
		EXPIRED_CONTENT: EXPIRED_CONTENT$n,
		"Fast Forward": "Adelantar",
		"Font Family": "Familia de fuente",
		"Font Size": "TamaÃ±o de fuente",
		Foreground: Foreground$n,
		From: From$n,
		Fullscreen: Fullscreen$n,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$n,
		"Get ESPN+": "SuscrÃ­bete a ESPN+",
		"Get MLB.TV": "SuscrÃ­bete a MLB.TV",
		Green: Green$n,
		hour: hour$n,
		hours: hours$n,
		"Language Settings": "Ajustes de idioma",
		"Learn More": "Aprende mÃ¡s",
		LIVE: LIVE$n,
		Loaded: Loaded$n,
		"Logged Into TV Provider": "Conectado a Proveedor",
		Magenta: Magenta$n,
		Menu: Menu$n,
		Message: Message$n,
		minute: minute$n,
		minutes: minutes$n,
		"Monospace Sans-Serif": "Sans-Serif monoespaciada",
		"Monospace Serif": "Serif monoespaciada",
		More: More$n,
		Mute: Mute$n,
		NOT_FOUND: NOT_FOUND$n,
		"No compatible source was found for this media.": "No se ha encontrado ninguna fuente compatible con este vÃ­deo.",
		"No video has been loaded": "No hay ningÃºn vÃ­deo cargado.",
		"Non-Fullscreen": "TamaÃ±o original",
		None: None$n,
		"Now Playing": "Reproduciendo Ahora",
		OK: OK$n,
		Opaque: Opaque$n,
		Pause: Pause$n,
		Pausing: Pausing$n,
		Play: Play$n,
		"Playback Rate": "Velocidad de reproducciÃ³n",
		"Playback Speed": "Velocidad de reproducciÃ³n",
		Playing: Playing$n,
		"please confirm you are connected to the internet": "Compruebe si su equipo estÃ¡ conectado a internet.",
		Progress: Progress$n,
		"Proportional Sans-Serif": "Sans-Serifproporcional",
		"Proportional Serif": "Serif proporcional",
		Purchased: Purchased$n,
		Raised: Raised$n,
		Red: Red$n,
		"Remaining Time": "Tiempo restante",
		Replay: Replay$n,
		"Reset to Defaults": "Regresar a configuraciÃ³n original",
		Rewind: Rewind$n,
		Script: Script$n,
		second: second$n,
		seconds: seconds$n,
		"Seek to live": "Escuchando En vivo",
		"Seek to live, currently playing live": "Progreso a En Vivo",
		"Select Broadcast": "Elegir transmisiÃ³n",
		"Semi-Opaque": "Semi-opaco",
		"Semi-Transparent": "Semitransparente",
		Send: Send$n,
		Settings: Settings$n,
		Share: Share$n,
		"Skip Ad": "Saltar anuncio",
		"Small Caps": "Versalitas",
		"Start at": "Iniciar en",
		Stop: Stop$n,
		STREAM_LIMITED: STREAM_LIMITED$n,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$n,
		"Stream Type": "Tipo de secuencia",
		"Subscribed to ESPN+": "Suscrito a ESPN+",
		Subtitles: Subtitles$n,
		"subtitles off": "SubtÃ­tulos desactivados",
		"Technical details": "Detalles tÃ©cnicos",
		"Text Edge Style": "Estilo de borde de los caracteres",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "No se ha podido cargar el vÃ­deo debido a un fallo de red o del servidor o porque el formato es incompatible.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost,": "Se ha perdido la conexiÃ³n al vÃ­deo.",
		"The video download was cancelled": "Ha interrumpido la reproducciÃ³n del vÃ­deo.",
		"The video is bad or in a format that cannot be played on your browser": "El vÃ­deo estÃ¡ daÃ±ado o tiene un formato no reproducible en su navegador.",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "La reproducciÃ³n de vÃ­deo se ha interrumpido por un problema de corrupciÃ³n de datos o porque el vÃ­deo precisa funciones que su navegador no ofrece.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "The video you're trying to watch is encrypted and we don't know how to decrypt it",
		"This content is not available for your package or region.": "Este contenido no estÃ¡ disponible para su regiÃ³n o para el paquete que tiene contratado.",
		"This video is either unavailable or not supported in this browser": "Este vÃ­deo no estÃ¡ disponible o es incompatible con este navegador.",
		"This video is unavailable": "Este vÃ­deo no estÃ¡ disponible.",
		To: To$n,
		Transparent: Transparent$n,
		Uniform: Uniform$n,
		Unmute: Unmute$n,
		Unmuted: Unmuted$n,
		"Up Next": "A continuaciÃ³n",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Reproductor de video",
		Watch: Watch$n,
		"WATCH NOW": "VER AHORA",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$n,
		Window: Window$n,
		Yellow: Yellow$n,
		"You aborted the media playback": "Ha interrumpido la reproducciÃ³n del vÃ­deo.",
		"elapsed out of": "transcurridos de",
		hours_minutes_seconds_format: hours_minutes_seconds_format$9,
		minutes_seconds_format: minutes_seconds_format$9
	};

	var Ad$m = "Mainos";
	var Autoplay$m = "Automaattitoisto";
	var Background$m = "Tausta";
	var Black$m = "Musta";
	var Blue$m = "Sininen";
	var Button$m = "Painike";
	var Captions$m = "Tekstitys";
	var Casual$m = "Rento";
	var Chapters$m = "Luvut";
	var Copied$m = "Kopioitu";
	var Copy$m = "Kopioi";
	var Cyan$m = "Syaani";
	var Default$m = "Oletus";
	var Depressed$m = "Alaspainettu";
	var Done$m = "Valmis";
	var DRM_REQUIRED$m = "DRM_REQUIRED";
	var Email$m = "SÃ¤hkÃ¶posti";
	var EMBARGOED$m = "EMBARGOED";
	var EXPIRED$m = "EXPIRED";
	var EXPIRED_CONTENT$m = "EXPIRED_CONTENT";
	var Foreground$m = "Etuala";
	var From$m = "LÃ¤hettÃ¤jÃ¤";
	var Fullscreen$m = "Koko nÃ¤yttÃ¶";
	var GEOLOCATION_NOT_ALLOWED$m = "GEOLOCATION_NOT_ALLOWED";
	var Green$m = "VihreÃ¤";
	var hour$m = "tunti";
	var hours$m = "tuntia";
	var LIVE$m = "SUORA";
	var Loaded$m = "Ladattu";
	var Magenta$m = "Magenta";
	var Menu$m = "Valikko";
	var Message$m = "Viesti";
	var minute$m = "minuutti";
	var minutes$m = "minuuttia";
	var More$m = "LisÃ¤Ã¤";
	var Mute$m = "MykistÃ¤";
	var NOT_FOUND$m = "NOT_FOUND";
	var None$m = "Ei mitÃ¤Ã¤n";
	var OK$m = "OK";
	var Opaque$m = "LÃ¤pinÃ¤kymÃ¤tÃ¶n";
	var Pause$m = "KeskeytÃ¤";
	var Pausing$m = "Keskeytetty";
	var Play$m = "Toista";
	var Playing$m = "Toistetaan";
	var Progress$m = "Edistys";
	var Purchased$m = "Ostettu";
	var Raised$m = "Nostettu";
	var Red$m = "Punainen";
	var Replay$m = "Uusinta";
	var Rewind$m = "Takaisinkelaus";
	var Script$m = "KÃ¤sikirjoitus";
	var second$m = "sekunti";
	var seconds$m = "sekuntia";
	var Send$m = "LÃ¤hetÃ¤";
	var Settings$m = "Asetukset";
	var Share$m = "Jaa";
	var Stop$m = "PysÃ¤ytÃ¤";
	var STREAM_LIMITED$m = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$m = "STREAM_LIMIT_ERROR";
	var Subtitles$m = "Tekstitys";
	var To$m = "Vastaanottaja";
	var Transparent$m = "LÃ¤pinÃ¤kyvÃ¤";
	var Uniform$m = "YhtenÃ¤inen";
	var Unmute$m = "Poista mykistys";
	var Unmuted$m = "Mykistys poistettu";
	var Watch$m = "Katso";
	var White$m = "Valkoinen";
	var Window$m = "Ikkuna";
	var Yellow$m = "Keltainen";
	var fi = {
		"A network error caused the media download to fail part-way.": "Videolataus epÃ¤onnistui kesken latauksen verkkovirheen takia.",
		Ad: Ad$m,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Videotoistossa tapahtui virhe mahdollisesti verkkoyhteyden takia tai koska vÃ¤lilehti jÃ¤tettiin taustalle. YritÃ¤ uudelleen.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "ÃÃ¤niasetukset",
		Autoplay: Autoplay$m,
		"Back to video": "Palaa videoon",
		"Close share": "Close share",
		Background: Background$m,
		Black: Black$m,
		Blue: Blue$m,
		Button: Button$m,
		"Buy PPV": "Osta tilausvideo",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Tekstitysasetukset",
		Captions: Captions$m,
		"captions off": "Tekstitys pois",
		"Captions Preview": "Tekstityksen esikatselu",
		Casual: Casual$m,
		Chapters: Chapters$m,
		"Check out this video on ESPN": "Tutustu tÃ¤hÃ¤n videoon ESPN-palvelussa",
		"Choose Broadcast": "Valitse lÃ¤hetys",
		"Choose TV Provider": "Valitse TV-palvelun toimittaja",
		"Closed Caption": "Tekstitys",
		"Closed Captions": "Tekstitys",
		Copied: Copied$m,
		Copy: Copy$m,
		"Copy Embed Link": "Kopioi upotuslinkki",
		"Copy Link": "Kopioi linkki",
		"Could not download the video": "Could not download the video",
		"Current Time": "Nykyinen aika",
		"currently behind live": "jÃ¤ljessÃ¤ suorasta lÃ¤hetyksestÃ¤",
		Cyan: Cyan$m,
		Default: Default$m,
		Depressed: Depressed$m,
		Done: Done$m,
		DRM_REQUIRED: DRM_REQUIRED$m,
		"Drop shadow": "Varjostus",
		"Duration Time": "Kesto",
		Email: Email$m,
		"Email Video": "Ã¤hetÃ¤ video",
		EMBARGOED: EMBARGOED$m,
		"Embed Code": "Upotuskoodi",
		"Error Code": "Virhekoodi",
		"Exit Full Screen": "Poistu koko nÃ¤ytÃ¶n tilasta",
		EXPIRED: EXPIRED$m,
		EXPIRED_CONTENT: EXPIRED_CONTENT$m,
		"Fast Forward": "EteenpÃ¤inkelaus",
		"Font Family": "Fonttiperhe",
		"Font Size": "Fontin koko",
		Foreground: Foreground$m,
		From: From$m,
		Fullscreen: Fullscreen$m,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$m,
		"Get ESPN+": "Hanki ESPN+",
		"Get MLB.TV": "Hanki MLB.TV",
		Green: Green$m,
		hour: hour$m,
		hours: hours$m,
		"Language Settings": "Kieliasetukset",
		"Learn More": "LisÃ¤tietoja",
		LIVE: LIVE$m,
		Loaded: Loaded$m,
		"Logged Into TV Provider": "Kirjautunut TV-palvelun sivustolle",
		Magenta: Magenta$m,
		Menu: Menu$m,
		Message: Message$m,
		minute: minute$m,
		minutes: minutes$m,
		"Monospace Sans-Serif": "KiinteÃ¤vÃ¤linen Sans-Serif",
		"Monospace Serif": "KiinteÃ¤vÃ¤linen Serif",
		More: More$m,
		Mute: Mute$m,
		NOT_FOUND: NOT_FOUND$m,
		"No compatible source was found for this media.": "TÃ¤lle videolle ei lÃ¶ytynyt yhteensopivaa lÃ¤hdettÃ¤.",
		"No video has been loaded": "MitÃ¤Ã¤n videota ei ladattu",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$m,
		"Now Playing": "Nyt toistetaan",
		OK: OK$m,
		Opaque: Opaque$m,
		Pause: Pause$m,
		Pausing: Pausing$m,
		Play: Play$m,
		"Playback Rate": "Toistonopeus",
		"Playback Speed": "Toistonopeus",
		Playing: Playing$m,
		"please confirm you are connected to the internet": "Vahvista, ettÃ¤ sinulla on Internet-yhteys.",
		Progress: Progress$m,
		"Proportional Sans-Serif": "Suhteellinen Sans-Serif",
		"Proportional Serif": "Suhteellinen Serif",
		Purchased: Purchased$m,
		Raised: Raised$m,
		Red: Red$m,
		"Remaining Time": "Aikaa jÃ¤ljellÃ¤",
		Replay: Replay$m,
		"Reset to Defaults": "Palauta oletusarvoihin",
		Rewind: Rewind$m,
		Script: Script$m,
		second: second$m,
		seconds: seconds$m,
		"Seek to live": "Hae suoraa lÃ¤hetystÃ¤",
		"Seek to live, currently playing live": "Hae suoraa lÃ¤hetystÃ¤, toistetaan parhaillaan suoraa lÃ¤hetystÃ¤",
		"Select Broadcast": "Valitse lÃ¤hetys",
		"Semi-Opaque": "LÃ¤pikuultava",
		"Semi-Transparent": "PuolilÃ¤pinÃ¤kyvÃ¤",
		Send: Send$m,
		Settings: Settings$m,
		Share: Share$m,
		"Skip Ad": "Ohita mainos",
		"Small Caps": "Kapiteelit",
		"Start at": "Aloita kohdasta",
		Stop: Stop$m,
		STREAM_LIMITED: STREAM_LIMITED$m,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$m,
		"Stream Type": "Suoratoistotyyppi",
		"Subscribed to ESPN+": "ESPN+-palvelu tilattu",
		Subtitles: Subtitles$m,
		"subtitles off": "tekstitys pois",
		"Technical details": "Tekniset tiedot",
		"Text Edge Style": "Tekstin reunan tyyli",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Tilisi suurin samanaikaisten suoratoistojen mÃ¤Ã¤rÃ¤ on saavutettu. Jos sinulla on kysyttÃ¤vÃ¤Ã¤ tai tarvitset apua, kÃ¤y osoitteessa es.pn/watchfaq tai soita numeroon +1-888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Mediatiedostoa ei voitu ladata palvelin tai verkkovirheen takia tai koska tiedostomuotoa ei tueta.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "Videolataus peruutettiin",
		"The video is bad or in a format that cannot be played on your browser": "Video on virheellinen tai muodossa, jota ei voida nÃ¤yttÃ¤Ã¤ selaimessa",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Videotoisto keskeytettiin videovirheen takia tai koska videossa kÃ¤ytettiin toimintoja, joita kÃ¤yttÃ¤mÃ¤si selain ei tue.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "YritÃ¤t katsoa salattua videota emmekÃ¤ tiedÃ¤, miten se puretaan.",
		"This content is not available for your package or region.": "TÃ¤mÃ¤ sisÃ¤ltÃ¶ ei ole kÃ¤ytettÃ¤vissÃ¤ tilauksessasi tai alueellasi.",
		"This video is either unavailable or not supported in this browser": "TÃ¤mÃ¤ video ei ole kÃ¤ytettÃ¤vissÃ¤ tai sitÃ¤ ei tueta tÃ¤ssÃ¤ selaimessa.",
		"This video is unavailable": "TÃ¤mÃ¤ video ei ole kÃ¤ytettÃ¤vissÃ¤.",
		To: To$m,
		Transparent: Transparent$m,
		Uniform: Uniform$m,
		Unmute: Unmute$m,
		Unmuted: Unmuted$m,
		"Up Next": "Seuraavaksi",
		"Video has expired.": "Video on vanhentunut.",
		"Video is not available in your country.": "Video ei ole kÃ¤ytettÃ¤vissÃ¤ maassasi.",
		"Video is not yet available.": "Video ei ole vielÃ¤ kÃ¤ytettÃ¤vissÃ¤.",
		"Video Player": "Videosoitin",
		Watch: Watch$m,
		"WATCH NOW": "KATSO NYT",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Valitettavasti tÃ¤tÃ¤ selainta ei enÃ¤Ã¤ tueta. PÃ¤ivitÃ¤ Google Chromen, FireFoxin tai Microsoft Edgen uusimpaan versioon, jotta voit katsoa tÃ¤tÃ¤ sisÃ¤ltÃ¶Ã¤.",
		White: White$m,
		Window: Window$m,
		Yellow: Yellow$m,
		"You aborted the media playback": "Katkaisit videotoiston",
		"elapsed out of": "kulunut ajasta"
	};

	var Ad$l = "Pub";
	var Autoplay$l = "Lecture automatique";
	var Background$l = "ArriÃ¨re-plan";
	var Black$l = "Noir";
	var Blue$l = "Bleu";
	var Button$l = "Bouton";
	var Captions$l = "Sous-titres";
	var Casual$l = "DÃ©contractÃ©";
	var Chapters$l = "Chapitre";
	var Copied$l = "CopiÃ©";
	var Copy$l = "Copier";
	var Cyan$l = "Cyan";
	var Default$l = "Par dÃ©faut";
	var Depressed$l = "Maintenu";
	var Done$l = "Fait";
	var DRM_REQUIRED$l = "DRM_REQUIRED";
	var Email$l = "E-mail";
	var EMBARGOED$l = "EMBARGOED";
	var EXPIRED$l = "EXPIRED";
	var EXPIRED_CONTENT$l = "EXPIRED_CONTENT";
	var Foreground$l = "Premier plan";
	var From$l = "De";
	var Fullscreen$l = "Plein Ã©cran";
	var GEOLOCATION_NOT_ALLOWED$l = "GEOLOCATION_NOT_ALLOWED";
	var Green$l = "Vert";
	var hour$l = "heure";
	var hours$l = "heures";
	var LIVE$l = "EN DIRECT";
	var Loaded$l = "ChargÃ©";
	var Magenta$l = "Magenta";
	var Menu$l = "Menu";
	var Message$l = "Message";
	var minute$l = "minute";
	var minutes$l = "minutes";
	var More$l = "Plus";
	var Mute$l = "DÃ©sactiver le son";
	var NOT_FOUND$l = "NOT_FOUND";
	var None$l = "Aucune";
	var OK$l = "OK";
	var Opaque$l = "Opaque";
	var Pause$l = "Pause";
	var Pausing$l = "En pause";
	var Play$l = "Lecture";
	var Playing$l = "En cours de lecture";
	var Progress$l = "Progression";
	var Purchased$l = "AchetÃ©";
	var Raised$l = "AugmentÃ©";
	var Red$l = "Rouge";
	var Replay$l = "Replay";
	var Rewind$l = "Retour rapide";
	var Script$l = "Script";
	var second$l = "seconde";
	var seconds$l = "secondes";
	var Send$l = "Envoyer";
	var Settings$l = "ParamÃ¨tres";
	var Share$l = "Partager";
	var Stop$l = "ArrÃªt";
	var STREAM_LIMITED$l = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$l = "STREAM_LIMIT_ERROR";
	var Subtitles$l = "Sous-titres";
	var To$l = "Vers";
	var Transparent$l = "Transparent";
	var Uniform$l = "Uniforme";
	var Unmute$l = "Activer le son";
	var Unmuted$l = "Son activÃ©";
	var Watch$l = "Voir";
	var White$l = "Blanc";
	var Window$l = "FenÃªtre";
	var Yellow$l = "Jaune";
	var fr = {
		"A network error caused the media download to fail part-way.": "Une erreur de rÃ©seau a causÃ© l'Ã©chec du tÃ©lÃ©chargement de la vidÃ©o.",
		Ad: Ad$l,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Une erreur s'est produite lors de la lecture de la vidÃ©o, peut-Ãªtre en raison de la connexion au rÃ©seau ou de la prÃ©sence d'un onglet de navigateur en arriÃ¨re-plan. Veuillez rÃ©essayer.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Options audio",
		Autoplay: Autoplay$l,
		"Back to video": "Retour Ã  la vidÃ©o",
		"Close share": "Close share",
		Background: Background$l,
		Black: Black$l,
		Blue: Blue$l,
		Button: Button$l,
		"Buy PPV": "Achat PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "ParamÃ¨tres des sous-titres",
		Captions: Captions$l,
		"captions off": "Sans sous-titres",
		"Captions Preview": "AperÃ§u des sous-titres",
		Casual: Casual$l,
		Chapters: Chapters$l,
		"Check out this video on ESPN": "DÃ©couvrez cette vidÃ©o sur ESPN",
		"Choose Broadcast": "Choisissez le type de diffusion",
		"Choose TV Provider": "Choisissez le fournisseur de tÃ©lÃ©vision",
		"Closed Caption": "Sous-titre",
		"Closed Captions": "Sous-titres",
		Copied: Copied$l,
		Copy: Copy$l,
		"Copy Embed Link": "Copier le lien intÃ©grÃ©",
		"Copy Link": "Copier le lien",
		"Could not download the video": "Could not download the video",
		"Current Time": "Heure actuelle",
		"currently behind live": "actuellement en dÃ©calage",
		Cyan: Cyan$l,
		Default: Default$l,
		Depressed: Depressed$l,
		Done: Done$l,
		DRM_REQUIRED: DRM_REQUIRED$l,
		"Drop shadow": "Ombre",
		"Duration Time": "DurÃ©e",
		Email: Email$l,
		"Email Video": "Envoyer la vidÃ©o",
		EMBARGOED: EMBARGOED$l,
		"Embed Code": "Code intÃ©grÃ©",
		"Error Code": "Code d'erreur",
		"Exit Full Screen": "Quitter plein Ã©cran",
		EXPIRED: EXPIRED$l,
		EXPIRED_CONTENT: EXPIRED_CONTENT$l,
		"Fast Forward": "Avance rapide",
		"Font Family": "Famille de police",
		"Font Size": "Taille de police",
		Foreground: Foreground$l,
		From: From$l,
		Fullscreen: Fullscreen$l,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$l,
		"Get ESPN+": "Obtenir ESPN+",
		"Get MLB.TV": "Obtenir MLB.TV",
		Green: Green$l,
		hour: hour$l,
		hours: hours$l,
		"Language Settings": "ParamÃ¨tres des langues",
		"Learn More": "En savoir plus",
		LIVE: LIVE$l,
		Loaded: Loaded$l,
		"Logged Into TV Provider": "ConnectÃ© au fournisseur de tÃ©lÃ©vision",
		Magenta: Magenta$l,
		Menu: Menu$l,
		Message: Message$l,
		minute: minute$l,
		minutes: minutes$l,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$l,
		Mute: Mute$l,
		NOT_FOUND: NOT_FOUND$l,
		"No compatible source was found for this media.": "Aucune source compatible dÃ©tectÃ©e pour cette vidÃ©o.",
		"No video has been loaded": "Aucune vidÃ©o chargÃ©e",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$l,
		"Now Playing": "En cours de lecture",
		OK: OK$l,
		Opaque: Opaque$l,
		Pause: Pause$l,
		Pausing: Pausing$l,
		Play: Play$l,
		"Playback Rate": "Niveau de lecture",
		"Playback Speed": "Vitesse de lecture",
		Playing: Playing$l,
		"please confirm you are connected to the internet": "veuillez confirmer que vous Ãªtes connectÃ©(e) Ã  Internet",
		Progress: Progress$l,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$l,
		Raised: Raised$l,
		Red: Red$l,
		"Remaining Time": "Temps restant",
		Replay: Replay$l,
		"Reset to Defaults": "RÃ©initialiser",
		Rewind: Rewind$l,
		Script: Script$l,
		second: second$l,
		seconds: seconds$l,
		"Seek to live": "Recherche de directs",
		"Seek to live, currently playing live": "Recherche de directs, diffusions en direct",
		"Select Broadcast": "Choix de la diffusion",
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send$l,
		Settings: Settings$l,
		Share: Share$l,
		"Skip Ad": "Ignorer la pub",
		"Small Caps": "Minuscules",
		"Start at": "DÃ©part Ã ",
		Stop: Stop$l,
		STREAM_LIMITED: STREAM_LIMITED$l,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$l,
		"Stream Type": "Type de streaming",
		"Subscribed to ESPN+": "AbonnÃ© Ã  ESPN+",
		Subtitles: Subtitles$l,
		"subtitles off": "Sans sous-titres",
		"Technical details": "DÃ©tails techniques",
		"Text Edge Style": "Style de bordure du texte",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Le nombre maximum de diffusions simultanÃ©es a Ã©tÃ© atteint sur votre compte. Si vous avez des questions ou avez besoin d'aide, rendez-vous sur es.pn/watchfaq ou appelez le 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Impossible de charger le support, soit en raison d'un problÃ¨me de serveur ou rÃ©seau, soit parce que son format est incompatible.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "La connexion de la vidÃ©o a Ã©tÃ© interrompue",
		"The video download was cancelled": "Le tÃ©lÃ©chargement de la vidÃ©o a Ã©tÃ© annulÃ©",
		"The video is bad or in a format that cannot be played on your browser": "La vidÃ©o est corrompue ou sous un format illisible sur votre navigateur",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "La lecture de la vidÃ©o a Ã©tÃ© annulÃ©e soit en raison de donnÃ©es corrompues, soit parce que la vidÃ©o utilise des fonctionnalitÃ©s incompatibles avec votre navigateur.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "La vidÃ©o que vous essayez de voir est codÃ©e et nous ne savons pas comment la dÃ©coder",
		"This content is not available for your package or region.": "Ce contenu n'est pas disponible dans le cadre de votre abonnement ou pour votre rÃ©gion.",
		"This video is either unavailable or not supported in this browser": "Soit cette vidÃ©o n'est pas disponible soit elle est incompatible avec votre navigateur.",
		"This video is unavailable": "Cette vidÃ©o n'est pas disponible.",
		To: To$l,
		Transparent: Transparent$l,
		Uniform: Uniform$l,
		Unmute: Unmute$l,
		Unmuted: Unmuted$l,
		"Up Next": "Suivante",
		"Video has expired.": "La vidÃ©o a expirÃ©.",
		"Video is not available in your country.": "La vidÃ©o n'est pas disponible dans votre pays.",
		"Video is not yet available.": "La vidÃ©o n'est pas disponible pour le moment.",
		"Video Player": "Lecteur de vidÃ©o",
		Watch: Watch$l,
		"WATCH NOW": "VOIR MAINTENANT",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "DÃ©solÃ©, mais ce navigateur n'est plus pris en charge. Veuillez installer la derniÃ¨re version de Google Chrome, FireFox ou Microsoft Edge pour voir ce contenu.",
		White: White$l,
		Window: Window$l,
		Yellow: Yellow$l,
		"You aborted the media playback": "Vous avez annulÃ© la lecture de la vidÃ©o",
		"elapsed out of": "Ã©coulÃ© sur"
	};

	var Ad$k = "×¤×¨×¡×××ª";
	var Autoplay$k = "××¤×¢×× ××××××××ª";
	var Background$k = "×¨×§×¢";
	var Black$k = "×©×××¨";
	var Blue$k = "××××";
	var Button$k = "×××¦×";
	var Captions$k = "××ª×××××ª";
	var Casual$k = "× ×× ××";
	var Chapters$k = "×¤×¨×§××";
	var Copied$k = "×××¢×ª×§";
	var Copy$k = "××¢×ª×§";
	var Cyan$k = "×××¨×§××";
	var Default$k = "××¨××¨×ª ××××";
	var Depressed$k = "××××¥";
	var Done$k = "×××¦×¢";
	var DRM_REQUIRED$k = "";
	var Email$k = "×××\"×";
	var EMBARGOED$k = "";
	var EXPIRED$k = "";
	var EXPIRED_CONTENT$k = "";
	var Foreground$k = "××××ª";
	var From$k = "××©×××";
	var Fullscreen$k = "××¡× ×××";
	var GEOLOCATION_NOT_ALLOWED$k = "";
	var Green$k = "××¨××§";
	var hour$k = "×©×¢×";
	var hours$k = "×©×¢××ª";
	var LIVE$k = "×©××××¨ ××";
	var Loaded$k = "× ××¢×";
	var Magenta$k = "××× ××";
	var Menu$k = "×ª×¤×¨××";
	var Message$k = "××××¢×";
	var minute$k = "××§×";
	var minutes$k = "××§××ª";
	var More$k = "×¢××";
	var Mute$k = "××©×ª×§";
	var NOT_FOUND$k = "";
	var None$k = "×××";
	var OK$k = "×××©××¨";
	var Opaque$k = "××××";
	var Pause$k = "××©××";
	var Pausing$k = "××©××";
	var Play$k = "××¤×¢×";
	var Playing$k = "×× ×× ×¢××©××";
	var Progress$k = "××ª×§××××ª";
	var Purchased$k = "× ×¨××©";
	var Raised$k = "×××¢××";
	var Red$k = "××××";
	var Replay$k = "××¤×¢× ××××©";
	var Rewind$k = "××¨×¥ ××××¨×";
	var Script$k = "×ª×¡×¨××";
	var second$k = "×©× ×××";
	var seconds$k = "×©× ×××ª";
	var Send$k = "×©××";
	var Settings$k = "××××¨××ª";
	var Share$k = "×©×ª×£";
	var Stop$k = "××¤×¡×§";
	var STREAM_LIMITED$k = "";
	var STREAM_LIMIT_ERROR$k = "";
	var Subtitles$k = "××ª×××××ª";
	var To$k = "××";
	var Transparent$k = "×©×§××£";
	var Uniform$k = "××××";
	var Unmute$k = "××× ××©×ª×§×";
	var Unmuted$k = "××××× ××©×ª×§×";
	var Watch$k = "×¦×¤×";
	var White$k = "×××";
	var Window$k = "××××";
	var Yellow$k = "×¦×××";
	var he = {
		"A network error caused the media download to fail part-way.": "×©××××ª ×¨×©×ª ××¨×× ××××¨××ª ××××××× ×××××©× ××××¦×¢ ××ª××××.",
		Ad: Ad$k,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "×××¨×¢× ×©×××× ××××× ××¤×¢××ª ××××××, ××ª×× ×¢×§× ×××××¨ ××¨×©×ª ×× ×©×××× ×××¨×××¡×××ª ××¤××¤× ××¨×§×¢. ×××§×©× × ×¡× ×©××.",
		"An unanticipated problem was encountered, check back soon and try again": "",
		"Audio Options": "××¤×©×¨××××ª ×©××¢",
		Autoplay: Autoplay$k,
		"Back to video": "×××¨× ×××××××",
		"Close share": "Close share",
		Background: Background$k,
		Black: Black$k,
		Blue: Blue$k,
		Button: Button$k,
		"Buy PPV": "×ª×©××× ××¤× ×¦×¤××× (PPV)",
		"com.espn.watch.api.AccessDeniedException": "",
		"Caption Settings": "××××¨×ª ××ª×××××ª",
		Captions: Captions$k,
		"captions off": "××ª×××××ª ××××××ª",
		"Captions Preview": "×ª×¦××× ×××§×××ª ×©× ××ª×××××ª",
		Casual: Casual$k,
		Chapters: Chapters$k,
		"Check out this video on ESPN": "×¦×¤× ××××××× ××× ×-ESPN",
		"Choose Broadcast": "×××¨ ×©××××¨",
		"Choose TV Provider": "×××¨ ×¡×¤×§ ××××××××",
		"Closed Caption": "××ª×××××ª",
		"Closed Captions": "××ª×××××ª",
		Copied: Copied$k,
		Copy: Copy$k,
		"Copy Embed Link": "××¢×ª×§ ×§××©××¨ ×××××¢",
		"Copy Link": "××¢×ª×§ ×§××©××¨",
		"Could not download the video": "",
		"Current Time": "××× × ××××",
		"currently behind live": "××¨××¢ ××¢×××× ×××¡××ª ××©××××¨ ××",
		Cyan: Cyan$k,
		Default: Default$k,
		Depressed: Depressed$k,
		Done: Done$k,
		DRM_REQUIRED: DRM_REQUIRED$k,
		"Drop shadow": "××××ª ×¦×",
		"Duration Time": "××©× ×××",
		Email: Email$k,
		"Email Video": "×©×× ××××× ××××\"×",
		EMBARGOED: EMBARGOED$k,
		"Embed Code": "××××¢ ×§××",
		"Error Code": "×§×× ×©××××",
		"Exit Full Screen": "×¦× ×××¡× ×××",
		EXPIRED: EXPIRED$k,
		EXPIRED_CONTENT: EXPIRED_CONTENT$k,
		"Fast Forward": "××¨×¥ ×§××××",
		"Font Family": "××©×¤××ª ×××¤× ××",
		"Font Size": "×××× ×××¤×",
		Foreground: Foreground$k,
		From: From$k,
		Fullscreen: Fullscreen$k,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$k,
		"Get ESPN+": "×§×× ESPN+",
		"Get MLB.TV": "×§×× MLB.TV",
		Green: Green$k,
		hour: hour$k,
		hours: hours$k,
		"Language Settings": "××××¨××ª ×©×¤×",
		"Learn More": "×××××¢ × ××¡×£",
		LIVE: LIVE$k,
		Loaded: Loaded$k,
		"Logged Into TV Provider": "×××××¨ ××¡×¤×§ ××××××××",
		Magenta: Magenta$k,
		Menu: Menu$k,
		Message: Message$k,
		minute: minute$k,
		minutes: minutes$k,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$k,
		Mute: Mute$k,
		NOT_FOUND: NOT_FOUND$k,
		"No compatible source was found for this media.": "×× × ××¦× ××§××¨ ×ª××× ××××××× ××.",
		"No video has been loaded": "×× × ××¢× ×××××",
		"Non-Fullscreen": "",
		None: None$k,
		"Now Playing": "×× ×× ×¢××©××",
		OK: OK$k,
		Opaque: Opaque$k,
		Pause: Pause$k,
		Pausing: Pausing$k,
		Play: Play$k,
		"Playback Rate": "×§×¦× ××¤×¢××",
		"Playback Speed": "××××¨××ª ××¤×¢××",
		Playing: Playing$k,
		"please confirm you are connected to the internet": "×× × ×××× ×©××ª× ×××××¨ ×××× ××¨× ×",
		Progress: Progress$k,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$k,
		Raised: Raised$k,
		Red: Red$k,
		"Remaining Time": "××× ×©× ××ª×¨",
		Replay: Replay$k,
		"Reset to Defaults": "×××¤××¡ ×××××¨××ª ××¨××¨×ª ××××",
		Rewind: Rewind$k,
		Script: Script$k,
		second: second$k,
		seconds: seconds$k,
		"Seek to live": "××¤×© ×©××××¨ ××",
		"Seek to live, currently playing live": "××¤×© ×©××××¨ ××, ××¨××¢ ××¤×¢×× ××©××××¨ ××",
		"Select Broadcast": "×××¨ ×©××××¨",
		"Semi-Opaque": "×××× ××××¦×",
		"Semi-Transparent": "×©×§××£ ××××¦×",
		Send: Send$k,
		Settings: Settings$k,
		Share: Share$k,
		"Skip Ad": "××× ×¢× ×¤×¨×¡×××ª",
		"Small Caps": "×¨××©×××ª ×××§×× ××ª",
		"Start at": "××ª××× ×-",
		Stop: Stop$k,
		STREAM_LIMITED: STREAM_LIMITED$k,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$k,
		"Stream Type": "×¡×× ×××¨××",
		"Subscribed to ESPN+": "×¨×©×× ××× ×× ×-ESPN+",
		Subtitles: Subtitles$k,
		"subtitles off": "××ª×××××ª ×× ×××¤×¢×××ª",
		"Technical details": "×¤×¨××× ××× ×××",
		"Text Edge Style": "×¡×× ×× ×§×¦× ××§×¡×",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "××©××× × ××××¢ ×××¡×¤×¨ ×××¨×× ×©× ×××¨×××ª ××§×××××ª. ×× ××© ×× ×©××××ª ×× ×× ××ª× ××§××§ ××¢××¨×, ××§×¨ ×××ª×¨ es.pn/watchfaq ×× ××ª×§×©×¨ ×× 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "×× × ××ª× ××× ×××¢×× ××ª ×××××, ×××× ×¢×§× ×ª×§×× ××©×¨×ª ×× ××¨×©×ª, ×× ×¢×§× ×× ×©××¤××¨×× ××× × × ×ª××.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "",
		"The video connection was lost": "×××××¨ ××××××× ×××",
		"The video download was cancelled": "×××¨××ª ××××××× ×××××",
		"The video is bad or in a format that cannot be played on your browser": "××××××× ××××××ª ××¨××× ×× ××¤××¨×× ×©×× × ××ª× ×××¤×¢×× ×××¤××¤×",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "××¤×¢××ª ××××××× ×××¤×¡×§× ×¢×§× ××¢×××ª ×¢××××ª ×× ×¢×§× ×× ×©××××××× ×¢×©× ×©××××© ××ª××× ××ª ×©××× × × ×ª××××ª ×¢× ××× ×××¤××¤×",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "××××××× ×©××ª× ×× ×¡× ××¦×¤××ª ×× ×××¦×¤× ×××× × × ××××¢×× ×××¦× ××¤×¢× × ×××ª×",
		"This content is not available for your package or region.": "×ª××× ×× ×× ×××× ×××××¨ ×× ×¢×××¨ ×××××× ×©××.",
		"This video is either unavailable or not supported in this browser": "××××× ×× ×× ×××× ×× ×©××× × × ×ª×× ×××¤××¤× ××",
		"This video is unavailable": "××××× ×× ×× ××××.",
		To: To$k,
		Transparent: Transparent$k,
		Uniform: Uniform$k,
		Unmute: Unmute$k,
		Unmuted: Unmuted$k,
		"Up Next": "××××©×â¦",
		"Video has expired.": "×¤× ×ª××§×£ ×××××××.",
		"Video is not available in your country.": "××××××× ×× ×××× ××××× ×ª×.",
		"Video is not yet available.": "××××××× ×× ×××× ×¢××××.",
		"Video Player": "× ×× ×××××",
		Watch: Watch$k,
		"WATCH NOW": "×¦×¤× ××¢×ª",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "××¦××¢×¨××, ××¤××¤× ×× ×××¨ ×× × ×ª××. ×©××¨× ××××¨×¡× ××××¨×× × ×©× Google Chrome, FireFox, ×× Microsoft Edge ××× ××¦×¤××ª ××ª××× ××.",
		White: White$k,
		Window: Window$k,
		Yellow: Yellow$k,
		"You aborted the media playback": "×§××¢×ª ××ª ××¤×¢××ª ×××××××",
		"elapsed out of": "×××£ ××ª××"
	};

	var Ad$j = "HirdetÃ©s";
	var Autoplay$j = "Automatikus lejÃ¡tszÃ¡s";
	var Background$j = "HÃ¡ttÃ©r";
	var Black$j = "Fekete";
	var Blue$j = "KÃ©k";
	var Button$j = "Gomb";
	var Captions$j = "Feliratok";
	var Casual$j = "Alkalmi";
	var Chapters$j = "Fejezetek";
	var Copied$j = "KimÃ¡solva";
	var Copy$j = "MÃ¡solÃ¡s";
	var Cyan$j = "CiÃ¡nkÃ©k";
	var Default$j = "AlapÃ©rtelmezett";
	var Depressed$j = "Lenyomott";
	var Done$j = "KÃ©sz";
	var DRM_REQUIRED$j = "DRM_REQUIRED";
	var Email$j = "E-mail";
	var EMBARGOED$j = "EMBARGOED";
	var EXPIRED$j = "EXPIRED";
	var EXPIRED_CONTENT$j = "EXPIRED_CONTENT";
	var Foreground$j = "ElÅtÃ©r";
	var From$j = "FeladÃ³";
	var Fullscreen$j = "Teljes kÃ©pernyÅ";
	var GEOLOCATION_NOT_ALLOWED$j = "GEOLOCATION_NOT_ALLOWED";
	var Green$j = "ZÃ¶ld";
	var hour$j = "Ã³ra";
	var hours$j = "Ã³ra";
	var LIVE$j = "ÃLÅ";
	var Loaded$j = "BetÃ¶ltve";
	var Magenta$j = "Magenta";
	var Menu$j = "MenÃ¼";
	var Message$j = "Ãzenet";
	var minute$j = "perc";
	var minutes$j = "perc";
	var More$j = "BÅvebben";
	var Mute$j = "NÃ©mÃ­tÃ¡s";
	var NOT_FOUND$j = "NOT_FOUND";
	var None$j = "Egyik sem";
	var OK$j = "OK";
	var Opaque$j = "ÃttetszÅ";
	var Pause$j = "PillanatmegÃ¡llÃ­tÃ¡s";
	var Pausing$j = "PillanatmegÃ¡llÃ­tÃ¡s";
	var Play$j = "LejÃ¡tszÃ¡s";
	var Playing$j = "LejÃ¡tszÃ¡s alatt";
	var Progress$j = "StÃ¡tusz";
	var Purchased$j = "MegvÃ¡sÃ¡rolva";
	var Raised$j = "Emelt";
	var Red$j = "Piros";
	var Replay$j = "ÃjrajÃ¡tszÃ¡s";
	var Rewind$j = "VisszatekerÃ©s";
	var Script$j = "Szkript";
	var second$j = "mÃ¡sodperc";
	var seconds$j = "mÃ¡sodperc";
	var Send$j = "KÃ¼ldÃ©s";
	var Settings$j = "BeÃ¡llÃ­tÃ¡sok";
	var Share$j = "MegosztÃ¡s";
	var Stop$j = "MegÃ¡llÃ­tÃ¡s";
	var STREAM_LIMITED$j = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$j = "STREAM_LIMIT_ERROR";
	var Subtitles$j = "Feliratok";
	var To$j = "CÃ­mzett:";
	var Transparent$j = "ÃtlÃ¡tszÃ³";
	var Uniform$j = "EgysÃ©ges";
	var Unmute$j = "NÃ©mÃ­tÃ¡s visszavonÃ¡sa";
	var Unmuted$j = "NÃ©mÃ­tÃ¡s visszavonva";
	var Watch$j = "MegtekintÃ©s";
	var White$j = "FehÃ©r";
	var Window$j = "Ablak";
	var Yellow$j = "SÃ¡rga";
	var hu = {
		"A network error caused the media download to fail part-way.": "A videÃ³ letÃ¶ltÃ©se hÃ¡lÃ³zati hiba miatt megszakadt.",
		Ad: Ad$j,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Hiba tÃ¶rtÃ©nt a videÃ³ lejÃ¡tszÃ¡sa kÃ¶zben, valÃ³szÃ­nÅ±leg a hÃ¡lÃ³zati kapcsolat miatt, vagy mert hÃ¡ttÃ©rben lÃ©vÅ bÃ¶ngÃ©szÅlapra kerÃ¼lt. KÃ©rjÃ¼k, prÃ³bÃ¡lkozz Ãºjra.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "HangbeÃ¡llÃ­tÃ¡sok",
		Autoplay: Autoplay$j,
		"Back to video": "Vissza a videÃ³hoz",
		"Close share": "Close share",
		Background: Background$j,
		Black: Black$j,
		Blue: Blue$j,
		Button: Button$j,
		"Buy PPV": "KÃ¶lcsÃ¶nzÃ©s",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "FeliratbeÃ¡llÃ­tÃ¡sok",
		Captions: Captions$j,
		"captions off": "feliratok ki",
		"Captions Preview": "Felirat elÅnÃ©zet",
		Casual: Casual$j,
		Chapters: Chapters$j,
		"Check out this video on ESPN": "VideÃ³ megtekintÃ©se az ESPN-en",
		"Choose Broadcast": "VÃ¡lassz kÃ¶zvetÃ­tÃ©st",
		"Choose TV Provider": "TV-szolgÃ¡ltatÃ³ vÃ¡lasztÃ¡sa",
		"Closed Caption": "Felirat",
		"Closed Captions": "Feliratok",
		Copied: Copied$j,
		Copy: Copy$j,
		"Copy Embed Link": "BeÃ¡gyazott hivatkozÃ¡s mÃ¡solÃ¡sa",
		"Copy Link": "HivatkozÃ¡s mÃ¡solÃ¡sa",
		"Could not download the video": "Could not download the video",
		"Current Time": "Jelenlegi idÅ",
		"currently behind live": "jelenleg az Ã©lÅtÅl lemaradva",
		Cyan: Cyan$j,
		Default: Default$j,
		Depressed: Depressed$j,
		Done: Done$j,
		DRM_REQUIRED: DRM_REQUIRED$j,
		"Drop shadow": "Vetett Ã¡rnyÃ©k",
		"Duration Time": "IdÅtartam",
		Email: Email$j,
		"Email Video": "VideÃ³ kÃ¼ldÃ©se e-mailben",
		EMBARGOED: EMBARGOED$j,
		"Embed Code": "KÃ³d beÃ¡gyazÃ¡sa",
		"Error Code": "HibakÃ³d",
		"Exit Full Screen": "KilÃ©pÃ©s teljes kÃ©pernyÅs mÃ³dbÃ³l",
		EXPIRED: EXPIRED$j,
		EXPIRED_CONTENT: EXPIRED_CONTENT$j,
		"Fast Forward": "ElÅretekerÃ©s",
		"Font Family": "BetÅ±tÃ­puscsalÃ¡d",
		"Font Size": "BetÅ±mÃ©ret",
		Foreground: Foreground$j,
		From: From$j,
		Fullscreen: Fullscreen$j,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$j,
		"Get ESPN+": "ESPN+ elÅfizetÃ©s",
		"Get MLB.TV": "MLB.TV elÅfizetÃ©s",
		Green: Green$j,
		hour: hour$j,
		hours: hours$j,
		"Language Settings": "Nyelvi beÃ¡llÃ­tÃ¡sok",
		"Learn More": "BÅvebben",
		LIVE: LIVE$j,
		Loaded: Loaded$j,
		"Logged Into TV Provider": "Bejelentkezve a TV-szolgÃ¡ltatÃ³hoz",
		Magenta: Magenta$j,
		Menu: Menu$j,
		Message: Message$j,
		minute: minute$j,
		minutes: minutes$j,
		"Monospace Sans-Serif": "Fix mÃ©retÅ± talpatlan betÅ±",
		"Monospace Serif": "Fix mÃ©retÅ± talpas betÅ±",
		More: More$j,
		Mute: Mute$j,
		NOT_FOUND: NOT_FOUND$j,
		"No compatible source was found for this media.": "Nem talÃ¡lhatÃ³ kompatibilis forrÃ¡s a videÃ³hoz.",
		"No video has been loaded": "Nincs videÃ³ betÃ¶ltve",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$j,
		"Now Playing": "LejÃ¡tszÃ¡s alatt",
		OK: OK$j,
		Opaque: Opaque$j,
		Pause: Pause$j,
		Pausing: Pausing$j,
		Play: Play$j,
		"Playback Rate": "LejÃ¡tszÃ¡si sebessÃ©g",
		"Playback Speed": "LejÃ¡tszÃ¡si sebessÃ©g",
		Playing: Playing$j,
		"please confirm you are connected to the internet": "kÃ©rjÃ¼k, erÅsÃ­tsd meg, hogy csatlakoztÃ¡l az internetre",
		Progress: Progress$j,
		"Proportional Sans-Serif": "ArÃ¡nyos talpatlan betÅ±",
		"Proportional Serif": "ArÃ¡nyos talpas betÅ±",
		Purchased: Purchased$j,
		Raised: Raised$j,
		Red: Red$j,
		"Remaining Time": "HÃ¡tralevÅ idÅ",
		Replay: Replay$j,
		"Reset to Defaults": "Vissza alapÃ©rtelmezettre",
		Rewind: Rewind$j,
		Script: Script$j,
		second: second$j,
		seconds: seconds$j,
		"Seek to live": "ÃlÅ adÃ¡shoz",
		"Seek to live, currently playing live": "ÃlÅ adÃ¡shoz, jelenleg Ã©lÅben ad",
		"Select Broadcast": "KÃ¶zvetÃ­tÃ©s vÃ¡lasztÃ¡sa",
		"Semi-Opaque": "FÃ©lig Ã¡tlÃ¡tszatlan",
		"Semi-Transparent": "FÃ©lig Ã¡tlÃ¡tszÃ³",
		Send: Send$j,
		Settings: Settings$j,
		Share: Share$j,
		"Skip Ad": "HirdetÃ©s kihagyÃ¡sa",
		"Small Caps": "KiskapitÃ¡lis",
		"Start at": "Kezdd itt:",
		Stop: Stop$j,
		STREAM_LIMITED: STREAM_LIMITED$j,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$j,
		"Stream Type": "AdatfolyamtÃ­pus",
		"Subscribed to ESPN+": "ElÅfizetve az ESPN+-ra",
		Subtitles: Subtitles$j,
		"subtitles off": "feliratok ki",
		"Technical details": "Technikai rÃ©szletek",
		"Text Edge Style": "SzÃ¶vegperem stÃ­lusa",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "ElÃ©rted az egyidejÅ± adatfolyamok szÃ¡mÃ¡t a fiÃ³kodban. Ha bÃ¡rmilyen kÃ©rdÃ©sed van, vagy segÃ­tsÃ©gre van szÃ¼ksÃ©ged, lÃ¡togass el az es.pn/watchfaq oldalra, vagy hÃ­vd a 888-549-ESPN szÃ¡mot.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "A mÃ©diafÃ¡jlt nem lehetett betÃ¶lteni, mert a szerver vagy a hÃ¡lÃ³zat meghibÃ¡sodott, vagy mert a formÃ¡tum nem tÃ¡mogatott.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "A videokapcsolat megszakadt",
		"The video download was cancelled": "A videÃ³ letÃ¶ltÃ©se visszavonva",
		"The video is bad or in a format that cannot be played on your browser": "A videÃ³ rossz, vagy olyan formÃ¡tumÃº, amelyet nem lehet lejÃ¡tszani a bÃ¶ngÃ©szÅdben",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "A videÃ³ lejÃ¡tszÃ¡sa megszakadt sÃ©rÃ¼lÃ©s miatt, vagy azÃ©rt, mert a videÃ³ olyan funkciÃ³kat hasznÃ¡lt, amelyeket bÃ¶ngÃ©szÅd nem tÃ¡mogat.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "A megnÃ©zni kÃ­vÃ¡nt videÃ³ titkosÃ­tott, Ã©s nem tudjuk, hogyan kell visszafejteni",
		"This content is not available for your package or region.": "Ez a tartalom nem Ã©rhetÅ el csomagodban vagy rÃ©giÃ³dban.",
		"This video is either unavailable or not supported in this browser": "Ez a videÃ³ nem Ã©rhetÅ el, vagy nem tÃ¡mogatott ebben a bÃ¶ngÃ©szÅben",
		"This video is unavailable": "A videÃ³ nem Ã©rhetÅ el.",
		To: To$j,
		Transparent: Transparent$j,
		Uniform: Uniform$j,
		Unmute: Unmute$j,
		Unmuted: Unmuted$j,
		"Up Next": "KÃ¶vetkezÅ",
		"Video has expired.": "A videÃ³ lejÃ¡rt.",
		"Video is not available in your country.": "A videÃ³ nem Ã¡ll rendelkezÃ©sre az orszÃ¡godban.",
		"Video is not yet available.": "A videÃ³ mÃ©g nem elÃ©rhetÅ.",
		"Video Player": "VideolejÃ¡tszÃ³",
		Watch: Watch$j,
		"WATCH NOW": "MEGTEKINTÃS",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "SajnÃ¡ljuk, de ez a bÃ¶ngÃ©szÅ mÃ¡r nem tÃ¡mogatott. A tartalom megtekintÃ©sÃ©hez frissÃ­ts a Google Chrome, a FireFox vagy a Microsoft Edge legÃºjabb verziÃ³jÃ¡ra.",
		White: White$j,
		Window: Window$j,
		Yellow: Yellow$j,
		"You aborted the media playback": "MegszakÃ­tottad a videÃ³ lejÃ¡tszÃ¡sÃ¡t",
		"elapsed out of": "letelt ennyibÅl:"
	};

	var Ad$i = "Ad";
	var Autoplay$i = "Autoplay";
	var Background$i = "Background";
	var Black$i = "Black";
	var Blue$i = "Blue";
	var Button$i = "Button";
	var Captions$i = "Captions";
	var Casual$i = "Casual";
	var Chapters$i = "Chapters";
	var Copied$i = "Copied";
	var Copy$i = "Copy";
	var Cyan$i = "Cyan";
	var Default$i = "Default";
	var Depressed$i = "Depressed";
	var Done$i = "Done";
	var DRM_REQUIRED$i = "DRM_REQUIRED";
	var Email$i = "Email";
	var EMBARGOED$i = "EMBARGOED";
	var EXPIRED$i = "EXPIRED";
	var EXPIRED_CONTENT$i = "EXPIRED_CONTENT";
	var Foreground$i = "Foreground";
	var From$i = "From";
	var Fullscreen$i = "Fullscreen";
	var GEOLOCATION_NOT_ALLOWED$i = "GEOLOCATION_NOT_ALLOWED";
	var Green$i = "Green";
	var hour$i = "hour";
	var hours$i = "hours";
	var LIVE$i = "LIVE";
	var Loaded$i = "Loaded";
	var Magenta$i = "Magenta";
	var Menu$i = "Menu";
	var Message$i = "Message";
	var minute$i = "minute";
	var minutes$i = "minutes";
	var More$i = "More";
	var Mute$i = "Mute";
	var NOT_FOUND$i = "NOT_FOUND";
	var None$i = "None";
	var OK$i = "OK";
	var Opaque$i = "Opaque";
	var Pause$i = "Pause";
	var Pausing$i = "Pausing";
	var Play$i = "Play";
	var Playing$i = "Playing";
	var Progress$i = "Progress";
	var Purchased$i = "Purchased";
	var Raised$i = "Raised";
	var Red$i = "Red";
	var Replay$i = "Replay";
	var Rewind$i = "Rewind";
	var Script$i = "Script";
	var second$i = "second";
	var seconds$i = "seconds";
	var Send$i = "Send";
	var Settings$i = "Settings";
	var Share$i = "Share";
	var Stop$i = "Stop";
	var STREAM_LIMITED$i = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$i = "STREAM_LIMIT_ERROR";
	var Subtitles$i = "Subtitles";
	var To$i = "To";
	var Transparent$i = "Transparent";
	var Uniform$i = "Uniform";
	var Unmute$i = "Unmute";
	var Unmuted$i = "Unmuted";
	var Watch$i = "Watch";
	var White$i = "White";
	var Window$i = "Window";
	var Yellow$i = "Yellow";
	var hours_minutes_seconds_format$8 = "hours_minutes_seconds_format";
	var minutes_seconds_format$8 = "minutes_seconds_format";
	var id = {
		"A network error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
		Ad: Ad$i,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio Options",
		Autoplay: Autoplay$i,
		"Back to video": "Back to video",
		"Close share": "Close share",
		Background: Background$i,
		Black: Black$i,
		Blue: Blue$i,
		Button: Button$i,
		"Buy PPV": "Buy PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Caption Settings",
		Captions: Captions$i,
		"captions off": "captions off",
		"Captions Preview": "Captions Preview",
		Casual: Casual$i,
		Chapters: Chapters$i,
		"Check out this video on ESPN": "Check out this video on ESPN",
		"Choose Broadcast": "Choose Broadcast",
		"Choose TV Provider": "Choose TV Provider",
		"Closed Caption": "Closed Caption",
		"Closed Captions": "Closed Captions",
		Copied: Copied$i,
		Copy: Copy$i,
		"Copy Embed Link": "Copy Embed Link",
		"Copy Link": "Copy Link",
		"Could not download the video": "Could not download the video",
		"Current Time": "Current Time",
		"currently behind live": "currently behind live",
		Cyan: Cyan$i,
		Default: Default$i,
		Depressed: Depressed$i,
		Done: Done$i,
		DRM_REQUIRED: DRM_REQUIRED$i,
		"Drop shadow": "Drop shadow",
		"Duration Time": "Duration Time",
		Email: Email$i,
		"Email Video": "Email Video",
		EMBARGOED: EMBARGOED$i,
		"Embed Code": "Embed Code",
		"Error Code": "Error Code",
		"Exit Full Screen": "Exit Full Screen",
		EXPIRED: EXPIRED$i,
		EXPIRED_CONTENT: EXPIRED_CONTENT$i,
		"Fast Forward": "Fast Forward",
		"Font Family": "Font Family",
		"Font Size": "Font Size",
		Foreground: Foreground$i,
		From: From$i,
		Fullscreen: Fullscreen$i,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$i,
		"Get ESPN+": "Get ESPN+",
		"Get MLB.TV": "Get MLB.TV",
		Green: Green$i,
		hour: hour$i,
		hours: hours$i,
		"Language Settings": "Language Settings",
		"Learn More": "Learn More",
		LIVE: LIVE$i,
		Loaded: Loaded$i,
		"Logged Into TV Provider": "Logged Into TV Provider",
		Magenta: Magenta$i,
		Menu: Menu$i,
		Message: Message$i,
		minute: minute$i,
		minutes: minutes$i,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$i,
		Mute: Mute$i,
		NOT_FOUND: NOT_FOUND$i,
		"No compatible source was found for this media.": "No compatible source was found for this media.",
		"No video has been loaded": "No video has been loaded",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$i,
		"Now Playing": "Now Playing",
		OK: OK$i,
		Opaque: Opaque$i,
		Pause: Pause$i,
		Pausing: Pausing$i,
		Play: Play$i,
		"Playback Rate": "Playback Rate",
		"Playback Speed": "Playback Speed",
		Playing: Playing$i,
		"please confirm you are connected to the internet": "please confirm you are connected to the internet",
		Progress: Progress$i,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$i,
		Raised: Raised$i,
		Red: Red$i,
		"Remaining Time": "Remaining Time",
		Replay: Replay$i,
		"Reset to Defaults": "Reset to Defaults",
		Rewind: Rewind$i,
		Script: Script$i,
		second: second$i,
		seconds: seconds$i,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Select Broadcast": "Select Broadcast",
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send$i,
		Settings: Settings$i,
		Share: Share$i,
		"Skip Ad": "Skip Ad",
		"Small Caps": "Small Caps",
		"Start at": "Start at",
		Stop: Stop$i,
		STREAM_LIMITED: STREAM_LIMITED$i,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$i,
		"Stream Type": "Stream Type",
		"Subscribed to ESPN+": "Subscribed to ESPN+",
		Subtitles: Subtitles$i,
		"subtitles off": "subtitles off",
		"Technical details": "Technical details",
		"Text Edge Style": "Text Edge Style",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "The video download was cancelled",
		"The video is bad or in a format that cannot be played on your browser": "The video is bad or in a format that cannot be played on your browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "The video you are trying to watch is encrypted and we do not know how to decrypt it",
		"This content is not available for your package or region.": "This content is not available for your package or region.",
		"This video is either unavailable or not supported in this browser": "This video is either unavailable or not supported in this browser",
		"This video is unavailable": "This video is unavailable",
		To: To$i,
		Transparent: Transparent$i,
		Uniform: Uniform$i,
		Unmute: Unmute$i,
		Unmuted: Unmuted$i,
		"Up Next": "Up Next",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Video Player",
		Watch: Watch$i,
		"WATCH NOW": "WATCH NOW",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$i,
		Window: Window$i,
		Yellow: Yellow$i,
		"You aborted the media playback": "You aborted the media playback",
		"elapsed out of": "elapsed out of",
		hours_minutes_seconds_format: hours_minutes_seconds_format$8,
		minutes_seconds_format: minutes_seconds_format$8
	};

	var Ad$h = "PubblicitÃ ";
	var Autoplay$h = "Riproduzione automatica";
	var Background$h = "Sfondo";
	var Black$h = "Nero";
	var Blue$h = "Blu";
	var Button$h = "Pulsante";
	var Captions$h = "Didascalie";
	var Casual$h = "Casual";
	var Chapters$h = "Capitoli";
	var Copied$h = "Copiato";
	var Copy$h = "Copia";
	var Cyan$h = "Ciano";
	var Default$h = "Predefinito";
	var Depressed$h = "Premuto";
	var Done$h = "Fatto";
	var DRM_REQUIRED$h = "DRM_REQUIRED";
	var Email$h = "Email";
	var EMBARGOED$h = "EMBARGOED";
	var EXPIRED$h = "EXPIRED";
	var EXPIRED_CONTENT$h = "EXPIRED_CONTENT";
	var Foreground$h = "Primo piano";
	var From$h = "Da";
	var Fullscreen$h = "A tutto schermo";
	var GEOLOCATION_NOT_ALLOWED$h = "GEOLOCATION_NOT_ALLOWED";
	var Green$h = "Verde";
	var hour$h = "ora";
	var hours$h = "ore";
	var LIVE$h = "IN DIRETTA";
	var Loaded$h = "Caricato";
	var Magenta$h = "Magenta";
	var Menu$h = "Menu";
	var Message$h = "Messaggio";
	var minute$h = "minuto";
	var minutes$h = "minuti";
	var More$h = "Altro";
	var Mute$h = "Disattiva audio";
	var NOT_FOUND$h = "NOT_FOUND";
	var None$h = "No";
	var OK$h = "OK";
	var Opaque$h = "Opaco";
	var Pause$h = "Pausa";
	var Pausing$h = "In pausa";
	var Play$h = "Riproduci";
	var Playing$h = "Riproduzione in corso";
	var Progress$h = "Progressi";
	var Purchased$h = "Acquistato";
	var Raised$h = "In rilievo";
	var Red$h = "Rosso";
	var Replay$h = "Riproduci di nuovo";
	var Rewind$h = "Riavvolgi";
	var Script$h = "Script";
	var second$h = "secondo";
	var seconds$h = "secondi";
	var Send$h = "Invia";
	var Settings$h = "Impostazioni";
	var Share$h = "Condividi";
	var Stop$h = "Stop";
	var STREAM_LIMITED$h = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$h = "STREAM_LIMIT_ERROR";
	var Subtitles$h = "Sottotitoli";
	var To$h = "A";
	var Transparent$h = "Trasparente";
	var Uniform$h = "Uniforme";
	var Unmute$h = "Riattiva audio";
	var Unmuted$h = "Audio riattivato";
	var Watch$h = "Guarda";
	var White$h = "Bianco";
	var Window$h = "Finestra";
	var Yellow$h = "Giallo";
	var it = {
		"A network error caused the media download to fail part-way.": "Un errore di rete ha interrotto il download del video.",
		Ad: Ad$h,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Si Ã¨ verificato un errore durante la riproduzione del video. Possibili cause: si sono verificati problemi di connettivitÃ  di rete o hai deselezionato la scheda del browser con il video. Riprova.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Opzioni audio",
		Autoplay: Autoplay$h,
		"Back to video": "Torna al video",
		"Close share": "Close share",
		Background: Background$h,
		Black: Black$h,
		Blue: Blue$h,
		Button: Button$h,
		"Buy PPV": "Acquista PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Impostazioni delle didascalie",
		Captions: Captions$h,
		"captions off": "didascalie disattivate",
		"Captions Preview": "Anteprima delle didascalie",
		Casual: Casual$h,
		Chapters: Chapters$h,
		"Check out this video on ESPN": "Guarda questo video su ESPN",
		"Choose Broadcast": "Seleziona trasmissione",
		"Choose TV Provider": "Seleziona provider TV",
		"Closed Caption": "Didascalia",
		"Closed Captions": "Sottotitoli per non udenti",
		Copied: Copied$h,
		Copy: Copy$h,
		"Copy Embed Link": "Copia link di incorporazione",
		"Copy Link": "Copia link",
		"Could not download the video": "Could not download the video",
		"Current Time": "Ora attuale",
		"currently behind live": "attualmente in differita",
		Cyan: Cyan$h,
		Default: Default$h,
		Depressed: Depressed$h,
		Done: Done$h,
		DRM_REQUIRED: DRM_REQUIRED$h,
		"Drop shadow": "Elimina ombra",
		"Duration Time": "Durata",
		Email: Email$h,
		"Email Video": "Invia video tramite email",
		EMBARGOED: EMBARGOED$h,
		"Embed Code": "Codice di incorporazione",
		"Error Code": "Codice di errore",
		"Exit Full Screen": "Esci dalla modalitÃ  a tutto schermo",
		EXPIRED: EXPIRED$h,
		EXPIRED_CONTENT: EXPIRED_CONTENT$h,
		"Fast Forward": "Avanti veloce",
		"Font Family": "Tipo di carattere",
		"Font Size": "Dimensione dei caratteri",
		Foreground: Foreground$h,
		From: From$h,
		Fullscreen: Fullscreen$h,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$h,
		"Get ESPN+": "Ottieni ESPN+",
		"Get MLB.TV": "Ottieni MLB.TV",
		Green: Green$h,
		hour: hour$h,
		hours: hours$h,
		"Language Settings": "Impostazioni della lingua",
		"Learn More": "Scopri di piÃ¹",
		LIVE: LIVE$h,
		Loaded: Loaded$h,
		"Logged Into TV Provider": "Accesso al provider TV effettuato",
		Magenta: Magenta$h,
		Menu: Menu$h,
		Message: Message$h,
		minute: minute$h,
		minutes: minutes$h,
		"Monospace Sans-Serif": "Sans-Serif monospazio",
		"Monospace Serif": "Serif monospazio",
		More: More$h,
		Mute: Mute$h,
		NOT_FOUND: NOT_FOUND$h,
		"No compatible source was found for this media.": "Nessuna fonte compatibile trovata per questo video.",
		"No video has been loaded": "Nessun video caricato",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$h,
		"Now Playing": "Attualmente in riproduzione",
		OK: OK$h,
		Opaque: Opaque$h,
		Pause: Pause$h,
		Pausing: Pausing$h,
		Play: Play$h,
		"Playback Rate": "Frequenza di riproduzione",
		"Playback Speed": "VelocitÃ  di riproduzione",
		Playing: Playing$h,
		"please confirm you are connected to the internet": "verifica che il dispositivo sia connesso a Internet",
		Progress: Progress$h,
		"Proportional Sans-Serif": "Sans-Serif proporzionale",
		"Proportional Serif": "Serif proporzionale",
		Purchased: Purchased$h,
		Raised: Raised$h,
		Red: Red$h,
		"Remaining Time": "Tempo rimanente",
		Replay: Replay$h,
		"Reset to Defaults": "Ripristina le impostazioni predefinite",
		Rewind: Rewind$h,
		Script: Script$h,
		second: second$h,
		seconds: seconds$h,
		"Seek to live": "Mantieni la diretta",
		"Seek to live, currently playing live": "Mantieni la diretta, attualmente in diretta",
		"Select Broadcast": "Seleziona trasmissione",
		"Semi-Opaque": "Semi-opaco",
		"Semi-Transparent": "Semi-trasparente",
		Send: Send$h,
		Settings: Settings$h,
		Share: Share$h,
		"Skip Ad": "Salta pubblicitÃ ",
		"Small Caps": "Maiuscoletto",
		"Start at": "Inizia da",
		Stop: Stop$h,
		STREAM_LIMITED: STREAM_LIMITED$h,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$h,
		"Stream Type": "Tipo di streaming",
		"Subscribed to ESPN+": "Abbonato a ESPN+",
		Subtitles: Subtitles$h,
		"subtitles off": "sottotitoli disattivati",
		"Technical details": "Informazioni tecniche",
		"Text Edge Style": "Stile dei bordi del testo",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Ã stato raggiunto il numero massimo di visualizzazioni in streaming attive in contemporanea per il tuo account. Per domande o richieste di assistenza, vai su es.pn/watchfaq o chiama il numero 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Il contenuto multimediale non Ã¨ stato caricato. Possibili cause: si Ã¨ verificato un errore di rete o del server o il formato non Ã¨ supportato.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "Connessione video interrotta",
		"The video download was cancelled": "Download del video annullato",
		"The video is bad or in a format that cannot be played on your browser": "Il video Ã¨ danneggiato o il formato non Ã¨ supportato dal tuo browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "La riproduzione del video Ã¨ stata interrotta perchÃ© il video Ã¨ risultato danneggiato o perchÃ© il video utilizza funzionalitÃ  non supportate dal tuo browser.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Il video che stai cercando di visualizzare Ã¨ criptato e non sappiamo come decrittarlo",
		"This content is not available for your package or region.": "Questo contenuto non rientra nel tuo pacchetto o non Ã¨ disponibile nella tua area geografica.",
		"This video is either unavailable or not supported in this browser": "Questo video non Ã¨ disponibile o non Ã¨ supportato dal tuo browser",
		"This video is unavailable": "Questo video non Ã¨ disponibile",
		To: To$h,
		Transparent: Transparent$h,
		Uniform: Uniform$h,
		Unmute: Unmute$h,
		Unmuted: Unmuted$h,
		"Up Next": "A seguire",
		"Video has expired.": "Il video Ã¨ scaduto.",
		"Video is not available in your country.": "Questo video non Ã¨ disponibile nel tuo paese.",
		"Video is not yet available.": "Il video non Ã¨ ancora disponibile.",
		"Video Player": "Lettore video",
		Watch: Watch$h,
		"WATCH NOW": "GUARDA SUBITO",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Siamo spiacenti, ma questo browser non Ã¨ piÃ¹ supportato. Per visualizzare questo contenuto Ã¨ necessario aggiornare il proprio browser (Google Chrome, FireFox o Microsoft Edge) alla versione piÃ¹ recente.",
		White: White$h,
		Window: Window$h,
		Yellow: Yellow$h,
		"You aborted the media playback": "Hai interrotto la riproduzione video",
		"elapsed out of": "trascorsi/e su"
	};

	var Ad$g = "åºå";
	var Autoplay$g = "èªååç";
	var Background$g = "ããã¯ã°ã©ã¦ã³ã";
	var Black$g = "é»";
	var Blue$g = "é";
	var Button$g = "ãã¿ã³";
	var Captions$g = "ã­ã£ãã·ã§ã³";
	var Casual$g = "ã«ã¸ã¥ã¢ã«";
	var Chapters$g = "ã¨ãã½ã¼ã";
	var Copied$g = "ã³ãã¼æ¸ã¿";
	var Copy$g = "ã³ãã¼";
	var Cyan$g = "ã·ã¢ã³ï¼éç·ï¼";
	var Default$g = "ããã©ã«ã";
	var Depressed$g = "ãã¼ã¿æå­";
	var Done$g = "OK";
	var DRM_REQUIRED$g = "DRM_REQUIRED";
	var Email$g = "ã¡ã¼ã«ã¢ãã¬ã¹";
	var EMBARGOED$g = "EMBARGOED";
	var EXPIRED$g = "EXPIRED";
	var EXPIRED_CONTENT$g = "EXPIRED_CONTENT";
	var Foreground$g = "ãã©ã¢ã°ã©ã¦ã³ã";
	var From$g = "From";
	var Fullscreen$g = "å¨ç»é¢è¡¨ç¤º";
	var GEOLOCATION_NOT_ALLOWED$g = "GEOLOCATION_NOT_ALLOWED";
	var Green$g = "ç·";
	var hour$g = "æé";
	var hours$g = "æé";
	var LIVE$g = "ã©ã¤ãéä¿¡ä¸­";
	var Loaded$g = "èª­ã¿è¾¼ã¿æ¸ã¿";
	var Magenta$g = "ãã¼ã³ã¿ï¼èµ¤ç´«ï¼";
	var Menu$g = "ã¡ãã¥ã¼";
	var Message$g = "ã¡ãã»ã¼ã¸";
	var minute$g = "å";
	var minutes$g = "å";
	var More$g = "ãã®ä»";
	var Mute$g = "ãã¥ã¼ã";
	var NOT_FOUND$g = "NOT_FOUND";
	var None$g = "ãªã";
	var OK$g = "OK";
	var Opaque$g = "ä¸éæ";
	var Pause$g = "ä¸æåæ­¢";
	var Pausing$g = "ä¸æåæ­¢ä¸­";
	var Play$g = "åç";
	var Playing$g = "åçä¸­";
	var Progress$g = "é²è¡ç¶æ³";
	var Purchased$g = "è³¼å¥æ¸ã¿";
	var Raised$g = "æµ®ãåºãæå­";
	var Red$g = "èµ¤";
	var Replay$g = "ããä¸åº¦è¦ã";
	var Rewind$g = "æ©æ»ã";
	var Script$g = "ã¹ã¯ãªãã";
	var second$g = "ç§";
	var seconds$g = "ç§";
	var Send$g = "éä¿¡";
	var Settings$g = "è¨­å®";
	var Share$g = "ã·ã§ã¢";
	var Stop$g = "åæ­¢";
	var STREAM_LIMITED$g = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$g = "STREAM_LIMIT_ERROR";
	var Subtitles$g = "å­å¹è¨èª";
	var To$g = "To";
	var Transparent$g = "éæ";
	var Uniform$g = "åä¸";
	var Unmute$g = "ãã¥ã¼ãè§£é¤";
	var Unmuted$g = "ãã¥ã¼ããè§£é¤ãã¾ãã";
	var Watch$g = "ã¿ã";
	var White$g = "ç½";
	var Window$g = "æ ã®è²";
	var Yellow$g = "é»è²";
	var ja = {
		"A network error caused the media download to fail part-way.": "ãããã¯ã¼ã¯ã¨ã©ã¼ã«ããåç»ã®ãã¦ã³ã­ã¼ããå®äºãã¾ããã§ããã",
		Ad: Ad$g,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "ãããã¯ã¼ã¯æ¥ç¶ã«åé¡ãçºçããããããã¯ã°ã©ã¦ã³ã ãã©ã¦ã¶ã¿ãã«ãªã£ããããåç»ã®åçä¸­ã«ã¨ã©ã¼ãçºçãã¾ãããããä¸åº¦ãè©¦ããã ããã",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "é³å£°ãªãã·ã§ã³",
		Autoplay: Autoplay$g,
		"Back to video": "åç»ã«æ»ã",
		"Close share": "Close share",
		Background: Background$g,
		Black: Black$g,
		Blue: Blue$g,
		Button: Button$g,
		"Buy PPV": "PPV ãè³¼å¥ãã",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "ã­ã£ãã·ã§ã³ã®è¨­å®",
		Captions: Captions$g,
		"captions off": "ã­ã£ãã·ã§ã³ ãªã",
		"Captions Preview": "ã­ã£ãã·ã§ã³ã®ãã¬ãã¥ã¼",
		Casual: Casual$g,
		Chapters: Chapters$g,
		"Check out this video on ESPN": "ESPNã§ãã®åç»ãè¦ã",
		"Choose Broadcast": "ãã­ã¼ãã­ã£ã¹ããé¸æ",
		"Choose TV Provider": "ãã¬ããã­ãã¤ã",
		"Closed Caption": "ã¯ã­ã¼ãºãã­ã£ãã·ã§ã³",
		"Closed Captions": "ã¯ã­ã¼ãºãã­ã£ãã·ã§ã³",
		Copied: Copied$g,
		Copy: Copy$g,
		"Copy Embed Link": "åãè¾¼ã¿ãªã³ã¯ãã³ãã¼",
		"Copy Link": "ãªã³ã¯ãã³ãã¼",
		"Could not download the video": "Could not download the video",
		"Current Time": "ç¾å¨ã®æé",
		"currently behind live": "ç¾å¨ã©ã¤ãéä¿¡ãã¦ãã¾ãã",
		Cyan: Cyan$g,
		Default: Default$g,
		Depressed: Depressed$g,
		Done: Done$g,
		DRM_REQUIRED: DRM_REQUIRED$g,
		"Drop shadow": "ãã­ããã·ã£ãã¦",
		"Duration Time": "åçæé",
		Email: Email$g,
		"Email Video": "åç»ãã¡ã¼ã«ã§éä¿¡",
		EMBARGOED: EMBARGOED$g,
		"Embed Code": "åãè¾¼ã¿ã³ã¼ã",
		"Error Code": "ã¨ã©ã¼ã³ã¼ã",
		"Exit Full Screen": "å¨ç»é¢è¡¨ç¤ºãçµäº",
		EXPIRED: EXPIRED$g,
		EXPIRED_CONTENT: EXPIRED_CONTENT$g,
		"Fast Forward": "æ©éã",
		"Font Family": "ãã©ã³ã ãã¡ããªã¼",
		"Font Size": "ãã©ã³ããµã¤ãº",
		Foreground: Foreground$g,
		From: From$g,
		Fullscreen: Fullscreen$g,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$g,
		"Get ESPN+": "ESPN+ã«å å¥",
		"Get MLB.TV": "MLB.TVã«å å¥",
		Green: Green$g,
		hour: hour$g,
		hours: hours$g,
		"Language Settings": "è¨èªè¨­å®",
		"Learn More": "è©³ç´°",
		LIVE: LIVE$g,
		Loaded: Loaded$g,
		"Logged Into TV Provider": "ãã¬ããã­ãã¤ãã«ã­ã°ã¤ã³æ¸ã¿",
		Magenta: Magenta$g,
		Menu: Menu$g,
		Message: Message$g,
		minute: minute$g,
		minutes: minutes$g,
		"Monospace Sans-Serif": "ç­å¹ãµã³ã»ãªã",
		"Monospace Serif": "ç­å¹ã»ãªã",
		More: More$g,
		Mute: Mute$g,
		NOT_FOUND: NOT_FOUND$g,
		"No compatible source was found for this media.": "ãã®åç»ã¨äºææ§ã®ããã½ã¼ã¹ãè¦ã¤ããã¾ããã§ããã",
		"No video has been loaded": "èª­ã¿è¾¼ã¾ãã¦ããåç»ãããã¾ããã",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$g,
		"Now Playing": "åçä¸­",
		OK: OK$g,
		Opaque: Opaque$g,
		Pause: Pause$g,
		Pausing: Pausing$g,
		Play: Play$g,
		"Playback Rate": "åçéåº¦",
		"Playback Speed": "åçéåº¦",
		Playing: Playing$g,
		"please confirm you are connected to the internet": "ã¤ã³ã¿ã¼ãããã«æ¥ç¶ãã¦ãããã¨ããç¢ºèªãã ããã",
		Progress: Progress$g,
		"Proportional Sans-Serif": "ãã­ãã¼ã·ã§ãã«ãµã³ã»ãªã",
		"Proportional Serif": "ãã­ãã¼ã·ã§ãã« ã»ãªã",
		Purchased: Purchased$g,
		Raised: Raised$g,
		Red: Red$g,
		"Remaining Time": "æ®ãæé",
		Replay: Replay$g,
		"Reset to Defaults": "ããã©ã«ãã«ãªã»ãã",
		Rewind: Rewind$g,
		Script: Script$g,
		second: second$g,
		seconds: seconds$g,
		"Seek to live": "ã©ã¤ãéä¿¡ã¾ã§é²ã",
		"Seek to live, currently playing live": "ç¾å¨ã®ã©ã¤ãéä¿¡ã¾ã§é²ã",
		"Select Broadcast": "ãã­ã¼ãã­ã£ã¹ããé¸ã¶",
		"Semi-Opaque": "åéæ",
		"Semi-Transparent": "åéæ",
		Send: Send$g,
		Settings: Settings$g,
		Share: Share$g,
		"Skip Ad": "åºåãã¹ã­ãã",
		"Small Caps": "ã¹ã¢ã¼ã«ã­ã£ãã¿ã«",
		"Start at": "éå§æéï¼",
		Stop: Stop$g,
		STREAM_LIMITED: STREAM_LIMITED$g,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$g,
		"Stream Type": "éä¿¡æ¹æ³",
		"Subscribed to ESPN+": "ESPN+ã«å å¥",
		Subtitles: Subtitles$g,
		"subtitles off": "å­å¹ ãªã",
		"Technical details": "è©³ç´°ãªæè¡æå ±",
		"Text Edge Style": "ãã­ã¹ãè£é£¾ã¹ã¿ã¤ã«",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "ãå©ç¨ã®ã¢ã«ã¦ã³ãã§åæéä¿¡ã§ããä¸éã«éãã¾ããããè³ªåããä¸æãªç¹ããããã¾ãããããµã¤ãï¼es.pn/watchfaqï¼ããè¦§ããã ããã888-549-ESPNã¾ã§ãé»è©±ãã ããã",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "ã¡ãã£ã¢ãèª­ã¿è¾¼ãã¾ããããµã¼ãã¼ãã¾ãã¯ãããã¯ã¼ã¯ã«åé¡ãçºçããããå¯¾å¿ãã¦ããªããã©ã¼ãããã§ã",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "åç»ã®æ¥ç¶ãå¤±ããã¾ããã",
		"The video download was cancelled": "åç»ã®ãã¦ã³ã­ã¼ããã­ã£ã³ã»ã«ãã¾ããã",
		"The video is bad or in a format that cannot be played on your browser": "åç»ã«åé¡ããããããå©ç¨ã®ãã©ã¦ã¶ã§åçã§ããªããã©ã¼ãããã§ãã",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "åç»ãç ´æãã¦ãããããå©ç¨ã®ãã©ã¦ã¶ãå¯¾å¿ãã¦ããªãæ©è½ãä½¿ç¨ããã¦ããããåçãä¸­æ­ããã¾ããã",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "ãã®åç»ã¯æå·åããã¦ãã¾ããå¾©å·åã§ããªãããè¦è´ã§ãã¾ããã",
		"This content is not available for your package or region.": "ãå©ç¨ã®ããã±ã¼ã¸ãã¾ãã¯ãä½ãã®å½ãå°åã§ã¯å©ç¨ã§ããªãã³ã³ãã³ãã§ãã",
		"This video is either unavailable or not supported in this browser": "è¦è´ã§ããªãåç»ãã¾ãã¯ãã©ã¦ã¶ã§å¯¾å¿ãã¦ããªãåç»ã§ãã",
		"This video is unavailable": "ãã®åç»ã¯è¦è´ã§ãã¾ããã",
		To: To$g,
		Transparent: Transparent$g,
		Uniform: Uniform$g,
		Unmute: Unmute$g,
		Unmuted: Unmuted$g,
		"Up Next": "æ¬¡ã®åç»",
		"Video has expired.": "åç»ãæéåãã«ãªãã¾ããã",
		"Video is not available in your country.": "ãä½ã¾ãã®å½ã§ã¯è¦è´ã§ããªãåç»ã§ãã",
		"Video is not yet available.": "ã¾ã è¦è´ã§ããªãåç»ã§ãã",
		"Video Player": "åç»ãã¬ã¤ã¤ã¼",
		Watch: Watch$g,
		"WATCH NOW": "ä»ããã¿ã",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "ãã®ãã©ã¦ã¶ã¯ç¾å¨å¯¾å¿ãã¦ãã¾ããããã®ã³ã³ãã³ããè¦è´ããã«ã¯Google ChromeãFireFoxãã¾ãã¯Microsoft Edgeã®ææ°ãã¼ã¸ã§ã³ã«ã¢ããã°ã¬ã¼ããã¦ãã ããã",
		White: White$g,
		Window: Window$g,
		Yellow: Yellow$g,
		"You aborted the media playback": "åç»ã®åçãä¸­æ­ãã¾ãã"
	};

	var Ad$f = "ê´ê³ ";
	var Autoplay$f = "ìë ì¬ì";
	var Background$f = "ë°°ê²½";
	var Black$f = "ê²ìì";
	var Blue$f = "íëì";
	var Button$f = "ë²í¼";
	var Captions$f = "ìë§";
	var Casual$f = "ìºì£¼ì¼";
	var Chapters$f = "ì±í°";
	var Copied$f = "ë³µì¬ë¨";
	var Copy$f = "ë³µì¬";
	var Cyan$f = "ììì";
	var Default$f = "ê¸°ë³¸";
	var Depressed$f = "ì¤ëª©";
	var Done$f = "ìë£";
	var DRM_REQUIRED$f = "DRM_REQUIRED";
	var Email$f = "ì´ë©ì¼";
	var EMBARGOED$f = "EMBARGOED";
	var EXPIRED$f = "EXPIRED";
	var EXPIRED_CONTENT$f = "EXPIRED_CONTENT";
	var Foreground$f = "ì ê²½";
	var From$f = "From";
	var Fullscreen$f = "ì ì²´ íë©´";
	var GEOLOCATION_NOT_ALLOWED$f = "GEOLOCATION_NOT_ALLOWED";
	var Green$f = "ì´ë¡ì";
	var hour$f = "ìê°";
	var hours$f = "ìê°";
	var LIVE$f = "ìì¤ê³";
	var Loaded$f = "ë¡ëë¨";
	var Magenta$f = "ë§ì  íì";
	var Menu$f = "ë©ë´";
	var Message$f = "ë©ìì§";
	var minute$f = "ë¶";
	var minutes$f = "ë¶";
	var More$f = "ë ë³´ê¸°";
	var Mute$f = "ììê±°";
	var NOT_FOUND$f = "NOT_FOUND";
	var None$f = "ìì";
	var OK$f = "íì¸";
	var Opaque$f = "ë¶í¬ëª";
	var Pause$f = "ì¼ì ì¤ì§";
	var Pausing$f = "ì¼ì ì¤ì§";
	var Play$f = "ì¬ì";
	var Playing$f = "ì¬ì ì¤";
	var Progress$f = "ì§í ìí";
	var Purchased$f = "êµ¬ë§¤ ìë£";
	var Raised$f = "ë³¼ë¡";
	var Red$f = "ë¹¨ëì";
	var Replay$f = "ë¤ì ì¬ì";
	var Rewind$f = "ëê°ê¸°";
	var Script$f = "ì¤í¬ë¦½í¸";
	var second$f = "ì´";
	var seconds$f = "ì´";
	var Send$f = "ë³´ë´ê¸°";
	var Settings$f = "ì¤ì ";
	var Share$f = "ê³µì ";
	var Stop$f = "ì¤ì§";
	var STREAM_LIMITED$f = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$f = "STREAM_LIMIT_ERROR";
	var Subtitles$f = "ìë§";
	var To$f = "To";
	var Transparent$f = "í¬ëª";
	var Uniform$f = "ê· ë±";
	var Unmute$f = "ììê±° í´ì ";
	var Unmuted$f = "ììê±° í´ì ë¨";
	var Watch$f = "ìì²­";
	var White$f = "í°ì";
	var Window$f = "ì°½";
	var Yellow$f = "ë¸ëì";
	var ko = {
		"A network error caused the media download to fail part-way.": "ë¤í¸ìí¬ ì¤ë¥ë¡ ì¸í´ ìì ì ì¥ì´ ì¤ë¨ëììµëë¤.",
		Ad: Ad$f,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "ìì ì¬ì ì¤ ì¤ë¥ê° ë°ìíìµëë¤. ë¤í¸ìí¬ ì°ê²° ìí ëë ë°°ê²½ ë¸ë¼ì°ì  í­ ë´ ì¬ìì¼ë¡ ì¸í ì¤ë¥ì¼ ê°ë¥ì±ì´ ììµëë¤. ë¤ì ìëí´ ì£¼ì¸ì.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "ì¤ëì¤ ìµì",
		Autoplay: Autoplay$f,
		"Back to video": "ììì¼ë¡ ëìê°ê¸°",
		"Close share": "Close share",
		Background: Background$f,
		Black: Black$f,
		Blue: Blue$f,
		Button: Button$f,
		"Buy PPV": "PPV êµ¬ë§¤",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "ìë§ ì¤ì ",
		Captions: Captions$f,
		"captions off": "ìë§ ëê¸°",
		"Captions Preview": "ìë§ ë¯¸ë¦¬ë³´ê¸°",
		Casual: Casual$f,
		Chapters: Chapters$f,
		"Check out this video on ESPN": "ESPNìì ì´ ìì ë³´ê¸°",
		"Choose Broadcast": "ë°©ì¡ ì í",
		"Choose TV Provider": "TV ìë¹ì¤ìì²´ ì í",
		"Closed Caption": "ì í ìë§",
		"Closed Captions": "ì í ìë§",
		Copied: Copied$f,
		Copy: Copy$f,
		"Copy Embed Link": "Embed ë§í¬ ë³µì¬",
		"Copy Link": "ë§í¬ ë³µì¬",
		"Could not download the video": "Could not download the video",
		"Current Time": "íì¬ ìê°",
		"currently behind live": "íì¬ ìì¤ê³ ìê°ìì ë¤ì²ì§",
		Cyan: Cyan$f,
		Default: Default$f,
		Depressed: Depressed$f,
		Done: Done$f,
		DRM_REQUIRED: DRM_REQUIRED$f,
		"Drop shadow": "ê·¸ë¦¼ì í¨ê³¼",
		"Duration Time": "ì´ ìê°",
		Email: Email$f,
		"Email Video": "ì´ë©ì¼ë¡ ìì ì ì¡",
		EMBARGOED: EMBARGOED$f,
		"Embed Code": "Embed ì½ë",
		"Error Code": "ì¤ë¥ ì½ë",
		"Exit Full Screen": "ì ì²´ íë©´ ëê°ê¸°",
		EXPIRED: EXPIRED$f,
		EXPIRED_CONTENT: EXPIRED_CONTENT$f,
		"Fast Forward": "ë¹¨ë¦¬ ê°ê¸°",
		"Font Family": "í°í¸ í¨ë°ë¦¬",
		"Font Size": "í°í¸ í¬ê¸°",
		Foreground: Foreground$f,
		From: From$f,
		Fullscreen: Fullscreen$f,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$f,
		"Get ESPN+": "ESPN+ ê°ì",
		"Get MLB.TV": "MLB.TV ê°ì",
		Green: Green$f,
		hour: hour$f,
		hours: hours$f,
		"Language Settings": "ì¸ì´ ì¤ì ",
		"Learn More": "ë ììë³´ê¸°",
		LIVE: LIVE$f,
		Loaded: Loaded$f,
		"Logged Into TV Provider": "TV ìë¹ì¤ìì²´ì ë¡ê·¸ì¸ë¨",
		Magenta: Magenta$f,
		Menu: Menu$f,
		Message: Message$f,
		minute: minute$f,
		minutes: minutes$f,
		"Monospace Sans-Serif": "ê³ ì í­ ì°ì¸ë¦¬í",
		"Monospace Serif": "ê³ ì í­ ì¸ë¦¬í",
		More: More$f,
		Mute: Mute$f,
		NOT_FOUND: NOT_FOUND$f,
		"No compatible source was found for this media.": "ì´ ììì í¸íëë ìì¤ê° ììµëë¤.",
		"No video has been loaded": "ë¡ëë ììì´ ììµëë¤",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$f,
		"Now Playing": "ì§ê¸ ì¬ì",
		OK: OK$f,
		Opaque: Opaque$f,
		Pause: Pause$f,
		Pausing: Pausing$f,
		Play: Play$f,
		"Playback Rate": "ì¬ì ìë",
		"Playback Speed": "ì¬ì ìë",
		Playing: Playing$f,
		"please confirm you are connected to the internet": "ì¸í°ë·ì ì°ê²°ëì´ ìëì§ íì¸í´ ì£¼ì¸ì",
		Progress: Progress$f,
		"Proportional Sans-Serif": "ê°ë³í­ ì°ì¸ë¦¬í",
		"Proportional Serif": "ê°ë³í­ ì¸ë¦¬í",
		Purchased: Purchased$f,
		Raised: Raised$f,
		Red: Red$f,
		"Remaining Time": "ë¨ì ìê°",
		Replay: Replay$f,
		"Reset to Defaults": "ê¸°ë³¸ì¼ë¡ ì¬ì¤ì ",
		Rewind: Rewind$f,
		Script: Script$f,
		second: second$f,
		seconds: seconds$f,
		"Seek to live": "ìì¤ê³ íë©´ì¼ë¡ ì´ë",
		"Seek to live, currently playing live": "ìì¤ê³ íë©´ì¼ë¡ ì´ë, íì¬ ìì¤ê³ íë©´ ì¬ì",
		"Select Broadcast": "ë°©ì¡ ì í",
		"Semi-Opaque": "ë°ë¶í¬ëª",
		"Semi-Transparent": "ë°í¬ëª",
		Send: Send$f,
		Settings: Settings$f,
		Share: Share$f,
		"Skip Ad": "ê´ê³  ê±´ëë°ê¸°",
		"Small Caps": "ìì ëë¬¸ì",
		"Start at": "ìì ìê°:",
		Stop: Stop$f,
		STREAM_LIMITED: STREAM_LIMITED$f,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$f,
		"Stream Type": "ì¤í¸ë¦¬ë° ì í",
		"Subscribed to ESPN+": "ESPN+ ê°ì ìë£",
		Subtitles: Subtitles$f,
		"subtitles off": "ìë§ ëê¸°",
		"Technical details": "ê¸°ì  ì¸ë¶ ì¬í­",
		"Text Edge Style": "í°í¸ íëë¦¬ ì¤íì¼",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "íìë ê³ì ìì ê°ë¥í ìµë ëì ì¤í¸ë¦¬ë° ìì ëë¬íìµëë¤. ë¬¸ìí  ì ì´ ìê±°ë ëìì´ íìí ê²½ì° es.pn/watchfaqë¥¼ ë°©ë¬¸íê±°ë 888-549-ESPNë²ì¼ë¡ ì íí´ ì£¼ìê¸° ë°ëëë¤.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "ë¯¸ëì´ë¥¼ ë¡ëí  ì ììµëë¤. ìë²ë ë¤í¸ìí¬ ì¤ë¥ê° ë°ìíê±°ë íìì´ ì§ìëì§ ììµëë¤.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "ìì ì°ê²°ì´ ëê²¼ìµëë¤",
		"The video download was cancelled": "ìì ì ì¥ì´ ì·¨ìëììµëë¤",
		"The video is bad or in a format that cannot be played on your browser": "ìíê° ë¶ëíê±°ë ë¸ë¼ì°ì ìì ì¬ì ë¶ê°ë¥í íìì ìììëë¤",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "ìì ë¬¸ì  ëë ë¸ë¼ì°ì ìì ì§ìëì§ ìë ìì ê¸°ë¥ì¼ë¡ ì¸í´ ìì ì¬ìì´ ì¤ë¨ëììµëë¤.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "ìì²­íë ¤ë ììì´ ìí¸íëì´ ìì¼ë©° ìí¸ í´ëì´ ë¶ê°ë¥í©ëë¤",
		"This content is not available for your package or region.": "í¨í¤ì§ì í¬í¨ëì§ ìê±°ë ê±°ì£¼ ì§ì­ìì ìì²­ ë¶ê°í ì½íì¸ ìëë¤.",
		"This video is either unavailable or not supported in this browser": "ìì²­í  ì ìê±°ë ë¸ë¼ì°ì ìì ì§ìëì§ ìë ìììëë¤",
		"This video is unavailable": "ìì²­í  ì ìë ìììëë¤",
		To: To$f,
		Transparent: Transparent$f,
		Uniform: Uniform$f,
		Unmute: Unmute$f,
		Unmuted: Unmuted$f,
		"Up Next": "ë¤ì ì¬ì",
		"Video has expired.": "ì¬ì© ê¸°ê°ì´ ë§ë£ë ìììëë¤.",
		"Video is not available in your country.": "íì¬ ê±°ì£¼íê³  ê³ì  êµ­ê°ìì ìì²­í  ì ìë ìììëë¤.",
		"Video is not yet available.": "ìì§ ìì²­í  ì ìë ìììëë¤.",
		"Video Player": "ìì íë ì´ì´",
		Watch: Watch$f,
		"WATCH NOW": "ì§ê¸ ìì²­",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "ì£ì¡í©ëë¤. ì´ ë¸ë¼ì°ì ê° ë ì´ì ì§ìëì§ ììµëë¤. ì´ ì½íì¸ ë¥¼ ìì²­íë ¤ë©´ ìµì  ë²ì ì Google Chrome, FireFox ëë Microsoft Edgeë¡ ìê·¸ë ì´ëíì¸ì.",
		White: White$f,
		Window: Window$f,
		Yellow: Yellow$f,
		"You aborted the media playback": "ìì ì¬ìì ì¤ë¨íìµëë¤"
	};

	var Ad$e = "Ad";
	var Autoplay$e = "Autoplay";
	var Background$e = "Background";
	var Black$e = "Black";
	var Blue$e = "Blue";
	var Button$e = "Button";
	var Captions$e = "Captions";
	var Casual$e = "Casual";
	var Chapters$e = "Chapters";
	var Copied$e = "Copied";
	var Copy$e = "Copy";
	var Cyan$e = "Cyan";
	var Default$e = "Default";
	var Depressed$e = "Depressed";
	var Done$e = "Done";
	var DRM_REQUIRED$e = "DRM_REQUIRED";
	var Email$e = "Email";
	var EMBARGOED$e = "EMBARGOED";
	var EXPIRED$e = "EXPIRED";
	var EXPIRED_CONTENT$e = "EXPIRED_CONTENT";
	var Foreground$e = "Foreground";
	var From$e = "From";
	var Fullscreen$e = "Fullscreen";
	var GEOLOCATION_NOT_ALLOWED$e = "GEOLOCATION_NOT_ALLOWED";
	var Green$e = "Green";
	var hour$e = "hour";
	var hours$e = "hours";
	var LIVE$e = "LIVE";
	var Loaded$e = "Loaded";
	var Magenta$e = "Magenta";
	var Menu$e = "Menu";
	var Message$e = "Message";
	var minute$e = "minute";
	var minutes$e = "minutes";
	var More$e = "More";
	var Mute$e = "Mute";
	var NOT_FOUND$e = "NOT_FOUND";
	var None$e = "None";
	var OK$e = "OK";
	var Opaque$e = "Opaque";
	var Pause$e = "Pause";
	var Pausing$e = "Pausing";
	var Play$e = "Play";
	var Playing$e = "Playing";
	var Progress$e = "Progress";
	var Purchased$e = "Purchased";
	var Raised$e = "Raised";
	var Red$e = "Red";
	var Replay$e = "Replay";
	var Rewind$e = "Rewind";
	var Script$e = "Script";
	var second$e = "second";
	var seconds$e = "seconds";
	var Send$e = "Send";
	var Settings$e = "Settings";
	var Share$e = "Share";
	var Stop$e = "Stop";
	var STREAM_LIMITED$e = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$e = "STREAM_LIMIT_ERROR";
	var Subtitles$e = "Subtitles";
	var To$e = "To";
	var Transparent$e = "Transparent";
	var Uniform$e = "Uniform";
	var Unmute$e = "Unmute";
	var Unmuted$e = "Unmuted";
	var Watch$e = "Watch";
	var White$e = "White";
	var Window$e = "Window";
	var Yellow$e = "Yellow";
	var hours_minutes_seconds_format$7 = "hours_minutes_seconds_format";
	var minutes_seconds_format$7 = "minutes_seconds_format";
	var ms = {
		"A network error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
		Ad: Ad$e,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio Options",
		Autoplay: Autoplay$e,
		"Back to video": "Back to video",
		"Close share": "Close share",
		Background: Background$e,
		Black: Black$e,
		Blue: Blue$e,
		Button: Button$e,
		"Buy PPV": "Buy PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Caption Settings",
		Captions: Captions$e,
		"captions off": "captions off",
		"Captions Preview": "Captions Preview",
		Casual: Casual$e,
		Chapters: Chapters$e,
		"Check out this video on ESPN": "Check out this video on ESPN",
		"Choose Broadcast": "Choose Broadcast",
		"Choose TV Provider": "Choose TV Provider",
		"Closed Caption": "Closed Caption",
		"Closed Captions": "Closed Captions",
		Copied: Copied$e,
		Copy: Copy$e,
		"Copy Embed Link": "Copy Embed Link",
		"Copy Link": "Copy Link",
		"Could not download the video": "Could not download the video",
		"Current Time": "Current Time",
		"currently behind live": "currently behind live",
		Cyan: Cyan$e,
		Default: Default$e,
		Depressed: Depressed$e,
		Done: Done$e,
		DRM_REQUIRED: DRM_REQUIRED$e,
		"Drop shadow": "Drop shadow",
		"Duration Time": "Duration Time",
		Email: Email$e,
		"Email Video": "Email Video",
		EMBARGOED: EMBARGOED$e,
		"Embed Code": "Embed Code",
		"Error Code": "Error Code",
		"Exit Full Screen": "Exit Full Screen",
		EXPIRED: EXPIRED$e,
		EXPIRED_CONTENT: EXPIRED_CONTENT$e,
		"Fast Forward": "Fast Forward",
		"Font Family": "Font Family",
		"Font Size": "Font Size",
		Foreground: Foreground$e,
		From: From$e,
		Fullscreen: Fullscreen$e,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$e,
		"Get ESPN+": "Get ESPN+",
		"Get MLB.TV": "Get MLB.TV",
		Green: Green$e,
		hour: hour$e,
		hours: hours$e,
		"Language Settings": "Language Settings",
		"Learn More": "Learn More",
		LIVE: LIVE$e,
		Loaded: Loaded$e,
		"Logged Into TV Provider": "Logged Into TV Provider",
		Magenta: Magenta$e,
		Menu: Menu$e,
		Message: Message$e,
		minute: minute$e,
		minutes: minutes$e,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$e,
		Mute: Mute$e,
		NOT_FOUND: NOT_FOUND$e,
		"No compatible source was found for this media.": "No compatible source was found for this media.",
		"No video has been loaded": "No video has been loaded",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$e,
		"Now Playing": "Now Playing",
		OK: OK$e,
		Opaque: Opaque$e,
		Pause: Pause$e,
		Pausing: Pausing$e,
		Play: Play$e,
		"Playback Rate": "Playback Rate",
		"Playback Speed": "Playback Speed",
		Playing: Playing$e,
		"please confirm you are connected to the internet": "please confirm you are connected to the internet",
		Progress: Progress$e,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$e,
		Raised: Raised$e,
		Red: Red$e,
		"Remaining Time": "Remaining Time",
		Replay: Replay$e,
		"Reset to Defaults": "Reset to Defaults",
		Rewind: Rewind$e,
		Script: Script$e,
		second: second$e,
		seconds: seconds$e,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Select Broadcast": "Select Broadcast",
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send$e,
		Settings: Settings$e,
		Share: Share$e,
		"Skip Ad": "Skip Ad",
		"Small Caps": "Small Caps",
		"Start at": "Start at",
		Stop: Stop$e,
		STREAM_LIMITED: STREAM_LIMITED$e,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$e,
		"Stream Type": "Stream Type",
		"Subscribed to ESPN+": "Subscribed to ESPN+",
		Subtitles: Subtitles$e,
		"subtitles off": "subtitles off",
		"Technical details": "Technical details",
		"Text Edge Style": "Text Edge Style",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "The video download was cancelled",
		"The video is bad or in a format that cannot be played on your browser": "The video is bad or in a format that cannot be played on your browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "The video you are trying to watch is encrypted and we do not know how to decrypt it",
		"This content is not available for your package or region.": "This content is not available for your package or region.",
		"This video is either unavailable or not supported in this browser": "This video is either unavailable or not supported in this browser",
		"This video is unavailable": "This video is unavailable",
		To: To$e,
		Transparent: Transparent$e,
		Uniform: Uniform$e,
		Unmute: Unmute$e,
		Unmuted: Unmuted$e,
		"Up Next": "Up Next",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Video Player",
		Watch: Watch$e,
		"WATCH NOW": "WATCH NOW",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$e,
		Window: Window$e,
		Yellow: Yellow$e,
		"You aborted the media playback": "You aborted the media playback",
		"elapsed out of": "elapsed out of",
		hours_minutes_seconds_format: hours_minutes_seconds_format$7,
		minutes_seconds_format: minutes_seconds_format$7
	};

	var Ad$d = "Reklame";
	var Autoplay$d = "Automatisk avspilling";
	var Background$d = "Bakgrunn";
	var Black$d = "Sort";
	var Blue$d = "BlÃ¥";
	var Button$d = "Knapp";
	var Captions$d = "Undertekster";
	var Casual$d = "OrdinÃ¦r";
	var Chapters$d = "Kapitler";
	var Copied$d = "Kopiert";
	var Copy$d = "Kopier";
	var Cyan$d = "Cyan";
	var Default$d = "Standard";
	var Depressed$d = "Inntrykket";
	var Done$d = "Ferdig";
	var DRM_REQUIRED$d = "DRM_REQUIRED";
	var Email$d = "E-post";
	var EMBARGOED$d = "EMBARGOED";
	var EXPIRED$d = "EXPIRED";
	var EXPIRED_CONTENT$d = "EXPIRED_CONTENT";
	var Foreground$d = "Forgrunn";
	var From$d = "Fra";
	var Fullscreen$d = "Fullskjerm";
	var GEOLOCATION_NOT_ALLOWED$d = "GEOLOCATION_NOT_ALLOWED";
	var Green$d = "GrÃ¸nn";
	var hour$d = "time";
	var hours$d = "timer";
	var LIVE$d = "DIREKTE";
	var Loaded$d = "Innlastet";
	var Magenta$d = "Magenta";
	var Menu$d = "Meny";
	var Message$d = "Melding";
	var minute$d = "minutt";
	var minutes$d = "minutter";
	var More$d = "Mer";
	var Mute$d = "Demp";
	var NOT_FOUND$d = "NOT_FOUND";
	var None$d = "Ingen";
	var OK$d = "OK";
	var Opaque$d = "Gjennomsiktig";
	var Pause$d = "Pause";
	var Pausing$d = "Pauser";
	var Play$d = "Spill av";
	var Playing$d = "Spiller";
	var Progress$d = "Fremdrift";
	var Purchased$d = "KjÃ¸pt";
	var Raised$d = "Innsamlet";
	var Red$d = "RÃ¸d";
	var Replay$d = "Reprise";
	var Rewind$d = "Spol tilbake";
	var Script$d = "Skript";
	var second$d = "sekund";
	var seconds$d = "sekunder";
	var Send$d = "Send";
	var Settings$d = "Innstillinger";
	var Share$d = "Del";
	var Stop$d = "Stopp";
	var STREAM_LIMITED$d = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$d = "STREAM_LIMIT_ERROR";
	var Subtitles$d = "Undertekster";
	var To$d = "Til";
	var Transparent$d = "Gjennomsiktig";
	var Uniform$d = "Uniform";
	var Unmute$d = "Fjern demping";
	var Unmuted$d = "Demping fjernet";
	var Watch$d = "Se";
	var White$d = "Hvit";
	var Window$d = "Vindu";
	var Yellow$d = "Gul";
	var nb = {
		"A network error caused the media download to fail part-way.": "En nettverksfeil gjorde at nedlastingen av videoen feilet.",
		Ad: Ad$d,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "En feil oppstod under avspillingen av video. Problemet oppstod kanskje pÃ¥ grunn av tilkoblingsproblemer eller ved at fanen ble lagt i bakgrunnen. PrÃ¸v igjen.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Lydinnstillinger",
		Autoplay: Autoplay$d,
		"Back to video": "Tilbake til video",
		"Close share": "Close share",
		Background: Background$d,
		Black: Black$d,
		Blue: Blue$d,
		Button: Button$d,
		"Buy PPV": "KjÃ¸p PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Innstillinger for undertekster",
		Captions: Captions$d,
		"captions off": "undertekster av",
		"Captions Preview": "ForhÃ¥ndsvisning av undertekster",
		Casual: Casual$d,
		Chapters: Chapters$d,
		"Check out this video on ESPN": "Se denne videoen pÃ¥ ESPN",
		"Choose Broadcast": "Velg kringkasting",
		"Choose TV Provider": "Velg TV-leverandÃ¸r",
		"Closed Caption": "Undertekst",
		"Closed Captions": "Undertekster",
		Copied: Copied$d,
		Copy: Copy$d,
		"Copy Embed Link": "Kopier integreringslenke",
		"Copy Link": "Kopier lenke",
		"Could not download the video": "Could not download the video",
		"Current Time": "Tid akkurat nÃ¥",
		"currently behind live": "henger for Ã¸yeblikket etter direktesendingen",
		Cyan: Cyan$d,
		Default: Default$d,
		Depressed: Depressed$d,
		Done: Done$d,
		DRM_REQUIRED: DRM_REQUIRED$d,
		"Drop shadow": "Droppskygge",
		"Duration Time": "Varighet",
		Email: Email$d,
		"Email Video": "E-postvideo",
		EMBARGOED: EMBARGOED$d,
		"Embed Code": "Integreringskode",
		"Error Code": "Feilkode",
		"Exit Full Screen": "Avslutt fullskjerm",
		EXPIRED: EXPIRED$d,
		EXPIRED_CONTENT: EXPIRED_CONTENT$d,
		"Fast Forward": "Spol fremover",
		"Font Family": "Fontfamilie",
		"Font Size": "FontstÃ¸rrelse",
		Foreground: Foreground$d,
		From: From$d,
		Fullscreen: Fullscreen$d,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$d,
		"Get ESPN+": "Skaff ESPN+",
		"Get MLB.TV": "Skaff MLB.TV",
		Green: Green$d,
		hour: hour$d,
		hours: hours$d,
		"Language Settings": "SprÃ¥kinnstillinger",
		"Learn More": "Finn ut mer",
		LIVE: LIVE$d,
		Loaded: Loaded$d,
		"Logged Into TV Provider": "Logget pÃ¥ TV-leverandÃ¸r",
		Magenta: Magenta$d,
		Menu: Menu$d,
		Message: Message$d,
		minute: minute$d,
		minutes: minutes$d,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$d,
		Mute: Mute$d,
		NOT_FOUND: NOT_FOUND$d,
		"No compatible source was found for this media.": "Ingen kompatible kilde ble funnet for denne videoen.",
		"No video has been loaded": "Ingen video har blitt lastet inn",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$d,
		"Now Playing": "Spiller nÃ¥",
		OK: OK$d,
		Opaque: Opaque$d,
		Pause: Pause$d,
		Pausing: Pausing$d,
		Play: Play$d,
		"Playback Rate": "Avspillingsrate",
		"Playback Speed": "Avspillingshastighet",
		Playing: Playing$d,
		"please confirm you are connected to the internet": "bekreft at du er koblet til internett",
		Progress: Progress$d,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$d,
		Raised: Raised$d,
		Red: Red$d,
		"Remaining Time": "GjenvÃ¦rende tid",
		Replay: Replay$d,
		"Reset to Defaults": "Tilbakestill til standardinnstillinger",
		Rewind: Rewind$d,
		Script: Script$d,
		second: second$d,
		seconds: seconds$d,
		"Seek to live": "GÃ¥ til direktesending",
		"Seek to live, currently playing live": "GÃ¥ til direktesending, spiller av direkte",
		"Select Broadcast": "Velg kringkasting",
		"Semi-Opaque": "Delvis gjennomsiktig",
		"Semi-Transparent": "Delvis gjennomsiktig",
		Send: Send$d,
		Settings: Settings$d,
		Share: Share$d,
		"Skip Ad": "Hopp over reklame",
		"Small Caps": "SmÃ¥ bokstaver",
		"Start at": "Start pÃ¥",
		Stop: Stop$d,
		STREAM_LIMITED: STREAM_LIMITED$d,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$d,
		"Stream Type": "StrÃ¸mmetype",
		"Subscribed to ESPN+": "Abonnerer pÃ¥ ESPN+",
		Subtitles: Subtitles$d,
		"subtitles off": "undertekster av",
		"Technical details": "Teknisk informasjon",
		"Text Edge Style": "Kantstil for tekst",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Det maksimale antallet strÃ¸mminger samtidig har blitt nÃ¥dd for denne kontoen. Om du har noen spÃ¸rsmÃ¥l eller trenger hjelp kan du gÃ¥ til es.pn/watchfaq eller ringe 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Kunne ikke laste inn media. Dette kan vÃ¦re fordi serveren eller nettverket sviktet, eller fordi formatet ikke stÃ¸ttes.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "Videotilkoblingen er tapt",
		"The video download was cancelled": "Videonedlastingen ble kansellert",
		"The video is bad or in a format that cannot be played on your browser": "Det er enten noe feil ved videoen eller den er i et format som ikke kan bli spilt av i nettleseren din",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Videoavspillingen ble avbrutt pÃ¥ grunn av korrupsjonsproblem eller fordi videoen brukte funksjoner som nettleseren din ikke stÃ¸tter.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Videoen du prÃ¸ver Ã¥ se pÃ¥ er kryptert og vi vet ikke hvordan vi skal dekryptere den",
		"This content is not available for your package or region.": "Dette innholdet er ikke tilgjengelig med pakken din eller i din region.",
		"This video is either unavailable or not supported in this browser": "Denne videoen er enten utilgjengelig eller stÃ¸ttes ikke i denne nettleseren",
		"This video is unavailable": "Denne videoen er ikke tilgjengelig.",
		To: To$d,
		Transparent: Transparent$d,
		Uniform: Uniform$d,
		Unmute: Unmute$d,
		Unmuted: Unmuted$d,
		"Up Next": "Starter snart",
		"Video has expired.": "Videoen er utgÃ¥tt",
		"Video is not available in your country.": "Videoen er ikke tilgjengelig i landet ditt.",
		"Video is not yet available.": "Videoen er ikke tilgjengelig ennÃ¥.",
		"Video Player": "Videospiller",
		Watch: Watch$d,
		"WATCH NOW": "SE NÃ",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Vi beklager, men denne nettleseren stÃ¸ttes ikke lenger. Oppgrader til den nyeste utgaven av Google Chrome, FireFox eller Microsoft Edge for Ã¥ se pÃ¥ dette innholdet.",
		White: White$d,
		Window: Window$d,
		Yellow: Yellow$d,
		"You aborted the media playback": "Du stoppet videoavspillingen",
		"elapsed out of": "avspilt av"
	};

	var Ad$c = "Advertentie";
	var Autoplay$c = "Automatisch afspelen";
	var Background$c = "Achtergrond";
	var Black$c = "Zwart";
	var Blue$c = "Blauw";
	var Button$c = "Toets";
	var Captions$c = "Ondertiteling";
	var Casual$c = "Casual";
	var Chapters$c = "Hoofdstukken";
	var Copied$c = "Gekopieerd";
	var Copy$c = "KopiÃ«ren";
	var Cyan$c = "Cyaan";
	var Default$c = "Standaard";
	var Depressed$c = "Ingedrukt";
	var Done$c = "Klaar";
	var DRM_REQUIRED$c = "DRM_REQUIRED";
	var Email$c = "E-mailen";
	var EMBARGOED$c = "EMBARGOED";
	var EXPIRED$c = "EXPIRED";
	var EXPIRED_CONTENT$c = "EXPIRED_CONTENT";
	var Foreground$c = "Voorgrond";
	var From$c = "Van";
	var Fullscreen$c = "Volledig scherm";
	var GEOLOCATION_NOT_ALLOWED$c = "GEOLOCATION_NOT_ALLOWED";
	var Green$c = "Groen";
	var hour$c = "uur";
	var hours$c = "uren";
	var LIVE$c = "LIVE";
	var Loaded$c = "Geladen";
	var Magenta$c = "Magenta";
	var Menu$c = "Menu";
	var Message$c = "Bericht";
	var minute$c = "minuut";
	var minutes$c = "minuten";
	var More$c = "Meer";
	var Mute$c = "Geluid uitzetten";
	var NOT_FOUND$c = "NOT_FOUND";
	var None$c = "Geen";
	var OK$c = "OkÃ©";
	var Opaque$c = "Ondoorzichtig";
	var Pause$c = "Pauze";
	var Pausing$c = "Pauzeren";
	var Play$c = "Afspelen";
	var Playing$c = "Wordt afgespeeld";
	var Progress$c = "Voortgang";
	var Purchased$c = "Gekocht";
	var Raised$c = "Niet ingedrukt";
	var Red$c = "Rood";
	var Replay$c = "Opnieuw afspelen";
	var Rewind$c = "Terugspoelen";
	var Script$c = "Script";
	var second$c = "seconde";
	var seconds$c = "seconden";
	var Send$c = "Sturen";
	var Settings$c = "Instellingen";
	var Share$c = "Delen";
	var Stop$c = "Stoppen";
	var STREAM_LIMITED$c = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$c = "STREAM_LIMIT_ERROR";
	var Subtitles$c = "Ondertiteling";
	var To$c = "Aan";
	var Transparent$c = "Doorzichtig";
	var Uniform$c = "Uniform";
	var Unmute$c = "Geluid aanzetten";
	var Unmuted$c = "Geluid aangezet";
	var Watch$c = "Kijken";
	var White$c = "Wit";
	var Window$c = "Venster";
	var Yellow$c = "Geel";
	var nl = {
		"A network error caused the media download to fail part-way.": "Het downloaden van de video is door een netwerkfout mislukt.",
		Ad: Ad$c,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Er is een fout opgetreden tijdens het afspelen van de video, mogelijk vanwege de netwerkverbinding of omdat de video op een browsertabblad op de achtergrond werd afgespeeld. Probeer het opnieuw.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio-opties",
		Autoplay: Autoplay$c,
		"Back to video": "Terug naar video",
		"Close share": "Close share",
		Background: Background$c,
		Black: Black$c,
		Blue: Blue$c,
		Button: Button$c,
		"Buy PPV": "PPV kopen",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Instellingen ondertiteling",
		Captions: Captions$c,
		"captions off": "ondertiteling uit",
		"Captions Preview": "Preview ondertiteling",
		Casual: Casual$c,
		Chapters: Chapters$c,
		"Check out this video on ESPN": "Check deze video op ESPN",
		"Choose Broadcast": "Uitzending kiezen",
		"Choose TV Provider": "Tv-provider kiezen",
		"Closed Caption": "Ondertiteling",
		"Closed Captions": "Ondertiteling",
		Copied: Copied$c,
		Copy: Copy$c,
		"Copy Embed Link": "Link voor insluiten kopiÃ«ren",
		"Copy Link": "Link kopiÃ«ren",
		"Could not download the video": "Could not download the video",
		"Current Time": "Huidige tijd",
		"currently behind live": "momenteel niet live",
		Cyan: Cyan$c,
		Default: Default$c,
		Depressed: Depressed$c,
		Done: Done$c,
		DRM_REQUIRED: DRM_REQUIRED$c,
		"Drop shadow": "Slagschaduw",
		"Duration Time": "Tijdsduur",
		Email: Email$c,
		"Email Video": "Video e-mailen",
		EMBARGOED: EMBARGOED$c,
		"Embed Code": "Insluitcode",
		"Error Code": "Foutcode",
		"Exit Full Screen": "Volledig scherm afsluiten",
		EXPIRED: EXPIRED$c,
		EXPIRED_CONTENT: EXPIRED_CONTENT$c,
		"Fast Forward": "Snel vooruit",
		"Font Family": "Lettertypefamilie",
		"Font Size": "Lettergrootte",
		Foreground: Foreground$c,
		From: From$c,
		Fullscreen: Fullscreen$c,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$c,
		"Get ESPN+": "Neem ESPN+",
		"Get MLB.TV": "Neem MLB.TV",
		Green: Green$c,
		hour: hour$c,
		hours: hours$c,
		"Language Settings": "Taalinstellingen",
		"Learn More": "Meer informatie",
		LIVE: LIVE$c,
		Loaded: Loaded$c,
		"Logged Into TV Provider": "Ingelogd bij tv-provider",
		Magenta: Magenta$c,
		Menu: Menu$c,
		Message: Message$c,
		minute: minute$c,
		minutes: minutes$c,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$c,
		Mute: Mute$c,
		NOT_FOUND: NOT_FOUND$c,
		"No compatible source was found for this media.": "Er is geen compatibele bron gevonden voor deze video.",
		"No video has been loaded": "Er is geen video geladen",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$c,
		"Now Playing": "Wordt nu afgespeeld",
		OK: OK$c,
		Opaque: Opaque$c,
		Pause: Pause$c,
		Pausing: Pausing$c,
		Play: Play$c,
		"Playback Rate": "Afspeelsnelheid",
		"Playback Speed": "Afspeelsnelheid",
		Playing: Playing$c,
		"please confirm you are connected to the internet": "bevestig dat je verbonden bent met het internet",
		Progress: Progress$c,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$c,
		Raised: Raised$c,
		Red: Red$c,
		"Remaining Time": "Resterende tijd",
		Replay: Replay$c,
		"Reset to Defaults": "Resetten naar standaard",
		Rewind: Rewind$c,
		Script: Script$c,
		second: second$c,
		seconds: seconds$c,
		"Seek to live": "Zoeken naar live",
		"Seek to live, currently playing live": "Zoeken naar live, nu live afgespeeld",
		"Select Broadcast": "Uitzending selecteren",
		"Semi-Opaque": "Semi-ondoorzichtig",
		"Semi-Transparent": "Semi-doorzichtig",
		Send: Send$c,
		Settings: Settings$c,
		Share: Share$c,
		"Skip Ad": "Advertentie overslaan",
		"Small Caps": "Kleine ondertiteling",
		"Start at": "Beginnen op",
		Stop: Stop$c,
		STREAM_LIMITED: STREAM_LIMITED$c,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$c,
		"Stream Type": "Streamtype",
		"Subscribed to ESPN+": "Geabonneerd op ESPN+",
		Subtitles: Subtitles$c,
		"subtitles off": "ondertiteling uit",
		"Technical details": "Technische gegevens",
		"Text Edge Style": "Stijl tekstrand",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Het maximale aantal gelijktijdige streams is bereikt op je account. Ga naar es.pn/watchfaq of bel 888-549-ESPN als je vragen of hulp nodig hebt.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Het mediabestand kan niet worden geladen, ofwel vanwege een server- of netwerkfout, ofwel omdat de indeling niet wordt ondersteund.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "De videoverbinding is verbroken",
		"The video download was cancelled": "Het downloaden van de video is geannuleerd",
		"The video is bad or in a format that cannot be played on your browser": "De video is beschadigd of heeft een indeling die niet in je browser kan worden afgespeeld",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Het afspelen van de video is onderbroken door een beschadiging of omdat de video functies gebruikt die je browser niet ondersteunt.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "De video die je probeert te kijken, is versleuteld en we weten niet hoe we hem kunnen ontsleutelen.",
		"This content is not available for your package or region.": "Deze content is niet beschikbaar voor je pakket of regio.",
		"This video is either unavailable or not supported in this browser": "Deze video is niet beschikbaar of wordt niet ondersteund in deze browser",
		"This video is unavailable": "Deze video is niet beschikbaar.",
		To: To$c,
		Transparent: Transparent$c,
		Uniform: Uniform$c,
		Unmute: Unmute$c,
		Unmuted: Unmuted$c,
		"Up Next": "Hierna",
		"Video has expired.": "Video is verlopen.",
		"Video is not available in your country.": "Video is niet beschikbaar in je land.",
		"Video is not yet available.": "Video is nog niet beschikbaar.",
		"Video Player": "Videospeler",
		Watch: Watch$c,
		"WATCH NOW": "NU KIJKEN",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Deze browser wordt helaas niet meer ondersteund. Upgrade naar de nieuwste versie van Google Chrome, Firefox of Microsoft Edge om deze content te bekijken.",
		White: White$c,
		Window: Window$c,
		Yellow: Yellow$c,
		"You aborted the media playback": "Je hebt het afspelen van de video afgebroken",
		"elapsed out of": "verstreken van"
	};

	var Ad$b = "Reklama";
	var Autoplay$b = "Autoodtwarzanie";
	var Background$b = "TÅo";
	var Black$b = "Czarny";
	var Blue$b = "Niebieski";
	var Button$b = "Przycisk";
	var Captions$b = "Podpisy";
	var Casual$b = "ZwykÅe";
	var Chapters$b = "RozdziaÅy";
	var Copied$b = "Skopiowano";
	var Copy$b = "Skopiuj";
	var Cyan$b = "Cyjan";
	var Default$b = "DomyÅlny";
	var Depressed$b = "WciÅniÄty";
	var Done$b = "Gotowe";
	var DRM_REQUIRED$b = "DRM_REQUIRED";
	var Email$b = "E-mail";
	var EMBARGOED$b = "EMBARGOED";
	var EXPIRED$b = "EXPIRED";
	var EXPIRED_CONTENT$b = "EXPIRED_CONTENT";
	var Foreground$b = "Pierwszy plan";
	var From$b = "Od";
	var Fullscreen$b = "PeÅny ekran";
	var GEOLOCATION_NOT_ALLOWED$b = "GEOLOCATION_NOT_ALLOWED";
	var Green$b = "Zielony";
	var hour$b = "godz.";
	var hours$b = "godz.";
	var LIVE$b = "NA Å»YWO";
	var Loaded$b = "ZaÅadowano";
	var Magenta$b = "Magenta";
	var Menu$b = "Menu";
	var Message$b = "WiadomoÅÄ";
	var minute$b = "min.";
	var minutes$b = "min.";
	var More$b = "WiÄcej";
	var Mute$b = "Wycisz";
	var NOT_FOUND$b = "NOT_FOUND";
	var None$b = "Brak";
	var OK$b = "OK";
	var Opaque$b = "Nieprzejrzysty";
	var Pause$b = "Pauza";
	var Pausing$b = "Pauzowanie";
	var Play$b = "Odtwarzaj";
	var Playing$b = "Odtwarzanie";
	var Progress$b = "PostÄp";
	var Purchased$b = "Zakupiono";
	var Raised$b = "NiewciÅniÄty";
	var Red$b = "Czerwony";
	var Replay$b = "PowtÃ³rka";
	var Rewind$b = "PrzewiÅ w tyÅ";
	var Script$b = "Skrypt";
	var second$b = "sek.";
	var seconds$b = "sek.";
	var Send$b = "WyÅlij";
	var Settings$b = "Ustawienia";
	var Share$b = "UdostÄpnij";
	var Stop$b = "Zatrzymaj";
	var STREAM_LIMITED$b = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$b = "STREAM_LIMIT_ERROR";
	var Subtitles$b = "Napisy";
	var To$b = "Do";
	var Transparent$b = "Przezroczysty";
	var Uniform$b = "Jednolity";
	var Unmute$b = "WyÅ. wyciszenie";
	var Unmuted$b = "WyÅÄczono wyciszenie";
	var Watch$b = "Obejrzyj";
	var White$b = "BiaÅy";
	var Window$b = "Okno";
	var Yellow$b = "Å»Ã³Åty";
	var pl = {
		"A network error caused the media download to fail part-way.": "BÅÄd sieci sprawiÅ, Å¼e pobieranie wideo zostaÅo przerwane.",
		Ad: Ad$b,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Podczas odtwarzania wideo wystÄpiÅ bÅÄd, najprawdopodobniej zwiÄzany z bÅÄdem sieci lub przeÅÄczeniem zakÅadki przeglÄdarki. SprÃ³buj ponownie.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Opcje dÅºwiÄkowe",
		Autoplay: Autoplay$b,
		"Back to video": "WrÃ³Ä do wideo",
		"Close share": "Close share",
		Background: Background$b,
		Black: Black$b,
		Blue: Blue$b,
		Button: Button$b,
		"Buy PPV": "Kup PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Ustawienia podpisÃ³w",
		Captions: Captions$b,
		"captions off": "podpisy wyÅ.",
		"Captions Preview": "PodglÄd podpisÃ³w",
		Casual: Casual$b,
		Chapters: Chapters$b,
		"Check out this video on ESPN": "Obejrzyj to wideo na ESPN",
		"Choose Broadcast": "Wybierz transmisjÄ",
		"Choose TV Provider": "Wybierz dostawcÄ usÅug telewizyjnych",
		"Closed Caption": "Napisy kodowane",
		"Closed Captions": "Napisy kodowane",
		Copied: Copied$b,
		Copy: Copy$b,
		"Copy Embed Link": "Kopiuj link do embedowania",
		"Copy Link": "Kopiuj link ",
		"Could not download the video": "Could not download the video",
		"Current Time": "Aktualny czas",
		"currently behind live": "opÃ³Åºnienie wzglÄdem transmisji na Å¼ywo",
		Cyan: Cyan$b,
		Default: Default$b,
		Depressed: Depressed$b,
		Done: Done$b,
		DRM_REQUIRED: DRM_REQUIRED$b,
		"Drop shadow": "CieÅ",
		"Duration Time": "Czas trwania",
		Email: Email$b,
		"Email Video": "E-mail z wideo",
		EMBARGOED: EMBARGOED$b,
		"Embed Code": "Kod embedowania",
		"Error Code": "Kod bÅÄdu",
		"Exit Full Screen": "OpuÅÄ peÅny ekran",
		EXPIRED: EXPIRED$b,
		EXPIRED_CONTENT: EXPIRED_CONTENT$b,
		"Fast Forward": "PrzewiniÄcie naprzÃ³d",
		"Font Family": "Rodzina czcionek",
		"Font Size": "Rozmiar czcionki",
		Foreground: Foreground$b,
		From: From$b,
		Fullscreen: Fullscreen$b,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$b,
		"Get ESPN+": "Zyskaj dostÄp do ESPN+",
		"Get MLB.TV": "Zyskaj dostÄp do MLB.TV",
		Green: Green$b,
		hour: hour$b,
		hours: hours$b,
		"Language Settings": "Ustawienia jÄzyka",
		"Learn More": "Dowiedz siÄ wiÄcej",
		LIVE: LIVE$b,
		Loaded: Loaded$b,
		"Logged Into TV Provider": "Zalogowano siÄ u dostawcy usÅug telewizyjnych",
		Magenta: Magenta$b,
		Menu: Menu$b,
		Message: Message$b,
		minute: minute$b,
		minutes: minutes$b,
		"Monospace Sans-Serif": "Monospace, bezszeryfowa",
		"Monospace Serif": "Monospace, szeryfowa",
		More: More$b,
		Mute: Mute$b,
		NOT_FOUND: NOT_FOUND$b,
		"No compatible source was found for this media.": "Nie znaleziono kompatybilnego ÅºrÃ³dÅa dla tego wideo.",
		"No video has been loaded": "Nie zaÅadowano Å¼adnego wideo",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$b,
		"Now Playing": "Odtwarzane teraz",
		OK: OK$b,
		Opaque: Opaque$b,
		Pause: Pause$b,
		Pausing: Pausing$b,
		Play: Play$b,
		"Playback Rate": "Tempo odtwarzania",
		"Playback Speed": "SzybkoÅÄ odtwarzania",
		Playing: Playing$b,
		"please confirm you are connected to the internet": "upewnij siÄ, Å¼e masz poÅÄczenie z internetem",
		Progress: Progress$b,
		"Proportional Sans-Serif": "Proporcjonalna bezszeryfowa",
		"Proportional Serif": "Proporcjonalna szeryfowa",
		Purchased: Purchased$b,
		Raised: Raised$b,
		Red: Red$b,
		"Remaining Time": "PozostaÅy czas",
		Replay: Replay$b,
		"Reset to Defaults": "PrzywrÃ³Ä domyÅlne",
		Rewind: Rewind$b,
		Script: Script$b,
		second: second$b,
		seconds: seconds$b,
		"Seek to live": "WÅÄcz na Å¼ywo",
		"Seek to live, currently playing live": "WÅÄcz na Å¼ywo, obecnie odtwarzanie na Å¼ywo",
		"Select Broadcast": "Wybierz transmisjÄ",
		"Semi-Opaque": "CzÄÅciowo nieprzejrzysty",
		"Semi-Transparent": "CzÄÅciowo przezroczysty",
		Send: Send$b,
		Settings: Settings$b,
		Share: Share$b,
		"Skip Ad": "PomiÅ reklamÄ",
		"Small Caps": "MaÅe podpisy",
		"Start at": "Rozpocznij od",
		Stop: Stop$b,
		STREAM_LIMITED: STREAM_LIMITED$b,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$b,
		"Stream Type": "Typ transmisji",
		"Subscribed to ESPN+": "Subskrybujesz ESPN+",
		Subtitles: Subtitles$b,
		"subtitles off": "napisy wyÅ.",
		"Technical details": "SzczegÃ³Åy techniczne",
		"Text Edge Style": "Styl krawÄdzi tekstu",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Na twoim koncie osiÄgniÄto maksymalnÄ liczbÄ jednoczesnych transmisji. JeÅli masz pytania lub potrzebujesz pomocy, odwiedÅº stronÄ es.pn/watchfaq lub zadzwoÅ pod numer 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Nie udaÅo siÄ zaÅadowaÄ pliku mediÃ³w ze wzglÄdu na bÅÄd serwera bÄdÅº sieci albo ze wzglÄdu na nieobsÅugiwany format.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "Anulowano pobieranie wideo",
		"The video is bad or in a format that cannot be played on your browser": "Ten plik wideo jest uszkodzony lub posiada format nieobsÅugiwany przez twojÄ przeglÄdarkÄ",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Odtwarzanie wideo zostaÅo przerwane ze wzglÄdu na uszkodzenie pliku lub teÅ¼ wideo wykorzystuje funkcje nieobsÅugiwane przez twojÄ przeglÄdarkÄ.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Wideo, ktÃ³re prÃ³bujesz obejrzeÄ jest zaszyfrowane i nie wiemy jak je odszyfrowaÄ",
		"This content is not available for your package or region.": "Ta zawartoÅÄ jest niedostÄpna w twoim pakiecie lub regionie.",
		"This video is either unavailable or not supported in this browser": "To wideo jest niedostÄpne lub nieobsÅugiwane przez twojÄ przeglÄdarkÄ",
		"This video is unavailable": "To wideo jest niedostÄpne.",
		To: To$b,
		Transparent: Transparent$b,
		Uniform: Uniform$b,
		Unmute: Unmute$b,
		Unmuted: Unmuted$b,
		"Up Next": "JuÅ¼ za chwilÄ",
		"Video has expired.": "Wideo utraciÅo waÅ¼noÅÄ.",
		"Video is not available in your country.": "To wideo jest niedostÄpne w twoim kraju.",
		"Video is not yet available.": "To wideo nie jest jeszcze dostÄpne.",
		"Video Player": "Odtwarzacz wideo",
		Watch: Watch$b,
		"WATCH NOW": "OBEJRZYJ TERAZ",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Niestety, ta przeglÄdarka nie jest juÅ¼ obsÅugiwana. Aby obejrzeÄ tÄ zwartoÅÄ, zaktualizuj swojÄ przeglÄdarkÄ do najnowszej wersji Google Chrome, FireFox lub Microsoft Edge.",
		White: White$b,
		Window: Window$b,
		Yellow: Yellow$b,
		"You aborted the media playback": "Przerwano odtwarzanie wideo",
		"elapsed out of": "z"
	};

	var Ad$a = "Publicidade";
	var Autoplay$a = "Reproduzir automaticamente";
	var Background$a = "Fundo";
	var Black$a = "Preto";
	var Blue$a = "Azul";
	var Button$a = "botÃ£o";
	var Captions$a = "AnotaÃ§Ãµes";
	var Casual$a = "Casual";
	var Chapters$a = "CapÃ­tulos";
	var Copied$a = "Copied";
	var Copy$a = "Copiar";
	var Cyan$a = "Ciano";
	var Default$a = "PadrÃ£o";
	var Depressed$a = "Diminuido";
	var Done$a = "Pronto";
	var DRM_REQUIRED$a = "Desculpe-nos mas este navegador nÃ£o Ã© mais suportado. Por favor atualize para a versÃ£o mais recente do Google Chrome FireFox ou Microsoft Edge para assistir o conteÃºdo.";
	var Email$a = "Email";
	var EMBARGOED$a = "VÃ­deo ainda nÃ£o disponÃ­vel.";
	var EXPIRED$a = "VÃ­deo expirou.";
	var EXPIRED_CONTENT$a = "VÃ­deo expirou.";
	var Foreground$a = "Primer plano";
	var From$a = "DÃª";
	var Fullscreen$a = "Tela cheia";
	var GEOLOCATION_NOT_ALLOWED$a = "VÃ­deo nÃ£o estÃ¡ disponÃ­vel no seu paÃ­s.";
	var Green$a = "Verde";
	var hour$a = "hora";
	var hours$a = "horas";
	var LIVE$a = "AO VIVO";
	var Loaded$a = "Carregado";
	var Magenta$a = "Magenta";
	var Menu$a = "Menu";
	var Message$a = "Mensagem";
	var minute$a = "minuto";
	var minutes$a = "minutes";
	var More$a = "More";
	var Mute$a = "Mudo";
	var NOT_FOUND$a = "VÃ­deo nÃ£o disponÃ­vel.";
	var None$a = "Nenhum";
	var OK$a = "Ok";
	var Opaque$a = "Opaco";
	var Pause$a = "Pauzeren";
	var Pausing$a = "Pausando";
	var Play$a = "Play";
	var Playing$a = "Playing";
	var Progress$a = "Progresso";
	var Purchased$a = "Comprado";
	var Raised$a = "Aumentado";
	var Red$a = "Vermelho";
	var Replay$a = "Tocar novamente";
	var Rewind$a = "Rewind";
	var Script$a = "Script";
	var second$a = "segundo";
	var seconds$a = "segundos";
	var Send$a = "Enviar";
	var Settings$a = "OpÃ§Ãµes";
	var Share$a = "Compartilhar";
	var Stop$a = "Parar";
	var STREAM_LIMITED$a = "O nÃºmero mÃ¡ximo de conexÃµes simultÃ¢neas foi atingido em sua conta.";
	var STREAM_LIMIT_ERROR$a = "O nÃºmero mÃ¡ximo de conexÃµes simultÃ¢neas foi atingido em sua conta.";
	var Subtitles$a = "Legendas";
	var To$a = "Para";
	var Transparent$a = "Transparente";
	var Uniform$a = "Uniforme";
	var Unmute$a = "Ativar o som";
	var Unmuted$a = "Ativar o som";
	var Watch$a = "Assista";
	var White$a = "Branco";
	var Window$a = "Janela";
	var Yellow$a = "Amarelo";
	var hours_minutes_seconds_format$6 = "<%= hours %> <%= minutes %> y <%= seconds %>";
	var minutes_seconds_format$6 = "<%= minutes %> y <%= seconds %>";
	var pt = {
		"A network error caused the media download to fail part-way.": "Um erro na rede fez o vÃ­deo parar parcialmente.",
		Ad: Ad$a,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "Aconteceu um erro inesperado tente novamente mais tarde",
		"Audio Options": "OpÃ§Ãµes da Ã¡udio",
		Autoplay: Autoplay$a,
		"Back to video": "Voltar ao vÃ­deo",
		"Close share": "Close share",
		Background: Background$a,
		Black: Black$a,
		Blue: Blue$a,
		Button: Button$a,
		"Buy PPV": "Comprar PPV",
		"com.espn.watch.api.AccessDeniedException": "Esse conteÃºdo nÃ£o estÃ¡ disponÃ­vel no seu pacote de assinatura ou regiÃ£o.",
		"Caption Settings": "OpÃ§Ãµes da legenda",
		Captions: Captions$a,
		"captions off": "Legendas desligadas",
		"Captions Preview": "VisualizaÃ§Ã£o de legendas",
		Casual: Casual$a,
		Chapters: Chapters$a,
		"Check out this video on ESPN": "Confira esse vÃ­deo no WatchESPN",
		"Choose Broadcast": "Escolha o Canal",
		"Choose TV Provider": "Escolha o Seu Provedor",
		"Closed Caption": "Legendas",
		"Closed Captions": "Legendas",
		Copied: Copied$a,
		Copy: Copy$a,
		"Copy Embed Link": "Copiar o link de embed",
		"Copy Link": "Copiar o link",
		"Could not download the video": "Ocorreu um erro durante a reproduÃ§Ã£o do vÃ­deo provavelmente devido a problemas na sua conexÃ£o ou em uma aba do navegador em segundo plano. Por favor tente novamente.",
		"Current Time": "Hora atual",
		"currently behind live": "currently behind live",
		Cyan: Cyan$a,
		Default: Default$a,
		Depressed: Depressed$a,
		Done: Done$a,
		DRM_REQUIRED: DRM_REQUIRED$a,
		"Drop shadow": "Sombra",
		"Duration Time": "Tempo de duraÃ§Ã£o",
		Email: Email$a,
		"Email Video": "Enviar vÃ­deo por email",
		EMBARGOED: EMBARGOED$a,
		"Embed Code": "CÃ³digo de embed",
		"Error Code": "CÃ³digo de erro",
		"Exit Full Screen": "Exit Full Screen",
		EXPIRED: EXPIRED$a,
		EXPIRED_CONTENT: EXPIRED_CONTENT$a,
		"Fast Forward": "Fast Forward",
		"Font Family": "Grupo de fontes",
		"Font Size": "Tamanho da fonte",
		Foreground: Foreground$a,
		From: From$a,
		Fullscreen: Fullscreen$a,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$a,
		"Get ESPN+": "Assine a ESPN+",
		"Get MLB.TV": "Assine aÂ MLB.TV",
		Green: Green$a,
		hour: hour$a,
		hours: hours$a,
		"Language Settings": "ConfiguraÃ§Ãµes de idioma",
		"Learn More": "Saiba mais",
		LIVE: LIVE$a,
		Loaded: Loaded$a,
		"Logged Into TV Provider": "Logado ao Seu Provedor",
		Magenta: Magenta$a,
		Menu: Menu$a,
		Message: Message$a,
		minute: minute$a,
		minutes: minutes$a,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$a,
		Mute: Mute$a,
		NOT_FOUND: NOT_FOUND$a,
		"No compatible source was found for this media.": "NÃ£o foi encontrada fonte de vÃ­deo compatÃ­vel.",
		"No video has been loaded": "Nenhum vÃ­deo foi carregado",
		"Non-Fullscreen": "Tela Normal",
		None: None$a,
		"Now Playing": "Reproduzindo Agora",
		OK: OK$a,
		Opaque: Opaque$a,
		Pause: Pause$a,
		Pausing: Pausing$a,
		Play: Play$a,
		"Playback Rate": "axa de reproduÃ§Ã£o",
		"Playback Speed": "Playback Speed",
		Playing: Playing$a,
		"please confirm you are connected to the internet": "Por favor confirme que estÃ¡ conectado a internet",
		Progress: Progress$a,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$a,
		Raised: Raised$a,
		Red: Red$a,
		"Remaining Time": "Tempo restante",
		Replay: Replay$a,
		"Reset to Defaults": "Restaurar para as configuraÃ§Ãµes padrÃ£o",
		Rewind: Rewind$a,
		Script: Script$a,
		second: second$a,
		seconds: seconds$a,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Select Broadcast": "Escolha a transmissÃ£o",
		"Semi-Opaque": "Meio opaco",
		"Semi-Transparent": "Meio transparente",
		Send: Send$a,
		Settings: Settings$a,
		Share: Share$a,
		"Skip Ad": "Pular anÃºncio",
		"Small Caps": "MinÃºscula",
		"Start at": "ComeÃ§ar em",
		Stop: Stop$a,
		STREAM_LIMITED: STREAM_LIMITED$a,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$a,
		"Stream Type": "Tipo de streaming",
		"Subscribed to ESPN+": "Assinante da ESPN+",
		Subtitles: Subtitles$a,
		"subtitles off": "Desligar legendas",
		"Technical details": "Detalhes tÃ©cnicos",
		"Text Edge Style": "Estilo da borda do texto",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "O vÃ­deo nÃ£o pode ser carregado ou porque houve um problema com sua rede ou pelo formato do vÃ­deo nÃ£o ser suportado.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "A execuÃ§Ã£o foi interrompida por um problema com o vÃ­deo ou por seu navegador nÃ£o dar suporte ao seu formato.",
		"The video connection was lost,": "A conexÃ£o com o vÃ­deo foi perdida.",
		"The video download was cancelled": "O download do vÃ­deo foi cancelado",
		"The video is bad or in a format that cannot be played on your browser": "O vÃ­deo estÃ¡ em um formato que o seu browser nÃ£o suporta",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "O vÃ­deo que vocÃª estÃ¡ tentando assistir Ã© criptografado e nÃ³s nÃ£o sabemos como decodificÃ¡-lo",
		"This content is not available for your package or region.": "Esse conteÃºdo nÃ£o estÃ¡ disponÃ­vel no seu pacote de assinatura ou regiÃ£o.",
		"This video is either unavailable or not supported in this browser": "O vÃ­deo nÃ£o estÃ¡ disponÃ­vel ou nÃ£o Ã© suportado pelo seu browser",
		"This video is unavailable": "VÃ­deo nÃ£o disponÃ­vel",
		To: To$a,
		Transparent: Transparent$a,
		Uniform: Uniform$a,
		Unmute: Unmute$a,
		Unmuted: Unmuted$a,
		"Up Next": "VER AGORA",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Player de VÃ­deo",
		Watch: Watch$a,
		"WATCH NOW": "VER AHORA",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$a,
		Window: Window$a,
		Yellow: Yellow$a,
		"You aborted the media playback": "VocÃª parou a execuÃ§Ã£o do vÃ­deo.",
		"elapsed out of": "verstreken van",
		hours_minutes_seconds_format: hours_minutes_seconds_format$6,
		minutes_seconds_format: minutes_seconds_format$6
	};

	var Ad$9 = "ReclamÄ";
	var Autoplay$9 = "Redare automatÄ";
	var Background$9 = "Fundal";
	var Black$9 = "Negru";
	var Blue$9 = "Albastru";
	var Button$9 = "Buton";
	var Captions$9 = "SubtitrÄri complexe";
	var Casual$9 = "Ocazional";
	var Chapters$9 = "Capitole";
	var Copied$9 = "Copiat";
	var Copy$9 = "Copiere";
	var Cyan$9 = "Cyan";
	var Default$9 = "Implicit";
	var Depressed$9 = "ApÄsat";
	var Done$9 = "Terminat";
	var DRM_REQUIRED$9 = "";
	var Email$9 = "E-mail";
	var EMBARGOED$9 = "";
	var EXPIRED$9 = "";
	var EXPIRED_CONTENT$9 = "";
	var Foreground$9 = "Prim-plan";
	var From$9 = "De la";
	var Fullscreen$9 = "Ecran complet";
	var GEOLOCATION_NOT_ALLOWED$9 = "";
	var Green$9 = "Verde";
	var hour$9 = "orÄ";
	var hours$9 = "ore";
	var LIVE$9 = "LIVE";
	var Loaded$9 = "ÃncÄrcat";
	var Magenta$9 = "Magenta";
	var Menu$9 = "Meniu";
	var Message$9 = "Mesaj";
	var minute$9 = "minut";
	var minutes$9 = "minute";
	var More$9 = "Mai multe";
	var Mute$9 = "Dezactivare sunet";
	var NOT_FOUND$9 = "";
	var None$9 = "FÄrÄ";
	var OK$9 = "OK";
	var Opaque$9 = "Opac";
	var Pause$9 = "PauzÄ";
	var Pausing$9 = "Trecere Ã®n pauzÄ";
	var Play$9 = "Redare";
	var Playing$9 = "Se redÄ";
	var Progress$9 = "DesfÄÈurare";
	var Purchased$9 = "CumpÄrat";
	var Raised$9 = "Reliefat";
	var Red$9 = "RoÈu";
	var Replay$9 = "Reluare";
	var Rewind$9 = "Derulare Ã®napoi";
	var Script$9 = "Script";
	var second$9 = "secundÄ";
	var seconds$9 = "secunde";
	var Send$9 = "Trimitere";
	var Settings$9 = "SetÄri";
	var Share$9 = "Distribuire";
	var Stop$9 = "Stop";
	var STREAM_LIMITED$9 = "";
	var STREAM_LIMIT_ERROR$9 = "";
	var Subtitles$9 = "SubtitrÄri";
	var To$9 = "La";
	var Transparent$9 = "Transparent";
	var Uniform$9 = "Uniform";
	var Unmute$9 = "Activare sunet";
	var Unmuted$9 = "Sunet activat";
	var Watch$9 = "Vizionare";
	var White$9 = "Alb";
	var Window$9 = "FereastrÄ";
	var Yellow$9 = "Galben";
	var ro = {
		"A network error caused the media download to fail part-way.": "O eroare de reÈea a Ã®mpiedicat descÄrcarea totalÄ a videoclipului.",
		Ad: Ad$9,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Eroare Ã®n timpul redÄrii videoclipului. Cauza poate fi o problemÄ cu conexiunea la reÈea sau trecerea filei de browser Ã®n fundal. ÃncercaÈi din nou.",
		"An unanticipated problem was encountered, check back soon and try again": "",
		"Audio Options": "OpÈiuni audio",
		Autoplay: Autoplay$9,
		"Back to video": "Revenire la videoclip",
		"Close share": "Close share",
		Background: Background$9,
		Black: Black$9,
		Blue: Blue$9,
		Button: Button$9,
		"Buy PPV": "CumpÄrare PPV",
		"com.espn.watch.api.AccessDeniedException": "",
		"Caption Settings": "SetÄri de subtitrÄri complexe",
		Captions: Captions$9,
		"captions off": "fÄrÄ subtitrÄri complexe",
		"Captions Preview": "Previzualizare subtitrÄri complexe",
		Casual: Casual$9,
		Chapters: Chapters$9,
		"Check out this video on ESPN": "VizionaÈi acest videoclip pe ESPN",
		"Choose Broadcast": "AlegeÈi emisiunea",
		"Choose TV Provider": "AlegeÈi furnizorul TV",
		"Closed Caption": "Subtitrare complexÄ",
		"Closed Captions": "SubtitrÄri complexe",
		Copied: Copied$9,
		Copy: Copy$9,
		"Copy Embed Link": "Copiere link incorporat",
		"Copy Link": "Copiere link",
		"Could not download the video": "",
		"Current Time": "Ora curentÄ",
		"currently behind live": "momentan Ã®n urma transmisiei live",
		Cyan: Cyan$9,
		Default: Default$9,
		Depressed: Depressed$9,
		Done: Done$9,
		DRM_REQUIRED: DRM_REQUIRED$9,
		"Drop shadow": "Cu umbrÄ",
		"Duration Time": "DuratÄ",
		Email: Email$9,
		"Email Video": "Trimitere videoclip prin e-mail",
		EMBARGOED: EMBARGOED$9,
		"Embed Code": "Cod de incorporat",
		"Error Code": "Cod de eroare",
		"Exit Full Screen": "IeÈire din modul Ecran complet",
		EXPIRED: EXPIRED$9,
		EXPIRED_CONTENT: EXPIRED_CONTENT$9,
		"Fast Forward": "Derulare Ã®nainte",
		"Font Family": "Familie de fonturi",
		"Font Size": "MÄrime font",
		Foreground: Foreground$9,
		From: From$9,
		Fullscreen: Fullscreen$9,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$9,
		"Get ESPN+": "AccesaÈi ESPN+",
		"Get MLB.TV": "AccesaÈi MLB.TV",
		Green: Green$9,
		hour: hour$9,
		hours: hours$9,
		"Language Settings": "SetÄri de limbÄ",
		"Learn More": "InformaÈii suplimentare",
		LIVE: LIVE$9,
		Loaded: Loaded$9,
		"Logged Into TV Provider": "Conectat la furnizorul TV",
		Magenta: Magenta$9,
		Menu: Menu$9,
		Message: Message$9,
		minute: minute$9,
		minutes: minutes$9,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$9,
		Mute: Mute$9,
		NOT_FOUND: NOT_FOUND$9,
		"No compatible source was found for this media.": "Nu s-a gÄsit nicio sursÄ compatibilÄ pentru acest videoclip.",
		"No video has been loaded": "Nu s-a Ã®ncÄrcat niciun videoclip",
		"Non-Fullscreen": "",
		None: None$9,
		"Now Playing": "Ãn redare",
		OK: OK$9,
		Opaque: Opaque$9,
		Pause: Pause$9,
		Pausing: Pausing$9,
		Play: Play$9,
		"Playback Rate": "RatÄ de redare",
		"Playback Speed": "VitezÄ de redare",
		Playing: Playing$9,
		"please confirm you are connected to the internet": "verificaÈi dacÄ aveÈi conexiune la internet",
		Progress: Progress$9,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$9,
		Raised: Raised$9,
		Red: Red$9,
		"Remaining Time": "Timp rÄmas",
		Replay: Replay$9,
		"Reset to Defaults": "Resetare la valorile implicite",
		Rewind: Rewind$9,
		Script: Script$9,
		second: second$9,
		seconds: seconds$9,
		"Seek to live": "CÄutare moment live",
		"Seek to live, currently playing live": "CÄutare moment live, se redÄ live",
		"Select Broadcast": "Selectare emisiune",
		"Semi-Opaque": "Semiopac",
		"Semi-Transparent": "Semitransparent",
		Send: Send$9,
		Settings: Settings$9,
		Share: Share$9,
		"Skip Ad": "Ãnchidere reclamÄ",
		"Small Caps": "Litere mici",
		"Start at": "Ãncepere la",
		Stop: Stop$9,
		STREAM_LIMITED: STREAM_LIMITED$9,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$9,
		"Stream Type": "Tip flux",
		"Subscribed to ESPN+": "Abonat la ESPN+",
		Subtitles: Subtitles$9,
		"subtitles off": "fÄrÄ subtitrÄri",
		"Technical details": "Detalii tehnice",
		"Text Edge Style": "Stil contur de text",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Contul dvs. a atins numÄrul maxim permis de fluxuri simultane. DacÄ aveÈi Ã®ntrebÄri sau aveÈi nevoie de asistenÈÄ, accesaÈi es.pn/watchfaq sau sunaÈi la 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "ÃncÄrcarea materialului nu a reuÈit. A apÄrut o eroare pe server ori Ã®n reÈea sau formatul nu este acceptat.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "",
		"The video connection was lost": "Conexiunea video s-a Ã®ntrerupt",
		"The video download was cancelled": "DescÄrcarea videoclipului a fost anulatÄ",
		"The video is bad or in a format that cannot be played on your browser": "Videoclipul este deteriorat sau este Ã®ntr-un format care nu poate fi redat Ã®n browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Redarea video a fost Ã®ntreruptÄ din cauza deteriorÄrii datelor sau din cauzÄ cÄ videoclipul a utilizat funcÈii neacceptate de browser.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Videoclipul pe care Ã®ncercaÈi sÄ-l vizionaÈi este criptat Èi nu Ã®l putem decripta",
		"This content is not available for your package or region.": "ConÈinutul nu este disponibil Ã®n pachetul sau Ã®n regiunea dvs.",
		"This video is either unavailable or not supported in this browser": "Acest videoclip este indisponibil sau nu este acceptat de browser",
		"This video is unavailable": "Acest videoclip este indisponibil.",
		To: To$9,
		Transparent: Transparent$9,
		Uniform: Uniform$9,
		Unmute: Unmute$9,
		Unmuted: Unmuted$9,
		"Up Next": "UrmeazÄ",
		"Video has expired.": "Videoclipul a expirat.",
		"Video is not available in your country.": "Videoclipul nu este disponibil Ã®n Èara dvs.",
		"Video is not yet available.": "Videoclipul nu este disponibil Ã®ncÄ.",
		"Video Player": "Player video",
		Watch: Watch$9,
		"WATCH NOW": "VIZIONARE IMEDIATÄ",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Ne pare rÄu, acest browser nu mai este acceptat. Pentru a putea viziona acest conÈinut, faceÈi upgrade la cea mai recentÄ versiune de Google Chrome, FireFox sau Microsoft Edge.",
		White: White$9,
		Window: Window$9,
		Yellow: Yellow$9,
		"You aborted the media playback": "AÈi Ã®ntrerupt redarea video",
		"elapsed out of": "trecute din"
	};

	var Ad$8 = "Ad";
	var Autoplay$8 = "Autoplay";
	var Background$8 = "Background";
	var Black$8 = "Black";
	var Blue$8 = "Blue";
	var Button$8 = "Button";
	var Captions$8 = "Captions";
	var Casual$8 = "Casual";
	var Chapters$8 = "Chapters";
	var Copied$8 = "Copied";
	var Copy$8 = "Copy";
	var Cyan$8 = "Cyan";
	var Default$8 = "Default";
	var Depressed$8 = "Depressed";
	var Done$8 = "Done";
	var DRM_REQUIRED$8 = "DRM_REQUIRED";
	var Email$8 = "Email";
	var EMBARGOED$8 = "EMBARGOED";
	var EXPIRED$8 = "EXPIRED";
	var EXPIRED_CONTENT$8 = "EXPIRED_CONTENT";
	var Foreground$8 = "Foreground";
	var From$8 = "From";
	var Fullscreen$8 = "Fullscreen";
	var GEOLOCATION_NOT_ALLOWED$8 = "GEOLOCATION_NOT_ALLOWED";
	var Green$8 = "Green";
	var hour$8 = "hour";
	var hours$8 = "hours";
	var LIVE$8 = "LIVE";
	var Loaded$8 = "Loaded";
	var Magenta$8 = "Magenta";
	var Menu$8 = "Menu";
	var Message$8 = "Message";
	var minute$8 = "minute";
	var minutes$8 = "minutes";
	var More$8 = "More";
	var Mute$8 = "Mute";
	var NOT_FOUND$8 = "NOT_FOUND";
	var None$8 = "None";
	var OK$8 = "OK";
	var Opaque$8 = "Opaque";
	var Pause$8 = "Pause";
	var Pausing$8 = "Pausing";
	var Play$8 = "Play";
	var Playing$8 = "Playing";
	var Progress$8 = "Progress";
	var Purchased$8 = "Purchased";
	var Raised$8 = "Raised";
	var Red$8 = "Red";
	var Replay$8 = "Replay";
	var Rewind$8 = "Rewind";
	var Script$8 = "Script";
	var second$8 = "second";
	var seconds$8 = "seconds";
	var Send$8 = "Send";
	var Settings$8 = "Settings";
	var Share$8 = "Share";
	var Stop$8 = "Stop";
	var STREAM_LIMITED$8 = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$8 = "STREAM_LIMIT_ERROR";
	var Subtitles$8 = "Subtitles";
	var To$8 = "To";
	var Transparent$8 = "Transparent";
	var Uniform$8 = "Uniform";
	var Unmute$8 = "Unmute";
	var Unmuted$8 = "Unmuted";
	var Watch$8 = "Watch";
	var White$8 = "White";
	var Window$8 = "Window";
	var Yellow$8 = "Yellow";
	var hours_minutes_seconds_format$5 = "hours_minutes_seconds_format";
	var minutes_seconds_format$5 = "minutes_seconds_format";
	var ru = {
		"A network error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
		Ad: Ad$8,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio Options",
		Autoplay: Autoplay$8,
		"Back to video": "Back to video",
		"Close share": "Close share",
		Background: Background$8,
		Black: Black$8,
		Blue: Blue$8,
		Button: Button$8,
		"Buy PPV": "Buy PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Caption Settings",
		Captions: Captions$8,
		"captions off": "captions off",
		"Captions Preview": "Captions Preview",
		Casual: Casual$8,
		Chapters: Chapters$8,
		"Check out this video on ESPN": "Check out this video on ESPN",
		"Choose Broadcast": "Choose Broadcast",
		"Choose TV Provider": "Choose TV Provider",
		"Closed Caption": "Closed Caption",
		"Closed Captions": "Closed Captions",
		Copied: Copied$8,
		Copy: Copy$8,
		"Copy Embed Link": "Copy Embed Link",
		"Copy Link": "Copy Link",
		"Could not download the video": "Could not download the video",
		"Current Time": "Current Time",
		"currently behind live": "currently behind live",
		Cyan: Cyan$8,
		Default: Default$8,
		Depressed: Depressed$8,
		Done: Done$8,
		DRM_REQUIRED: DRM_REQUIRED$8,
		"Drop shadow": "Drop shadow",
		"Duration Time": "Duration Time",
		Email: Email$8,
		"Email Video": "Email Video",
		EMBARGOED: EMBARGOED$8,
		"Embed Code": "Embed Code",
		"Error Code": "Error Code",
		"Exit Full Screen": "Exit Full Screen",
		EXPIRED: EXPIRED$8,
		EXPIRED_CONTENT: EXPIRED_CONTENT$8,
		"Fast Forward": "Fast Forward",
		"Font Family": "Font Family",
		"Font Size": "Font Size",
		Foreground: Foreground$8,
		From: From$8,
		Fullscreen: Fullscreen$8,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$8,
		"Get ESPN+": "Get ESPN+",
		"Get MLB.TV": "Get MLB.TV",
		Green: Green$8,
		hour: hour$8,
		hours: hours$8,
		"Language Settings": "Language Settings",
		"Learn More": "Learn More",
		LIVE: LIVE$8,
		Loaded: Loaded$8,
		"Logged Into TV Provider": "Logged Into TV Provider",
		Magenta: Magenta$8,
		Menu: Menu$8,
		Message: Message$8,
		minute: minute$8,
		minutes: minutes$8,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$8,
		Mute: Mute$8,
		NOT_FOUND: NOT_FOUND$8,
		"No compatible source was found for this media.": "No compatible source was found for this media.",
		"No video has been loaded": "No video has been loaded",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$8,
		"Now Playing": "Now Playing",
		OK: OK$8,
		Opaque: Opaque$8,
		Pause: Pause$8,
		Pausing: Pausing$8,
		Play: Play$8,
		"Playback Rate": "Playback Rate",
		"Playback Speed": "Playback Speed",
		Playing: Playing$8,
		"please confirm you are connected to the internet": "please confirm you are connected to the internet",
		Progress: Progress$8,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$8,
		Raised: Raised$8,
		Red: Red$8,
		"Remaining Time": "Remaining Time",
		Replay: Replay$8,
		"Reset to Defaults": "Reset to Defaults",
		Rewind: Rewind$8,
		Script: Script$8,
		second: second$8,
		seconds: seconds$8,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Select Broadcast": "Select Broadcast",
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send$8,
		Settings: Settings$8,
		Share: Share$8,
		"Skip Ad": "Skip Ad",
		"Small Caps": "Small Caps",
		"Start at": "Start at",
		Stop: Stop$8,
		STREAM_LIMITED: STREAM_LIMITED$8,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$8,
		"Stream Type": "Stream Type",
		"Subscribed to ESPN+": "Subscribed to ESPN+",
		Subtitles: Subtitles$8,
		"subtitles off": "subtitles off",
		"Technical details": "Technical details",
		"Text Edge Style": "Text Edge Style",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "The video download was cancelled",
		"The video is bad or in a format that cannot be played on your browser": "The video is bad or in a format that cannot be played on your browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "The video you are trying to watch is encrypted and we do not know how to decrypt it",
		"This content is not available for your package or region.": "This content is not available for your package or region.",
		"This video is either unavailable or not supported in this browser": "This video is either unavailable or not supported in this browser",
		"This video is unavailable": "This video is unavailable",
		To: To$8,
		Transparent: Transparent$8,
		Uniform: Uniform$8,
		Unmute: Unmute$8,
		Unmuted: Unmuted$8,
		"Up Next": "Up Next",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Video Player",
		Watch: Watch$8,
		"WATCH NOW": "WATCH NOW",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$8,
		Window: Window$8,
		Yellow: Yellow$8,
		"You aborted the media playback": "You aborted the media playback",
		"elapsed out of": "elapsed out of",
		hours_minutes_seconds_format: hours_minutes_seconds_format$5,
		minutes_seconds_format: minutes_seconds_format$5
	};

	var Ad$7 = "Ad";
	var Autoplay$7 = "Autoplay";
	var Background$7 = "Background";
	var Black$7 = "Black";
	var Blue$7 = "Blue";
	var Button$7 = "Button";
	var Captions$7 = "Captions";
	var Casual$7 = "Casual";
	var Chapters$7 = "Chapters";
	var Copied$7 = "Copied";
	var Copy$7 = "Copy";
	var Cyan$7 = "Cyan";
	var Default$7 = "Default";
	var Depressed$7 = "Depressed";
	var Done$7 = "Done";
	var DRM_REQUIRED$7 = "DRM_REQUIRED";
	var Email$7 = "Email";
	var EMBARGOED$7 = "EMBARGOED";
	var EXPIRED$7 = "EXPIRED";
	var EXPIRED_CONTENT$7 = "EXPIRED_CONTENT";
	var Foreground$7 = "Foreground";
	var From$7 = "From";
	var Fullscreen$7 = "Fullscreen";
	var GEOLOCATION_NOT_ALLOWED$7 = "GEOLOCATION_NOT_ALLOWED";
	var Green$7 = "Green";
	var hour$7 = "hour";
	var hours$7 = "hours";
	var LIVE$7 = "LIVE";
	var Loaded$7 = "Loaded";
	var Magenta$7 = "Magenta";
	var Menu$7 = "Menu";
	var Message$7 = "Message";
	var minute$7 = "minute";
	var minutes$7 = "minutes";
	var More$7 = "More";
	var Mute$7 = "Mute";
	var NOT_FOUND$7 = "NOT_FOUND";
	var None$7 = "None";
	var OK$7 = "OK";
	var Opaque$7 = "Opaque";
	var Pause$7 = "Pause";
	var Pausing$7 = "Pausing";
	var Play$7 = "Play";
	var Playing$7 = "Playing";
	var Progress$7 = "Progress";
	var Purchased$7 = "Purchased";
	var Raised$7 = "Raised";
	var Red$7 = "Red";
	var Replay$7 = "Replay";
	var Rewind$7 = "Rewind";
	var Script$7 = "Script";
	var second$7 = "second";
	var seconds$7 = "seconds";
	var Send$7 = "Send";
	var Settings$7 = "Settings";
	var Share$7 = "Share";
	var Stop$7 = "Stop";
	var STREAM_LIMITED$7 = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$7 = "STREAM_LIMIT_ERROR";
	var Subtitles$7 = "Subtitles";
	var To$7 = "To";
	var Transparent$7 = "Transparent";
	var Uniform$7 = "Uniform";
	var Unmute$7 = "Unmute";
	var Unmuted$7 = "Unmuted";
	var Watch$7 = "Watch";
	var White$7 = "White";
	var Window$7 = "Window";
	var Yellow$7 = "Yellow";
	var hours_minutes_seconds_format$4 = "hours_minutes_seconds_format";
	var minutes_seconds_format$4 = "minutes_seconds_format";
	var sr = {
		"A network error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
		Ad: Ad$7,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio Options",
		Autoplay: Autoplay$7,
		"Back to video": "Back to video",
		"Close share": "Close share",
		Background: Background$7,
		Black: Black$7,
		Blue: Blue$7,
		Button: Button$7,
		"Buy PPV": "Buy PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Caption Settings",
		Captions: Captions$7,
		"captions off": "captions off",
		"Captions Preview": "Captions Preview",
		Casual: Casual$7,
		Chapters: Chapters$7,
		"Check out this video on ESPN": "Check out this video on ESPN",
		"Choose Broadcast": "Choose Broadcast",
		"Choose TV Provider": "Choose TV Provider",
		"Closed Caption": "Closed Caption",
		"Closed Captions": "Closed Captions",
		Copied: Copied$7,
		Copy: Copy$7,
		"Copy Embed Link": "Copy Embed Link",
		"Copy Link": "Copy Link",
		"Could not download the video": "Could not download the video",
		"Current Time": "Current Time",
		"currently behind live": "currently behind live",
		Cyan: Cyan$7,
		Default: Default$7,
		Depressed: Depressed$7,
		Done: Done$7,
		DRM_REQUIRED: DRM_REQUIRED$7,
		"Drop shadow": "Drop shadow",
		"Duration Time": "Duration Time",
		Email: Email$7,
		"Email Video": "Email Video",
		EMBARGOED: EMBARGOED$7,
		"Embed Code": "Embed Code",
		"Error Code": "Error Code",
		"Exit Full Screen": "Exit Full Screen",
		EXPIRED: EXPIRED$7,
		EXPIRED_CONTENT: EXPIRED_CONTENT$7,
		"Fast Forward": "Fast Forward",
		"Font Family": "Font Family",
		"Font Size": "Font Size",
		Foreground: Foreground$7,
		From: From$7,
		Fullscreen: Fullscreen$7,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$7,
		"Get ESPN+": "Get ESPN+",
		"Get MLB.TV": "Get MLB.TV",
		Green: Green$7,
		hour: hour$7,
		hours: hours$7,
		"Language Settings": "Language Settings",
		"Learn More": "Learn More",
		LIVE: LIVE$7,
		Loaded: Loaded$7,
		"Logged Into TV Provider": "Logged Into TV Provider",
		Magenta: Magenta$7,
		Menu: Menu$7,
		Message: Message$7,
		minute: minute$7,
		minutes: minutes$7,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$7,
		Mute: Mute$7,
		NOT_FOUND: NOT_FOUND$7,
		"No compatible source was found for this media.": "No compatible source was found for this media.",
		"No video has been loaded": "No video has been loaded",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$7,
		"Now Playing": "Now Playing",
		OK: OK$7,
		Opaque: Opaque$7,
		Pause: Pause$7,
		Pausing: Pausing$7,
		Play: Play$7,
		"Playback Rate": "Playback Rate",
		"Playback Speed": "Playback Speed",
		Playing: Playing$7,
		"please confirm you are connected to the internet": "please confirm you are connected to the internet",
		Progress: Progress$7,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$7,
		Raised: Raised$7,
		Red: Red$7,
		"Remaining Time": "Remaining Time",
		Replay: Replay$7,
		"Reset to Defaults": "Reset to Defaults",
		Rewind: Rewind$7,
		Script: Script$7,
		second: second$7,
		seconds: seconds$7,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Select Broadcast": "Select Broadcast",
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send$7,
		Settings: Settings$7,
		Share: Share$7,
		"Skip Ad": "Skip Ad",
		"Small Caps": "Small Caps",
		"Start at": "Start at",
		Stop: Stop$7,
		STREAM_LIMITED: STREAM_LIMITED$7,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$7,
		"Stream Type": "Stream Type",
		"Subscribed to ESPN+": "Subscribed to ESPN+",
		Subtitles: Subtitles$7,
		"subtitles off": "subtitles off",
		"Technical details": "Technical details",
		"Text Edge Style": "Text Edge Style",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "The video download was cancelled",
		"The video is bad or in a format that cannot be played on your browser": "The video is bad or in a format that cannot be played on your browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "The video you are trying to watch is encrypted and we do not know how to decrypt it",
		"This content is not available for your package or region.": "This content is not available for your package or region.",
		"This video is either unavailable or not supported in this browser": "This video is either unavailable or not supported in this browser",
		"This video is unavailable": "This video is unavailable",
		To: To$7,
		Transparent: Transparent$7,
		Uniform: Uniform$7,
		Unmute: Unmute$7,
		Unmuted: Unmuted$7,
		"Up Next": "Up Next",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Video Player",
		Watch: Watch$7,
		"WATCH NOW": "WATCH NOW",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$7,
		Window: Window$7,
		Yellow: Yellow$7,
		"You aborted the media playback": "You aborted the media playback",
		"elapsed out of": "elapsed out of",
		hours_minutes_seconds_format: hours_minutes_seconds_format$4,
		minutes_seconds_format: minutes_seconds_format$4
	};

	var Ad$6 = "Annons";
	var Autoplay$6 = "Automatisk uppspelning";
	var Background$6 = "Bakgrund";
	var Black$6 = "Svart";
	var Blue$6 = "BlÃ¥";
	var Button$6 = "Knapp";
	var Captions$6 = "Textning";
	var Casual$6 = "Informell";
	var Chapters$6 = "Kapitel";
	var Copied$6 = "Kopierad";
	var Copy$6 = "Kopiera";
	var Cyan$6 = "Cyan";
	var Default$6 = "Standard";
	var Depressed$6 = "Nedtryckt";
	var Done$6 = "Klar";
	var DRM_REQUIRED$6 = "DRM_REQUIRED";
	var Email$6 = "E-post";
	var EMBARGOED$6 = "EMBARGOED";
	var EXPIRED$6 = "EXPIRED";
	var EXPIRED_CONTENT$6 = "EXPIRED_CONTENT";
	var Foreground$6 = "FÃ¶rgrund";
	var From$6 = "FrÃ¥n";
	var Fullscreen$6 = "HelskÃ¤rm";
	var GEOLOCATION_NOT_ALLOWED$6 = "GEOLOCATION_NOT_ALLOWED";
	var Green$6 = "GrÃ¶n";
	var hour$6 = "timme";
	var hours$6 = "timmar";
	var LIVE$6 = "LIVE";
	var Loaded$6 = "Laddad";
	var Magenta$6 = "Magenta";
	var Menu$6 = "Meny";
	var Message$6 = "Meddelande";
	var minute$6 = "minut";
	var minutes$6 = "minuter";
	var More$6 = "Mer";
	var Mute$6 = "StÃ¤ng av ljud";
	var NOT_FOUND$6 = "NOT_FOUND";
	var None$6 = "Ingen";
	var OK$6 = "OK";
	var Opaque$6 = "Ogenomskinlig";
	var Pause$6 = "Paus";
	var Pausing$6 = "Pausar";
	var Play$6 = "Spela";
	var Playing$6 = "Spelar upp";
	var Progress$6 = "Sett hittills";
	var Purchased$6 = "KÃ¶pt";
	var Raised$6 = "HÃ¶jd";
	var Red$6 = "RÃ¶d";
	var Replay$6 = "Spela upp igen";
	var Rewind$6 = "Spola tillbaka";
	var Script$6 = "Skript";
	var second$6 = "sekund";
	var seconds$6 = "sekunder";
	var Send$6 = "Skicka";
	var Settings$6 = "InstÃ¤llningar";
	var Share$6 = "Dela";
	var Stop$6 = "Stoppa";
	var STREAM_LIMITED$6 = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$6 = "STREAM_LIMIT_ERROR";
	var Subtitles$6 = "Undertexter";
	var To$6 = "Till";
	var Transparent$6 = "Transparent";
	var Uniform$6 = "Enhetlig";
	var Unmute$6 = "SlÃ¥ pÃ¥ ljudet";
	var Unmuted$6 = "Ljudet Ã¤r pÃ¥";
	var Watch$6 = "Titta";
	var White$6 = "Vit";
	var Window$6 = "FÃ¶nster";
	var Yellow$6 = "Gul";
	var sv = {
		"A network error caused the media download to fail part-way.": "PÃ¥ grund av ett nÃ¤tverksfel misslyckades hÃ¤mtningen av videon.",
		Ad: Ad$6,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "Ett fel uppstod under videouppspelningen, mÃ¶jligtvis pÃ¥ grund av nÃ¤tverksanslutningen eller att den spelades upp i en bakgrundsflik. FÃ¶rsÃ¶k igen.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Ljudalternativ",
		Autoplay: Autoplay$6,
		"Back to video": "Tillbaka till videon",
		Background: Background$6,
		Black: Black$6,
		Blue: Blue$6,
		Button: Button$6,
		"Buy PPV": "KÃ¶p betal-TV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "InstÃ¤llningar fÃ¶r textning",
		Captions: Captions$6,
		"captions off": "textning av",
		"Captions Preview": "FÃ¶rhandsvisning av textning",
		Casual: Casual$6,
		Chapters: Chapters$6,
		"Check out this video on ESPN": "Se den hÃ¤r videon pÃ¥ ESPN",
		"Choose Broadcast": "VÃ¤lj sÃ¤ndning",
		"Choose TV Provider": "VÃ¤lj TV-leverantÃ¶r",
		"Closed Caption": "Undertext",
		"Closed Captions": "Undertexter",
		Copied: Copied$6,
		Copy: Copy$6,
		"Copy Embed Link": "Kopiera inbÃ¤ddningslÃ¤nk",
		"Copy Link": "Kopiera lÃ¤nk",
		"Could not download the video": "Could not download the video",
		"Current Time": "Aktuell tid",
		"currently behind live": "fÃ¶rdrÃ¶jning efter live",
		Cyan: Cyan$6,
		Default: Default$6,
		Depressed: Depressed$6,
		Done: Done$6,
		DRM_REQUIRED: DRM_REQUIRED$6,
		"Drop shadow": "Skugga",
		"Duration Time": "Varaktighet",
		Email: Email$6,
		"Email Video": "Skicka video med e-post",
		EMBARGOED: EMBARGOED$6,
		"Embed Code": "InbÃ¤ddningskod",
		"Error Code": "Felkod",
		"Exit Full Screen": "LÃ¤mna helskÃ¤rm",
		EXPIRED: EXPIRED$6,
		EXPIRED_CONTENT: EXPIRED_CONTENT$6,
		"Fast Forward": "Spola framÃ¥t",
		"Font Family": "Teckensnittsfamilj",
		"Font Size": "Teckensnittsstorlek",
		Foreground: Foreground$6,
		From: From$6,
		Fullscreen: Fullscreen$6,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$6,
		"Get ESPN+": "Skaffa ESPN+",
		"Get MLB.TV": "Skaffa MLB.TV",
		Green: Green$6,
		hour: hour$6,
		hours: hours$6,
		"Language Settings": "SprÃ¥kinstÃ¤llningar",
		"Learn More": "LÃ¤s mer",
		LIVE: LIVE$6,
		Loaded: Loaded$6,
		"Logged Into TV Provider": "Inloggad hos TV-leverantÃ¶r",
		Magenta: Magenta$6,
		Menu: Menu$6,
		Message: Message$6,
		minute: minute$6,
		minutes: minutes$6,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$6,
		Mute: Mute$6,
		NOT_FOUND: NOT_FOUND$6,
		"No compatible source was found for this media.": "Ingen kompatibel kÃ¤lla hittades fÃ¶r videon.",
		"No video has been loaded": "Ingen video har laddats",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$6,
		"Now Playing": "Spelar upp",
		OK: OK$6,
		Opaque: Opaque$6,
		Pause: Pause$6,
		Pausing: Pausing$6,
		Play: Play$6,
		"Playback Rate": "Uppspelningsfrekvens",
		"Playback Speed": "Uppspelningshastighet",
		Playing: Playing$6,
		"please confirm you are connected to the internet": "bekrÃ¤fta att du Ã¤r ansluten till internet",
		Progress: Progress$6,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$6,
		Raised: Raised$6,
		Red: Red$6,
		"Remaining Time": "ÃterstÃ¥ende tid",
		Replay: Replay$6,
		"Reset to Defaults": "ÃterstÃ¤ll till standard",
		Rewind: Rewind$6,
		Script: Script$6,
		second: second$6,
		seconds: seconds$6,
		"Seek to live": "SÃ¶k till live",
		"Seek to live, currently playing live": "SÃ¶k till live, spelar nu upp live",
		"Select Broadcast": "VÃ¤lj sÃ¤ndning",
		"Semi-Opaque": "Halvgenomskinlig",
		"Semi-Transparent": "Halvtransparent",
		Send: Send$6,
		Settings: Settings$6,
		Share: Share$6,
		"Skip Ad": "Hoppa Ã¶ver annons",
		"Small Caps": "SmÃ¥ bokstÃ¤ver",
		"Start at": "Starta vid",
		Stop: Stop$6,
		STREAM_LIMITED: STREAM_LIMITED$6,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$6,
		"Stream Type": "StrÃ¶mningstyp",
		"Subscribed to ESPN+": "Prenumererar pÃ¥ ESPN+",
		Subtitles: Subtitles$6,
		"subtitles off": "undertexter av",
		"Technical details": "Teknisk information",
		"Text Edge Style": "Textens kantstil",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "Det maximala antalet samtidiga strÃ¶mningar har uppnÃ¥tts pÃ¥ ditt konto. Om du har nÃ¥gra frÃ¥gor eller behÃ¶ver hjÃ¤lp, gÃ¥ till es.pn/watchfaq eller ring 888-549-ESPN.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Media kunde inte laddas, antingen pÃ¥ grund av problem med servern eller nÃ¤tverket, eller fÃ¶r att formatet inte stÃ¶ds.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "Videoanslutningen fÃ¶rlorades",
		"The video download was cancelled": "VideohÃ¤mtningen avbrÃ¶ts",
		"The video is bad or in a format that cannot be played on your browser": "Videon Ã¤r skadad eller i ett format som inte kan spelas upp i din webblÃ¤sare",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Videouppspelningen avbrÃ¶ts pÃ¥ grund av en skada eller fÃ¶r att videon anvÃ¤nder funktioner som inte stÃ¶ds av din webblÃ¤sare.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Videon du fÃ¶rsÃ¶ker titta pÃ¥ Ã¤r krypterad och vi kan inte dekryptera den.",
		"This content is not available for your package or region.": "Detta innehÃ¥ll Ã¤r inte tillgÃ¤ngligt fÃ¶r ditt paket eller din region.",
		"This video is either unavailable or not supported in this browser": "Denna video Ã¤r antingen inte tillgÃ¤nglig eller stÃ¶ds inte i den hÃ¤r webblÃ¤saren",
		"This video is unavailable": "Denna video Ã¤r inte tillgÃ¤nglig",
		To: To$6,
		Transparent: Transparent$6,
		Uniform: Uniform$6,
		Unmute: Unmute$6,
		Unmuted: Unmuted$6,
		"Up Next": "Kommer hÃ¤rnÃ¤st",
		"Video has expired.": "Videon har upphÃ¶rt",
		"Video is not available in your country.": "Videon Ã¤r inte tillgÃ¤nglig i ditt land.",
		"Video is not yet available.": "Videon Ã¤r inte tillgÃ¤nglig Ã¤n.",
		"Video Player": "Videospelare",
		Watch: Watch$6,
		"WATCH NOW": "TITTA NU",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "Den hÃ¤r webblÃ¤saren stÃ¶ds tyvÃ¤rr inte lÃ¤ngre. Uppgradera till den senaste versionen av Google Chrome, FireFox eller Microsoft Edge fÃ¶r att titta pÃ¥ det hÃ¤r innehÃ¥llet.",
		White: White$6,
		Window: Window$6,
		Yellow: Yellow$6,
		"You aborted the media playback": "Du avbrÃ¶t videouppspelningen",
		"elapsed out of": "fÃ¶rfluten tid av"
	};

	var Ad$5 = "Ad";
	var Autoplay$5 = "Autoplay";
	var Background$5 = "Background";
	var Black$5 = "Black";
	var Blue$5 = "Blue";
	var Button$5 = "Button";
	var Captions$5 = "Captions";
	var Casual$5 = "Casual";
	var Chapters$5 = "Chapters";
	var Copied$5 = "Copied";
	var Copy$5 = "Copy";
	var Cyan$5 = "Cyan";
	var Default$5 = "Default";
	var Depressed$5 = "Depressed";
	var Done$5 = "Done";
	var DRM_REQUIRED$5 = "DRM_REQUIRED";
	var Email$5 = "Email";
	var EMBARGOED$5 = "EMBARGOED";
	var EXPIRED$5 = "EXPIRED";
	var EXPIRED_CONTENT$5 = "EXPIRED_CONTENT";
	var Foreground$5 = "Foreground";
	var From$5 = "From";
	var Fullscreen$5 = "Fullscreen";
	var GEOLOCATION_NOT_ALLOWED$5 = "GEOLOCATION_NOT_ALLOWED";
	var Green$5 = "Green";
	var hour$5 = "hour";
	var hours$5 = "hours";
	var LIVE$5 = "LIVE";
	var Loaded$5 = "Loaded";
	var Magenta$5 = "Magenta";
	var Menu$5 = "Menu";
	var Message$5 = "Message";
	var minute$5 = "minute";
	var minutes$5 = "minutes";
	var More$5 = "More";
	var Mute$5 = "Mute";
	var NOT_FOUND$5 = "NOT_FOUND";
	var None$5 = "None";
	var OK$5 = "OK";
	var Opaque$5 = "Opaque";
	var Pause$5 = "Pause";
	var Pausing$5 = "Pausing";
	var Play$5 = "Play";
	var Playing$5 = "Playing";
	var Progress$5 = "Progress";
	var Purchased$5 = "Purchased";
	var Raised$5 = "Raised";
	var Red$5 = "Red";
	var Replay$5 = "Replay";
	var Rewind$5 = "Rewind";
	var Script$5 = "Script";
	var second$5 = "second";
	var seconds$5 = "seconds";
	var Send$5 = "Send";
	var Settings$5 = "Settings";
	var Share$5 = "Share";
	var Stop$5 = "Stop";
	var STREAM_LIMITED$5 = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$5 = "STREAM_LIMIT_ERROR";
	var Subtitles$5 = "Subtitles";
	var To$5 = "To";
	var Transparent$5 = "Transparent";
	var Uniform$5 = "Uniform";
	var Unmute$5 = "Unmute";
	var Unmuted$5 = "Unmuted";
	var Watch$5 = "Watch";
	var White$5 = "White";
	var Window$5 = "Window";
	var Yellow$5 = "Yellow";
	var hours_minutes_seconds_format$3 = "hours_minutes_seconds_format";
	var minutes_seconds_format$3 = "minutes_seconds_format";
	var th = {
		"A network error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
		Ad: Ad$5,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio Options",
		Autoplay: Autoplay$5,
		"Back to video": "Back to video",
		Background: Background$5,
		Black: Black$5,
		Blue: Blue$5,
		Button: Button$5,
		"Buy PPV": "Buy PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Caption Settings",
		Captions: Captions$5,
		"captions off": "captions off",
		"Captions Preview": "Captions Preview",
		Casual: Casual$5,
		Chapters: Chapters$5,
		"Check out this video on ESPN": "Check out this video on ESPN",
		"Choose Broadcast": "Choose Broadcast",
		"Choose TV Provider": "Choose TV Provider",
		"Closed Caption": "Closed Caption",
		"Closed Captions": "Closed Captions",
		Copied: Copied$5,
		Copy: Copy$5,
		"Copy Embed Link": "Copy Embed Link",
		"Copy Link": "Copy Link",
		"Could not download the video": "Could not download the video",
		"Current Time": "Current Time",
		"currently behind live": "currently behind live",
		Cyan: Cyan$5,
		Default: Default$5,
		Depressed: Depressed$5,
		Done: Done$5,
		DRM_REQUIRED: DRM_REQUIRED$5,
		"Drop shadow": "Drop shadow",
		"Duration Time": "Duration Time",
		Email: Email$5,
		"Email Video": "Email Video",
		EMBARGOED: EMBARGOED$5,
		"Embed Code": "Embed Code",
		"Error Code": "Error Code",
		"Exit Full Screen": "Exit Full Screen",
		EXPIRED: EXPIRED$5,
		EXPIRED_CONTENT: EXPIRED_CONTENT$5,
		"Fast Forward": "Fast Forward",
		"Font Family": "Font Family",
		"Font Size": "Font Size",
		Foreground: Foreground$5,
		From: From$5,
		Fullscreen: Fullscreen$5,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$5,
		"Get ESPN+": "Get ESPN+",
		"Get MLB.TV": "Get MLB.TV",
		Green: Green$5,
		hour: hour$5,
		hours: hours$5,
		"Language Settings": "Language Settings",
		"Learn More": "Learn More",
		LIVE: LIVE$5,
		Loaded: Loaded$5,
		"Logged Into TV Provider": "Logged Into TV Provider",
		Magenta: Magenta$5,
		Menu: Menu$5,
		Message: Message$5,
		minute: minute$5,
		minutes: minutes$5,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$5,
		Mute: Mute$5,
		NOT_FOUND: NOT_FOUND$5,
		"No compatible source was found for this media.": "No compatible source was found for this media.",
		"No video has been loaded": "No video has been loaded",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$5,
		"Now Playing": "Now Playing",
		OK: OK$5,
		Opaque: Opaque$5,
		Pause: Pause$5,
		Pausing: Pausing$5,
		Play: Play$5,
		"Playback Rate": "Playback Rate",
		"Playback Speed": "Playback Speed",
		Playing: Playing$5,
		"please confirm you are connected to the internet": "please confirm you are connected to the internet",
		Progress: Progress$5,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$5,
		Raised: Raised$5,
		Red: Red$5,
		"Remaining Time": "Remaining Time",
		Replay: Replay$5,
		"Reset to Defaults": "Reset to Defaults",
		Rewind: Rewind$5,
		Script: Script$5,
		second: second$5,
		seconds: seconds$5,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Select Broadcast": "Select Broadcast",
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send$5,
		Settings: Settings$5,
		Share: Share$5,
		"Skip Ad": "Skip Ad",
		"Small Caps": "Small Caps",
		"Start at": "Start at",
		Stop: Stop$5,
		STREAM_LIMITED: STREAM_LIMITED$5,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$5,
		"Stream Type": "Stream Type",
		"Subscribed to ESPN+": "Subscribed to ESPN+",
		Subtitles: Subtitles$5,
		"subtitles off": "subtitles off",
		"Technical details": "Technical details",
		"Text Edge Style": "Text Edge Style",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "The video download was cancelled",
		"The video is bad or in a format that cannot be played on your browser": "The video is bad or in a format that cannot be played on your browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "The video you are trying to watch is encrypted and we do not know how to decrypt it",
		"This content is not available for your package or region.": "This content is not available for your package or region.",
		"This video is either unavailable or not supported in this browser": "This video is either unavailable or not supported in this browser",
		"This video is unavailable": "This video is unavailable",
		To: To$5,
		Transparent: Transparent$5,
		Uniform: Uniform$5,
		Unmute: Unmute$5,
		Unmuted: Unmuted$5,
		"Up Next": "Up Next",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Video Player",
		Watch: Watch$5,
		"WATCH NOW": "WATCH NOW",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$5,
		Window: Window$5,
		Yellow: Yellow$5,
		"You aborted the media playback": "You aborted the media playback",
		"elapsed out of": "elapsed out of",
		hours_minutes_seconds_format: hours_minutes_seconds_format$3,
		minutes_seconds_format: minutes_seconds_format$3
	};

	var Ad$4 = "Ad";
	var Autoplay$4 = "Autoplay";
	var Background$4 = "Background";
	var Black$4 = "Black";
	var Blue$4 = "Blue";
	var Button$4 = "Button";
	var Captions$4 = "Captions";
	var Casual$4 = "Casual";
	var Chapters$4 = "Chapters";
	var Copied$4 = "Copied";
	var Copy$4 = "Copy";
	var Cyan$4 = "Cyan";
	var Default$4 = "Default";
	var Depressed$4 = "Depressed";
	var Done$4 = "Done";
	var DRM_REQUIRED$4 = "DRM_REQUIRED";
	var Email$4 = "Email";
	var EMBARGOED$4 = "EMBARGOED";
	var EXPIRED$4 = "EXPIRED";
	var EXPIRED_CONTENT$4 = "EXPIRED_CONTENT";
	var Foreground$4 = "Foreground";
	var From$4 = "From";
	var Fullscreen$4 = "Fullscreen";
	var GEOLOCATION_NOT_ALLOWED$4 = "GEOLOCATION_NOT_ALLOWED";
	var Green$4 = "Green";
	var hour$4 = "hour";
	var hours$4 = "hours";
	var LIVE$4 = "LIVE";
	var Loaded$4 = "Loaded";
	var Magenta$4 = "Magenta";
	var Menu$4 = "Menu";
	var Message$4 = "Message";
	var minute$4 = "minute";
	var minutes$4 = "minutes";
	var More$4 = "More";
	var Mute$4 = "Mute";
	var NOT_FOUND$4 = "NOT_FOUND";
	var None$4 = "None";
	var OK$4 = "OK";
	var Opaque$4 = "Opaque";
	var Pause$4 = "Pause";
	var Pausing$4 = "Pausing";
	var Play$4 = "Play";
	var Playing$4 = "Playing";
	var Progress$4 = "Progress";
	var Purchased$4 = "Purchased";
	var Raised$4 = "Raised";
	var Red$4 = "Red";
	var Replay$4 = "Replay";
	var Rewind$4 = "Rewind";
	var Script$4 = "Script";
	var second$4 = "second";
	var seconds$4 = "seconds";
	var Send$4 = "Send";
	var Settings$4 = "Settings";
	var Share$4 = "Share";
	var Stop$4 = "Stop";
	var STREAM_LIMITED$4 = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$4 = "STREAM_LIMIT_ERROR";
	var Subtitles$4 = "Subtitles";
	var To$4 = "To";
	var Transparent$4 = "Transparent";
	var Uniform$4 = "Uniform";
	var Unmute$4 = "Unmute";
	var Unmuted$4 = "Unmuted";
	var Watch$4 = "Watch";
	var White$4 = "White";
	var Window$4 = "Window";
	var Yellow$4 = "Yellow";
	var hours_minutes_seconds_format$2 = "hours_minutes_seconds_format";
	var minutes_seconds_format$2 = "minutes_seconds_format";
	var tl = {
		"A network error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
		Ad: Ad$4,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio Options",
		Autoplay: Autoplay$4,
		"Back to video": "Back to video",
		Background: Background$4,
		Black: Black$4,
		Blue: Blue$4,
		Button: Button$4,
		"Buy PPV": "Buy PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Caption Settings",
		Captions: Captions$4,
		"captions off": "captions off",
		"Captions Preview": "Captions Preview",
		Casual: Casual$4,
		Chapters: Chapters$4,
		"Check out this video on ESPN": "Check out this video on ESPN",
		"Choose Broadcast": "Choose Broadcast",
		"Choose TV Provider": "Choose TV Provider",
		"Closed Caption": "Closed Caption",
		"Closed Captions": "Closed Captions",
		Copied: Copied$4,
		Copy: Copy$4,
		"Copy Embed Link": "Copy Embed Link",
		"Copy Link": "Copy Link",
		"Could not download the video": "Could not download the video",
		"Current Time": "Current Time",
		"currently behind live": "currently behind live",
		Cyan: Cyan$4,
		Default: Default$4,
		Depressed: Depressed$4,
		Done: Done$4,
		DRM_REQUIRED: DRM_REQUIRED$4,
		"Drop shadow": "Drop shadow",
		"Duration Time": "Duration Time",
		Email: Email$4,
		"Email Video": "Email Video",
		EMBARGOED: EMBARGOED$4,
		"Embed Code": "Embed Code",
		"Error Code": "Error Code",
		"Exit Full Screen": "Exit Full Screen",
		EXPIRED: EXPIRED$4,
		EXPIRED_CONTENT: EXPIRED_CONTENT$4,
		"Fast Forward": "Fast Forward",
		"Font Family": "Font Family",
		"Font Size": "Font Size",
		Foreground: Foreground$4,
		From: From$4,
		Fullscreen: Fullscreen$4,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$4,
		"Get ESPN+": "Get ESPN+",
		"Get MLB.TV": "Get MLB.TV",
		Green: Green$4,
		hour: hour$4,
		hours: hours$4,
		"Language Settings": "Language Settings",
		"Learn More": "Learn More",
		LIVE: LIVE$4,
		Loaded: Loaded$4,
		"Logged Into TV Provider": "Logged Into TV Provider",
		Magenta: Magenta$4,
		Menu: Menu$4,
		Message: Message$4,
		minute: minute$4,
		minutes: minutes$4,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$4,
		Mute: Mute$4,
		NOT_FOUND: NOT_FOUND$4,
		"No compatible source was found for this media.": "No compatible source was found for this media.",
		"No video has been loaded": "No video has been loaded",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$4,
		"Now Playing": "Now Playing",
		OK: OK$4,
		Opaque: Opaque$4,
		Pause: Pause$4,
		Pausing: Pausing$4,
		Play: Play$4,
		"Playback Rate": "Playback Rate",
		"Playback Speed": "Playback Speed",
		Playing: Playing$4,
		"please confirm you are connected to the internet": "please confirm you are connected to the internet",
		Progress: Progress$4,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$4,
		Raised: Raised$4,
		Red: Red$4,
		"Remaining Time": "Remaining Time",
		Replay: Replay$4,
		"Reset to Defaults": "Reset to Defaults",
		Rewind: Rewind$4,
		Script: Script$4,
		second: second$4,
		seconds: seconds$4,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Select Broadcast": "Select Broadcast",
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send$4,
		Settings: Settings$4,
		Share: Share$4,
		"Skip Ad": "Skip Ad",
		"Small Caps": "Small Caps",
		"Start at": "Start at",
		Stop: Stop$4,
		STREAM_LIMITED: STREAM_LIMITED$4,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$4,
		"Stream Type": "Stream Type",
		"Subscribed to ESPN+": "Subscribed to ESPN+",
		Subtitles: Subtitles$4,
		"subtitles off": "subtitles off",
		"Technical details": "Technical details",
		"Text Edge Style": "Text Edge Style",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "The video download was cancelled",
		"The video is bad or in a format that cannot be played on your browser": "The video is bad or in a format that cannot be played on your browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "The video you are trying to watch is encrypted and we do not know how to decrypt it",
		"This content is not available for your package or region.": "This content is not available for your package or region.",
		"This video is either unavailable or not supported in this browser": "This video is either unavailable or not supported in this browser",
		"This video is unavailable": "This video is unavailable",
		To: To$4,
		Transparent: Transparent$4,
		Uniform: Uniform$4,
		Unmute: Unmute$4,
		Unmuted: Unmuted$4,
		"Up Next": "Up Next",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Video Player",
		Watch: Watch$4,
		"WATCH NOW": "WATCH NOW",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$4,
		Window: Window$4,
		Yellow: Yellow$4,
		"You aborted the media playback": "You aborted the media playback",
		"elapsed out of": "elapsed out of",
		hours_minutes_seconds_format: hours_minutes_seconds_format$2,
		minutes_seconds_format: minutes_seconds_format$2
	};

	var Ad$3 = "Reklam";
	var Autoplay$3 = "Otomatik Oynatma";
	var Background$3 = "Arka Plan";
	var Black$3 = "Siyah";
	var Blue$3 = "Mavi";
	var Button$3 = "DÃ¼Äme";
	var Captions$3 = "AÃ§Ä±klamalÄ± Alt YazÄ±lar";
	var Casual$3 = "Rahat";
	var Chapters$3 = "BÃ¶lÃ¼mler";
	var Copied$3 = "KopyalandÄ±";
	var Copy$3 = "Kopyala";
	var Cyan$3 = "CamgÃ¶beÄi";
	var Default$3 = "VarsayÄ±lan";
	var Depressed$3 = "BasÄ±lÄ±";
	var Done$3 = "Bitti";
	var DRM_REQUIRED$3 = "DRM_REQUIRED";
	var Email$3 = "E-posta";
	var EMBARGOED$3 = "EMBARGOED";
	var EXPIRED$3 = "EXPIRED";
	var EXPIRED_CONTENT$3 = "EXPIRED_CONTENT";
	var Foreground$3 = "Ãn Plan";
	var From$3 = "Kaynak";
	var Fullscreen$3 = "Tam Ekran";
	var GEOLOCATION_NOT_ALLOWED$3 = "GEOLOCATION_NOT_ALLOWED";
	var Green$3 = "YeÅil";
	var hour$3 = "saat";
	var hours$3 = "saat";
	var LIVE$3 = "CANLI";
	var Loaded$3 = "YÃ¼klendi";
	var Magenta$3 = "Eflatun";
	var Menu$3 = "MenÃ¼";
	var Message$3 = "Mesaj";
	var minute$3 = "dakika";
	var minutes$3 = "dakika";
	var More$3 = "DiÄer";
	var Mute$3 = "Sesi Kapat";
	var NOT_FOUND$3 = "NOT_FOUND";
	var None$3 = "HiÃ§biri";
	var OK$3 = "Tamam";
	var Opaque$3 = "Opak";
	var Pause$3 = "Duraklat";
	var Pausing$3 = "DuraklatÄ±lÄ±yor";
	var Play$3 = "Oynat";
	var Playing$3 = "OynatÄ±lÄ±yor";
	var Progress$3 = "Ä°lerleme";
	var Purchased$3 = "SatÄ±n AlÄ±ndÄ±";
	var Raised$3 = "YÃ¼kseltildi";
	var Red$3 = "KÄ±rmÄ±zÄ±";
	var Replay$3 = "Tekrar Oynat";
	var Rewind$3 = "Geri Sar";
	var Script$3 = "Betik";
	var second$3 = "saniye";
	var seconds$3 = "saniye";
	var Send$3 = "GÃ¶nder";
	var Settings$3 = "Ayarlar";
	var Share$3 = "PaylaÅ";
	var Stop$3 = "Durdur";
	var STREAM_LIMITED$3 = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$3 = "STREAM_LIMIT_ERROR";
	var Subtitles$3 = "Alt YazÄ±lar";
	var To$3 = "Hedef";
	var Transparent$3 = "Åeffaf";
	var Uniform$3 = "TekdÃ¼zen";
	var Unmute$3 = "Sesi AÃ§";
	var Unmuted$3 = "Sesi AÃ§Ä±ldÄ±";
	var Watch$3 = "Ä°zle";
	var White$3 = "Beyaz";
	var Window$3 = "Pencere";
	var Yellow$3 = "SarÄ±";
	var tr = {
		"A network error caused the media download to fail part-way.": "Bir aÄ hatasÄ± nedeniyle videonun indirilmesi yarÄ±da kesildi.",
		Ad: Ad$3,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "AÄ baÄlantÄ± sorunu veya arka plandaki bir tarayÄ±cÄ± sekmesinde olmasÄ± nedeniyle video oynatÄ±lÄ±rken bir hata oluÅtu. LÃ¼tfen tekrar deneyin.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Ses SeÃ§enekleri",
		Autoplay: Autoplay$3,
		"Back to video": "Videoya Geri DÃ¶n",
		"Close share": "Close share",
		Background: Background$3,
		Black: Black$3,
		Blue: Blue$3,
		Button: Button$3,
		"Buy PPV": "Ä°BÃ SatÄ±n Al",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "AÃ§Ä±klamalÄ± Alt YazÄ± AyarlarÄ±",
		Captions: Captions$3,
		"captions off": "AÃ§Ä±klamalÄ± Alt YazÄ±lar KapalÄ±",
		"Captions Preview": "AÃ§Ä±klamalÄ± Alt YazÄ± Ãn Ä°zlemesi",
		Casual: Casual$3,
		Chapters: Chapters$3,
		"Check out this video on ESPN": "ESPN Ã¼zerinden bu videoya gÃ¶z at",
		"Choose Broadcast": "YayÄ±n SeÃ§",
		"Choose TV Provider": "TV SaÄlayÄ±cÄ±sÄ± SeÃ§",
		"Closed Caption": "KapalÄ± AÃ§Ä±klamalÄ± Alt YazÄ±",
		"Closed Captions": "KapalÄ± AÃ§Ä±klamalÄ± Alt YazÄ±lar",
		Copied: Copied$3,
		Copy: Copy$3,
		"Copy Embed Link": "GÃ¶mÃ¼lÃ¼ BaÄlantÄ±yÄ± Kopyala",
		"Copy Link": "BaÄlantÄ±yÄ± Kopyala",
		"Could not download the video": "Could not download the video",
		"Current Time": "GeÃ§erli Zaman",
		"currently behind live": "Åu anda canlÄ± yayÄ±nÄ±n gerisinde",
		Cyan: Cyan$3,
		Default: Default$3,
		Depressed: Depressed$3,
		Done: Done$3,
		DRM_REQUIRED: DRM_REQUIRED$3,
		"Drop shadow": "Alt GÃ¶lge",
		"Duration Time": "SÃ¼re",
		Email: Email$3,
		"Email Video": "Videoyu E-postayla GÃ¶nder",
		EMBARGOED: EMBARGOED$3,
		"Embed Code": "GÃ¶mme Kodu",
		"Error Code": "Hata Kodu",
		"Exit Full Screen": "Tam Ekrandan ÃÄ±k",
		EXPIRED: EXPIRED$3,
		EXPIRED_CONTENT: EXPIRED_CONTENT$3,
		"Fast Forward": "HÄ±zlÄ± Ä°leri Sar",
		"Font Family": "YazÄ± Tipi Ailesi",
		"Font Size": "YazÄ± Tipi Boyutu",
		Foreground: Foreground$3,
		From: From$3,
		Fullscreen: Fullscreen$3,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$3,
		"Get ESPN+": "ESPN+'Ä± Al",
		"Get MLB.TV": "MLB.TV'yi Al",
		Green: Green$3,
		hour: hour$3,
		hours: hours$3,
		"Language Settings": "Dil AyarlarÄ±",
		"Learn More": "Daha Fazla Bilgi",
		LIVE: LIVE$3,
		Loaded: Loaded$3,
		"Logged Into TV Provider": "TV SaÄlayÄ±cÄ±sÄ±nda Oturum AÃ§Ä±ldÄ±",
		Magenta: Magenta$3,
		Menu: Menu$3,
		Message: Message$3,
		minute: minute$3,
		minutes: minutes$3,
		"Monospace Sans-Serif": "Tek AralÄ±klÄ± TÄ±rnaksÄ±z",
		"Monospace Serif": "Tek AralÄ±klÄ± TÄ±rnaklÄ±",
		More: More$3,
		Mute: Mute$3,
		NOT_FOUND: NOT_FOUND$3,
		"No compatible source was found for this media.": "Bu video iÃ§in uyumlu bir kaynak bulunamadÄ±.",
		"No video has been loaded": "YÃ¼klÃ¼ video yok",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$3,
		"Now Playing": "Åimdi OynatÄ±lÄ±yor",
		OK: OK$3,
		Opaque: Opaque$3,
		Pause: Pause$3,
		Pausing: Pausing$3,
		Play: Play$3,
		"Playback Rate": "Oynatma OranÄ±",
		"Playback Speed": "Oynatma HÄ±zÄ±",
		Playing: Playing$3,
		"please confirm you are connected to the internet": "LÃ¼tfen internete baÄlÄ± olduÄunuzu doÄrulayÄ±n",
		Progress: Progress$3,
		"Proportional Sans-Serif": "OrantÄ±lÄ± TÄ±rnaksÄ±z",
		"Proportional Serif": "OrantÄ±lÄ± TÄ±rnaklÄ±",
		Purchased: Purchased$3,
		Raised: Raised$3,
		Red: Red$3,
		"Remaining Time": "Kalan SÃ¼re",
		Replay: Replay$3,
		"Reset to Defaults": "VarsayÄ±lana SÄ±fÄ±rla",
		Rewind: Rewind$3,
		Script: Script$3,
		second: second$3,
		seconds: seconds$3,
		"Seek to live": "CanlÄ± yayÄ±nda ara",
		"Seek to live, currently playing live": "CanlÄ± yayÄ±nda ara, Åu anda canlÄ± oynatÄ±lÄ±yor",
		"Select Broadcast": "YayÄ±n SeÃ§",
		"Semi-Opaque": "YarÄ± Opak",
		"Semi-Transparent": "YarÄ± Åeffaf",
		Send: Send$3,
		Settings: Settings$3,
		Share: Share$3,
		"Skip Ad": "ReklamÄ± GeÃ§",
		"Small Caps": "KÃ¼Ã§Ã¼k Harf",
		"Start at": "BaÅlatma NoktasÄ±:",
		Stop: Stop$3,
		STREAM_LIMITED: STREAM_LIMITED$3,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$3,
		"Stream Type": "AkÄ±Å TÃ¼rÃ¼",
		"Subscribed to ESPN+": "ESPN+'a Abone Olundu",
		Subtitles: Subtitles$3,
		"subtitles off": "Alt YazÄ±lar KapalÄ±",
		"Technical details": "Teknik Bilgiler",
		"Text Edge Style": "Metin Kenar Stili",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "HesabÄ±nÄ±zda aynÄ± anda yapÄ±labilecek maksimum akÄ±Å sayÄ±sÄ±na ulaÅÄ±ldÄ±. SorularÄ±nÄ±z veya desteÄe ihtiyacÄ±nÄ±z varsa lÃ¼tfen es.pn/watchfaq adresini ziyaret edin veya 888-549-ESPN numarasÄ±nÄ± arayÄ±n.",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "Sunucu ya da aÄ hatasÄ± nedeniyle veya format desteklenmediÄi iÃ§in medya yÃ¼klenemedi.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "Video baÄlantÄ±sÄ± koptu",
		"The video download was cancelled": "Video indirmesi iptal edildi",
		"The video is bad or in a format that cannot be played on your browser": "Video bozuk ya da tarayÄ±cÄ±nÄ±zda oynatÄ±lamayacak bir formatta",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "Bir bozulma sorunu nedeniyle veya videoda tarayÄ±cÄ±nÄ±z tarafÄ±ndan desteklenmeyen Ã¶zellikler kullanÄ±ldÄ±ÄÄ± iÃ§in video oynatÄ±mÄ± yarÄ±da kesildi.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "Ä°zlemeye Ã§alÄ±ÅtÄ±ÄÄ±nÄ±z video Åifreli ve bunun Åifresinin nasÄ±l Ã§Ã¶zÃ¼leceÄini bilmiyoruz.",
		"This content is not available for your package or region.": "Bu iÃ§erik elinizdeki paket dÃ¢hilinde veya bulunduÄunuz bÃ¶lgede izlenemez.",
		"This video is either unavailable or not supported in this browser": "Bu video kullanÄ±lamÄ±yor veya bu tarayÄ±cÄ±da desteklenmiyor",
		"This video is unavailable": "Bu video kullanÄ±lamÄ±yor.",
		To: To$3,
		Transparent: Transparent$3,
		Uniform: Uniform$3,
		Unmute: Unmute$3,
		Unmuted: Unmuted$3,
		"Up Next": "SÄ±radaki",
		"Video has expired.": "Videonun sÃ¼resi doldu.",
		"Video is not available in your country.": "Video bulunduÄunuz Ã¼lkede mevcut deÄil.",
		"Video is not yet available.": "Video henÃ¼z mevcut deÄil.",
		"Video Player": "Video OynatÄ±cÄ±sÄ±",
		Watch: Watch$3,
		"WATCH NOW": "HEMEN Ä°ZLE",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "ÃzgÃ¼nÃ¼z ama bu tarayÄ±cÄ± artÄ±k desteklenmiyor. Bu iÃ§eriÄi izleyebilmek iÃ§in lÃ¼tfen Google Chrome, FireFox veya Microsoft Edge'in en son sÃ¼rÃ¼mÃ¼ne yÃ¼kseltin.",
		White: White$3,
		Window: Window$3,
		Yellow: Yellow$3,
		"You aborted the media playback": "Video oynatÄ±mÄ±ndan Ã§Ä±ktÄ±nÄ±z",
		"elapsed out of": "geÃ§ti/"
	};

	var Ad$2 = "Ad";
	var Autoplay$2 = "Autoplay";
	var Background$2 = "Background";
	var Black$2 = "Black";
	var Blue$2 = "Blue";
	var Button$2 = "Button";
	var Captions$2 = "Captions";
	var Casual$2 = "Casual";
	var Chapters$2 = "Chapters";
	var Copied$2 = "Copied";
	var Copy$2 = "Copy";
	var Cyan$2 = "Cyan";
	var Default$2 = "Default";
	var Depressed$2 = "Depressed";
	var Done$2 = "Done";
	var DRM_REQUIRED$2 = "DRM_REQUIRED";
	var Email$2 = "Email";
	var EMBARGOED$2 = "EMBARGOED";
	var EXPIRED$2 = "EXPIRED";
	var EXPIRED_CONTENT$2 = "EXPIRED_CONTENT";
	var Foreground$2 = "Foreground";
	var From$2 = "From";
	var Fullscreen$2 = "Fullscreen";
	var GEOLOCATION_NOT_ALLOWED$2 = "GEOLOCATION_NOT_ALLOWED";
	var Green$2 = "Green";
	var hour$2 = "hour";
	var hours$2 = "hours";
	var LIVE$2 = "LIVE";
	var Loaded$2 = "Loaded";
	var Magenta$2 = "Magenta";
	var Menu$2 = "Menu";
	var Message$2 = "Message";
	var minute$2 = "minute";
	var minutes$2 = "minutes";
	var More$2 = "More";
	var Mute$2 = "Mute";
	var NOT_FOUND$2 = "NOT_FOUND";
	var None$2 = "None";
	var OK$2 = "OK";
	var Opaque$2 = "Opaque";
	var Pause$2 = "Pause";
	var Pausing$2 = "Pausing";
	var Play$2 = "Play";
	var Playing$2 = "Playing";
	var Progress$2 = "Progress";
	var Purchased$2 = "Purchased";
	var Raised$2 = "Raised";
	var Red$2 = "Red";
	var Replay$2 = "Replay";
	var Rewind$2 = "Rewind";
	var Script$2 = "Script";
	var second$2 = "second";
	var seconds$2 = "seconds";
	var Send$2 = "Send";
	var Settings$2 = "Settings";
	var Share$2 = "Share";
	var Stop$2 = "Stop";
	var STREAM_LIMITED$2 = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$2 = "STREAM_LIMIT_ERROR";
	var Subtitles$2 = "Subtitles";
	var To$2 = "To";
	var Transparent$2 = "Transparent";
	var Uniform$2 = "Uniform";
	var Unmute$2 = "Unmute";
	var Unmuted$2 = "Unmuted";
	var Watch$2 = "Watch";
	var White$2 = "White";
	var Window$2 = "Window";
	var Yellow$2 = "Yellow";
	var hours_minutes_seconds_format$1 = "hours_minutes_seconds_format";
	var minutes_seconds_format$1 = "minutes_seconds_format";
	var uk = {
		"A network error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
		Ad: Ad$2,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio Options",
		Autoplay: Autoplay$2,
		"Back to video": "Back to video",
		"Close share": "Close share",
		Background: Background$2,
		Black: Black$2,
		Blue: Blue$2,
		Button: Button$2,
		"Buy PPV": "Buy PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Caption Settings",
		Captions: Captions$2,
		"captions off": "captions off",
		"Captions Preview": "Captions Preview",
		Casual: Casual$2,
		Chapters: Chapters$2,
		"Check out this video on ESPN": "Check out this video on ESPN",
		"Choose Broadcast": "Choose Broadcast",
		"Choose TV Provider": "Choose TV Provider",
		"Closed Caption": "Closed Caption",
		"Closed Captions": "Closed Captions",
		Copied: Copied$2,
		Copy: Copy$2,
		"Copy Embed Link": "Copy Embed Link",
		"Copy Link": "Copy Link",
		"Could not download the video": "Could not download the video",
		"Current Time": "Current Time",
		"currently behind live": "currently behind live",
		Cyan: Cyan$2,
		Default: Default$2,
		Depressed: Depressed$2,
		Done: Done$2,
		DRM_REQUIRED: DRM_REQUIRED$2,
		"Drop shadow": "Drop shadow",
		"Duration Time": "Duration Time",
		Email: Email$2,
		"Email Video": "Email Video",
		EMBARGOED: EMBARGOED$2,
		"Embed Code": "Embed Code",
		"Error Code": "Error Code",
		"Exit Full Screen": "Exit Full Screen",
		EXPIRED: EXPIRED$2,
		EXPIRED_CONTENT: EXPIRED_CONTENT$2,
		"Fast Forward": "Fast Forward",
		"Font Family": "Font Family",
		"Font Size": "Font Size",
		Foreground: Foreground$2,
		From: From$2,
		Fullscreen: Fullscreen$2,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED$2,
		"Get ESPN+": "Get ESPN+",
		"Get MLB.TV": "Get MLB.TV",
		Green: Green$2,
		hour: hour$2,
		hours: hours$2,
		"Language Settings": "Language Settings",
		"Learn More": "Learn More",
		LIVE: LIVE$2,
		Loaded: Loaded$2,
		"Logged Into TV Provider": "Logged Into TV Provider",
		Magenta: Magenta$2,
		Menu: Menu$2,
		Message: Message$2,
		minute: minute$2,
		minutes: minutes$2,
		"Monospace Sans-Serif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$2,
		Mute: Mute$2,
		NOT_FOUND: NOT_FOUND$2,
		"No compatible source was found for this media.": "No compatible source was found for this media.",
		"No video has been loaded": "No video has been loaded",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$2,
		"Now Playing": "Now Playing",
		OK: OK$2,
		Opaque: Opaque$2,
		Pause: Pause$2,
		Pausing: Pausing$2,
		Play: Play$2,
		"Playback Rate": "Playback Rate",
		"Playback Speed": "Playback Speed",
		Playing: Playing$2,
		"please confirm you are connected to the internet": "please confirm you are connected to the internet",
		Progress: Progress$2,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$2,
		Raised: Raised$2,
		Red: Red$2,
		"Remaining Time": "Remaining Time",
		Replay: Replay$2,
		"Reset to Defaults": "Reset to Defaults",
		Rewind: Rewind$2,
		Script: Script$2,
		second: second$2,
		seconds: seconds$2,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Select Broadcast": "Select Broadcast",
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send$2,
		Settings: Settings$2,
		Share: Share$2,
		"Skip Ad": "Skip Ad",
		"Small Caps": "Small Caps",
		"Start at": "Start at",
		Stop: Stop$2,
		STREAM_LIMITED: STREAM_LIMITED$2,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$2,
		"Stream Type": "Stream Type",
		"Subscribed to ESPN+": "Subscribed to ESPN+",
		Subtitles: Subtitles$2,
		"subtitles off": "subtitles off",
		"Technical details": "Technical details",
		"Text Edge Style": "Text Edge Style",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "The media could not be loaded, either because the server or network failed or because the format is not supported.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "The video download was cancelled",
		"The video is bad or in a format that cannot be played on your browser": "The video is bad or in a format that cannot be played on your browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "The video you are trying to watch is encrypted and we do not know how to decrypt it",
		"This content is not available for your package or region.": "This content is not available for your package or region.",
		"This video is either unavailable or not supported in this browser": "This video is either unavailable or not supported in this browser",
		"This video is unavailable": "This video is unavailable",
		To: To$2,
		Transparent: Transparent$2,
		Uniform: Uniform$2,
		Unmute: Unmute$2,
		Unmuted: Unmuted$2,
		"Up Next": "Up Next",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Video Player",
		Watch: Watch$2,
		"WATCH NOW": "WATCH NOW",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$2,
		Window: Window$2,
		Yellow: Yellow$2,
		"You aborted the media playback": "You aborted the media playback",
		"elapsed out of": "elapsed out of",
		hours_minutes_seconds_format: hours_minutes_seconds_format$1,
		minutes_seconds_format: minutes_seconds_format$1
	};

	var Ad$1 = "Ad";
	var Autoplay$1 = "Autoplay";
	var Background$1 = "Background";
	var Black$1 = "Black";
	var Blue$1 = "Blue";
	var Button$1 = "Button";
	var Captions$1 = "Captions";
	var Casual$1 = "Casual";
	var Chapters$1 = "Chapters";
	var Copied$1 = "Copied";
	var Copy$1 = "Copy";
	var Cyan$1 = "Cyan";
	var Default$1 = "Default";
	var Depressed$1 = "Depressed";
	var Done$1 = "Done";
	var DRM_REQUIRED$1 = "DRM_REQUIRED";
	var Email$1 = "Email";
	var EMBARGOED$1 = "EMBARGOED";
	var EXPIRED$1 = "EXPIRED";
	var EXPIRED_CONTENT$1 = "EXPIRED_CONTENT";
	var Foreground$1 = "Foreground";
	var From$1 = "From";
	var Fullscreen$1 = "Fullscreen";
	var GEOLOCATION_NOT_ALLOWED$1 = "GEOLOCATION_NOT_ALLOWED";
	var Green$1 = "Green";
	var hour$1 = "hour";
	var hours$1 = "hours";
	var LIVE$1 = "LIVE";
	var Loaded$1 = "Loaded";
	var Magenta$1 = "Magenta";
	var Menu$1 = "Menu";
	var Message$1 = "Message";
	var minute$1 = "minute";
	var minutes$1 = "minutes";
	var More$1 = "More";
	var Mute$1 = "Mute";
	var NOT_FOUND$1 = "NOT_FOUND";
	var None$1 = "None";
	var OK$1 = "OK";
	var Opaque$1 = "Opaque";
	var Pause$1 = "Pause";
	var Pausing$1 = "Pausing";
	var Play$1 = "Play";
	var Playing$1 = "Playing";
	var Progress$1 = "Progress";
	var Purchased$1 = "Purchased";
	var Raised$1 = "Raised";
	var Red$1 = "Red";
	var Replay$1 = "Replay";
	var Rewind$1 = "Rewind";
	var Script$1 = "Script";
	var second$1 = "second";
	var seconds$1 = "seconds";
	vaop";
	var STREAM_LIMITED$1 = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR$1 = "STREAM_LIMIT_ERROR";
	var Subtitles$1 = "Subtitles";
	var To$1 = "To";
	var Transparent$1 = "Transparent";
	var Uniform$1 = "Uniform";
	var Unmute$1 = "Unmute";
	var Unmuted$1 = "Unmuted";
	var Watch$1 = "Watch";
	var White$1 = "White";
	var Window$1 = "Window";
	var Yellow$1 = "Yellow";
	var hours_minutes_seconds_format = "hours_minutes_seconds_formtwork error caused the media download to fail part-way.": "A network error caused the media download to fail part-way.",
		Ad: Ad$1,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "Audio Options",
		Autoplay: Autoplay$1,
		"Back to video": "Back to video",
		"Close share": "Close share",
		Background: Background$1,
		Black: Black$1,
		Blue: Blue$1,
		Button: Button$1,
		"Buy PPV": "Buy PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "Caption Settings",
		Captions: Captions$1,
		"captions off": "captions off",
		"Captions Preview": "Captions Preview",
		Casual: Casual$1,
		Chapters: Chapters$1,
		"Check out this video on ESPN": "Check out this video on ESPN",
		"Choose Broadcast": "Choose Broadcast",
		"Choose TV Provider": "Choose TV Provider",
		"Closed Caption": "Closed Caption",
		"Closed Captions": "Closed Captions",
		Copied: Copied$1,
		Copy: Copy$1,
		"Copy Embed Link": "Copy Embed Link",
		"Copy Link": "Copy Link",
		"Could not download "Current Time",
		"currently behind live": "currently behind live",
		Cyan: Cyan$1,
		Default: Default$1,
		Depressed: Depressed$1,
		Done: Done$1,
		DRM_REQUIRED: DRM_REQUIRED$1,
		"Drop shadow": "Drop shadow",
		"Duration Time": "Duration Time",
		Email: Email$1,
		"Email Video": "Email Video",
		EMBARGOED: EMBARGOED$1,
		"Embed Code": "Embed Code",
	rd",
		"Font Family": "Font Family",
		"Font Size": "Font Size",
		Foreground: rif": "Monospace Sans-Serif",
		"Monospace Serif": "Monospace Serif",
		More: More$1,
		Mute: Mute$1,
		NOT_FOUND: NOT_FOUND$1,
		"No compatible source was found for this media.": "No compatible source was found for this media.",
		"No video has been loaded": "No video has been loaded",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None$1,
		"Now Playing": "Now Playing",
		OK: OK$1,
		Opaque: Opaque$1,
		Pause: Pause$1,
		Pausing: Pausing$1,
		Play:back Speed": "Playback Speed",
		Playing: Playing$1,
		"please confirm you are connected to the internet": "please confirm you are connected to the internet",
		Progress: Progress$1,
		"Proportional Sans-Serif": "Proportional Sans-Serif",
		"Proportional Serif": "Proportional Serif",
		Purchased: Purchased$1,
		Raised: Raised$1,
		Red: Red$1,
		"Remaining Time": "Remaining Time",
		Replay: Replay$1,
		"Reset to Defaults": "Reset to Defaults",
		Rewind: Rewind$1,
		Script: Script$1,
		second: second$1,
		seconds: seconds$1,
		"Seek to live": "Seek to live",
		"Seek to live, currently playing live": "Seek to live, currently playing live",
		"Select Broadcast": "Select Broadcast",
		"Semi-Opaque": "Semi-Opaque",
		"Semi-Transparent": "Semi-Transparent",
		Send: Send$1,
		Settings: Settings$1,
		Share: Share$1,
		"Skip Ad": "Skip Ad",
		"Small Caps": "Small Caps",
		"Start at": "Start at",
		Stop: Stop$1,
		STREAM_LIMITED: STREAM_LIMITED$1,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR$1,
		"Stream Type": "Stream Type",
		"Subscribed to ESPN+": "Subscribed to ESPN+",
		Subtitles: Subtitles$1,
		"subtitles off": "subtitles off",
		"Technical details": "Technical details",
		"Text Edge Style": "Text Edge Style",
		"The maximum number of concurrent streams has been reached on your account. If you have any questions or need assistance please visit es.pn/watchfaq or call 888-549-ESPN.,": "The maximum number oIf you have any questions or need assistance please visit es.pn/watchfaq o or network failed or because the format is not supported.",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "The video connection was lost",
		"The video download was cancelled": "The video download was cancelled",
		"The video is bad or in a format that cannot be played on your browser": "The video is bad or in a format that cannot be played on your browser",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The video playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "The video you are trying to watch is encrypted and we do not know how to decrypt it",
		"This content is not available for your package or region.": "This content is not available for your package or region.",
		"This video is either unavailable or not supported in this browser": "This video is either unavailable or not supported in this browser",
		"This video is unavailable": "This video is unavailable",
		To: To$1,
		Transparent: Transparent$1,
		Uniform: Uniform$1,
		Unmute: Unmute$1,
		Unmuted: Unmuted$1,
		"Up Next": "Up Next",
		"Video has expired.": "Video has expired.",
		"Video is not available in your country.": "Video is not available in your country.",
		"Video is not yet available.": "Video is not yet available.",
		"Video Player": "Video Player",
		Watch: Watch$1,
		"WATCH NOW": "WATCH NOW",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.",
		White: White$1,
		Window: Window$1,
		Yellow: Yellow$1,
		"You aborted the media playback": "You aborted the media playback",
		"elapsed out of": "elapsed out of",
		hours_minutes_seconds_format: hours_minutes_seconds_format,
		minutes_seconds_format: minutes_seconds_format
	};

	var Ad = "å¹¿å";
	var Autoplay = "èªå¨æ­æ¾";
	var Background = "èæ¯";
	var Black = "é»è²";
	var Blue = "èè²";
	var Button = "æé®";
	var Captions = "éèå¼å­å¹";
	var Casual = "éæ­£å¼";
	var Chapters = "ç« æ°";
	var Copied = "å·²å¤å¶";
	var Copy = "å¤å¶";
	var Cyan = "éè²";
	var Default = "é»è®¤";
	var Depressed = "å¹é·";
	var Done = "å®æ";
	var DRM_REQUIRED = "DRM_REQUIRED";
	var Email = "çµå­é®ä»¶";
	var EMBARGOED = "EMBARGOED";
	var EXPIRED = "EXPIRED";
	var EXPIRED_CONTENT = "EXPIRED_CONTENT";
	var Foreground = "åæ¯";
	var From = "ä»";
	var Fullscreen = "å¨å±";
	var GEOLOCATION_NOT_ALLOWED = "GEOLOCATION_NOT_ALLOWED";
	var Green = "ç»¿è²";
	var hour = "å°æ¶";
	var hours = "å°æ¶";
	var LIVE = "ç´æ­";
	var Loaded = "å·²å è½½";
	var Magenta = "åçº¢";
	var Menu = "èå";
	var Message = "æ¶æ¯";
	var minute = "åé";
	var minutes = "åé";
	var More = "æ´å¤";
	var Mute = "éé³";
	var NOT_FOUND = "NOT_FOUND";
	var None = "æ ";
	var OK = "ç¡®å®";
	var Opaque = "ä¸éæ";
	var Pause = "æå";
	var Pausing = "æåä¸­";
	var Play = "æ­æ¾";
	var Playing = "æ­£å¨æ­æ¾";
	var Progress = "è¿åº¦";
	var Purchased = "å·²è´­ä¹°";
	var Raised = "å¸èµ·";
	var Red = "çº¢è²";
	var Replay = "éæ­";
	var Rewind = "åå¸¦";
	var Script = "æå";
	var second = "ç§";
	var seconds = "ç§";
	var Send = "åé";
	var Settings = "è®¾ç½®";
	var Share = "åäº«";
	var Stop = "åæ­¢";
	var STREAM_LIMITED = "STREAM_LIMITED";
	var STREAM_LIMIT_ERROR = "STREAM_LIMIT_ERROR";
	var Subtitles = "å­å¹";
	var To = "è³";
	var Transparent = "éæ";
	var Uniform = "ä¸è´";
	var Unmute = "åæ¶éé³";
	var Unmuted = "å·²åæ¶éé³";
	var Watch = "è§ç";
	var White = "ç½è²";
	var Window = "çªå£";
	var Yellow = "é»è²";
	var zh = {
		"A network error caused the media download to fail part-way.": "åçç½ç»éè¯¯ï¼å¯¼è´è§é¢ä¸è½½ä¸­æ­ã",
		Ad: Ad,
		"An error occurred during video playback, possibly due to network connectivity or being in a backgrounded browser tab. Please try again.": "è§é¢æ­æ¾åºéï¼å¯è½æ¯ç±äºç½ç»è¿æ¥é®é¢ãææ¯å¨ä¸ä¸ªèæ¯æµè§å¨é¡µé¢æ­æ¾æè´ãè¯·åè¯ä¸æ¬¡ã",
		"An unanticipated problem was encountered, check back soon and try again": "An unanticipated problem was encountered, check back soon and try again",
		"Audio Options": "é³é¢éé¡¹",
		Autoplay: Autoplay,
		"Back to video": "è¿åè§é¢",
		"Close share": "Close share",
		Background: Background,
e,
		Button: Button,
		"Buy PPV": "è´­ä¹° PPV",
		"com.espn.watch.api.AccessDeniedException": "com.espn.watch.api.AccessDeniedException",
		"Caption Settings": "éèå¼å­å¹è®¾ç½®",
		Captions: Captions,
		"captions off": "å³é­å­å¹",
		"Captions Preview": "é¢è§å­å¹",
		Casual: Casual,
		Chapters: Chapters,
		"Check out this video on ESPN": "å° ESPN æ¥çæ­¤è§é¢",
		"Choose Broadcast": "éæ©å¹¿æ­",
		"Choose TV Provider": "éæ©çµè§æå¡å",
		"Closed Caption": "éèå¼å­å¹",
		"Closed Captions": "éèå¼å­å¹",
		Copied: Copied,
		Copy: Copy,
		"Copy Embed Link": "å¤å¶ååµé¾æ¥",
		"Copy Link": "å¤å¶é¾æ¥",
		"Could not download the video": "Could not download the video",
		"Current Time": "å½åæ¶é´",
		"currently behind live": "å½åä¸ç´æ­æ¶é´å·®",
		Cyan: Cyan,
		Default: Default,
		Depressed: Depressed,
		Done: Done,
		DRM_REQUIREdow": "é´å½±",
		"Duration Time": "æ¶é¿",
		Email: Email,
		"Email Video": "ç¨çµå­é®ä»¶åäº«è§é¢",
		EMBARGOED: EMBARGOED,
		"Embed Code": "ååµä»£ç ",
		"Error Code": "éè¯¯ä»£ç ",
		"Exit Full Screen": "éåºå¨å±",
		EXPIRED: EXPIRED,
		EXPIRED_CONTENT: EXPIRED_CONTENT,
		"Fast Forward": "å¿«è¿",
		"Font Family": "å­ä½ç³»å",
		"Font Size": "å­ä½å¤§å°",
		Foreground: Foreground,
		From: From,
		Fullscreen: Fullscreen,
		GEOLOCATION_NOT_ALLOWED: GEOLOCATION_NOT_ALLOWED,
		"Get ESPN+"	hour: hour,
		hours: hours,
		"Language Settings": "è¯­è¨è®¾ç½®",
		"Learn More": "äºè§£æ´å¤",
		LIVE: LIVE,
		Loaded: Loaded,
		"Logged Into TV Provider": "å·²ç»å½è³çµè§æå¡å",
		Magenta: Magenta,
		Menu: Menu,
		Message: Message,
		minute: minute,
		minutes: minutes,
		"Monospace Sans-Serif": "ç­å®½æ è¡¬çº¿ä½",
		"Monospace Serif": "ç­å®½è¡¬çº¿ä½",
		More: More,
		Mute: Mute,
		NOT_FOUND: NOT_FOUND,
		"No compatible source was found for this media.": "æªæ¾å°æ­¤è§é¢çå¼å®¹èµæºã",
		"No video has been loaded": "æªå è½½ä»»ä½è§é¢",
		"Non-Fullscreen": "Non-Fullscreen",
		None: None,
		"Now Playing": "æ­£å¨æ­æ¾",
		OK: OK,
		Opaque: Opaque,
		Pause: Pause,
		Pausing: Pausing,
		Play: Play,
		"Playback Rate": "æ­æ¾éç",
		"Playback Speed": "æ­æ¾éåº¦",
		Playing: Playing,
		"please confirm you are connected to the internet": "è¯·ç¡®è®¤æ¨å·²è¿æ¥è³ç½ç»",
		Progress: Progress,
		"Proportional Sans-Serif": "æ¯ä¾æ è¡¬çº¿ä½",
		"Proportional Serif		Raised: Raised,
		Red: Red,
		"Remaining Time": "å©ä½æ¶é´",
		Replay: Replay,
		"Reset to Defaults": "éç½®ä¸ºé»è®¤å¼",
		Rewind: Rewind,
		Script: Script,
		second: second,
		seconds: seconds,
		"Seek to live": "è·³è³ç´æ­ç»é¢",
		"Seek to live, currently playing live": "è·³è³ç´æ­ç»é¢ï¼æ­£å¨æ­æ¾ç´æ­ç»é¢",
		"Select Broadcast": "éæ©å¹¿æ­",
		"Semi-Opaque": "åä¸éæ",
		"Semi-Traettings,
		Share: Share,
		"Skip Ad": "è·³è¿å¹¿å",
		"Small Caps": "å°åå¤§åå­æ¯",
		"Start at": "å¼å§æ¶é´ï¼",
		Stop: Stop,
		STREAM_LIMITED: STREAM_LIMITED,
		STREAM_LIMIT_ERROR: STREAM_LIMIT_ERROR,
		"Stream Type": "æµå¼æ­æ¾ç±»å",
		"Subscribed to ESPN+": "å·²è®¢é ESPN+",
		Subtitles: Subtitles,
		"subtitles off": "å³é­å­å¹",
		"Technical details": "ææ¯ç»è",
		"Text Edge Style": "æå­è¾¹ç¼æ ·å¼",
		"The maximum number of concurrent streams has been reached on your account. If ¨æä»»ä½é®é¢æéè¦å¸®å©ï¼è¯·è®¿é® es.pn/watchfaq æè´çµ 888-549-ESPNã",
		"The media could not be loaded, either because the server or network failed or because the format is not supported.": "ç±äºæå¡å¨æç½ç»æéï¼æç±äºåªä½æ ¼å¼ä¸åæ¯æï¼æ æ³å è½½åªä½ã",
		"The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
		"The video connection was lost": "è§é¢è¿æ¥ä¸­æ­",
		"The video download was cancelled": "è§é¢ä¸è½½å·²è¢«åæ¶",
		"The video is bad or in a format that cannot be played on your browser": "è§é¢å·²æåï¼ææ¨çæµè§å¨ä¸è½æ­æ¾æ­¤è§é¢çæ ¼å¼ã",
		"The video playback was aborted due to a corruption problem or because the media used features your browser did not support.": "ç±äºè§é¢å·²æåæè§é¢åå«æç§æµè§å¨ä¸æ¯æçåè½ï¼æ­æ¾å·²ä¸­æ­¢ã",
		"The video you are trying to watch is encrypted and we do not know how to decrypt it": "æ¨æ³è§ççæ¯ä¸ä¸ªå å¯è§é¢ï¼æä»¬æ æ³è§£å¯ã",
		"This content is not available for your package or region.": "æ¨æå¨å°åºä¸æä¾æ­¤åå®¹ï¼ææ¨çè®¢éä¸åæ¬æ­¤åå®¹ã",
		"This video is either unavailable or not supported in this browser": "æªæä¾æ­¤è§é¢ææµè§å¨ä¸æ¯ææ­¤è§é¢",
		"This video is unavailable": "æªæä¾æ­¤è§é¢ã",
		To: To,
		Transparent: Transparent,
		Uniform: Uniform,
		Unmute: Unmute,
		Unmuted: Unmuted,
		"Up Next": "æ¥ä¸æ¥æ­æ¾",
		"Video has expired.": "è§é¢å·²è¿æã",
		"Video is not available in your country.": "æ¨æå¨å½å®¶æå°åºä¸æä¾æ­¤è§é¢ã",
		"Video is not yet available.": "å°æªæä¾æ­¤è§é¢ã",
		"Video Player": "è§é¢æ­æ¾å¨",
		Watch: Watch,
		"WATCH NOW": "ç«å³è§ç",
		"We're sorry, but this browser is no longer supported. Please upgrade to the latest version of Google Chrome, FireFox, or Microsoft Edge to watch this content.": "æ±æ­ï¼æä»¬å·²ä¸åæ¯ææ­¤æµè§å¨ãè¯·ä½¿ç¨ææ°çæ¬ç Google ChromeãFireFox æ Microsoft Edge è§çæ­¤åå®¹ã",
		White: White,
		Window: Window,
		Yellow: Yellow,
		"You aborted the media playback": "æ¨å·²ä¸­æ­¢è§é¢æ­æ¾"
	};

	/* eslint-disable no-restricted-syntax */
	let LANG = 'en';
	let TRANSLATIONS = {};
	const I18n = function I18n(key) {
	  return TRANSLATIONS[LANG][key] || TRANSLATIONS.en[key] || key;
	};

	/*
	  Adds key/value pairs in the form of:
	  {
	    "Yes": "ã¯ã"
	    "No": "ããã"
	  }
	 */
	I18n.add = function add(lang, data) {
	  let k;
	  let v;
	  if (!TRANSLATIONS[lang]) {
	    TRANSLATIONS[lang] = {};
	  }
	  for (k in data) {
	    v = data[k];
	    TRANSLATIONS[lang][k] = v;
	  }
	};

	/*
	  Destroy translation data
	 */
	I18n.reset = function reset() {
	  TRANSLATIONS = {};
	  LANG = 'en';
	};
	I18n.setLang = function setLang(lang) {
	  if (TRANSLATIONS[lang]) {
	    LANG = lang;
	  }
	};
	I18n.translations = function translations() {
	  return TRANSLATIONS;
	};
	I18n.add('en', en);
	I18n.add('ar', ar);
	I18n.add('bg', bg);
	I18n.add('cs', cs);
	I18n.add('da', da);
	I18n.add('de', de);
	I18n.add('el', el);
	I18n.add('es', es);
	I18n.add('fi', fi);
	I18n.add('fr', fr);
	I18n.add('he', he);
	I18n.add('hu', hu);
	I18n.add('id', id);
	I18n.add('it', it);
	I18n.add('ja', ja);
	I18n.add('ko', ko);
	I18n.add('ms', ms);
	I18n.add('nb', nb);
	I18n.add('no', nb);
	I18n.add('nl', nl);
	I18n.add('pl', pl);
	I18n.add('pt', pt);
	I18n.add('ro', ro);
	I18n.add('ru', ru);
	I18n.add('sr', sr);
	I18n.add('sv', sv);
	I18n.add('th', th);
	I18n.add('tl', tl);
	I18n.add('tr', tr);
	I18n.add('uk', uk);
	I18n.add('vi', vi);
	I18n.add('zh', zh);

	const defaultOptions = {
	  bindTo: 'on',
	  unbindTo: 'off',
	  createDisposer: true
	};
	const noop = function noop() {};
	function subscribeTo(target, evtNames, handler, options) {
	  const {
	    bindTo,
	    unbindTo,
	    createDisposer
	  } = videojs.mergeOptions(defaultOptions, options);
	  const bindToFunc = typeof target[bindTo] === 'function' ? target[bindTo].bind(target) : noop;
	  const unbindToFunc = typeof target[unbindTo] === 'function' ? target[unbindTo].bind(target) : noop;
	  const disposers = [];
	  if (evtNames instanceof Array) {
	    evtNames.forEach(evtName => {
	      bindToFunc(evtName, handler);
	      if (createDisposer) {
	        disposers.push(() => {
	          unbindToFunc(evtName, handler);
	        });
	      }
	    });
	  }
	  return disposers;
	}

	var $propertyIsEnumer0$p.f;

	var propertyIsEnumerable = uncurryThis$1($propertyIsEnumerable);
	var push = uncurryThis$1([].push);

	// in some IE versions, `propertyIsEnumerable` returns incorrect result on integer keys
	// of `null` prototype objects
	var IE_BUG = DESCRIPTORS && fails(function () {
	  // eslint-disable-next-line es/no-object-create -- safe
	  var O = Object.create(null);
	  O[2] = 2;
	  return !propertyIsEnumerable(O, 2);
	});

	// `Object.{ entries, values }` methods implementation
	var createMethod = function (TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var IE_WORKAROUND = IE_BUG && objectGetPrototypeOf(O) === null;
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!DESCRIPTORS || (IE_WORKAROUND ? key in O : propertyIsEnumerable(O, key))) {
	        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.es/ecma262/#sec-object.entries
	  entries: createMethod(true),
	  // `Object.values` method
	  // https://tc39.es/ecma262/#sec-object.values
	  values: createMethod(false)
	};

	var require$$0$2 = objectToArray;

	var $entries = require$$0$2.entries;

	// `Object.entries` method
	// https://tc39.es/ecma262/#sec-object.entries
	$({ target: 'Object', stat: true }, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	var entries$2 = path.Object.entries;

	var parent$1 = entries$2;

	var entries$1 = parent$1;

	var require$$0$1 = entries$1;

	var entries = require$$0$1;

	function adsManagerLoadedCallbackFactory(player) {
	  return function adsManagerLoadedCallback() {
	    const {
	      ima
	    } = player;
	    const eventMap = {
	      'ads-ad-ended': google.ima.AdEvent.Type.COMPLETE,
	      'ads-ad-skipped': google.ima.AdEvent.Type.SKIPPED,
	      'ads-click': google.ima.AdEvent.Type.CLICK,
	      'ads-first-quartile': google.ima.AdEvent.Type.FIRST_QUARTILE,
	      'ads-midpoint': google.ima.AdEvent.Type.MIDPOINT,
	      'ads-mute': google.ima.AdEvent.Type.VOLUME_MUTED,
	      'ads-pause': google.ima.AdEvent.Type.PAUSED,
	      'ads-play': google.ima.AdEvent.Type.RESUMED,
	      'ads-third-quartile': google.ima.AdEvent.Type.THIRD_QUARTILE,
	      'ads-volumechange': google.ima.AdEvent.Type.VOLUME_CHANGED,
	      'ads-all-ads-completed': google.ima.AdEvent.Type.ALL_ADS_COMPLETED,
	      'content-resume-requested': google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED,
	      'ad-progress': google.ima.AdEvent.Type.AD_PROGRESS,
	      'ad-can-play': google.ima.AdEvent.Type.AD_CAN_PLAY,
	      'ad-call-loaded': google.ima.AdEvent.Type.LOADED,
	      'ad-metadata': google.ima.AdEvent.Type.AD_METADATA
	    };
	    entries(eventMap).forEach(([playerEvent, imaEvent]) => {
	      ima.addEventListener(imaEvent, () => {
	        player.trigger(playerEvent);
	      });
	    });
	    ima.addEventListener(google.ima.AdEvent.Type.AD_PROGRESS, evt => {
	      const {
	        currentTime
	      } = evt && evt.getAdData && evt.getAdData() || {};
	      player.trigger('timeupdate', {
	        currentTime,
	        type: 'ad'
	      });
	    });
	    player.trigger('ads-manager-loaded');
	  };
	}

	const adStates = {
	  AD_PLAYBACK: 'ad-playback',
	  CONTENT_PLAYBACK: 'content-playback',
	  CONTENT_SET: 'content-set',
	  ADS_READY: 'ads-ready',
	  CONTENT_RESUMING: 'content-resuming',
	  MAYBE_ADS_READY: 'ads-ready?',
	  MAYBE_PREROLL: 'preroll?',
	  MAYBE_POSTROLL: 'postroll?'
	};
	class AdsManager {
	  static getServerUrl(advertisingInfo) {f('espn') > -1 ? advertisingInfo.dictionaryForImaSdk() : advertisingInfo.dictionaryForEntertainment();

	    /**
	     * check usprivacy cookie and add us_privacy param to cust_params GAM
	     */

	    imaSdkDictionary = addUsPrivacyCustomParams(imaSdkDictionary, advertisingInfo);
	    const queryString = map(_context = keys(imaSdkDictionary)).call(_context, key => {
	      if (key !== 'cust_params') {
	        return `${key}=${imaSdkDictionary[key]}`;
	      }
	      return `cust_params=${encodeURIComponent(imaSdkDictionary.cust_params)}`;
	    });
	    let baseUrl = AdsManager.defaultBaseUrl;
	    if (advertisingInfo.vdm === 'live') {
	      baseUrl = baseUrl.replace(/gampad\/ads$/, 'gampad/live/ads');
	    }
	    return `${baseUrl}?${queryString.join('&')}`;
	  }
	  static getConfigsByType(options, serverUrl, player) {
	    const {
	      debug = false,
	      requestMode = 'onload',
	      showVpaidControls = true,
	      timeout = 4000
	    } = options;
	    const sharedConfigs = {
	      debug,
	      requestMode,
	      showVpaidControls,
	      timeout: parseInt(timeout, 10)
	    };
	    const playerDims = player.currentDimensions();
	    if (sharedConfigs.requestMode === 'onload') {
	      sharedConfigs.requestMode = 'onLoad';
	    }
	    if (sharedConfigs.requestMode === 'onplay') {
	      sharedConfigs.requestMode = 'onPlay';
	    }
	    if (serverUrl) {
	      sharedConfigs.adTagUrl = serverUrl;
	    }
	    const disableCustomPlaybackForIOS10Plus = IS_IPAD || options !== null && options !== void 0 && options.disableCustomPlaybackForIOS10Plus ? {
	      disableCustomPlaybackForIOS10Plus: true
	    } : undefined;
	    return {
	      ...sharedConfigs,
	      ...disableCustomPlaybackForIOS10Plus,
	      preventLateAdStart: true,
	      adsRequest: {
	        linearAdSlotWidth: parseInt(playerDims.width, 10),
	        linearAdSlotHeight: parseInt(playerDims.height, 10),
	        nonLinearAdSlotWidth: parseInt(playerDims.width, 10),
ManagerLoadedCallback: adsManagerLoadedCallbackFactory(player)
	    };
	  }
	}
	AdsManager.defaultBaseUrl = 'https://pubads.g.doubleclick.net/gampad/ads';

	var $filter = require$$0$e.filter;


	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

	// `Array.prototype.filter` method
	// https://tc39.es/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var filter$3 = entryVirtual('Array').filter;

	var method = filter$3;

	var ArrayPrototype = Array.prototype;

	var filter$2 = function (it) {
	  var own = it.filter;
	  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.filter) ? method : own;
	};

	var parent = filter$2;

	var filt= require$$0;

	var _context;
	const orderedComponentsList = map(_context = [CONTROL_BAR_COMPONENT_NAMES.PLAY_TOGGLE, CONTROL_BAR_COMPONENT_NAMES.VOLUME_PANEL, CONTROL_BAR_COMPONENT_NAMES.REWIND, CONTROL_BAR_COMPONENT_NAMES.FAST_FORWARD, CONTROL_BAR_COMPONENT_NAMES.CURRENT_TIMER_DISPLAY, CONTROL_BAR_COMPONENT_NAMES.TIME_DIVIDER, CONTROL_BAR_COMPONENT_NAMES.DURATION_DISPLAY, CONTROL_BAR_COMPONENT_NAMES.PROGRESS_CONTROL, CONTROL_BAR_COMPONENT_NAMES.LIVE_DISPLAY, CONTROL_BAR_COMPONENT_NAMES.SEEK_TO_LIVE, CONTROL_BAR_COMPONENT_NAMES.REMAINING_TIME_DISPLAY, CONTROL_BAR_COMPONENT_NAMES.CUSTOM_CONTROL_SPACER, CONTROL_BAR_COMPONENT_NAMES.PLAYBACK_RATE_MENU_BUTTON, CONTROL_BAR_COMPONENT_NAMES.CHAPTERS_BUTTON, CONTROL_BAR_COMPONENT_NAMES.DESCRIPTIONS_BUTTON, CONTROL_BAR_COMPONENT_NAMES.SUBS_CAPS_BUTTON, CONTROL_BAR_COMPONENT_NAMES.AUDIO_TRACK_BUTTON, CONTROL_BAR_COMPONENT_NAMES.PICTURE_IN_PICTURE_TOGGLE, CONTROL_BAR_COMPONENT_NAMES.SOCIAL_BUTTON, CONTROL_BAR_COMPONENT_NAMES.BRANDED_SOCIAL_BUTTON, CONTROL_BAR_COMPONENT_NAMES.CAPTION_TOGGLE_BUTTON, CONTROL_BAR_COMPONENT_NAMES.SETTINGS_MENU_BUTTON, CONTROL_BAR_COMPONENT_NAMES.BRANDED_SETTINGS_MENU_BUTTON, CONTROL_BAR_COMPONENT_NAMES.STREAM_PICKER_BUTTON, CONTROL_BAR_COMPONENT_NAMES.FULLSCREEN_TOGGLE]).call(_context, name => name.toLowerCase());
	const getControlBarComponentIndex = (player, name = '') => {
	  var _context2;
	  // transforming everything to lowercase is done
	  // due to unknown inconsistency with videoJS.
	  // children() returns class names as strings, while
	  // documentation suggests using component names, so
	  // to avoid potential inconsistencies we're transforming everything
	  const doesNotExist = !includes(orderedComponentsList).call(orderedComponentsList, name.toLowerCase());

	  // adding a new component requires an explicit
	  // ordering above
	  if (doesNotExist) {
	    throw new Error(`Unknown order for component ${name}`);
	  }
	  if (!player || !name) {
	    throw new Error(`${name ? 'Player instance' : 'Component Name'} was not provided`);
	  }

	  // get all previously registered components
	  const registeredComponents = map(_context2 = player.controlBar.children()).call(_context2, c => c.name().toLowerCase());
	  // most use cases for this function are done prior
	  // to new component being added as a child, so
	  // we need to add it on top of existing components.
	  // If called after component has already been added -
	  // it will not affect the order since fullComponentsList is only used
	  // to filter out components that don't exist.
	  const fullComponentsList = [...registeredComponents, name.toLowerCase()];
	  const orderedRegisteredComponents = filter(orderedComponentsList).call(orderedComponentsList, name => includes(fullComponentsList).call(fullComponentsList, name));
	  return orderedRegisteredComponents.indexOf(name.toLowerCase());
	};

	const PLAY = 300; // play event timestamp buffer

	class VideoJsAdapter extends BasePlayerAdapter {
	  constructor(element, configs = {}, coordinator, mediaManager = {}) {
	    super(element, configs, coordinator, mediaManager);
	    this.newRelic_ = {};
	    this.isNRtrackingEnabled_ = false;
	    this.lastErrorTime_ = null;
	    this.activeButton_ = null;
	    this.isDisposed = false;
	    this.resumePausedTimeouts_ = [];
	    this.dtciSocial = null;
	    this.resumePausedVideo = this.resumePausedVideo.bind(this);
	    this.onPlayCallback = this.onPlayCallback.bind(this);
	    this.onPlayNextContent = this.onPlayNextContent.bind(this);
	    this.reportPlayerErrorEvent = this.reportPlayerErrorEvent.bind(this);
	    this.onFatalErrorDisposePlayer = this.onFatalErrorDisposePlayer.bind(this);
	    this.debouncedSetSizeClass = debounce$1(this.setSizeClass.bme() {
	    if (this.mediaManager && this.mediaManager.analyticsService && this.mediaManager.analyticsService.dmedQOE && this.mediaManager.analyticsService.dmedQOE.options && this.mediaManager.analyticsService.dmedQOE.options.playerName) {
	      return this.mediaManager.analyticsService.dmedQOE.options.playerName;
	    }
	    return `DTCI bundle ${"5.3.16"}, VideoJS ${this.tech.VERSION}`;
	  }
	  get platformVersion() {
	    return "5.3.16";
	  }
	  get showCaptionsUI_() {
	    const {
	      captions: {
	        disabled = false
	      } = {}
	    } = this.configs_;
	    return !disabled;
	  }
	  prepareForPlayer_() {
	    super.prepareForPlayer_();
	    const adProvider = this.configs_ && this.configs_.adProvider || {};
	    if (adProvider) {
	      const options = adProvider.options || {};
	      this.configs_.adProvider = {
	        options,
	        provider: adProvider.provider || 'GoogleForVideoJS'
	      };
	    }
	    this.setUpVideoJs_();
	  }
	  setInactivityTimeout(player) {
	    if (player) {
	      const INACTIVITY_TIMEOUT = 15000;
	      player.options_.inactivityTimeout = INACTIVITY_TIMEOUT;
	    }
	  }
	  createPlayer_() {
	    super.createPlayer_();

	    // Set dispose player to false when create a new player
	    // isDisposed let the player know when it has been disposed to prevent dispose twice
	    this.isDisposed = false;
	    this.initPlugins_(   } = this;
	    const {
	      disableAutoplayMenu
	    } = configs_;
	    if (!disableAutoplayMenu) {
	      let {
	        autoplay
	      } = configs_;
	      if (autoplay === 'userPreference') {
	        const fan = new Fan();
	        autoplay = await fan.getAutoStart();
	      } else {
	        autoplay = !!(autoplay === 'on' || autoplay === true);
	      }

	      // Set the autoplay menu item to reflect `autoStart` value in the UI
	      this.updateAutoplayUI(autoplay);
	    }
	    super.configurePlayer();
	  }
	  updateAutoplayUI(autoplay) {
	    const {
	      player,
	      configs_: {
	        isAudio
	      }
	    } = this;
	    if (isAudio && typeof player.brandedSetettingsMenu().autoplayMenuItem.selected(autoplay);
	    } else if (typeof player.settingsMenu === 'function') {
	      player.settingsMenu().autoplayMenuItem.selected(autoplay);
	    }
	  }
	  setUpVideoJs_() {
	    this.onBeforeSetup_ = this.onBeforeSetup_.bind(this);
	    const localizations = I18n.translations();
	    for (const lang in localizations) {
	      videojs.addLanguage(lang, localizations[lang]);
	    }
	    videojs.hook('beforesetup', this.onBeforeSetup_);
	  }
	  onBeforeSetup_(videoEl, options) {
	    if (this.element && videoEl.id === this.element.id) {
	      // As of Brightcove v5.19.2, `player.error()` no longer pauses playback by default.
	      options.errorDisplay = {
	        pauseOnOpen: true
	      };
	      if (IS_IOS) {
	        // Start loading the video immediately if the browser supports it on iOS
	        options.preload = 'none';
	      } else {
	        // Don't preload any data. The browser will wait until the user hits "play" to begin downloading.
	        options.preload = 'none';
	gs_.chromeless) {
	        // Disable controls
	        videoEl.controls = false;
	        options.controls = false;
	      }
	    }
	    return options;
	  }
	  initPlugins_() {
	    var _this$configs_, _this$configs_$brandC, _this$configs_$brandC2;
	    super.initPlugins_();
	    const {
	      configs_: {
	        auth,
	        captions,
	        brandConfig: {
	          enableAdCountdown = false
	        } = {},
	        disableFastForwardAndRewind,
	        feedsMenu,
	        logo,
	        settingsMenu = {},
	        disableAutoplayMenu,
	        seekStep,
	        skipInitialFocus,
	        isAudio,
	        playbackRates = [0.5, 1, 1.5, 2]
	      } = {},
	      player,
	      player: {
	        controlBar
	      }
	    } = this;
	    const newRelic = (_this$configs_ = this.configs_) === null || _this$configs_ === void 0 ? void 0 : (_this$configs_$brandC = _this$configs_.brandConfig) === null || _this$configs_$brandC === void 0 ? void 0 : (_this$configs_$brandC2 = _this$configs_$brandC.analytics) === null || _this$configs_$brandC2 === void 0 ? void 0 : _this$configs_$brandC2.newRelic;
	    const {
	      drmTesting
	    } = this.configs_;
	    this.isNRtrackingEnabled_ = (newRelic === null || newRelic === void 0 ? void 0 : newRelic.enabled) && !drmTesting;
	    if (this.isNRtrackingEnabled_) {
	      this.initNewRelicOnTrackingEnabled_();
	    }
	    if (typeof player.eme === 'function') {
	      player.eme();
	    }
	    if (typeof player.id3 === 'function') {
	      player.id3();
	    }
	    if (videojs.browser.TOUCH_ENABLED) {
	      this.setInactivityTimeout(player);
	      if (typeof player.contextmenuUI === 'function') {
	        // disable playerInfo modal for touch device that's triggered by long press
	        player.contextmenuUI({
	          content: []
	        });
	      }
	    }
	    if (videojs.getComponent('logoLink')) {
	      player.addChild('logoLink', logo, 4 /* after text-track-display */);
	    }

	    if (typeof player.captionController === 'function') {
	      player.captionController(captions);
	    }
	    if (typeof player.settingsMenu === 'function' && !isAudio) {
	      player.settingsMenu({
	        ...settingsMenu,
	        disableAutoplayMenu
	      });
	    } else if (typeof player.brandedSettingsMenu === 'function') {
	      let descendingOrderPlaybackRates;
	      if (Array.isArray(playbackRates)) {
	        descendingOrderPlaybackRates = sort(playbackRates).call(playbackRates, (a, b) => b - a);
	      }
	      const brandedSettingsMenuOption = {
	        ...settingsMenu,
	        playbackRates: descendingOrderPlaybackRates
	      };
	      player.brandedSettingsMenu(brandedSettingsMenuOption);
	    }
	    if (feedsMenu && typeof player.streamPicker === 'function') {
	      if (!feedsMenu.auth && auth) {
	        feedsMenu.auth = auth;
	      }
	      player.streamPicker(feedsMenu);
	    }
	    if (this.showCaptionsUI_ && videojs.getComponent('captionSettings')) {
	      player.addChild('captionSettings');
	    }
	    if (typeof player.adUI === 'function') {
	      const {
	        configs_: {
	          brandConfig: {
	            enableGracePeriod,
	            gracePeriodTime
	          } = {}
	        }
	      } = this;
	      player.adUI({
	        enableAdCountdown,
	        enableGracePeriod,
	        gracePeriodTime,
	        advertisementService: this.mediaManager.advertisementService
	      });
	    }
	    if (typeof player.audioContentContainer === 'function' && player.isAudio_) {
	      player.audioContentContainer();
	    }
	    if (typeof controlBar.seekToLive === 'function') {
	      controlBar.seekToLive.hide();
	    }

	    // `fastForward` and `rewind` are defined in the same plugin, so we can
	    // safely assume that if one exists, so does the other.
	    if (videojs.getComponent('fastForward') && !disableFastForwardAndRewind && controlBar) {
	      controlBar.addChild(CONTROL_BAR_COMPONENT_NAMES.FAST_FORWARD, {
	        seekStep,
	        name: 'fastForward'
	      }, getControlBarComponentIndex(player, CONTROL_BAR_COMPONENT_NAMES.FAST_FORWARD));
	      controlBar.addChild(CONTROL_BAR_COMPONENT_NAMES.REWIND, {
	        seekStep,
	        name: 'rewind'
	      }, getControlBarComponentIndex(player, CONTROL_BAR_COMPONENT_NAMES.REWIND));
	    }
	    if (videojs.getPlugin('hotkeys')) {
	      // https://github.com/ctd1500/videojs-hotkeys#options
	      player.hotkeys({
	        seekStep,
	        enableVolumeScroll: false,
	        // disables volume scrolling with mouse
	        enableInactiveFocus: false,
	        // WEBPLAYER-174
	        skipInitialFocus
	      });
	    }
	  }
	  getAdType() {
	    const {
	      player
	    } = this;
	    const currTime = player.currentTime();
	    return currTime < 5 ? 'preroll' : 'midroll';
	  }
	  initEventHandlers_() {
	    const {
	      configs_: {
	        loop
	      } = {},
	      player
	    } = this;
	    const playerEl = player.el();
	    this.disposers = this.disposers || [];
	    player.on('error', () => this.handlePlayerErrorEvent_());

	    /*
	      Addresses issue where user could not resume a video after leaving
	      fullscreeaffects iPhone. On iPad, controls _are_ visible, so this
	      isn't necessary.
	    */
	    player.on('touchstart', () => {
	      if (player.paused() && player.usingNativeControls()) {
	        player.play();
	      }
	    });
	    this.disposers.push(...subscribeTo(player, ['rewind'], evt => {
	      this.coordinator.coordinate('dtci.rewind', evt);
	    }));
	    this.disposers.push(...subscribeTo(player, ['fast-forward'], evt => {
	      this.coordinator.coordinate('dtci.fast-forward', evt);
	    }));
	    this.disposers.push(...subscribeTo(player, ['endcard.selected'], evt => {
	      this.coordinator.coordinate('dtci.endcard.selected', evt);
	    }));
	    this.disposers.push(...subscribeTo(player, ['endcard.closed'], evt => {
	      this.coordinator.coordinate('dtci.endcard.closed', evt);
	    }));
	    this.disposers.push(...subscribeTo(player, ['waiting', 'ima3-ad-buffering'], evt => {
	      this.coordinator.coordinate('dtci.waiting', evt);
	    }));
	    this.disposers.push(...subscribeTo(player, ['vjs-waiting.start'], evt => {
	      if (!player.paused()) {
	        this.coordinator.coordinate('dtci.pause', {
	          userInitiated: true
	        });
	      }
	      this.coordinator.coordinate('dtci.waiting.started', evt);
	    }));
	    this.disposers.push(...subscribeTo(player, ['vjs-waiting.end'], evt => {
	      this.coordinator.coordinate('dtci.waiting.ended', evt);
	      if (!player.paused()) {
	        this.coordinator.coordinate('dtci.playing');
	      }
	    }));
	    this.disposers.push(...subscribeTo(player, ['ads-pod-started'], () => {
	      player.addClass('vjs-ad-playing');

	      // Player event might still fire even if ad is canceled by grace period.
	      if (!this.mediaManager.advertisementService.isInAdGracePeriod) {
	        const adType = this.getAdType();
	        this.coordinator.coordinate('dtci.ads.podStarted', {
	          type: adType
	        });
	      }
	    }));
	    this.disposers.push(...subscribeTo(player, ['loadedmetadata'], () => {
	      const {
	        player
	      } = this;
	      let evtData;
	      if (player) {
	        evtData = {
	          duration: player.duration(),
	          videoWidth: player.videoWidth(),
	          // native video width
	          videoHeight: player.videoHeight() // native video height
	        };
	      }

	      this.coordinator.coordinate('dtci.loadedMetadata', evtData);
	    }));
	    this.disposers.push(...subscribeTo(player, ['ads-pod-ended'], () => {
	      // Player event might still fire even if ad is canceled by grace period.
	      if (!this.mediaManager.advertisementService.isInAdGracePeriod) {
	        const adType = this.getAdType();
	        this.coordinator.coordinate('dtci.ads.podEnded', {
	          type: adType
	        });
	      }
	      this.resumePausedVideo();
	      player.removeClass('vjs-ad-playing');
	    }));
	    this.disposers.push(...subscribeTo(player, ['contentplayback'], () => {
	      // Addresses an issue where the control bar is not visible in fullscreen
	      player.one('mouseover', () => player.el().classList.remove('not-hover'));
	    }));

	    // @TODO: imo all of this ad-related logic should go into the ad-ui plugin
	    this.disposers.push(...subscribeTo(player, ['ima3-all-ads-completed'], () => {
	      player.removeClass('vjs-ad-loading');
	      player.removeClass('vjs-ad-playing');
	    }));
	    this.disposers.push(...subscribeTo(player, ['play', 'ads-play', 'ads-ad-started'], this.onPlayCallback));

	    // videojs doesn't pass original event to our event handlers, so we'll need to keep
	    // track of the active element ourselves to determine whether certain interactions were
	    // user initiated or programmatic
	    this.disposers.push(...subscribeTo(playerEl, ['click', 'keydown'], evt => {
	      const {
	        target,
	        target: {
	          nodeName
	        } = {}
	      } = evt;
	      if (nodeName === 'BUTTON' || nodeName === 'VIDEO') {
	        this.activeButton_ = target;

	        // next tick set back to null
	        setTimeout(() => {
	          this.activeButton_ = null;
	        });
	      }
	    }, {
	      bindTo: 'addEventListener',
	      unbindTo: 'removeEventListener'
	    }));
	    this.disposers.push(...subscribeTo(player, ['pause', 'ads-pause'], event => {
	      var _this$activeButton_, _this$activeButton_$c, _this$activeButton_2, _this$activeButton_2$, _this$activeButton_3;
	      if (!this.activeButton_) {
	        const {
	          target
	        } = event;
	        this.activeButton_ = target;
	      }
	      const userInitiated = ((_this$activeButton_ = this.activeButton_) === null || _this$activeButton_ === void 0 ? void 0 : (_this$activeButton_$c = _this$activeButton_.classList) === null || _this$activeButton_$c === void 0 ? void 0 : _this$activeButton_$c.contains('vjs-icon-share')) || ((_this$activeButton_2 = this.activeButton_) === null || _this$activeButton_2 === void 0 ? void 0 : (_this$activeButton_2$ = _this$activeButton_2.classList) === null || _this$activeButton_2$ === void 0 ? void 0 : _this$activeButton_2$.contains('vjs-paused')) || ((_this$activeButton_3 = this.activeButton_) === null || _this$activeButton_3 === void 0 ? void 0 : _this$activeButton_3.nodeName) === 'VIDEO' || false;
	      player.isPlaying = false;
	      if (event.type === 'pause') {
	        this.coordinator.coordinate('dtci.pause', {
	          userInitiated
	        });
	      }
	    }));
	    this.disposers.push(...subscribeTo(player, ['dtci.autoplayToggled'], (e, autoplay) => {
	      const fan = new Fan();
	      fan.setAutoStart(autoplay);
	      if (typeof this.player.endcard === 'function') {
	        this.player.endcard().updateOptions({
	          ...this.player.endcard().options,
	          autoplay
	        });
	      }
	      this.coordinator.coordinate('dtci.autoplayToggled', autoplay);
	    }));
	    this.disposers.push(...subscribeTo(player, ['ended'], () => {
	      var _player$ads;
	      if (!(player !== null && player !== void 0 && (_player$ads = player.ads) !== null && _player$ads !== void 0 && _player$ads.state) || player.ads.state === adStates.CONTENT_PLAYBACK) {
	        this.coordinator.coordinate('dtci.contentEnded');
	        if (loop) {
	          player.play();
	        }
	        if (!this.configs_.endcard) {
	          if (this.autoplay()) {
	            if (!this.configs_.disableAutoReplay) {
	              player.play();
	            }
	          } else {
	            player.currentTime(0);
	          }
	        }
	      }
	    }));

	    // iOS 11 Safari adds `controls` attribute automatically after exiting from fullscreen
	    this.disposers.push(...subscribeTo(player, ['fullscreenchange'], () => {
	      this.coordinator.coordinate(player.isFullscreen() ? 'dtci.fullscreen.entered' : 'dtci.fullscreen.exited');
	      if (IS_IOS && !player.isFullscption = NewRelicService$1.generatePlayerPluginConcurrenceLimit(STREAM_LIMIT_ERROR_MSG, err);
	      this.player.errorDisplay.show();
	      this.error({
	        message: player.localize('STREAM_LIMITED'),
	        headline: player.localize('STREAM_LIMITED'),
	        code: STREAM_LIMIT_ERROR_CODE,
	        errorException
	      }, err.message || STREAM_LIMIT_ERROR_MSG, false);
	      NewRelicService$1.playbackSessionFlowEvent({}, errorException);
	    });
	    this.disposers.push(...subscribeTo(player, ['dtci.captionSettings.closed', 'dtci.captionSettings.opened', 'dtci.socialOverlay.closed', 'dtci.socialOverlay.opened', 'dtci.id3.cueChange', 'dtci.autoplay', 'dtci.autoplay.muted', 'dtci.play.blocked', 'dtci.play', 'dtci.playing'], (event, payload) => {
	      this.coordinator.coordinate(event.type, payload);
	    }));

	    // Emit player events: DTCIMMP-1417
	    this.disposers.push(...subscribeTo(player, ['ads-ad-started'], () => {
	      const id = this.adId;
	      player.addClass('vjs-ad-playing');
	      if (id) {
	        const adType = this.getAdType();
	        this.coordinator.coordinate('dtci.ads.adStarted', {
	          type: adType,
	          id
	        });
	      }
	    }));
	    this.disposers.push(...subscribeTo(player, ['ads-ad-ended', 'ads-ad-skipped'], () => {
	      const id = this.adId || this.prevAdId_;

	      // Player event might still fire even if ad is canceled by grace period.
	      if (id && !this.mediaManager.advertisementService.isInAdGracePeriod) {
	        const adType = this.getAdType();
	        this.coordinator.coordinate('dtci.ads.adEnded', {
	          type: adType,
	          id
	        });
	      }
	      player.removeClass('vjs-ad-playing');
	      if (!this.mediaManager.advertisementService.isInAdGracePeriod) {
	        this.coordinator.coordinate('dtci.adend');
	      }
	    }));

	    /*
	      Addresses an issue where the player remains hidden, if an ad doesn't play.
	    */
	    this.disposers.push(...subscribeTo(player, ['adend', 'content-resume-requested'], () => {
	      player.removeClass('vjs-ad-loading');
	      this.resumePausedVideo();
	    }));
	    this.disposers.push(...subscribeTo(player, ['adserror', 'ima3-ad-error'], () => {
	      player.removeClass('vjs-ad-loading');
	      player.removeClass('vjs-ad-playing');
	    }));
	    this.disposers.push(...subscribeTo(player, ['ads-play'], () => {
	      if (!this.mediaManager.advertisementService.isInAdGracePeriod) {
	        this.coordinator.coordinate('dtci.ads.play');
	      }
	      this.coordinator.coordinate('dtci.playing');
	    }));
	    this.disposers.push(...subscribeTo(player, ['ads-pause'], () => this.coordinator.coordinate('dtci.ads.pause')));
	    this.disposers.push(...subscribeTo(player, ['ads-ad-skipped'], () => this.coordinator.coordinate('dtci.ads.adSkipped')));
	    this.disposers.push(...subscribeTo(player, ['dispose'], () => this.coordinator.coordinate('dtci.dispose')));
	    this.disposers.push(...subscribeTo(player, ['seeking'], () => this.coordinator.coordinate('dtci.seeking')));
	    this.disposers.push(...subscribeTo(player, ['seeked'], () => {
	      if (!player.paused()) {
	        this.coordinator.coordinate('dtci.pause', {
	          userInitiated: true
	        });
	        this.coordinator.coordinate('dtci.seeked');
	        this.coordinator.coordinate('dtci.playing');
	      }
	    }));
	    this.disposers.push(...subscribeTo(player, ['timeupdate'], (evt, evtData = {}) => {
	      const {
	        currentTime,
	        type
	      } = evtData;
	      const coordinatedData = {
	        currentTime: currentTime || player.currentTime()
	      };
	      if (player.ads && this.isInAdMode) {
	        coordinatedData.type = 'ad';
	      } else if (type) {
	        coordinatedData.type = type;
	      }
	      this.coordinator.coordinate('dtci.timeupdate', coordinatedData);
	    }));
	    if (this.configs_.chromeless) {
	      player.addClass('espn-chromeless');

	      // We use this to enforce controls remaining hidden.
	      this.disposers.push(...subscribeTo(player, ['controlsenabled'], () => player.controls(false)));
	      if (player.controlBar) {
	        player.controlBar.el().setAttribute('aria-hidden', 'true');
	      }
	      if (!this.showCaptionsUI_) {
	        // if we're surpressing text tracks for ambient video, consider
	        // the video decorative and indicate that by setting root element
	        // aria-hidden to "true" -- SEWEB-25685
	        player.el().setAttribute('aria-hidden', 'true');
	      }
	    }

	    // During pre-roll, the content player is paused behind the ad player. When
	    // playing a live stream, the content player doesn't always resume after
	    // the pre-roll. This ensures that playback resumes after pre-roll ads.
	    this.disposers.push(...subscribeTo(player, ['ads-allpods-completed'], () => {
	      this.resumePausedVideo();
	    }));
	    this.disposers.push(...subscribeTo(player, ['volumechange'], () => {
	      const volume = player.volume();
	      let data;
	      if (!player.muted()) {
	        data = {
	          value: volume,
	          muted: false
	        };
	      } else {
	        data = {
	          value: volume,
	          muted: true
	        };
	      }
	      this.coordinator.coordinate('dtci.volumeChanged', data);
	    }));
	    player.ready(() => {
	      this.setSizeClass();
	      this.updateCCPositionsPerConfigs_();
	      window.addEventListener('resize', this.debouncedSetSizeClass);
	      this.coordinator.coordinate('dtci.embedded');
	      this.initAccessibilityEnhancements();
	    });
	  }
	  onPlayCallback(event) {
	    // This handler method is getting bound to this class in this constructor. Before it was acting inconsistently due to
	    // listeners being applied first in the BasePlayerAdapter. Since moving init logic out of the constructors, it is acting
	    // as expected and is easier to understand. (It might make sense to delete this comment a few months after April 2022).

	    this.player.isPlaying = true;
	    if (event.type === 'play') {
	      const shouldClearPlayTimestamp = this.playTimestamp && Date.now() - this.playTimestamp > PLAY_EPSILON;
	      if (shouldClearPlayTimestamp) {
	        this.playTimestamp = undefined;
	      }
	      if (!this.playTimestamp) {
	        var _this$player$ads;
	        const adsState = (_this$player$ads = this.player.ads) === null || _this$player$ads === void 0 ? void 0 : _this$player$ads.state;
	        const isContent = !adsState || adsState === adStates.CONTENT_RESUMING || adsState === adStates.CONTENT_PLAYBACK;
	        this.player.trigger('dtci.play');
	        if (isContent) {
	          /**
	           * Use `dtci.playing` event to detect if the content has started to play (not including CSAI ads play)
	           */
	          this.player.trigger('dtci.playing');
	        }
	        this.playTimestamp = Date.now();
	      }
	    }
	  }

	  /**
	   * Makes a `player_.play()` call if paused. If the play call fails, it attempts to mute the player and play again
	   *
	   * @param {number} [timeout=PLAY_PAUSED_DELAY]
	   * @returns {Promise}
	   * @memberof VideoJsAdapter
	   */
	  resumePausedVideo(timeout = PLAY_PAUSED_DELAY) {
	    return new promise((resolve, reject) => {
	      this.resumePausedTimeouts_.push(setTimeout(function doResume() {
	        const {
	          player_,
	          configs_
	        } = this;
	        const onPlayedResolve = result => {
	          var _configs_$mediaItem;
	          const currTime = player_.currentTime();
	          const seekInSeconds = (configs_ === null || configs_ === void 0 ? void 0 : (_configs_$mediaItem = configs_.mediaItem) === null || _configs_$mediaItem === void 0 ? void 0 : _configs_$mediaItem.seekInSeconds) || 0;

	          // On iOS, the player does not want to remember that it was
	          // on a specific time when it comes back from ads and resumes.
	          // This reminds it then tries not to remind it a second time and only on a preroll add
	          // by first making sure the video hasn't moved beyond the seek point
	          //   getAdType is bad since sometimes the player thinks it is already
	          //   at the seek time when the preroll completes and reports it as midroll
	          // then making sure it hasn't already triggered
	          const isProbablyPreroll = currTime <= seekInSeconds + 1;
	          if (IS_IOS && seekInSeconds && isProbablyPreroll && (!this.seekedFromAd || currTime < 5)) {
	            player_.currentTime(seekInSeconds);
	            this.seekedFromAd = true;
	          }
	          player_.trigger('volumechange');
	          return resolve(result);
	        };
	        if (player_.paused()) {
	          player_.play().then(onPlayedResolve).catch(function tryPlayingMuted() {
	            // often a `play()` fails when it's trying to autoplay an unmuted video when the browser won't allow it...

	            // so try muting
	            player_.muted(true);

	            // and attempt playing the video again
	            player_.play().then(onPlayedResolve).catch(reject);
	          });
	        } else {
	          onPlayedResolve();
	        }
	      }.bind(this), timeout));
	    });
	  }
	  initAccessibilityEnhancements() {
	    if (this.player && this.player.dmedAccessibility) {
	      this.player.dmedAccessibility();
	    }
	  }
	  async handlePlayerErrorEvent_() {
	    const {
	      player
	    } = this;
	    const interval = 30;
	    const error = player.error();
	    if (this.mediaManager.errorHandlerService.isRecoverableError(error === null || error === void 0 ? void 0 : error.message)) {
	      this.player.errorDisplay.close();
	      return;
	    }
	    if (error) {
	      // Ensure an ad is not playing behind the error overlay.
	      // Shouldn't be necessary but I've seen cases where an ad continues playing under an error message.
	      if (player.ads && typeof player.ads.isAdPlaying === 'function' && player.ads.isAdPlaying()) {
	        player.pause();
	        if (player.ima && typeof player.ima.pauseAd === 'function') {
	          player.ima.pauseAd();
	        }
	      }

	      // Shaka player (used for DRM) raises 1001, similar to VideoJS's -2
	      if (error.code === -2 || error.code === 1001) {
	        if (this.lastErrorTime_) {
	          // if the error has re-occured within the interval
	          if (Date.now() - this.lastErrorTime_ < interval * 1000) {
	            // make sure we don't loop
	            this.lastErrorTime_ = 0;
	            player.reset();
	      }
	        if (this.lastErrorTime_ !== 0) this.lastErrorTime_ = Date.now();
	      } else if (error.message === ERRORS.DRM_REQUIRED || [1002, 3016, 4012, 6001, 6004, 6007, 6008].indexOf(error.code) > -1) {
	        // `DRM_REQUIRED` is returned by Shield when the content requires a `drmSupport` param, but none was provided
	        // The error codes are raised by the Shaka player; more info: https://github.com/google/shaka-player/blob/master/docs/tutorials/faq.md
	        let errorException;
	        if (error.message === ERRORS.DRM_REQUIRED) {
	          errorException = NewRelicService$1.generatePlayerSessionShieldDRMRequired(ERROR_CODES.SHIELD_DRM_REQUIRED, ERRORS.DRM_REQUIRED, error);
	        } else {
	          errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.SHAKA_PLAYER_DRM_ERROR, 'shaka drm error', error);
	        }
	        error.errorException = errorException;
	        await this.coordinator.coordinate('dtci.drm.error', error);
	      } else {
	        await this.coordinator.coordinate('dtci.error', error);
	      }
	    }
	    this.handlePlayerError(error);
	    if (typeof NewRelicService$1.trackError === 'function') {
	      NewRelicService$1.trackError(error);
	    }
	  }
	  handleRemoteTextTrack_(mediaItem) {
	    const {
	      remoteTextTrack: remoteTextTrackSrc
	    } = mediaItem || {};
	    const {
	      player
	    } = this;
	    const supportsRemoteTextTracks = player && typeof player.addRemoteTextTrack === 'function';
	    if (supportsRemoteTextTracks) {
	      // first see if there we already added a remote text track
	      let prevRemoteTextTrack;
	      const textTracks = player.textTracks();
	      const len = textTracks.length;
	      for (let i = 0; i < len; i += 1) {
	        // textTracks does not implement Interator, so we must iterate over manually
	        const textTrack = textTracks[i];
	        if ((textTrack === null || textTrack === void 0 ? void 0 : textTrack.id) === 'remote-text-track') {
	          prevRemoteTextTrack = textTrack;
	          break;
	        }
	      }
	      if (prevRemoteTextTrack) {
	        player.removeRemoteTextTrack(prevRemoteTextTrack);
	      }
	      if (remoteTextTrackSrc) {
	        player.one('loadedmetadata', function addRemoteTextTrack() {
	          const tracksEnabled = player.captionController && player.captionController().tracksEnabled;
	          const remoteTextTrack = player.addRemoteTextTrack({
	            id: 'remote-text-track',
	            src: remoteTextTrackSrc
	          });
	          if (remoteTextTrack !== null && remoteTextTrack !== void 0 && remoteTextTrack.track) {
	            // this can't be set in addRemoteTextTrack above :(
	            remoteTextTrack.track.mode = tracksEnabled ? 'showing' : 'hidden';
	          }
	        });
	      }
	    }
	  }
	  handlePlayerLoadstartEvent_() {
	    var _player$dash, _player$dash2;
	    const {
	      player
	    } = this;
	    const hlsTech = player.tech({
	      IWillNotUseThisInPlugins: true
	    }).vhs;
	    if (player !== null && player !== void 0 && (_player$dash = player.dash) !== null && _player$dash !== void 0 && _player$dash.mediaPlayer) {
	      const {
	        updateSettings,
	        getProtectionController
	      } = player.dash.mediaPlayer;
	      if (typeof updateSettings === 'function') {
	        const targetLatency = parseFloat('1', 10);
	        const minDrift = parseFloat('0.05', 10);
	        const catchupPlaybackRate = parseFloat('0.1', 10);
	        const liveCatchupLatencyThreshold = parseFloat('10', 10);
	        updateSettings({
	          streaming: {
	            liveDelay: targetLatency,
	            liveCatchup: {
	              minDrift,
	              playbackRate: catchupPlaybackRate,
	              latencyThreshold: liveCatchupLatencyThreshold
	            }
	          }
	        });
	      }
	      if (typeof getProtectionController === 'function') {
	        const {
	          setRobustnessLevel
	        } = getProtectionController();
	        if (typeof setRobustnessLevel === 'function') {
	          setRobustnessLevel('SW_SECURE_CRYPTO');
	        }
	      }
	    }

	    // Check for the HLS plugin. Safari supports HLS natively, so the plugin doesn't get loaded.
	    if (hlsTech) {
	      // start live playback 4 fragments from the end of the playlist (default 3)
	      videojs.Vhs.Playlist.UNSAFE_LIVE_SEGMENTS = 4;

	      // Send cookies (by setting `withCredentials`) only for `generateKey` request from Akamai
	      hlsTech.xhr.beforeRequest = options => {
	        const rex = new RegExp('generateKey');
	        if (rex.test(options.uri)) {
	          options.withCredentials = true;
	        }
	      };
	    }
	    if (IS_MOBILE) {
	      // Hide the volume slider, but show the mute button.
	      player.controlBar.volumePanel.volumeControl.hide();
	    }
	    if (IS_IOS) {
	      player.addClass('ios-device');
	    }
	    if (player !== null && player !== void 0 && (_player$dash2 = player.dash) !== null && _player$dash2 !== void 0 && _player$dash2.shakaPlayer) {
	      player.dash.shakaPlayer.configure({
	        // https://espn.slack.com/archives/CLRUZSTAL/p1567698463210900
	        // Make Shaka player start with the lowest rendition and work its way up from there.
	        // Improves initial performance on Android Chrome.
	        abr: {
	          defaultBandwidthEstimate: 1
	        },
	        // https://jira.disney.com/browse/WEBPLAYER-275
	        // Override Shaka's default retry logic and raise a -2
	        streaming: {
	          failureCallback(error) {
	            const errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_SHAKA_ERROR, 'shakaPlayer failureCallback error: ', error);
	            player.error({
	              code: -2,
	              errorException
	            });
	          },
	          smallGapLimit: 4
	        }
	      });
	    }
	  }
	  reportPlayerErrorEvent(content, value, showRetryButton = true) {
	    const {
	      player,
	      coordinator
	    } = this;
	    let defaultErrorRetryMessage = content;
	    if (content === '') {
	      defaultErrorRetryMessage = player.localize('DEFAULT_ERROR_RETRY_MSG');
	    }
	    const messages = {
	      retryButtonMessage: player.localize('retry_error_button'),
	      defaultErrorMessage: content,
	      defaultErrorRetryMessage
	    };
	    coordinator.coordinate(SET_CUSTOM_ERROR_MESSAGES_EVENT, messages);
	    super.reportPlayerErrorEvent(content, value, showRetryButton);
	  }
	  initNewRelicOnTrackingEnabled_() {
	    if (this.player) {
	      NewRelicService$1.setPlayer(this.player);
	      NewRelicService$1.start(this.coordinator);
	    }
	  }
	  autoplay(value) {
	    let value_;
	    if (value != null) {
	      value_ = value ? 'any' : false;
	    }
	    value_ = IS_IOS && value ? 'muted' : value_;
	    return this.player.autoplay(value_);
	  }
	  async play() {
	    const {
	      player
	    } = this;
	    if (player) {
	      const playerType = this.getPlayerType_(player);
	      try {
	        var _this$player, _this$player$ads2;
	        const isPlayerMuted = player.muted();
	        if (playerType === PLAYER_TYPE.imaAdPlayer && typeof ((_this$player = this.player) === null || _this$player === void 0 ? void 0 : (_this$player$ads2 = _this$player.ads) === null || _this$player$ads2 === void 0 ? void 0 : _this$player$ads2.inAdBreak) === 'function' && this.player.ads.inAdBreak()) {
	          player.ima.resumeAd();
	          // player.ima.resumeAd is function, not a promise, but if it gets here, we got playback
	          this.emitAutoPlayEvent_(isPlayerMuted);
	        } else {
	          const res = await this.handlePlayerPlayPromise_();
	          if (res !== true) {
	            throw res;
	          }
	        }
	        return promise.resolve();
	      } catch (err) {
	        console.error(`play() failed, err: ${err}, isMuted=${player.muted()}, playerType=${playerType}, autoplayPolicy=${this.autoplayPolicy}`);
	        player.trigger('dtci.play.blocked', {
	          err,
	          playerType
	        });
	        return promise.reject(err);
	      }
	    }
	    return promise.reject(new Error('play() failed: player is null'));
	  }
	  pause() {
	    const {
	      player
	    } = this;
	    if (player) {
	      const playerType = this.getPlayerType_(player);
	      if (playerType === PLAYER_TYPE.imaAdPlayer) {
	        player.ima.pauseAd();
	      } else {
	        player.pause();
	        if (player.paused() && !this.activeButton_) {
	          this.coordinator.coordinate('dtci.pause', {
	            userInitiated: true
	          });
	        }
	      }
	    }
	    return this;
	  }
	  getPlayerType_(player) {
	    let playerType = PLAYER_TYPE.videoPlayer;
	    if (this.isInAdMode) {
	      const {
	        ima
	      } = player;
	      if (ima && typeof ima.pauseAd === 'function' && typeof ima.resumeAd === 'function') {
	        playerType = PLAYER_TYPE.imaAdPlayer;
	      }
	    }
	    return playerType;
	  }
	  emitAutoPlayEvent_(isPlayerMuted) {
	    if (isPlayerMuted) {
	      this.coordinator.coordinate('dtci.autoplay.muted');
	    } else {
	      this.coordinator.coordinate('dtci.autoplay');
	    }
	  }
	  async handlePlayerPlayPromise_() {
	    let playResult = false;
	    const {
	      player
	    } = this;
	    try {
	      await player.play();
	      playResult = true; // if we make it to this line, the play worked!
	    } catch (err) {
	      console.error(`handlePlayerPlayPromise_ failed, err: ${err}, isMuted=${player.muted()}`);
	    }
	    if (playResult === true) {
	      this.emitAutoPlayEvent_(player.muted());
	    }
	    return playResult;
	  }
	  muted(value) {
	    const {
	      player
	    } = this;
	    if (player) {
	      if (typeof value === 'undefined') {
	        return player.muted();
	      }
	      const muteValue = player.muted(value);
	      return muteValue;
	    }
	    return this;
	  }
	  onFatalErrorDisposePlayer() {
	    const {
	      player
	    } = this;
	    if (!player) {
	      return;
	    }
	    const playerParent = document.querySelector(`#${player.id()}`).parentElement;
	    const playerSupport = document.createElement('div');
	    playerSupport.className = player.contentEl().className;
	    const errorMessage = document.querySelector('.vjs-error-display.vjs-modal-dialog').cloneNode(true);
	    this.dispose();
	    playerParent.appendChild(playerSupport);
	    playerSupport.appendChild(errorMessage);
	    this.player = null;
	  }
	  thumbnails(previews) {
	    const {
	      player
	    } = this;
	    if (typeof player.thumbnails !== 'function') {
	      return;
	    }
	    if (player.controlBar && player.controlBar.progressControl.$('.vjs-thumbnail-holder')) {
	      player.thumbnails().updatePreviews(previews);
	    } else {
	      player.thumbnails(previews);
	    }
	    player.thumbnailTime();
	  }
	  social(options) {
	    const {
	      player
	    } = this;
	    if ((!options || typeof player.social !== 'function') && !this.configs_.isAudio) {
	      return null;
	    }
	    if ((!options || typeof player.brandedSocial !== 'function') && this.configs_.isAudio) {
	      return null;
	    }
	    if (!this.dtciSocial) {
	      if (this.configs_.isAudio) {
	        this.dtciSocial = player.brandedSocial(options);
	      } else {
	        this.dtciSocial = player.social(options);
	      }
	    } else {
	      this.dtciSocial.options = options;
	    }
	    return this.dtciSocial;
	  }
	  endcard(clip, options = {}) {
	    const getNextContent = this.getNextContent(clip);
	    const {
	      timeout,
	      autoplay,
	      remaining,
	      countdown
	    } = options;
	    if (this.player.endcard && typeof this.player.endcartimeo   onplayer,
	        configs_: {
	          disableAdobe,
	          disableNielsen
	        } = {}
	      } = this;
	      const playerAutoplay = !!(player && typeof player.autoplay === 'function' && player.autoplay());
	      const analyticsEnabled = !disableAdobe && !disableNielsen;
	      this.startType = wasManual ? PLAYER_START_TYPE.ENDCARD_MANUAL : PLAYER_START_TYPE.ENDCARD_AUTOSTART;
	      mediaItem.startType = this.startType;
	      if (mediaItem.link && mediaItem.link.id) {
	        localStorage.setItem('endcardNextItem', mediaItem.link.id);
	        if (mediaItem.link.urlValue) {
	          this.coordinator.coordinate('dtci.contentEnded');

	          // [CPSF-5092]: setting 1000 ms timeout so that DCF has enough time to hook into `'dtci.contentEnded'` event
	          // before page is reloaded when window.top.location.href is set
	          setTimeout(() => {
	            const nextUrl = document.location.hostname === 'local.espn.com' ? `${document.location.origin}/entertainment.html?origin=endcard&tech=videojs` // Origin for test harness is different
	            : document.location.origin + mediaItem.link.urlValue;
	            window.top.location.href = nextUrl;
	          }, 1000);
	        }
	      }
	      if (analyticsEnabled) {
	        this.analytics.adobeDCR({
	          ESPN_CUSTOM_METADATA: {
	            startType: this.startType
	          }
	        });
	        this.analytics.conviva({
	          startType: this.startType
	        });
	      }
	      nowing
	      // if and when the video player will actually play it. Here we know the player is about
	      // to play this next `mediaItem`, so let the client know, so it can do updates outside
	      // of the player if needed
	      this.coordinator.coordinate('dtci.loaded', mediaItem);
	      if (!mediaItem.link) {
	        this.coordinator.coordinate('dtci.contentEnded');
	        this.clf, but endcard.autoplay was true, set player.autoplay to true the rest of continuous play
	        player.autoplay(true);
	      }
	    }
	  }
	  watchLoadedCallback(mediaItem, playbackSession) {
	    const {
	      player
	    } = this;
	    super.watchLoadedCallback(mediaItem, playbackSession);

	    /*
	      Seek to live point on play if the source is live. This prevents DVR-
	      like behavior for live streams.
	    */
	    if (mediaItem && mediaItem.isLive && player) {
	      player.on('play', () => {
	        if (player.seekable().length > 0 && player.mediainfo.live) {
	          player.currentTime(player.seekable().end(0));
	        }
	      });
	    }
	  }
	  setSizeClass() {
	    const {
	      player
	    } = this;
	    if (player) {
	      const playerWidth = player && player.currentWidth() || -1;
	      if (playerWidth >= 900) {
	        player.addClass('desktop-view');
	      } else {
	        player.removeClass('deskaddClass('mobile-portrait');
	      } else {
	        player.removeClass('mobile-portrait');
	      }
	      if (playerWidth <= 330) {
	        player.addClass('docked-video');
	      } else {
	        player.removeClass('docked-video');
	      }
	    }
	  }
	  updateCCPositionsPerConfigs_() {
	    const {
	      player,
	      configs_: {
	        captions: {
	          positionAdjust
	        } = {}
	      }
	    } = this;
	    if (player) {
	      if (positionAdjust === 'cc-lower-third') {
	   	  }
	  src(src) {
	    super.src(src);
	    this.player.off('error', this.handlePlayerError);
	  }
	  dispose() {
	    window.removeEventListener('resize', this.debouncedSetSizeClass);
	    if (this.resumePausedTimeouts_ instanceof Array) {
	      this.resumePausedTimeouts_.forEach(function clearResumePausedTimeout(resumePausedTimeouts) {
	        clearTimeout(resumePausedTimeouts);
	      }this.player) {
	        var _this$disposers;
	        try {
	          this.player.dispose();
	          thERROR_CODES.PLAYER_CAN_NOT_BE_DISPOSED, err.message, err));
	        }
	        if ((_this$disposers = this.disposers) !== null && _this$disposers !== void 0 && _this$disposers.length) {
	          this.disposers.forEach(disposer => disposer());
	        }
	        this.disposers = null;
	      }
	      super.dispose.apply(this);ter.techLoadedPromise = promise.resolve();
	    }
	    if (VideoJsAdapter.techLoadedPromise) {
	      return VideoJsAdapter.techLoadedPromise;
	    }
	    const {
	      playerBaseUrl = `https://a.espncdn.com/players/web-player-bundle/${"5.3.16"}/`,
	      unminified = false,
	      legacyAnalytics = false,
	      hasDRM = false,
	      type = 'video'
	    } = options;
	    const jsExt = `${unminified ? '' : '.min'}.js`;
	    const techUrl = `${playerBaseUrl}dtci.video${jsExt}`;
	    const additionalPluginUrls = [];
	    if (legacyAnalytics) {
	      additionalPluginUrls.push(`${playerBaseUrl}dtci.consumer-analytics-plugins${jsExt}`);
	    }
	    const typePluginsURL = type === 'audio' ? 'dtci.audio-plugins' : 'dtci.video-plugins';
	    additionalPluginUrls.push(`${playerBaseUrl}${typePluginsURL}${jsExt}`);
	    if (hasDRM) {
	      additionalPluginUrls.push(`${playerBaseUrl}libs/videojs-eme${jsExt}`);
	      additionalPluginUrls.push(`${playerBaseUrl}libs/videojs-contrib-dash${jsExt}`);
	    }
	    VideoJsAdapter.techLoadedPromise = (loadScript$1.url(techUrl) || promise.resolve()).then(() => {
	      // we want to wait to load additional plugins after we know videojs is loaded and window.videojs is defined
	      return additionalPluginUrls.length ? loadScript$1.urls(additionalPluginUrls) : promise.resolve();
	    });
	    return VideoJsAdapter.techLoadedPromise;
	  }
	}
	VideoJsAdapter.techLoadedPromise = null;

	const EMPTY_OBJ = freeze({});
	const EMPTY_STR = '';
	const PLAYER_BASE_DEFAULT = `https://assets.espn.com/players/web-player-bundle/${"5.3.16"}`;
	const PLAYER_SCRIPT_NAME = "espn-web-player-bundle" ;
	const THIS_DOCUMENT = typeof document !== 'undefined' ? document : EMPTY_OBJ;
	function getCurrentScript(file, doc = THIS_DOCUMENT) {
	  return doc && doc.querySelector(`script[src*="${file}"]`) || EMPTY_OBJ;
	}

	/**
	 * Given an extension-less @file, this function queries the @doc for a script that has a matching `src`
	 * and returns the basename. Ex: given `espn-web-player-bundle` and `window.document`
	 * it will return `https://assets.espn.com/players/web-player-bundle/[the-current-version]
	 *
	 * @export
	 * @param {String} [file?]
	 * @param {Document} [doc?]
	 * @returns base URL of the current script
	 */
	function getPlayerBaseURL(file = PLAYER_SCRIPT_NAME, doc = THIS_DOCUMENT) {
	  const {
	    src: scriptSrc = EMPTY_STR
	  } = getCurrentScript(file, doc);
	  const playerScriptRegExp = new RegExp(`/${file}(.min)?.js`);
	  const scriptNamePos = (scriptSrc.match(playerScriptRegExp, 'g') || {}).index || -1;
	  let playerBase;
	  if (scriptNamePos > -1) {
	    playerBase = scriptSrc.substr(0, scriptNamePos);
	  }
	  if (!playerBase) {
	    playerBase = PLAYER_BASE_DEFAULT;
	  }
	  return playerBase;
	}

	function injectPlayerBundleCssIntoDom() {
	  try {
	    const playerBaseUrl = getPlayerBaseURL();
	    const noPlayerCss = !document.querySelector(`link[href*=${PLAYER_SCRIPT_NAME}]`);
	    if (noPlayerCss) {
	      const playerStyles = document.createElement('link');
	      playerStyles.id = 'web_player_css';
	      playerStyles.rel = 'stylesheet';
	      playerStyles.href = `${playerBaseUrl}/${PLAYER_SCRIPT_NAME}.css`;
	      document.head.appendChild(playerStyles);
	    }
	  } catch (err) {
	    console.error(`injectPlayerBundleCssIntoDom error: ${err}`);
	  }
	}

	const Constants = {
	    StreamType: {
	        UNKNOWN: 'unknown',
	        LIVE: 'live',
	        VOD: 'vod',
	    },
	    PlaybackPlayerType: {
	        SHAKA_PLAYER: 'shakaPlayer',
	        DASH_MEDIA_PLAYER: 'mediaPlayer',
	        VIDEO_JS_VHS: 'vhs',
	    },
	    PlayerState: {
	        STOPPED: 'stopped',
	        PAUSED: 'paused',
	        BUFFERING: 'buffering',
	        UNKNOWN: 'unknown',
	        SEEK_STARTED: 'seekStarted',
	        SEEK_ENDED: 'seekEnded',
	        PLAYING: 'playing',
	        NOT_MONITORED: 'notMonitored',
	    },
	    Playback: {
	        BITRATE: 'BITRATE',
	        PLAY_HEAD_TIME: 'PLAY_HEAD_TIME',
	        RESOLUTION: 'RESOLUTION',
	        BUFFER_LENGTH: 'BUFFER_LENGTH',
	        PLAYER_STATE: 'PLAYER_STATE',
	        RENDERED_FRAMERATE: 'RENDERED_FRAMERATE',
	        SEEK_STARTED: 'SEEK_STARTED',
	        SEEK_ENDED: 'SEEK_ENDED',
	        CDN_IP: 'CDN_IP',
	        DROPPED_FRAMES_TOTAL: 'DROPPED_FRAMES_TOTAL',
	        DROPPED_FRAMES_COUNT: 'DROPPED_FRAMES_COUNT',
	    },
	    AdType: {
	        CLIENT_SIDE: 'client',
	        SERVER_SIDE: 'server',
	    },
	    AdPosition: {
	        PREROLL: 'Pre-roll',
	        MIDROLL: 'Mid-roll',
	        POSTROLL: 'Post-roll',
	    },
	    AdPlayer: {
	        CONTENT: 'CONTENT',
	        SEPARATE: 'SEPARATE',
	    },
	    ErrorSeverity: {
	        FATAL: 1,
	        WARNING: 0,
	    },
	    PartnerType: {
	        DMED: 'dmed',
	        ESPN_COM: 'espn-com',
	        ESPN_TVE: 'espn-tve',
	    },
	    STREAM_URL: 'streamUrl',
	    ASSET_NAME: 'assetName',
	    ASSET_ID: 'assetId',
	    IS_LIVE: 'isLive',
	    PLAYER_NAME: 'playerName',
	    VIEWER_ID: 'viewerId',
	    START_TYPE: 'startType',
	    VIDEO_RESOLUTION: 'videoResolution',
	    APP_BRAND: 'appBrand',
	    SITE: 'site',
	    PAGE: 'page',
	    CONNECTION_TYPE: 'dcType',
	    RESOURCE: 'resource',
	    MEDIA_TYPE: 'mediaType',
	    APPLICATION_VERSION: 'applicationVersion',
	    DRM_PROTECTION_TYPE: 'drmProtectionType',
	    STREAM_PROTOCOL: 'streamProtocol',
	    SPORT: 'sport',
	    LEAGUE: 'league',
	    EVENT_ID: 'eventId',
	    EVENT_NAME: 'eventName',
	    EVENT_TYPE: 'eventType',
	    PLAYER_STATE: 'playerState',
	    BITRATE: 'bitrate',
	    PLAY_HEAD_TIME: 'playHeadTime',
	    BUFFER_LENGTH: 'bufferLength',
	    DROPPED_FRAMES_TOTAL: 'droppedFramesTotal',
	    FRAMEWORK_NAME: 'frameworkName',
	    FRAMEWORK_VERSION: 'frameworkVersion',
	    MODULE_VERSION: 'moduleVersion',
	    MODULE_NAME: 'moduleName',
	    IMASDK_CONTENT_PLAYER: 'imaMainContentPlayer',
	    POD_POSITION: 'podPosition',
	    POD_INDEX: 'podIndex',
	    POD_DURATION: 'podDuration',
	    AD_PRELOAD_FEATURE: 'adPreloading',
	    DURATION: 'duration',
	    ACCESS_TYPE: 'accessType',
	    CDN_RESOURCE_LOCATION: 'locationName',
	    CDN_NAME: 'cdnName',
	    PARTNER: 'prt',
	    PARTNER_SDK: 'partnerSDK',
	    PCCID: 'pccId',
	    AD_ID: 'c3.ad.id',
	    SERIES_NAME: 'seriesName',
	    SEASON_NUMBER: 'seasonNumber',
	    GENRE: 'genre',
	    EPISODE_NUMBER: 'episodeNumber',
	    CONTENT_CATEGORY: 'contentCategory',
	    ASSET_PROVIDER_NAME: 'assetProviderName',
	};

	var MediaItemMediaCommand$3;
	(function (MediaItemMediaCommand) {
	    MediaItemMediaCommand[MediaItemMediaCommand["all"] = 0] = "all";
	    MediaItemMediaCommand[MediaItemMediaCommand["linearPlayback"] = 1] = "linearPlayback";
	})(MediaItemMediaCommand$3 || (MediaItemMediaCommand$3 = {}));

	var MediaItemNetworkType$3;
	(function (MediaItemNetworkType) {
	    MediaItemNetworkType["linear"] = "linear";
	    MediaItemNetworkType["event"] = "event";
	})(MediaItemNetworkType$3 || (MediaItemNetworkType$3 = {}));

	var MediaItemSourceVariant$4;
	(function (MediaItemSourceVariant) {
	    MediaItemSourceVariant["stitchedPreroll"] = "stitchedPreroll";
	})(MediaItemSourceVariant$4 || (MediaItemSourceVariant$4 = {}));

	var MediaItemStreamType$5;
	(function (MediaItemStreamType) {
	    MediaItemStreamType["live"] = "live";
	    MediaItemStreamType["onDemand"] = "onDemand";
	})(MediaItemStreamType$5 || (MediaItemStreamType$5 = {}));

	var MediaItemTrackingType$4;
	(function (MediaItemTrackingType) {
	    MediaItemTrackingType["nielsen"] = "nielsen";
	    MediaItemTrackingType["comscore"] = "comscore";
	    MediaItemTrackingType["conviva"] = "conviva";
	    MediaItemTrackingType["heartbeats"] = "heartbeats";
	})(MediaItemTrackingType$4 || (MediaItemTrackingType$4 = {}));

	var MediaItemEntityType$4;
	(function (MediaItemEntityType) {
	    MediaItemEntityType["shortform"] = "shortform";
	    MediaItemEntityType["longform"] = "longform";
	})(MediaItemEntityType$4 || (MediaItemEntityType$4 = {}));

	var MediaItemType$3;
	(function (MediaItemType) {
	    MediaItemType["audio"] = "audio";
	    MediaItemType["video"] = "video";
	})(MediaItemType$3 || (MediaItemType$3 = {}));

	var ApiSource$6;
	(function (ApiSource) {
	    ApiSource["pluto"] = "pluto";
	    ApiSource["graphQL"] = "graphQL";
	    ApiSource["cfa"] = "cfa";
	    ApiSource["itemFeed"] = "itemFeed";
	})(ApiSource$6 || (ApiSource$6 = {}));
	var ApiSource$7 = ApiSource$6;

	var MediaItemAuthenticationType$6;
	(function (MediaItemAuthenticationType) {
	    MediaItemAuthenticationType["open"] = "OPEN";
	    MediaItemAuthenticationType["direct"] = "DIRECT";
	    MediaItemAuthenticationType["mvpd"] = "MVPD";
	    MediaItemAuthenticationType["isp"] = "ISP";
	    MediaItemAuthenticationType["none"] = "NONE";
	})(MediaItemAuthenticationType$6 || (MediaItemAuthenticationType$6 = {}));
	var MediaItemAuthenticationType$7 = MediaItemAuthenticationType$6;

	var MediaItemSourceType$5;
	(function (MediaItemSourceType) {
	    MediaItemSourceType["none"] = "none";
	    MediaItemSourceType["startSession"] = "startSession";
	    MediaItemSourceType["bam"] = "bam";
	    MediaItemSourceType["shield"] = "shield";
	    MediaItemSourceType["entitlement"] = "entitlement";
	})(MediaItemSourceType$5 || (MediaItemSourceType$5 = {}));

	const defaultGraphQLServiceUrl$3 = 'https://watch.graph.api.espn.com/api';
	const defaultGraphQLApiKey$3 = 'd15c5790-7cb0-4fe1-8782-25f4698d0739';
	const defaultGraphQLNetworkSortOrder$3 = [
	    'espn_ppv',
	    'espn_dtc',
	    'espn1',
	    'espn2',
	    'espn3',
	    'espnu',
	    'sec',
	    'espnews',
	    'espndeportes',
	    'longhorn',
	    'goalline',
	    'buzzerbeater',
	    'secplus',
	    'acc',
	    'accextra',
	    'espn_free',
	    'bam_dtc',
	];
	const defaultItemFeedServiceUrl$3 = 'https://abcnews.go.com/video/itemfeed';
	class Configuration$4 {
	    constructor(apiSource, serviceUrl, apiKey, networkSortOrder) {
	        if (apiSource === ApiSource$7.graphQL) {
	            this.serviceUrl = serviceUrl || defaultGraphQLServiceUrl$3;
	            this.apiKey = apiKey || defaultGraphQLApiKey$3;
	            this.networkSortOrder = networkSortOrder || defaultGraphQLNetworkSortOrder$3;
	        }
	        else if (apiSource === ApiSource$7.cfa) {
	            this.apiSource = apiSource;
	            this.serviceUrl = serviceUrl;
	        }
	        else if (apiSource === ApiSource$7.itemFeed) {
	            this.serviceUrl = serviceUrl || defaultItemFeedServiceUrl$3;
	        }
	    }
	}

	new Configuration$4(ApiSource$7.graphQL);

	Object.freeze({});
	Object.freeze({});
	ApiSource$7.itemFeed;

	new Configuration$4(ApiSource$7.itemFeed);

	class MetadataCollector {
	    constructor(player, options) {
	        this.player = player;
	        this.options = options;
	        this.updatedBitrate_ = 0;
	        if (player) {
	            this.playerAdaptor_ = this.getPlayerAdaptor_();
	        }
	    }
	    get mediaItem_() {
	        const { playbackMediaItem } = this.options;
	        return playbackMediaItem;
	    }
	    get customTracking_() {
	        const { tracking: { conviva: { custom = {} } = {} } = {} } = this.mediaItem_;
	        return custom;
	    }
	    get authProvider_() {
	        const { authorization: { authenticatedProvider = {} } = {} } = this.options;
	        return authenticatedProvider;
	    }
	    get videoResolution() {
	        var _a;
	        if (!this.player || typeof ((_a = this.player) === null || _a === void 0 ? void 0 : _a.currentDimensions) !== 'function') {
	            return 'NA';
	        }
	        const { height, width } = this.player.currentDimensions();
	        return height && width ? `${Math.round(width)}x${Math.round(height)}` : 'NA';
	    }
	    get assetName() {
	        let trackName = null;
	        if (this.mediaItem_) {
	            const { id, title, tracking: { conviva: { assetName, custom: { network = {}, assetType = null } = {} } = {} } = {}, } = this.mediaItem_;
	            trackName = assetName;
	            if (!trackName) {
	                const linearNetworkWithId = network && network.id && network.type === 'linear';
	                if (linearNetworkWithId && assetType === 'live') {
	                    trackName = network.id;
	                }
	                else {
	                    trackName = `${title} - ${id}`;
	                }
	            }
	        }
	        return trackName;
	    }
	    get isLive() {
	        const { streamType } = this.mediaItem_;
	        const isLive = streamType === 'live';
	        return isLive ? MetadataCollector.Constants.StreamType.LIVE : MetadataCollector.Constants.StreamType.VOD;
	    }
	    get streamSrc() {
	        var _a;
	        return typeof ((_a = this.player) === null || _a === void 0 ? void 0 : _a.currentSrc) === 'function' ? this.player.currentSrc() : 'NA';
	    }
	    get locationData_() {
	        const { location: { hostname = '', href = '' } = {} } = window || {};
	        return {
	            hostname,
	            href,
	        };
	    }
	    get site() {
	        return this.locationData_.hostname;
	    }
	    get page() {
	        return this.locationData_.href;
	    }
	    get sport() {
	        return this.customTracking_.sport || 'NA';
	    }
	    get league() {
	        return this.customTracking_.league || 'NA';
	    }
	    get eventId() {
	        return this.customTracking_.contentId || this.mediaItem_.id;
	    }
	    get eventName() {
	        return this.customTracking_.eventName || this.mediaItem_.title;
	    }
	    get eventType() {
	        return this.customTracking_.eventType || 'NA';
	    }
	    get appBrand() {
	        return this.options.brand || 'NA';
	    }
	    get mediaType() {
	        return this.options.type;
	    }
	    get applicationVersion() {
	        return this.options.platformVersion;
	    }
	    get startType() {
	        return this.options.startType;
	    }
	    get drmProtectionType() {
	        return this.options.drmProtectionType || this.customTracking_.drmProtectionType || 'NA';
	    }
	    get streamProtocol() {
	        return this.options.streamProtocol;
	    }
	    get viewerId() {
	        return this.options.fanSWID || 'NA';
	    }
	    get playerName() {
	        return this.options.playerName;
	    }
	    get frameworkName() {
	        return 'Video JS';
	    }
	    get frameworkVersion() {
	        return this.options.frameworkVersion;
	    }
	    get moduleName() {
	        return 'QOE';
	    }
	    get errorMessage() {
	        const error = this.player.error() || { code: 'unknown', message: 'unknown' };
	        return `code:${error.code} ${error.type && error.type !== error.code ? error.type : error.headline || error.message}`;
	    }
	    get resource() {
	        return this.streamSrc;
	    }
	    get connectionType() {
	        const _nav = navigator;
	        const connection = _nav.connection || _nav.mozConnection || _nav.webkitConnection;
	        if (connection) {
	            return connection.effectiveType;
	        }
	        return 'NA';
	    }
	    get channel() {
	        return this.customTracking_.channel || 'NA';
	    }
	    get seriesName() {
	        return this.customTracking_.seriesName || 'NA';
	    }
	    get seasonNumber() {
	        return this.customTracking_.seasonNumber || this.mediaItem_.seasonNumber || 'NA';
	    }
	    get genre() {
	        var _a;
	        return ((_a = this.customTracking_) === null || _a === void 0 ? void 0 : _a.genre) || this.mediaItem_.videoShowGenre || 'NA';
	    }
	    get episodeNumber() {
	        var _a;
	        return ((_a = this.customTracking_) === null || _a === void 0 ? void 0 : _a.episodeNumber) || this.mediaItem_.episodeNumber || 'NA';
	    }
	    get contentCategory() {
	        var _a;
	        return ((_a = this.customTracking_) === null || _a === void 0 ? void 0 : _a.contentCategory) || 'NA';
	    }
	    get assetProviderName() {
	        return this.customTracking_.assetProviderName || 'NA';
	    }
	    get authenticationType() {
	        const [authenticationType = 'NA'] = this.mediaItem_.authenticationTypes;
	        return authenticationType;
	    }
	    get accessType() {
	        return this.customTracking_.accessType || 'NA';
	    }
	    get pccId() {
	        return this.customTracking_.pccId || 'NA';
	    }
	    get partnerSDK() {
	        return this.authProvider_.id || 'NA';
	    }
	    get cdnName() {
	        return this.customTracking_.cdnName || 'NA';
	    }
	    get cdnResourceLocation() {
	        return this.customTracking_.cdnLocation || 'NA';
	    }
	    get frameRate() {
	        if (!this.player) {
	            return null;
	        }
	        if (!this.player.vhs || !this.player.vhs.playlists || typeof this.player.vhs.media !== 'function') {
	            return 'NA';
	        }
	        const media = this.player.vhs.media() || {};
	        const { attributes: { 'FRAME-RATE': frameRate = 'NA' } = {} } = media;
	        return frameRate;
	    }
	    get partner() {
	        var _a;
	        if ((_a = this.customTracking_) === null || _a === void 0 ? void 0 : _a.prt) {
	            return this.customTracking_.prt;
	        }
	        return this.getBrandMappingPartner_();
	    }
	    get bitrate() {
	        this.playerAdaptor_ = this.playerAdaptor_ || this.getPlayerAdaptor_();
	        const { type } = this.playerAdaptor_ || {};
	        switch (type) {
	            case Constants.PlaybackPlayerType.SHAKA_PLAYER:
	                return this.getBitrateFromShakaPlayer_();
	            case Constants.PlaybackPlayerType.DASH_MEDIA_PLAYER:
	                return this.getBitrateFromDashMediaPlayer_();
	            case Constants.PlaybackPlayerType.VIDEO_JS_VHS:
	                return this.getBitrateFromVideoJSVhs_();
	            default:
	                return 0;
	        }
	    }
	    get updatedBitrate() {
	        return this.updatedBitrate_;
	    }
	    set updatedBitrate(v) {
	        this.updatedBitrate_ = v;
	    }
	    getBrandMappingPartner_() {
	        var _a;
	        if (!((_a = this.mediaItem_) === null || _a === void 0 ? void 0 : _a.brand)) {
	            return 'NA';
	        }
	        let prt = Constants.PartnerType.DMED;
	        if (this.isESPNTVE_()) {
	            prt = Constants.PartnerType.ESPN_TVE;
	        }
	        else if (this.isESPN_()) {
	            prt = Constants.PartnerType.ESPN_COM;
	        }
	        return prt;
	    }
	    isESPNTVE_() {
	        var _a, _b;
	        return ((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.authorization) === null || _b === void 0 ? void 0 : _b.authenticationType) === MediaItemAuthenticationType$7.mvpd && this.isESPN_();
	    }
	    isESPN_() {
	        var _a;
	        const brand = typeof ((_a = this.mediaItem_) === null || _a === void 0 ? void 0 : _a.brand) === 'string' && this.mediaItem_.brand.toLowerCase();
	        return brand === 'espn' || brand === 'secsports' || brand === 'cricinfo';
	    }
	    getPlayerAdaptor_() {
	        var _a, _b, _c, _d, _e, _f;
	        if ((_b = (_a = this.player) === null || _a === void 0 ? void 0 : _a.dash) === null || _b === void 0 ? void 0 : _b.shakaPlayer) {
	        .SHAKA_PLAYER,
	                player: this.player.dash.shakaPlayer,
	            };
	        }
	        if ((_d = (_c = this.player) === null || _c === void 0 ? void 0 : _c.dash) === null || _d === void 0 ? void 0 : _d.mediaPlayer) {
	            return {
	                type: Constants.PlaybackPlayerType.DASH_MEDIA_PLAYER,
	                player: this.player.dash.mediaPlayer,
	            };
	        }
	        if ((_e = this.player) === null || _e === void 0 ? void 0 : _e.vhs) {
	            return {
	                type: Constants.PlaybackPlayerType.VIDEO_JS_VHS,
	                player: (_f = this.player) === null || _f === void 0 ? void 0 : _f.vhs,
	            };
	        }
	        return null;
	    }
	    getBitrateFromShakaPlayer_() {
	        const player = this.playerAdaptor_.player;
	        const playerStats = typeof (player === null || player === void 0 ? void 0 : player.getStats) === 'function' && player.getStats();
	        const streamBandwidth = (playerStats === null || playerStats === void 0 ? void 0 : playerStats.streamBandwidth) && Math.round(playerStats.streamBandwidth / 1000);
	        if (streamBandwidth && this.updatedBitrate !== streamBandwidth) {
	            this.updatedBitrate = streamBandwidth;
	            return streamBandwidth;
diaPlayer_() {
	        const player = this.playerAdaptor_.player;
	        if (typeof (player === null || player === void 0 ? void 0 : player.getQualityFor) !== 'function' && typeof (player === null || player === void 0 ? void 0 : player.g            return 0;
	        }
	        const playerlistIndex = player.getQualit     videoBitrate = media.attributes.BANDWIDTH;
	            }
	            const audioBitrate = this.getAudioBitrate_(playlists, media);
	            const totalBitrate = Math.round((videoBitrate + audioBitrate) / 1000);
	            if (this.updatedBitrate !== totalBitrate) {
	                this.updatedBitrate = totalBitrate;
	                return totalBitrate;
	            }
	        }
	        return 0;
	    }
	    getAudioBitrate_(playlists, media) {
	        var _a;
	        let activeAudioTrack = null;
	        let audioBitrate = 0;
	        const audioTracks = typeof ((_a = this.player) === null || _a === void 0 ? void 0 : _a.audioTracks) === 'function' && this.player.audioTracks();
	        if (audioTracks && (audioTracks === null || audioTracks === void 0 ? void 0 : audioTracks.length)) {
	            for (let i = 0; i < audioTracks.length; i++) {
	                const audioTrack = audioTracks[i];
	                if (audioTrack.enabled) {
	                    activeAudioTrack = audioTrack;
	                    breiveAudioTrack && media.attributes.AUDIO) {
	            if (playlists && playlists.master && playlists.master.mediaGroups && playlists.master.mediaGroups.AUDIO) {
	                const audioPlaylistsForMedia = playlists.master.mediaGroups.AUDIO[media.attributes.AUDIO];
	                if (audioPlaylistsForMedia) {
	                    const audioPlaylist = audioPlaylistsForMedia[activeAudioTrack.id];
	                    if (aus[0].attributes;
	                        if (audioTrackAttributes && audioTrackAttributes.BANDWIDTH) {
	                            audioBitrate = audioTrackAttributes.BANDWIDTH;
	                        }
	                    }
	                }
	            }
	        }
	        return audioBitrate;
	    }
	    updateOptions(options) {
	        this.options = options;
	    }
	    aggregateContentInfo() {
	        var _a;
	        const contentInfo = {
	            [Constants.START_TYPE]: this.startType,
	            [Constants.DRM_PROTECTION_TYPE]: this.drmProtectionType,
	            [Constants.STREAM_PROTOCOL]: this.streamProtocol,
	            [Constants.SPORT]: this.sport,
	            [Constants.LEAGUE]: this.league,
	            [Constants.EVENT_ID]: this.eventId,
	            [Constants.EVENT_NAME]: this.eventName,
	            [Constants.EVENT_TYPE]: this.eventType,
	            [Constants.APP_BRAND]: this.appBrand,
	            [Constants.MEDIA_TYPE]: this.mediaType,
	            [Constants.APPLICATION_VERSION]: this.applicationVersion,
	            [Constants.VIEWER_ID]: this.viewerId,
	            [Constants.ASSET_NAME]: this.assetName,
	            [Constants.VIDEO_RESOLUTION]: this.videoResolution,
	            [Constants.PLAYER_NAME]: this.playerName,
	            [Constants.STREAM_URL]: this.streamSrc,
	            [Constants.IS_LIVE]: this.isLive,
	            [Constants.SITE]: this.site,
	            [Constants.PAGE]: this.page,
	            [Constants.CONNECTION_TYPE]: this.connectionType,
	            [Constants.RESOURCE]: this.resource,
	            [Constants.ACCESS_TYPE]: this.accessType,
	            [Constants.CDN_RESOURCE_LOCATION]: this.cdnResourceLocation,
	            [Constants.CDN_NAME]: this.cdnName,
	            [Constants.PARTNER]: this.partner,
	            [Constants.PARTNER_SDK]: this.partnerSDK,
	            [Constants.PCCID]: this.pccId,
	            [Constants.SERIES_NAME]: this.seriesName,
	            [Constants.SEASON_NUMBER]: this.seasonNumber,
	            [Constants.GENRE]: this.genre,
	            [Constants.EPISODE_NUMBER]: this.episodeNumber,
	            [Constants.CONTENT_CATEGORY]: this.contentCategory,
	            [Constants.ASSET_PROVIDER_NAME]: this.assetProviderName,
	            'c3.cm.channel': this.channel,
	            'c3.cm.categoryType': this.contentCategory,
	            'c3.cm.seriesName': this.seriesName,
	        };
	        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.DEBUG) {
	            console.debug('QOE ContentInfo:  ', contentInfo);
	        }
	        return contentInfo;
	    }
	}
	MetadataCollector.Constants = {
	    StreamType: {
	        LIVE: 'live',
	        VOD: 'vod',
	    },
	};

	class QoeInitWatcher {
	  static onInit(coordinator, combinedConfig) {
	    const {
	      enableQoe,
	      autoplay
	    } = combinedConfig;

	    /**
	     * The most of QOE code is placed in qoe-plugin
	     * Some clients use .load(autoplay=true) to start playback and not to
	     * load the player without user interaction. To have a full time reported from
	     * starting playback until playback
	     */
	    if (enableQoe) {
	      coordinator.coordinate('dtci.qoe', {
	        type: 'init'
	      });
	      if (autoplay) {
	        const collector = new MetadataCollector(null, {
	          playbackMediaItem: combinedConfig.mediaItem || {}
	        });
	        coordinator.coordinate('dtci.qoe', {
	          type: 'play',
	          data: collector.aggregateContentInfo()
	        });
	      }
	    }
	  }
	}

	var defaultConfig = {
	  chartbeat: {
	    uid: '22222',
	    domain: 'espn.com',
	    sections: null,
	    authors: null
	  },
	  comscore: {
	    clientId: '3000005',
	    labels: {
	      c3: '"*null"',
	      c4: 'MediaInfo.site',
	      c6: 'MediaInfo.comscoreC6',
	      c8: 'MediaInfo.pageTitle',
	      ns_st_pu: 'MediaInfo.publisher',
	      // publisher brand name
	      ns_st_pr: '"*null"',
	      // program title
	      ns_st_ep: 'MediaInfo.name',
	      // episode title
	      ns_st_sn: '"*null"',
	      // episode season number
	      ns_st_en: '"*null"',
	      // episode number
	      ns_st_st: '"*null"',
	      // station title
	      ns_st_ge: '"sports"',
	      // content genre
	      ns_st_ti: '"*null"',
	      // TMS/Gracenote ID
	      ns_st_ia: '"*null"',
	      // ad load flag (Boolean, present means true) will be true for ESPN1 & ESPN2
	      ns_st_ce: '"*null"',
	      // complete episode flag
	      ns_st_ddt: '"*null"',
	      // digital airdate
	      ns_st_tdt: '"*null"',
	      // TV airdate
	      ns_st_ct: 'MediaInfo.comscoreContentType' // content type, see DTCIMMP-438
	    }
	  },

	  qoe: {
	    playerName: 'Unified Player Web',
	    DEBUG: false
	  },
	  conviva: {
	    customerKey: 'eec329720efa1110d60c5a6d01a65baf032de653',
	    playerName: 'Unified Player Web',
	    DEBUG: false

	    /*
	      Plugin: Brightcove Perform Player (HTML5 1st/Flash Fallback) [c3.ESPN]
	      Documentation:	Conviva Community: Integrate: Plugins: Brightcove Perform Player
	      Production CUSTOMER_KEY:	766ee8daa5d5deaeeeab4481239072ea53f6f1cc
	      Test CUSTOMER_KEY:	4ef48c3f3b0803661e860a61b35963306389af7e
	       Plugin: Brightcove Perform Player (HTML5 1st/Flash Fallback) [c3.ESPN-com]
	      Documentation:	Conviva Community: Integrate: Plugins: Brightcove Perform Player
	      Production CUSTOMER_KEY:	fc8dbfdc5da519f576628f619306a357f31bd006
	      Test CUSTOMER_KEY:	eec329720efa1110d60c5a6d01a65baf032de653
	       Plugin: Brightcove Perform Player (HTML5 1st/Flash Fallback) [c3.ESPN-Intl]
	      Documentation:	Conviva Community: Integrate: Plugins: Brightcove Perform Player
	      Production CUSTOMER_KEY:	aff0675a75497f3e066783b2c5fd614c4e4d61cd
	      Test CUSTOMER_KEY:	e685ed240475325e03bff60be2ad80b41322ac74
	       Plugin: Brightcove Perform Player (HTML5) Prod [c3.DMED], Test [c3.DMED-Test]
	      Documentation:	https://community.conviva.com/site/one-sensor/sensors/javascript/index_one_sensor.gsp
	      Production CUSTOMER_KEY:	27f19c7c68e3eadf7756fb7efdb661dd8909acf9
	      Test CUSTOMER_KEY:	6f4780f3f1c410159773174fc103819d3763406e
	     */
	  },

	  adobeDCR: {
	    VISITOR_API: {
	      MARKETING_CLOUD_ORG_ID: 'EE0201AC512D2BE80A490D4C@AdobeOrg',
	      NAMESPACE: 'espn',
	      TRACKING_SERVER: 'sw88.espn.com',
	      TRACKING_SERVER_SECURE: 'sw88.espn.com'
	    },
	    APP_MEASUREMENT: {
	      RSID: 'wdgespredesign',
	      TRACKING_SERVER: 'sw88.espn.com',
	      TRACKING_SERVER_SECURE: 'sw88.espn.com'
	    },
	    HEARTBEAT: {
	      DISABLE: false,
	      // disable if using milestone tracking
	      TRACKING_SERVER: 'espn.hb.omtrdc.net',
	      PUBLISHER: 'EE0201AC512D2BE80A490D4C@AdobeOrg',
	      OVP: 'Brightcove',
	      SDK: '2.2.0',
	      DEBUG_LOGGING: false // sitecatalyst-specific logging - set to false for production
	    },

	    QUALITY: {
	      TIME_TO_START: 0
	    },
	    CUSTOM_EVENT: {
	      disable: true,
	      // disable if using heartbeat tracking
	      bc_data_mapping: {
	        name: 'eVar106,prop2',
	        // video name, accepts multiple eVars/props
	        segment: 'eVar203',
	        // current milestone (e.g., '1:M:0-25')
	        contentType: 'eVar201',
	        // content type (e.g., 'video' or 'ad')
	        timePlayed: 'event203',
	        // amount of time played since last tracking event, tracked with milestone events
	        view: 'event201',
	        // video start event
	        segmentView: 'event202',
	        // general milestone tracking event, tracked with milestone events
	        complete: 'event207',
	        // video complete event
	        milestones: {
	          // milestones in percent; milestones can be added/removed from list
	          25: 'event204',
	          // 25%
	          50: 'event205',
	          // 50%
	          75: 'event206' // 75%
	        }
	      },

	      // keep to track volume change events
	      bc_volumechange: {
	        event: 'event208',
	        // event tracking number
	        evar: 'prop1' // the new volume chosen by the user (from 0-1.00), only one prop/eVar supported here
	      },

	      // keep to track when user has paused an ad
	      bc_ad_pause: {
	        event: 'event209',
	        // event tracking number
	        evar: 'eVar205' // time value of pausing an ad, only one prop/eVar supported here
	      },

	      // keep to track when user enters full screen mode
	      bc_fullscreen_enter: {
	        event: 'event212' // event tracking number
	      },

	      // keep to track when user exits full screen mode
	      bc_fullscreen_exit: {
	        event: 'event213' // event tracking number
	      },

	      // keep to track when user opens social share menu
	      bc_social_opened: {
	        event: 'event214' // event tracking number
	      },

	      // keep to track when user closes social share menu
	      bc_social_closed: {
	        event: 'event215' // event tracking number
	      }
	    },

	    NIELSEN_DATA: {
	      /** ESPN TO CONFIGURE NIELSEN APPLICATION DATA * */
	      APP_INFO: {
	        clientId: 'us-600140-test',
	        vcid: 'b01',
	        apid: 'T31187EE2-AC6E-46CB-BB54-D07591BED067',
	        appName: 'BasicPlayerSample',
	        sfcode: 'dcr',
	        nol_sdkDebug: 'console',
	        nsdkv: '511'
	      },
	      CONFIG_KEY: '922e1d53d3e10abdde5cbea1b55459f5bacc65d4/55ba372b3336330017000bbf',
	      CONTENT_METADATA: {
	        type: 'content',
	        program: '',
	        segB: '',
	        segC: 'Sport/Program Code',
	        isfullepisode: '',
	        adloadtype: 2,
	        airdate: '',
	        dataSrc: 'CMS',
	        tv: false,
	        crossId2: 'ESPN',
	        assetid: '',
	        category: ''
	      },
	      AD_METADATA: []
	    },
	    ESPN_CUSTOM_METADATA: {},
	    MEDIAINFO: {},
	    DEBUG: false
	  },
	  nativeOmniture: {
	    trackingServer: 'sw88.espn.com',
	    reportSuites: 'wdgespcom,wdgespge',
	    secure: true,
	    site: 'espn'
	  }
	};

	// eslint-disable-next-line consistent-return
	function mergeCustomizer$1(objValue, srcValue) {
	  if (srcValue === null) {
	    return objValue;
	  }
	}
	class Analytics {
	  constructor() {
	    this.config_ = null;
	    this.convivaC3DMedAccounts_ = ['27f19c7c68e3eadf7756fb7efdb661dd8909acf9', '6f4780f3f1c410159773174fc103819d3763406e'];
	    this.defaultConfig_ = defaultConfig;
	    this.config_ = defaultConfig;
	  }
	  set config(obj) {
	    this.config_ = lodash_mergewith(defaultConfig, obj, mergeCustomizer$1);
	    return this.config_;
	  }
	  get config() {
	    return this.config_;
	  }
	  get isConvivaC3DMEDAccount() {
	    const {
	      conviva: {
	        customerKey
	      } = {}
	    } = this.config;
	    return this.convivaC3DMedAccounts_.indexOf(customerKey) !== -1;
	  }
	  chartbeat(options) {
	    if (options) {
	      return lodash_mergewith(this.config.chartbeat, options, mergeCustomizer$1);
	    }
	    return this.config.chartbeat;
	  }

	  /*
	    The comScore plugin for Brightcove pulls all of it's data from the
	    `mediainfo` property. Configuration here consists of "mapping" labels to
	    respective keys of the `mediainfo` object. Most of the mapping is done
	 re is manual overrides.
	     The plugin requires those keys be prefixed with `MediaInfo`.
	     If you need to provide a literal string, it needs to be double-quoted:
	        c3: '"*null"'
	   */
	  comscore(options) {
	    if (options) {
	      if (options.c2 || options.clientId) {
	        this.config.comscore.clientId = options.c2 || options.clientId;
	      }
	      if (options.labels) {
	        this.config.comscore.labels = lodash_mergewith(this.config.comscore.labels, options.labels);
	      }
	    }
	    const labelmap = [];
	    const ref = this.config.comscore.labels;
	    entries(ref).forEach(item => {
	      labelmap.push(`${item[0]}=${item[1]}`);
	    });
	    return {
	      c2: this.config.comscore.clientId,
	      labelmapping: labelmap.join(',')
	    };
	  }
	  conviva(options) {
	    if (options) {
	      lodash_mergewith(this.config.conviva, options, mergeCustomizer$1);
	    }
	    this.config.conviva.fanSWID = new Fan().SWID || null;
	    this.config.conviva.bundleVersion = "5.3.16";
	    return this.config.conviva;
	  }
	  qoe(options) {
	    if (options) {
	      lodash_mergewith(this.config.qoe, options, merg.config.qoe.fanSWID = new Fan().SWID || null;
	    return this.conftions) {
	      lodash_mergewith(this.config.adobeDCR, options, config.adoe
	  nativgeCustomizer$1);
	    }
	    return this.config.nativeOmniture;
	  }
	}

	/* esliar stringU{
	    if     }
	    return s.toString().length === 1 ? padValue + s : s;
	  }
     return (n < 10 ? '0' : '') + n;
	    }
	    let offset = new Date().getTimezoneOffset();
	    const sign = offset < 0 ? '+' : '-';
	    offset = Math.abs(offset);
	    return sign + z(offset / 60 | 0) + z(offset % 60);
	  }
	  function date2String(date, format) {
	    const p = input =>mat.replace(/dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?/g, format => {
	      switch (format) {
	        case 'hh':
	       .getHours(date.getHours() < 13 ? date.getHours() : date.getHours() - 12;
	        case 'HH':
	          return p(date.getHours());
	        case 'H':
	          return date.getHours();
	        case 'mm':
	          return p(date.getMinutes());
	        case 'm':
	          return date.getMinutes();
	        case 'ss':
	          return p(date.getSeconds());
	        case 's':
	          return date.getSeconds();
y':
	     etDate());     return p(date.getMonth() + 1);
	        case 'M':
	          return date.getMonth() + 1;
	        case 't':
	          return date.getHours() < 12 ? 'A' : 'P';
	        case 'tt':
	          return date.getHours() < 12 ? 'AM' : 'PM';
	       '';
	      }
	    });
	  }
	  return {
	    leadPadding,
	    date2String,
	    timezone2Offset
	  };
 {
	      appversion: plutoAppVersion || '7.0.0'
	    }
	  }).then(response => response.json());
	}

	/// Default values call endcard layout
	async function fetchPluto(playLoad) {
	  try {
	    const {
	      plutoAppVersion,
	      siteBrandId,
	      playlistId = '-1',
	      id,
	      env = 'prod',
	      layout = 'endcard',
	      moduleName = 'tilegroup',
	      customParams = {}
	    } = playLoad;
	    const plutoApi = `https://${env}.gatekeeper.us-abc.symphony.edgedatg.com/api/ws/pluto/v1/layout?authlevel=1&brand=${siteBrandId}&device=001&playlist=${playlistId || '-1'}&type=${layout}&video=${id}`;
	    return fetchLayout(plutoApi, plutoAppVersion).then(layout => {
	      var _context;
	      const layoutModule = filter(_context = layout.modules).call(_context, module => {
	        return module.type === moduleName;
	      })[0];
	      if (layoutModule && layoutModule.resource) {
	        let plutoEndpoint = layoutModule.resource;
	        const customParamsKeys = keys(customParams);
	        map(customParamsKeys).call(customParamsKeys, key => {
	          co          plutoEndpoint = plutoEndpoint.replace(`{${key}}`, paramValue);
	          return key;
	        });
	        return fetchLayout(plutoEndpoint).then(tiles => {
	          const nextContent = tiles && tiles.tiles ? tiles.tiles[0] : tiles;
	          return promise.resolve(nextContent);
	        });
	      }
	      return promise.reject(new Error('NO RESOURCE FOUND'));
	    });
	  } catch (err) {
	    console.error(`Get media items error: ${err}`);
	    return null;
	  }
	}

	class LiveAnalyticsWatcher {
	  constructor(player, coordinator, plutoAppVersion) {
	    this.player_ = player;
	    this.coordinator_ = coordinator;
	    this.onScheduleChange_ = this.onScheduleChange_.bind(this);
	    this.plutoAppVersion_ = plutoAppVersion;
	  }
	  dispose() {
	    if (this.videoEndTimer) {
	      window.clearTimeout(this.videoEndTimer);
	    }
	    this.player_ = null;
	    this.coordinator_ = null;
	  }
	  async getScheduleData() {
	    if (this.player_.mediaItem.streamType === 'live' && this.player_.mediaItem.source.type === 'entitlement') {
	      const scheduleData = await this.getScheduleDataFromPluto(this.player_.mediaItem, this.plutoAppVersion_);
	      return scheduleData;
	    }
	    return null;
	  }
	  trackScheduleShows() {
	    // If is live it will reload t      mediainfo = {}
	    } = this.player_;
	    if (mediainfo !== null && mediainfo !== void 0 && mediainfo.scheduleData) {
	      var _mediainfo$scheduleDa, _mediainfo$scheduleDa2;
	      const currentVideo = mediainfo === null || mediainfo === void 0 ? void 0 : (_mediainfo$scheduleDa = mediainfo.scheduleData) === null || _mediainfo$scheduleDa === void 0 ? void 0 : (_mediainfo$scheduleDa2 = _mediainfo$scheduleDa.videos) === null || _mediainfo$scheduleDa2 === void 0 ? void 0 : _mediainfo$scheduleDa2[0];
	      if (currentVideo !== null && currentVideo !== void 0 && currentVideo.airtime) {
	        const now = new Date();
	        const currentVideoStartTime = new Date(currentVideo === null || currentVideo === void 0 ? void 0 : currentVideo.airtime);
	        const nextVideoAfter = currentVideoStartTime.getTime() + currentVideo.duration - now.getTime();
	        //  allow one second (+1000 below) padding for next program boundary
	        if (this.videoEndTimer) {
	          window.clearTimeout(this.videoEndTimer);
	        }
	        this.videoEndTimer = setTimeout(this.onScheduleChange_, nextVideoAfter + 1000);
	      }
	    }
	  }
	  async getScheduleDataFromPluto(mediaItem, plutoAppVersion) {
	    var _mediaItem$network;
	    const currentDate = new Date();
	    const starttime = stringUtils().date2String(currentDate, 'yyyyMMdd-HHmm');
	    const endDate = new Date();
	    endDate.setHours(endDate.getHours() + 12);
	    const endtime = stringUtils().date2String(endDate, 'yyyyMMdd-HHmm');
	    const offset = stringUtils().timezone2Offset();
	    const plutoPayload = {
	      plutoAppVersion,
	      brand: mediaItem.brand,
	      siteBrandId: mediaItem.siteBrandId,
	      id: mediaItem.id,
	      layout: 'live_player',
	      moduleName: 'schedule',
	      customParams: {
	        starttime,
	        endtime,
	        offset,
	        affiliate: mediaItem !== null && mediaItem !== void 0 && (_mediaItem$network = mediaItem.network) !== null && _mediaItem$network !== void 0 && _mediaItem$network.affiliate ? mediaItem.network.affiliate : '-1'
	      }
	    };
	    return fetchPluto(plutoPayload).then(data => {
	      return data;
	    }).catch(error => {
	      console.error('Error retrieving schedule data', error);
	      return error;
	    });
	  }
	  async onScheduleChange_() {
	    this.coordinator_.coordinate('dtci.programChange', this.player_.mediaItem);
	    const scheduleData = await this.getScheduleData();
	    this.player_.mediainfo.scheduleData = scheduleData;
	    this.trackScheduleShows();
	  }
	}

	var timezone = createCommonjsModule(function (module) {
	!function (definition) {
	  if (module.exports) module.exports = definition();
	  else this.tz = definition();
	} (function () {
	/*
	  function die () {
	    console.log.apply(console, __slice.call(arguments, 0));
	    return process.exit(1);
	  }

	  function say () { return console.log.apply(console, __slice.call(arguments, 0)) }
	*/
	  function actualize (entry, rule, year) {
	    var actualized, date = rule.da (rule.day[0] < 7 && actualized.getUTCDay() != rule.day[0])

	    actualized = {
	      clock: rule.clock,
	      sort: actualized.getTime(),
	      rule: rule,
	      save: rule.save * 6e4,
	      offset: entry.offset
	    };

	    actualized[actualized.clock] = actualized.sort + rule.time * 6e4;

	    if (actualized.posix) {
	      actualized.wallclock = actualized[actualized.clock] + (entry.offset + rule.saved);
	    } else {
	      actualized.posix = actualized[actualized.clock] - (entry.offset + rule.saved);
	    }

	    return actualized;
	  }

	  function find (request, clock, time) {
	    var i, I, entry, found, zone = request[request.zone], actualized = [], abbrev, rules
	      , j, year = new Date(time).getUTCFullYear(), off = 1;
	    for (i = 1, I = zone.length; i < I; i++) if (zone[i][clock] <= time) break;
	    entry = zone[i];
	    if (entry.rules) {
	      rules = request[entry.rules];
	      for (j = year + 1; j >= year - off; --j)
	        for (i = 0, I = rules.length; i < I; i++)
	          if (rules[i].from <= j && j <= rules[i].to) actualized.push(actualize(entry, rules[i], j));
	          else if (rules[i].to < j && off == 1) off = j - rules[i].to;
	      actualized.sort(function (a, b) { return a.sort - b.sort });
	      for (i = 0, I = actualized.length; i < I; i++) {
	        if (time >= actualized[i][clock] && actualized[i][actualized[i].clock] > entry[actualized[i].clock]) found = actualized[i];
	      }
	    }
	    if (found) {
	      if (abbrev = /^(.*)\/(.*)$/.exec(entry.format)) {
	        found.abbrev = abbrev[found.save ? 2 : 1];
	      } else {
	        found.abbrev = entry.format.replace(/%s/, found.rule.letter);
	      }
	    }
	    return found || entry;
	  }

	  function convertToWallclock (request, posix) {
	    if (request.zone == "UTC") return posix;
	    request.entry = find(request, "posix", posix);
	    return posix + request.entry.offset + request.entry.save;
	  }

	  function convertToPOSIX (request, wallclock) {
	    if (request.zone == "UTC") return wallclock;

	    var entry, diff;
	    request.entry = entry = find(request, "wallclock", wallclock);
	    diff = wallclock - entry.wallclock;

	    return 0 < diff && diff < entry.save ? null : wallclock - entry.offset - entry.save;
	  }

	  function adjust (request, posix, match) {
	    var increment = +(match[1] + 1) // conversion necessary for week day addition
	      , offset = match[2] * increment
	      , index = UNITS.indexOf(match[3].toLowerCase())
	      , date
	      ;
	    if (index > 9) {
	      posix += offset * TIME[index - 10];
	    } else {
	      date = new Date(convertToWallclock(request, posix));
	      if (index < 7) {
	        while (offset) {
	          date.setUTCDate(date.getUTCDate() + increment);
	          if (date.getUTCDay() == index) offset -= increment;
	        }
	      } else if (index == 7) {
	        date.setUTCFullYear(date.getUTCFullYear() + offset);
	      } else if (index == 8) {
	        date.setUTCMonth(date.getUTCMonth() + offset);
	      } else {
	        date.setUTCDate(date.getUTCDate() + offset);
	      }
	      if ((posix = convertToPOSIX(request, date.getTime())) == null) {
	        posix = convertToPOSIX(request, date.getTime() + 864e5 * increment) - 864e5 * increment;
	      }
	    }
	    return posix;
	  }

	  function convert (vargs) {
	    if (!vargs.length) return "1.0.23";

	    var request = Object.create(this)
	      , adjustments = []
	      , i, I, $, argument, date
	      ;

	    for (i = 0; i < vargs.length; i++) { // leave the for loop alone, it works.
	      argument = vargs[i];
	      // https://twitter.com/bigeasy/status/215112186572439552
	      if (Array.isArray(argument)) {
	        if (!i && !isNaN(argument[1])) {
	          date = argument;
	        } else {
	          argument.splice.apply(vargs, [ i--, 1 ].concat(argument));at = argument;
	          } else if (!i && argument == "*") {
	            date = argument;
	          } else if (!i && ($ = /^(\d{4})-(\d{2})-(\d{2})(?:[T\s](\d{2}):(\d{2})(?::(\d{2})(?:\.(\d+))?)?(Z|(([+-])(\d{2}(:\d{2}){0,2})))?)?$/.exec(argument))) {
	            date = [];
	            date.push.apply(date, $.slice(1, 8));
	            if ($[9]) {
	              date.push($[10] + 1);
	              date.push.apply(date, $[11].split(/:/));
	            } else if ($[8]) {
	              date.push(1);
	            }
	          } else if (/^\w{2,3}_\w{2}$/.test(argument)) {
	            request.locale = argument;
	          } else if ($ = UNIT_RE.exec(argument)) {
	            adjustments.push($);
	          } else {
	            request.zone = argument;
	          }
	        } else ifent.call(request)) return $;
	        } else if (/^\w{2,3}_\w{2}$/.test(argument.name)) {
	          request[argument.name] = argument;
	        } else if (argument.zones) {
	          for ($ in argument.zones) request[$] = argument.zones[$];
	          for ($ in argument.rules) request[$] = argument.rules[$];
	        }
	      } else if (!i) {
	        date = argument;
	      }
	    }

	    if (!request[request.locale]) delete request.locale;
	    if (!request[request.zone]) delete request.zone;

	    if (date != null) {
	      if (date == "*") {
	        date = request.clock();
	      } else if (Array.isArray(date)) {
	        $ = [];
	        I = !date[7];
	        for (i = 0; i < 11; i++) $[i] = +(date[i] || 0); // conversion necessary for decrement
	        --$[1]; // Grr..
	        date = Date.UTC.apply(Date.UTC, $) + -$[7] * ($[8] * 36e5 + $[9] * 6e4 + $[10] * 1e3);
	      } else {
	        date = Math.floor(date);
	      }
	      if (!isNaN(date)) {
	        if (I) date = convertToPOSIX(request, date);

	        if (date == null) return date;

	        for (i = 0, I = adjustments.length; i < I; i++) {
	          date = adjust(request, date, adjustments[i]);
	        }

	        if (!request.format) return date;

	        $ = new Date(convertToWallclock(request, date));
	        return request.format.replace(/%([-0_^]?)(:{0,3})(\d*)(.)/g,
	        function (value, flag, colons, padding, specifier) {
	          var f, fill = "0", pad;
	          if (f = request[specifier]) {
	            value = String(f.call(request, $, date, flag, colons.length));
	            if ((flag || f.style) == "_") fill = " ";
	            pad = flag == "-" ? 0 : f.pad || 0;
	            while (value.length < pad) value = fill + value;
	            pad = flag == "-" ? 0 : padding || f.pad;
	            while (value.length < pad) value = fill + value;
	            if (specifier == "N" && pad < value.length) value = value.slice(0, pad);
	            if (flag == "^") value = value.toUpperCase();
	          }
	          return value;
	        });
	      }
	    }

	    return function () { return request.convert(arguments) };
	  }

	  var context =
	    { clock: function () { return +(new Date()) }
	    , zone: "UTC"
	    , entry: { abbrev: "UTC", offset: 0, save: 0 }
	    , UTC: 1
	    , z: function(date, posix, flag, delimiters) {
	        var offset = this.entry.offset + this.entry.save
	          , seconds = Math.abs(offset / 1000), parts = [], part = 3600, i, z;
	        for (i = 0; i < 3; i++) {
	          parts.push(("0" + Math.floor(seconds / part)).slice(-2));
	          seconds %= part;
	          part /= 60;
	        }
	        if (flag == "^" && !offset) return "Z";
	        if (flag == "^") delimiters = 3;
	        if (delimiters == 3) {
	          z = parts.join(":");
	          z = z.replace(/:00$/, "");
	          if (flag != "^") z = z.replace(/:00$/, "");
	        } else if (delimiters) {
	          z = parts.slice(0, delimiters + 1).join(":");
	          if (flag == "^") z = z.replace(/:00$/, "");
	        } else {
	          z = parts.slice(0, 2).join("");
	        }
	        z = (offset < 0 ? "-" : "+") + z;
	        z = z.replace(/([-+])(0)/, { "_": " $1", "-": "$1" }[flag] || "$1$2");
	        return z;
	      }
	    , "%": function(date) { return "%" }
	    , n: function (date) { return "\n" }
	    , t: function (date) { return "\t" }
	    , U: function (date) { return weekOfYear(date, 0) }
	    , W: function (date) { return weekOfYear(date, 1) }
	    , V: function (date) { return isoWeek(date)[0] }
	    , G: function (date) { return isoWeek(date)[1] }
	    , g: function (date) { return isoWeek(date)[1] % 100 }
	    , j: function (date) { return Math.floor((date.getTime() - Date.UTC(date.getUTCFullYear(), 0)) / 864e5) + 1 }
	    , s: function (date) { return Math.floor(date.getTime() / 1000) }
	    , C: function (date) { return Math.floor(date.getUTCFullYear() / 100) }
	    , N: function (date) { return date.getTime() % 1000 * 1000000 }
	    , m: function (date) { return date.getUTCMonth() + 1 }
	    , Y: function (date) { return date.getUTCFullYear() }
	    , y: function (date) { return date.getUTCFullYear() % 100 }
	    , H: function (date) { return date.getUTCHours() }
	    , M: function (date) { return date.getUTCMinutes() }
	    , S: function (date) { return date.getUTCSeconds() }
	    , e: function (date) { return date.getUTCDate() }
	    , d: function (date) { return date.getUTCDate() }
	    , u: function (date) { return date.getUTCDay() || 7 }
	    , w: function (date) { return date.getUTCDay() }
	    , l: function (date) { return date.getUTCHours() % 12 || 12 }
	    , I: function (date) { return date.getUTCHours() % 12 || 12 }
	    , k: function (date) { return date.getUTCHours() }
	    , Z: function (date) { return this.entry.abbrev }
	    , a: function (date) { return this[this.locale].day.abbrev[date.getUTCDay()] }
	    , A: function (date) { return this[this.locale].day.full[date.getUTCDay()] }
	    , h: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }
	    , b: function (date) { return this[this.locale].month.abbrev[date.getUTCMonth()] }
	    , B: function (date) { return this[this.locale].month.full[date.getUTCMonth()] }
	    , P: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)].toLowerCase() }
	    , p: function (date) { return this[this.locale].meridiem[Math.floor(date.getUTCHours() / 12)] }
	    , R: function (date, posix) { return this.convert([ posix, "%H:%M" ]) }
	    , T: function (date, posix) { return this.convert([ posix, "%H:%M:%S" ]) }
	    , D: function (date, posix) { return this.convert([ posix, "%m/%d/%y" ]) }
	    , F: function (date, posix) { return this.convert([ posix, "%Y-%m-%d" ]) }
	    , x: function (date, posix) { return this.convert([ posix, this[this.locale].date ]) }
	    , r: function (date, posix) { return this.convert([ posix, this[this.locale].time12 || '%I:%M:%S' ]) }
	    , X: function (date, posix) { return this.convert([ posix, this[this.locale].time24 ]) }
	    , c: function (date, posix) { return this.convert([ posix, this[this.locale].dateTime ]) }
	    , convert: convert
	    , locale: "en_US"
	    , en_US: {
	        date: "%m/%d/%Y",
	        time24: "%I:%M:%S %p",
	        time12: "%I:%M:%S %p",
	        dateTime: "%a %d %b %Y %I:%M:%S %p %Z",
	        meridiem: [ "AM", "PM" ],
	        month: {
	          abbrev: "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec".split("|"),
	          full: "January|February|March|April|May|June|July|August|September|October|November|December".split("|")
	        },
	        day: {
	          abbrev: "Sun|Mon|Tue|Wed|Thu|Fri|Sat".split("|"),
	          full: "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday".split("|")
	        }
	      }
	    };
	  var UNITS = "Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|year|month|day|hour|minute|second|millisecond"
	    , UNIT_RE = new RegExp("^\\s*([+-])(\\d+)\\s+(" + UNITS + ")s?\\s*$", "i")
	    , TIME = [ 36e5, 6e4, 1e3, 1 ]
	    ;
	  UNITS = UNITS.toLowerCase().split("|");

	  "delmHMSUWVgCIky".replace(/./g, function (e) { context[e].pad = 2; });

	  context.N.pad = 9;
	  context.j.pad = 3;

	  context.k.style = "_";
	  context.l.style = "_";
	  context.e.style = "_";

	  function weekOfYear (date, startOfWeek) {
	    var diff, nyd, weekStart;
	    nyd = new Date(Date.UTC(date.getUTCFullYear(), 0));
	    diff = Math.floor((date.getTime() - nyd.getTime()) / 864e5);
	    if (nyd.getUTCDay() == startOfWeek) {
	      weekStart = 0;
	    } else {
	      weekStart = 7 - nyd.getUTCDay() + startOfWeek;
	      if (weekStart == 8) {
	        weekStart = 1;
	      }
	    }
	    return diff >= weekStart ? Math.floor((diff - weekStart) / 7) + 1 : 0;
	  }

	  function isoWeek (date) {
	    var nyd, nyy, week;
	    nyy = date.getUTCFullYear();
	    nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
	    week = weekOfYear(date, 1) + (nyd > 1 && nyd <= 4 ? 1 : 0);
	    if (!week) {
	      nyy = date.getUTCFullYear() - 1;
	      nyd = new Date(Date.UTC(nyy, 0)).getUTCDay();
	      week = nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29) ? 53 : 52;
	      return [week, date.getUTCFullYear() - 1];
	    } else if (week == 53 && !(nyd == 4 || (nyd == 3 && new Date(nyy, 1, 29).getDate() == 29))) {
	      return [1, date.getUTCFullYear() + 1];
	    } else {
	      return [week, date.getUTCFullYear()];
	    }
	  }

	  return function () { return context.convert(arguments) };
	});
	});

	var New_York={"zones":{"America/New_York":["z",{"wallclock":-94694400000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-94676400000,"save":0,"rules":"US"},{"wallclock":-757382400000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-757364400000,"save":0,"rules":"NYC"},{"wallclock":-883612800000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-883594800000,"save":0,"rules":"US"},{"wallclock":-1577923200000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-1577905200000,"save":0,"rules":"NYC"},{"wallclock":-2717668562000,"format":"E%sT","abbrev":"EST","offset":-18000000,"posix":-2717650800000,"save":0,"rules":"US"},{"wallclock":-1.7976931348623157e+308,"format":"LMT","abbrev":"LMT","offset":-17762000,"posix":-1.7976931348623157e+308,"save":0}]},"rules":{"US":[{"from":2007,"to":1.7976931348623157e+308,"month":2,"day":[0,8],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":2007,"to":1.7976931348623157e+308,"month":10,"day":[0,1],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1967,"to":2006,"month":9,"day":[0,-31],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1987,"to":2006,"month":3,"day":[0,1],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1976,"to":1986,"month":3,"day":[0,-30],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1975,"to":1975,"month":1,"day":[7,23],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1974,"to":1974,"month":0,"day":[7,6],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1967,"to":1973,"month":3,"day":[0,-30],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1945,"to":1945,"month":7,"day":[7,14],"time":1380,"clock":"posix","save":60,"letter":"P","saved":3600000},{"from":1945,"to":1945,"month":8,"day":[0,-30],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1942,"to":1942,"month":1,"day":[7,9],"time":120,"clock":"wallclock","save":60,"letter":"W","saved":0},{"from":1918,"to":1919,"month":2,"day":[0,-31],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1918,"to":1919,"month":9,"day":[0,-31],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000}],"NYC":[{"from":1921,"to":1966,"month":3,"day":[0,-30],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1955,"to":1966,"month":9,"day":[0,-31],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1921,"to":1954,"month":8,"day":[0,-30],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000},{"from":1920,"to":1920,"month":2,"day":[0,-31],"time":120,"clock":"wallclock","save":60,"letter":"D","saved":0},{"from":1920,"to":1920,"month":9,"day":[0,-31],"time":120,"clock":"wallclock","save":0,"letter":"S","saved":3600000}]}};

	/* globals ADB */
	const heartbeatThreshold = 20000; // 20 seconds

	// eslint-disable-next-line consistent-return
	function mergeCustomizer(objValue, srcValue) {
	  if (srcValue === null) {
	    return objValue;
	  }
	}
	function playheadOffset(player, plugin) {
	  if (!player.mediainfo) {
	    return;
	  }
	  if (typeof plugin.setPlayheadOffset === 'function' && player.mediainfo.live && player.mediainfo.startDateTime) {
	    const playheadOffset = Math.round((Date.now() - player.mediainfo.startDateTime) / 1000);
	    player.ontMetadata = {};
	  const localConfig = {
	    NIELSEN_DATA: {
	      CONTENT_METADATA: {}
	    },
	    ESPN_CUSTOM_METADATA: {
	      Showcode: player.mediainfo.showcode
	    }
	  };

	  // https://espnjira.disney.com/browse/VPLAYREPLACE-769
	  // Airdate, formatted as `yyyyMMddHH:mm:ss`
	  if (player.mediainfo.originalPublishDate) {
	    localConfig.NIELSEN_DATA.CONTENT_METADATA.airdate = timezone(player.mediainfo.originalPublishDate, '%Y%m%d%k%M%S', New_York, 'America/New_York');
	  }
	  if (player.mediainfo.live) {
	    localhave
	  // either live or replay content, anything else would be a VOD clip
	  if (player.mediainfo.airingId || player.mediainfo.live) {
	    localConfig.ESPN_CUSTOM_METADATA[ADB.va.plugins.aa.VideoMetadataKeys.SHOW_TYPE] = '0';
	  } else {
	    localConfig.ESPN_CUSTOM_METADATA[ADB.va.plugins.aa.VideoMetadataKeys.SHOW_TYPE] = '2';
	  }
	  if (player.mediainfo.hasNielsenWatermarks) {
	    contentMetadata = {
	      adloadtype: 1,
	      dataSrc: 'ID3',
	      tv: true
	    };
	  }

	  // https://espnjira.disney.com/browse/VPLAYREPLACE-769
	  // Shared inventory
	  if (player.mediainfo.commercialReplacement === 'SHARED INV') {
	    contentMetadata.adloadtype = 1;
	  }

	  // https://espnjira.disney.com/browse/VPLAYREPLACE-769
	  // Cross Reference ID 1
	  if (player.mediainfo.nielsenCrossId1) {
	    contentMetadata.crossId1 = player.mediainfo.nielsenCrossId1;
	  }

	  // https://espnjira.disney.com/browse/WEWEB-1261
	  // Cross Reference ID 2
	  if (player.mediainfo.nielsenCrossId2) {
	    contentMetadata.crossId2 = player.mediainfo.nielsenCrossId2.toLowerCase();
	  }
	  lodash_mergewith(localConfig.NIELSEN_DATA.CONTENT_METADATA, contentMetadata, mergeCustomizer);
	  lodash_mergewith(config, localConfig, mergeCustomizer);
	  return config;
	}
	function setEventListeners(player, plugin, nielsenPlugin, coordinator) {
	  let adBreakStarted;
	  let adStarted;
	  let heartbeatTimeout;
	  const canTrackAdStartComplete = typeof plugin.trackAdStart === 'function' && typeof plugin.trackAdComplete === 'function';
	  function trackAdComplete(adID) {
	    // console.log('sending trackAdComplete', player.currentTime());

	    if (adStarted) {
	      plugin.trackAdComplete();
	      nielsenPlugin.trackAdComplete();
	      if (adID) {
	        coordinator.coordinate('dtci.ads.adEnded', {
	          type: 'midroll',
	          id: adID
	        });
	      }
	    }
	    adStarted = false;
	  }
	  function trackAdBreakStart() {
	    // console.log('sending trackAdBreakStart');

	    adBreakStarted = true;
	    plugin.trackAdBreakStart('midroll', player.currentTime());
	    nielsenPlugin.trackAdBreakStart();
	  }
	  function trackAdStart(adID) {
	    // console.log('sending trackAdStart', player.currentTime());

	    clearTimeout(heartbeatTimeout);
	    if (!adBreakStarted) {
	      trackAdBreakStart();
	    }
	    plugin.trackAdStart(adID);
	    nielsenPlugin.trackAdStart(adID);
	    adStarted = Date.now();
	    if (adID) {
	      coordinator.coordinate('dtci.ads.adStarted', {
	        type: 'midroll',
	        id: adID
	      });
	    }
	  }
	  function startHeartbeatTimer() {
	    // console.debug('starting ad timer', player.currentTime());

	    heartbeatTimeout = setTimeout(trackAdStart, heartbeatThreshold);
	  }
	  function trackAdBreakComplete() {
	    // console.log('sending trackAdBreakComplete');

	    plugin.trackAdBreakComplete();
	    nielsenPlugin.trackAdBreakComplete();
	    adBreakStarted = false;
	  }
	  function resetHeartbeatTimer() {
	    // console.log('resetting ad timer', player.currentTime(), adBreakStarted, adStarted);

	    clearTimeout(heartbeatTimeout);

	    // An ad break was started at least 20 seconds ago.
	    if (adStarted && adStarted + heartbeatThreshold < Date.now()) {
	      trackAdComplete();
	      trackAdBreakComplete();
	    }
	    startHeartbeatTimer();
	  }
	  function onPause() {
	    // console.debug('stopping ad timer');

	    if (!player.mediainfo.hasEspnId3Heartbeats) {
	      return;
	    }
	    clearTimeout(heartbeatTimeout);
	    player.one('play', () => {
	      startHeartbeatTimer();
	    });
	  }
	  function shouldSendID(player, cue) {
	    if (!player.mediainfo) {
	      return false;
	    }
	    return typeof plugin.sendID3 === 'function' && cue.owner && cue.owner.match(/^www\.nielsen\.com/i) !== null && (player.mediainfo.hasNielsenWatermarks || player.mediaItem.source.type === 'entitlement');
	  }
	  function onCueChange(event, cue) {
	    let payload;
	    try {
	      payload = JSON.parse(cue.text);
	    } catch (e) {
	      payload = cue.text;
	    }
	    const shouldSendID3 = shouldSendID(player, cue);
	    const shouldTrackAdTransitions = canTrackAdStartComplete && cue.owner === 'com.espn.authnet.transition';
	    const shouldResetAdTimer = canTrackAdStartComplete && player.mediainfo.hasEspnId3Heartbeats && cue.owner === 'com.espn.authnet.heartbeat' && payload[0].type === 'PROGRAM' && !(payload[1] && payload[1].type === 'COMMERCIAL');
	    if (shouldSendID3) {
	      // console.log(cue.owner);
	      nielsenPlugin.sendID3(cue.text);
	    }
	    if (shouldTrackAdTransitions) {
	      // console.log('transitioning from ' + payload.from.type + ' to ' + payload.to.type);

	      if (payload.from.type === 'PROGRAM' && payload.to.type === 'COMMERCIAL') {
	        coordinator.coordinate('dtci.ads.podStarted', {
	          type: 'midroll'
	        });
	        trackAdBreakStart();
	        trackAdStart(payload.to.id);
	      } else if (payload.from.type === 'COMMERCIAL' && payload.to.type === 'COMMERCIAL') {
	        trackAdComplete(payload.from.id);
	        trackAdStart(payload.to.id);
	      } else if (payload[1] && payload[1].type === 'COMMERCIAL') {
	        trackAdStart(payload[1].id);
	      } else if (payload.from.type === 'COMMERCIAL' && payload.to.type === 'PROGRAM') {
	        trackAdComplete(payload.from.id);
	        trackAdBreakComplete();
	        coordinator.coordinate('dtci.ads.podEnded', {
	          type: 'midroll'
	        });
	      }
	    }
	    if (shouldResetAdTimer) {
	      resetHeartbeatTimer();
	    }
	  }
	  player.on('pause', onPause);
	  player.on('dtci.id3.cueChange', onCueChange);
	  player.one('dispose', () => {
	    player.off('pause', onPause);
	    player.off('dtci.id3.cueChange', onCueChange);
	    clearTimeout(heartbeatTimeout);
	  });
	}
	class ESPNAdobeNielsenAdapter {
	  constructor(player, config, coordinator) {
	    if (typeof ADB === 'undefined') {
	      console.warn('DTCIVideoPlayer: Adobe Analytics SDK is not available');
	      return;
	    }
	    this.player = player;

	    // eslint-disable-next-line no-param-reassign
	    config = configure(this.player, config);
	    if (typeof this.player.BCGSAdobeDCRPlugin === 'function') {
	      // Brightcove's plugin
	      this.plugin = this.player.BCGSAdobeDCRPlugin({
	        options: config,
	        debug: config.DEBUG
	      });
	    } else {
	      console.error('DTCIVideoPlayer: No Adobe/Nielsen plugin found');
	      return;
	    }
	    if (typeof this.player.nielsen === 'function') {
	      this.nielsenPlugin = player.nielsen(config.NIELSEN_DATA);
	    }
	    playheis.player, this.plugin, this.nieof this.plugin.loadNewOptions === 'function') {
	      this.plugin.loadNewOptions(options);
	    }
	  }
	  completeLiveProgram() {
	    if (typeof this.plugin.completeLiveProgram === 'function') {
	      this.plugin.completeLiveProgram();
	    }
	  }
	}

	class AnalyticsService {
	  constructor(configs, coordinator) {
	    this.analytics_ = null;
	    this.adobeNielsen_ = null;
	    this.liveAnalyticsWatcher = null;
	    this.dmedConviva_ = null;
	    this.dmedQoe_ = null;
	    this.configs_ = configs;
	    this.coordinator = coordinator;
	    this.updateAnalytics = this.updateAnalytics.bind(this);
	    this.configureAnalytics = this.configureAnalytics.bind(this);
	    this.initAnalytics = this.initAnalytics.bind(this);
	    this.initConviva = this.initConviva.bind(this);
	    this.initQOE = this.initQOE.bind(this);
	    this.initQoeOrConviva = this.initQoeOrConviva.bind(this);
	    this.updateConvivaCustomMetadata = this.updateConvivaCustomMetadata.bind(this);
	    this.retryRequested = this.retryRequested.bind(this);
	  }
	  set analytics(value) {
	    this.analytics_ = value;
	  }
	  get analytics() {
	    return this.analytics_;
	  }
	  set dmedConviva(value) {
	    this.dmedConviva_ = value;
	  }
	  get dmedConviva() {
	    return this.dmedConviva_;
	  }
	  set dmedQoe(value) {
	    this.dmedQoe_ = value;
	  }
	  get dmedQoe() {
	    return this.dmedQoe_;
	  }
	  updateAnalytics(configs) {
	    const {
	      analytics
	    } = this;
	    if (!analytics) {
	      return console.warn('no analytics provided', analytics);
	    }
	    if (!configs) {
	      return console.warn('no congigs provided', configs);
	    }
	    const {
	      chartbeat,
	      comscore,
	      conviva,
	      adobeDCR
	    } = configs;
	    if (chartbeat) {
	      analytics.chartbeat(chartbeat);
	    }
	    if (comscore) {
	      analytics.comscore(comscore);
	    }
	    if (conviva) {
	      analytics.conviva(conviva);
	    }
	    if (adobeDCR) {
	      analytics.adobeDCR(adobeDCR);
	    }
	    return analytics;
	  }
	  configureAnalytics(configs) {
	    const {
	      analytics,
	      disableAdobe,
	      disableNielsen
	    } = configs || {};
	    const adobeTrackingEnabled = !disableAdobe && !disableNielsen;
	    this.analytics_ = new Analytics();
	    if (analytics) {
	      this.analytics_.config = analytics;
	    }
	    if (adobeTrackingEnabled) {
	      this.analytics_.adobeDCR({
	        ESPN_CUSTOM_METADATA: {
	          startType: this.startType
	        }
	      });
	    }
	  }
	  async initAnalytics(tracking, player, configs) {
	    try {
	      await this.coordinator.coordinate('dtci.updateAnalytics');
	      if (player.comscore && !configs.disableComscore) {
	        player.comscore(this.analytics.comscore());
	      }
	      if (player.chartbeat && !configs.disableChartbeat) {
	        player.chartbeat(this.analytics.chartbeat());
	      }
	      this.liveAnalyticsWatcher = new LiveAnalyticsWatcher(player, this.coordinator, configs === null || configs === void 0 ? void 0 : configs.plutoAppVersion);
	      const scheduleData = await this.liveAnalyticsWatcher.getScheduleData();
	      player.mediainfo.scheduleData = scheduleData;
	      if (player.mediaItem.streamType === 'live' && player.mediaItem.apiSource === 'pluto') {
	        this.liveAnalyticsWatcher.trackScheduleShows();
	      }
	      if (!configs.disableAdobe && !configs.disableNielsen) {
	        let customMetadata = null;
	        if (tracking && tracking.heartbeats) {
	          const {
	            'a.media.asset': asset,
	            'a.media.show': show,
	            'a.media.genre': genre
	          } = tracking.heartbeats;
	          if (asset || show || genre) {
	            customMetadata = {
	              ESPN_CUSTOM_METADATA: {
	                'a.media.asset': asset,
	                'a.media.show': show,
	                'a.media.genre': genre
	              }
	            };
	          }
	        }
	        if (!this.adobeNielsen_) {
	          this.adobeNielsen_ = new ESPNAdobeNielsenAdapter(player, this.analytics.adobeDCR(customMetadata), this.coordinator);
	        } else {
	          this.adobeNielsen_.loadNewOptions(this.analytics.adobeDCR(customMetadata));
	        }
	      }
	    } catch (err) {
	      const errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_ANALYTIC_INIT_ERR, 'initAnalytics', err);
	      NewRelicService$1.playerBundleEvent({}, errorException);
	    }
	  }
	  initConviva(mediaItem, context) {
	    const {
	      player,
	      platformVersion,
	      startType,
	      configs_: {
	        brand,
	        type
	      } = {}
	    } = context;
	    if (typeof player.conviva === 'function') {
	      const data = this.analo and it is a getter from techOptions.type
	        startType,
	        playbackMediaItem: mediaItem
	      });
	      this.dmedConviva = player.conviva(data);
	    }
	  }
	  initQOE(mediaItem, context) {
	    const {
	      player,
	      platformVersion,
	      startType,
	      authorizationPayload,
	      configs_: {
	        brand,
	        type
	      } = {}
	    } = context;
is.analytics.qoe({
	        coordinator: this.coordinator,
	        authorization: authorizationPayload,
	        brand,
	        platformVersion,
	        type,
	        startType,
	        playbackMediaItem: mediaItem
	      });
	      this.dmedQOE = player.qoe(data);
	    }
	  }
	  initQoeOrConviva(mediaItem, context) {
	    const {
	      player
	    } = context;
	    const {
	      disableConviva,
	      enableQoe
	    } = context.configs_;
	    const isRequiredQoeInit = player && disableConviva && !this.dmedQoe && enableQoe;
	    if (isRequiredQoeInit) {
	      this.initQOE(mediaItem, context);
	      // ignoring conviva tracking if QOE is in use
	      return;
	    }
	    const isRequiredConvivaInit = player && !this.dmedConviva && !disableConviva;
	    if (isRequiredConvivaInit) {
	      this.initConviva(mediaItem, context);
	    }
	  }
	  retryRequested() {
	    if (this.dmedQOE) {
	      this.dmedQOE.retryRequested();
	    }
	  }
	  updateConvivaCustomMetadata(streamInfo, context) {
	    try {
	      const {
	        authenticatedProvider: {
	          id
	        } = {}
	      } = context.authorizationPayload || {};
	      const startType = context.startType || streamInfo.startType;
	      const {
	        isConvivaC3DMEDAccount
	      } = this.analytics;
	      if (this.dmedQOE) {
	        this.dmedQOE.updateOptions({
	          ...this.dmedQOE.options,
	          ...streamInfo,
	          startType,
	          affiliate: id
	        });
	      }
	      if (this.dmedConviva) {
	        if (isConvivaC3DMEDAccount) {
	          this.dmedConviva.options = {
	            ...this.dmedConviva.options,
	            ...streamInfo,
	            startType,
	            affiliate: id
	          };
	        } else {
	          /**
	           * Follow code updates option for the old Conviva plugin (dtci-conviva) for clients who will be on the old Conviva SDK.
	           * After v3.2.63, the old Conviva plugin dtci-conviva has been removed in the repo. In Brightcove studio,
	           * we will need to include dtci-conviva v3.2.63 or earlier version. Using the old Conviva plugin will be temporary.
	           * All clients should be on the new Conviva plugin (demed-conviva) after Covnva is done validation
	           */
	          this.dmedConviva.options = {
	            ...this.dmedConviva.options,
	            tags: {
	              startType,
	              drmProtectionType: streamInfo.drmProtectionType,
	              streamProtocol: streamInfo.streamProtocol,
	              reloadCause: 'null'
	            }
	          };
	        }
	        return this.dmedConviva.options;
	      }
	    } catch (err) {
	      const errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.PLAYER_UNKNOWN, 'updateConvivaCustomMetadata error', err);
	      NewRelicService$1.playerBundleEvent({}, errorException);
	    }
	    return null;
Rights Reserved.*/
	function initMoatTracking(b, h, d) {
	  if (!1 === h.hasOwnProperty('partnerCode')) return !1;
	  var k = document.createElement('script');
	  d = d || b && ('undefined' !== typeof b.O ? b.O.parentNode : document.body) || document.body;
	  var f = [],
	    c = {
	      adsManager: b,
	      ids: h,
	      imaSDK: !0,
	      events: [],
	      dispatchEvent: function (a) {
	        var b = this.sendEvent,
	          c = this.events;
	        b ? (c && (c.push(a), a = c), b(a)) : c.push(a);
	      }
	    },
	    p = {
	      complete: 'AdVideoComplete',
	      firstquartile: 'AdVideoFirstQuartile',
	      impression: 'AdImpression',
	      loaded: 'AdLoaded',
	      midpoint: 'AdVideoMidpoint',
	      pause: 'AdPaused',
	      skip: 'AdSkipped',
	      start: 'AdVideoStart',
	      thirdquartile: 'AdVideoThirdQuartile',
	      volumeChange: 'AdVolumeChange'
	    };
	  if (google && google.ima && b) {
	    var e = '_moatApi' + Math.floor(1e8 * Math.random()),
	      l;
	    for (l in google.ima.AdEvent.Type) {
	      var n = function (a) {
	        if (c.sendEvent) {
	          for (a = f.length - 1; 0 <= a; a--) b.removeEventListener(f[a].type, f[a].func);
	          c.sendEvent(c.events);
	        } else c.events.push({
	          type: p[a.type] || a.type,
	          adVolume: b.getVolume()
	        });
	      };
	      b.addEventListener(google.ima.AdEvent.Type[l], n);
	      f.push({
	        type: google.ima.AdEvent.Type[l],
	  ,
	    m;
	  try {
	    g = d.ownerDocument, m = g.defaultView || g.parentWindow;
	  } catch (a) {
	    g = document, m = window;
	  }
	  m[e] = c;
	  k.type = 'text/javascript';
	  k.src = 'https://z.moatads.com/' + h.partnerCode + '/moatvideo.js#' + e;
	  d && d.appendChild(k);
	  return c;
	}

	/* globals google */
	function getMoatTrackingConfigs(player, partnerCode, zMoatAdUnitPath) {
	  const ids = {
	    partnerCode,
	    zMoatAdUnitPath,
	    viewMode: player.isFullscreen() ? google.ima.ViewMode.FULLSCREEN : google.ima.ViewMode.NORMAL,
	    slicer1: null,
	    slicer2: null
	  };
	  const {
	    ima
	  } = player;
	  let adsManager;
	  let adContainer;
	  if (ima) {
	    adsManager = ima.getAdsManager();
	    adContainer = ima.controller.getAdContainerDiv();
	  }
	  return {
	    adsManager,
	    ids,
	    adContainer
	  };
	}
	function getMoatConfigAndInitMoatTracking(player, partnerCode, zMoatAdUnitPath) {
	  const {
	    adsManager,
	    ids,
	    adContainer
	  } = getMoatTrackingConfigs(player, partnerCode, zMoatAdUnitPath);
	  initMoatTracking(adsManager, ids, adContainer);
	}
	let prevOnAdsAdStartedHandler = null;
	function moat(player, partnerCode, zMoatAdUnitPath) {
	  const {
	    mediaItem: {
	      cues
	    } = {}
	  } = player;
	  const onAdsAdStartedHandler = getMoatConfigAndInitMoatTracking.bind(null, player, partnerCode, zMoatAdUnitPath);
	  if (Array.isArray(cues)) {
	    player.one('ads-load', ler) {
	      pyer;
	      if (prevOnAdsAdStartedHandler) {
	        prevOnAdsAdStartedHandler = null;
	      }
	    });
	    prevOnAdsAdStartedHandler = onAdsAdStartedHandler;
	  } else {
	    player.one('adsready', onAdsAdStartedHandler);
	  }
	}

	function throttle(func, delay) {
	  let timeoutId;
	  let lastExecuted = 0;
	  return (...args) => {
	    const context = this;
	    const elapsed = Date.now() - lastExecuted;
	    const executeFunction = () => {
	      func.apply(context, args);
	      lastExecuted = Date.now();
	    };
	    if (elapsed >= delay) {
	      executeFunction();
	    } else {
	      clearTimeout(timeoutId);
	      timeoutId = setTimeout(executeFunction, delay - elapsed);
	    }
	  };
	}

	/*
	 * Google is an object that gets mixed into an AdProvider instance.
	 */
	const GoogleForVideoJS = {
	  validate(player) {
	    if (player.ima) {
	      return true;
	    }
	    console.warn('DTCIVideoPlayer: AdProvider: ima plugin is not available in this player');
	    return false;
	  },
	  initialize(player) {
	    this.player_ = player;
	    this.listen();
	  },
	  async loadDependencies(options, shouldRequestAds = false, configs) {
	    // eslint-disable-next-line consistent-return
	    return new promise(resolve => {
	      var _configs$mediaItem, _configs$mediaItem$so;
	      const isEntertainment = (configs === null || configs === void 0 ? void 0 : (_configs$mediaItem = configs.mediaItem) === null || _configs$mediaItem === void 0 ? void 0 : (_configs$mediaIte_co null || configs === void 0 ? void 0 : configs.autoplay;
	      const initIMA = () => {
	        if (shouldRequestAds && isEntertainment && isAutoplay) {
	          var _this$player_$ima, _this$player_;
	          const configs = AdsManager.getConfigsByType(options, null, this.player_);
	          (_this$player_$ima = (_this$player_ = this.player_).ima) === null || _this$player_$ima === void 0 ? void 0 : _this$player_$ima.call(_this$player_, {
	            ...configs,
	            contribAdsSettings: {
	              ...configs.contribAdsSettings,
	              prerollTimeout: this.timeout_
	            }
	          });
	        }
	        return resolve();
	      };
	      const onError = () => {
	        this.player_.trigger('ads-manager-loaded');
	        return resolve();
	      };
	      if (window.google && window.google.ima) {
	        return initIMA();
	      }
	      loadScript$1.url('https://imasdk.googleapis.com/js/sdkloader/ima3.js').then(initIMA).catch(onError);
	    });
	  },
	  async loadAds(advertisingInfo, options, coordinator, mediaItem) {
	    let {
	      shouldRequestAds
	    } = options;
	    if (!(window.google && window.google.ima) || !this.player_.ima) {
	      shouldRequestAds = false;
	    }
	    if (!shouldRequestAds) {
	      this.player_.removeClass('vjs-ad-loading');
	      this.player_.removeClass('vjs-ad-playing');
	      if (this.player_.ima.controller && this.player_.ima.controller.settings) {
	        this.player_.ima.controller.settings.adTagUrl = '';
	      }

	      // If we aren't making ad calls, the ad manager doesn't load.
	      // Triggering the load event so that the content can continue.
	      this.player_.trigger('ads-manager-loaded');
	    } else {
	      this.mediaItem_ = mediaItem;
	      this.timeout_ = (options === null || options === void 0 ? void 0 : options.timeout) || 4000;
	      await coordinator.coordinate('dtci.adProvider.getAdvertisingInfo', advertisingInfo);
	      const configs = AdsManager.getConfigsByType(options, AdsManager.getServerUrl(advertisingInfo), this.player_);

	      // mute the player if autoplayPolicy doesn't allow play with unmuted for ads
	      const shouldMutePlayerOnAdLoad = this.shouldMutePlayerOnAdLoad_(options);
	      if (shouldMutePlayerOnAdLoad) {
	        this.isAutoplayMuted = true;
	        this.wasPlayerMutedOnAdLoad = this.player_.muted();
	        this.player_.muted(true);
	      }
	      if (!options.disableMoat) {
	        moat(this.player_, advertisingInfo.moatPartnerCode, advertisingInfo.iu);
	      }
	      if (typeof this.player_.ima === 'function') {
	        this.player_.ima({
	          ...configs,
	          contribAdsSettings: {
	            ...configs.contribAdsSettings,
	            prerollTimeout: this.timeout_
	          }
	        });
	      } else if (typeof this.player_.ima.requestAds === 'function') {
	        this.player_.ima.initializeAdDisplayContainer();
	        this.player_.ima.setContentWithAdTag(null, configs.adTagUrl, false);
	        setTimeout(() => {
	          this.player_.ima.requestAds();
	        }, 0);
	      }
	      setTimeout(() => {
	        // Trigger loaded after configured timeout to protect against
	        // any failure of the ad manager to load blocking
	        // content.
	        this.player_.trigger('ads-manager-loaded');
	      }, this.timeout_);
	    }
	  },
	  shouldMutePlayerOnAdLoad_(options) {
	    if (IS_IPAD) {
	      return true;
	    }
	    const isAutoPlay = this.player_.autoplay();
	    // canAutoplay check will return autoplayPolicy as blocked even though browsers allow autoplay because of
	    // either ad request or autoplayPolicy check timeout, so we need to mute the player even when autoplayPolicy is blocked
	    const shouldMuteByPolicy = options.autoplayPolicy !== AUTOPLAY_ALLOW_TYPE.UNMUTED;
	    return isAutoPlay && shouldMuteByPolicy;
	  },
	  cancelEvent_(evt) {
	    evt.isImmediatePropagationStopped = () => {
	      return true;
	    };
	    evt.cancelBubble = true;
	    evt.isPropagationStopped = () => {
	      return true;
	    };
	  },
	  prefixEvent_(prefix, event) {
	    this.cancelEvent_(event);
	    this.player_.trigger({
	      type: prefix + event.type,
	      originalEvent: even.ads.state = value;
	  },
	  listen() {
	    this.onContentChanged_ = this.onContentChanged_.bind(this);
	    this.onPlay_ = this.onPlay_.bind(this);
	    this.onAdsReady_ = this.onAdsReady_.bind(this);
	    this.onAdProblem_ = this.onAdProblem_.bind(this);
	    this.onAdStart_ = this.onAdStart_.bind(this);
	    this.onAdEnd_ = this.onAdEnd_.bind(this);
	    this.onPlaying_ = this.onPlaying_.bind(this);
	    this.onContentEnded_ = this.onContentEnded_.bind(this);
	    this.onEnded_ = this.onEnded_.bind(this);
	    this.onDispose_ = this.onDispose_.bind(this);
	    this.checkContentStatus_ = this.checkContentStatus_.bind(this);
	    this.stopCheckingForAdsPodEnd_ = this.stopCheckingForAdsPodEnd_.bind(this);
	    this.checkContentStatus_ = throttle(this.checkContentStatus_, 500);
	    this.player_.on('contentchanged', this.onContentChanged_);
	    this.player_.on('play', this.onPlay_);
	    this.player_.on('adsready', this.onAdsReady_);
	    this.player_.on(['adserror', 'adtimeout', 'adskip'], this.onAdProblem_);
	    this.player_.on(['ads-ad-started', 'adstart'], this.onAdStart_);
	    this.player_.on('adend', this.onAdEnd_);
	    this.player_.on('playing', this.onPlaying_);
	    this.player_.on('contentended', this.onContentEnded_);
	    this.player_.on('ended', this.onEnded_);
	    this.player_.one('dispose', this.onDispose_);
	  },
	  unlisten() {
	    this.player_.off('contentchanged', this.onContentChanged_);
	    this.player_.off('play', this.onPlay_);
	    this.player_.off('adsready', this.onAdsReady_);
	    this.player_.off(['adserror', 'adtimeout', 'adskip'], this.onAdProblem_);
	    this.player_.off(['ads-ad-started', 'adstart'], this.onAdStart_);
	    this.player_.off('adend', this.onAdEnd_);
	    this.player_.off('playing', this.onPlaying_);
	    this.player_.off('contentended', this.onContentEnded_);
	    this.player_.off('ended', this.onEnded_);
	    this.player_.off('timeupdate', this.checkContentStatus_);
	  },
	  onContentChanged_() {
	    if (this.player_.paused()) {
	      this.setAdState_(adStates.CONTENT_SET);
	    } else {
	      this.setAdState_(adStates.MAYBE_ADS_READY);
	    }
	  },
	  onPlay_() {
	    if (this.currentAdState === adStates.CONTENT_SET) {
	      this.setAdState_(adStates.MAYBE_ADS_READY);
	    } else if (this.currentAdState === adStates.ADS_READY) {
	      this.setAdState_(adStates.MAYBE_PREROLL);
	    }
	  },
	  onAdsReady_() {
	    if (this.currentAdState === adStates.CONTENT_SET) {
	      this.setAdState_(adStates.ADS_READY);
	    } else if (this.currentAdState === adStates.MAYBE_ADS_READY) {
	      this.setAdState_(adStates.MAYBE_PREROLL);
	    }
	  },
	  onAdProblem_() {
	    if (this.currentAdState === adStates.MAYBE_ADS_READY || this.currentAdState === adStates.MAYBE_PREROLL) {
	      this.setAdState_(adStates.CONTENT_PLAYBACK);
	    }
	  },
	  onAdStart_() {
	    this.adSnapshot_ = this.player_.ads.snapshot;
	    const {
	      ads: {
	        startLinearAdMode
	      } = {}
	    } = this.player_ || {};
	    if (!IS_IOS && this.player_ && typeof this.player_.paused === 'function' && !this.player_.paused() && typeof this.player_.pause === 'function') {
	      this.player_.pause();
	    }
	    if (this.currentAdState !== adStates.AD_PLAYBACK) {
	      this.player_.trigger('ads-pod-started');
	    }
	    if (!this.isInAdMode_() && typeof startLinearAdMode === 'function') {
	      console.error('Manually calling startLinearAdMode because player is not in ad mode');
	      startLinearAdMode();
	    }
	    if (IS_IPAD) {
	      this.checkForAdStartFailure_();
	    }
	    this.setAdState_(adStates.AD_PLAYBACK);
	  },
	  onAdEnd_() {
	    this.doubleCheckForAdsPodEnd_();
	    this.setAdState_(adStates.CONTENT_RESUMING);
	  },
	  onPlaying_() {
	    this.checkContentStatus_();
	  },
	  onContentEnded_() {
	    if (this.currentAdState === adStates.CONTENT_PLAYBACK) {
	      this.setAdState_(adStates.MAYBE_POSTROLL);
	    }
	  },
	  onEnded_(evt) {
	    if (this.isInAdMode_()) {
	      this.prefixEvent_('ad', evt);
	    } else {
	      this.setAdState_(adStates.CONTENT_PLAYBACK);
	    }
	  },
	  onDispose_() {
	    this.unlisten();
	    this.preAdVideoState_ = null;
	  },
	  isInAdMode_() {
	    var _this$player_2, _this$player_3, _this$player_3$ads;
	    return ((_this$player_2 = this.player_) === null || _this$player_2 === void 0 ? void 0 : _this$player_2.ads) && typeof ((_this$player_3 = this.player_) === nuyer_3$ads === void 0 ? void 0 : _this$player_3$ads.isInAdMode) === 'function' && this.player_.ads.isInAdMode();
	  },
	  checkForAdStartFailure_() {
	    const {
	      ads: {
	        endLinearAdMode
	      } = {}
	    } = this.player_ || {};
	    this.onTimeUpdateVerification_ = this.onTimeUpdateVerification_.bind(this);
	    this.hasTimeUpdatedForAd = false;
	    this.player_.one('ad-progress', this.onTimeUpdateVerification_);
	    this.updatedVerificationTimeout = setTimeout(() => {
	      if (!this.hasTimeUpdatedForAd && this.isInAdMode_() && typeof endLinearAdMode === 'function') {
	        var _this$player_$el_;
	        endLinearAdMode();
	        const controlBarEl = (_this$player_$el_ = this.player_.el_) === null || _this$player_$el_ === void 0 ? void 0 : _this$player_$el_.querySelector('.vjs-control-bar');
	        if (controlBarEl && controlBarEl.classList && controlBarEl.classList.remove) {
	          controlBarEl.classList.remove('vjs-hidden');
	        }
	      }
	    }, this.timeout_);
	  },
	  doubleCheckForAdsPodEnd_() {
	    this.player_.one(['ad-progress', 'ads-ad-started', 'adstart'], this.stopCheckingForAdsPodEnd_);
	    this.player_.on('timeupdate', this.checkContentStatus_);
	  },
	  checkContentStatus_() {
	    var _this$player_4, _this$player_4$tech_, _this$adSnapshot_, _this$player_5;
	    const isContent = !this.adSnapshot_ || ((_this$player_4 = this.player_) === null || _this$player_4 === void 0 ? void 0 : (_this$player_4$tech_ = _this$player_4.tech_) === null || _this$player_4$tech_ === void 0 ? void 0 : _this$player_4$tech_.el_.src) === ((_this$adSnapshot_ = this.adSnapshot_) === null || _this$adSnapshot_ === void 0 ? void 0 : _this$adSnapshot_.src);
	    const isPlaying = !((_this$player_5 = this.player_) !== null && _this$player_5 !== void 0 && _this$player_5.paused());
	    if (isContent && isPlaying) {
	      if (this.currentAdState !== null) {
	        if (this.currentAdState !== adStates.CONTENT_PLAYBACK) {
	          this.player_.trigger('contentplayback');
	          if (this.currentAdState !== adStates.AD_PLAYBACK) {
	            this.player_.trigger('ads-pod-ended');
	            this.adSnapshot_ = null;
	            this.stopCheckingForAdsPodEnd_();
	            if (this.isAutoplayMuted && !this.wasPlayerMutedOnAdLoad) {
	              this.isAutoplayMuted = false;
	              this.player_.muted(this.wasPlayerMutedOnAdLoad);
	            }
	          }
	        }
	      }
	      this.setAdState_(adStates.CONTENT_PLAYBACK);
	    }
	  },
	  stopCheckingForAdsPodEnd_() {
	    this.player_.off('timeupdate', this.checkContentStatus_);
	  },
	  onTimeUpdateVerification_() {
	    if (this.isInAdMode_()) {
	      this.hasTimeUpdatedForAd = true;
	      clearTimeout(this.updatedVerificationTimeout);
	    }
	  }
	};

	const providers = {
	  GoogleForVideoJS
	};
	class AdProvider {
	  constructor(player, configs, coordinator) {
	    var _configs$adProvider, _configs$brandConfig;
	    this.player = player;
	    this.coordinator = coordinator;
	    this.provider = null;
	    this.options = {
	      ...(configs === null || configs === void 0 ? void 0 : (_configs$adProvider = configs.adProvider) === null || _configs$adProvider === void 0 ? void 0 : _configs$adProvider.options),
	      ...(configs === null || configs === void 0 ? void 0 : (_configs$brandConfig = configs.brandConfig) === null || _configs$brandConfig === void 0 ? void 0 : _configs$brandConfig.ads)
	    };
	    this.setProvider('GoogleForVideoJS');
	  }
	  setProvider(preferredProvider = 'GoogleForVideoJS') {
	    if (providers[preferredProvider]) {
	      const provider = providers[preferredProvider];
	      if (provider.validate(this.player)) {
	        this.provider = provider;
	      }
	    }
	  }

	  /*
	   * `initialize` provides a hook for an Ad Provider to load additional resources or modify runtime values.
	   * For example, GoogleForVideoJS needs to load the IMA SDK library. And previously, Brightcove Once, an SSAI provider, used
	   * `initialize` to query a backend API for an ad-injected playback URL.
	   */
	  initialize() {
	    if (this.provider) {
	      this.provider.initialize(this.player);
	    }
	  }
	  async loadDependencies(shouldRequestAds = false, configs) {
	    if (this.provider && this.provider.loadDependencies) {
	      await this.provider.loadDependencies(this.options, shouldRequestAds, configs);
	    }
	  }
	  async loadAds(advertisingInfo, mediaItem = {}, autoplayPolicy) {
	    if (this.provider) {
	      var _document;
	      const isBackgrounded = this.options.disableAdRequestOnBackgroundedVideo === true && ((_document = document) === null || _document === void 0 ? void 0 : _document.hidden);
	      const shouldRequestAds = isBackgrounded ? false : await this.coordinator.coordinate('dtci.adProvider.shouldRequestAds', true);
	      this.options.shouldRequestAds = shouldRequestAds;
	      this.options.autoplayPolicy = autoplayPolicy;
	      this.provider.loadAds(advertisingInfo, this.options, this.coordinator, mediaItem);
	    }
	  }
	}

	class AdvertisementService {
	  constructor(configs, coordinator) {
	    this.isAdGracePeriodEnabled = false;
	    this.GRACE_PERIOD_KEY = 'ads-adsmanager-ad-complete';
	    this.gracePeriodTime = 30000;
	    this.configs_ = configs;
	    this.coordinator = coordinator;
	    this.initAdProvider = this.initAdProvider.bind(this);
	    this.loadAds = this.loadAds.bind(this);
	    this.initAdGracePeriod = this.initAdGracePeriod.bind(this);
	    this.setAdGracePeriod = th
	  get curTime() {
	    return new Date().getTime();
	  }
	  get lastTime() {
	    return localStorage.getItem(this.GRACE_PERIOD_KEY) ? Number(localStorage.getItem(this.GRACE_PERIOD_KEY)) : null;
	  }
	  get gracePeriodEndTime() {
	    return this.lastTime + this.gracePeriodTime;
	  }
	  get isInAdGracePeriod() {
	    let isInAdGracePeriod = false;
	    if (this.isAdGracePeriodEnabled && this.lastTime) {
	      isInAdGracePeriod = this.curTime < this.gracePeriodEndTime;
	      if (!isInAdGracePeriod) {
	        // Clear variable if not needed anymore
	        this.unsetAdGracePeriod();
	      }
	    }
	    return isInAdGracePeriod;
	  }
	  initAdProvider(player) {
	    try {
	      const {
	        configs_,
;
	      adProvider.initialize();
	      return adProvider;
	    } catch (err) {
	      const errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.ADS_PROVIDER_ERR, `initAdProvider failed`, err);
	      NewRelicService$1.mediaPlayerFlowEvent({}, errorException);
	      return null;
	    }
	  }
	  async loadAds(adProvider, advertisingInfo = {}, mediaItem = {}, autoplayPolicy) {
	    try {
	      return await adProvider.loadAds(advertisingInfo, mediaItem, autoplayPolicy);
	    } catch (err) {
	      const errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(ERROR_CODES.ADS_FAILED_TO_LOAD, `loadAds failed`, err);
	      NewRelicService$1.mediaPlayerFlowEvent({}, errorException);
	      return null;
	    }
	  }
	  initAdGracePeriod(gracePeriodTime) {
	    this.isAdGracePeriodEnabled = true;
	    this.gracePeriodTime = gracePeriodTime ? gracePeriodTime * 1000 : this.gracePeriodTime;
	  }
	  setAdGracePeriod() {
	    localStorage.setItem(this.GRACE_PERIOD_KEY, this.curTime);
	  }
	  unsetAdGracePeriod() {
	    localStorage.removeItem(this.GRACE_PERIOD_KEY);
	  }
	}

	var MediaItemMediaCommand$2;
	(function (MediaItemMediaCommand) {
	    MediaItemMediaCommand[MediaItemMediaCommand["all"] = 0] = "all";
	    MediaItemMediaCommand[MediaItemMediaCommand["linearPlayback"] = 1] = "linearPlayback";
	})(MediaItemMediaCommand$2 || (MediaItemMediaCommand$2 = {}));

	var MediaItemNetworkType$2;
	(function (MediaItemNetworkType) {
	    MediaItemNetworkType["linear"] = "linear";
	    MediaItemNetworkType["event"] = "event";
	})(MediaItemNetworkType$2 || (MediaItemNetworkType$2 = {}));

	var MediaItemSourceVariant$3;
	(function (MediaItemSourceVariant) {
	    MediaItemSourceVariant["stitchedPreroll"] = "stitchedPreroll";
	})(MediaItemSourceVariant$3 || (MediaItemSourceVariant$3 = {}));

	var MediaItemStreamType$4;
	(function (MediaItemStreamType) {
	    MediaItemStreamType["live"] = "live";
	    MediaItemStreamType["onDemand"] = "onDemand";
	})(MediaItemStreamType$4 || (MediaItemStreamType$4 = {}));

	var MediaItemTrackingType$3;
	(function (MediaItemTrackingType) {
	    MediaItemTrackingType["nielsen"] = "nielsen";
	    MediaItemTrackingType["comscore"] = "comscore";
	    MediaItemTrackingType["conviva"] = "conviva";
	    MediaItemTrackingType["heartbeats"] = "heartbeats";
	})(MediaItemTrackingType$3 || (MediaItemTrackingType$3 = {}));

	var MediaItemEntityType$3;
	(function (MediaItemEntityType) {
	    MediaItemEntityType["shortform"] = "shortform";
	    MediaItemEntityType["longform"] = "longform";
	})(MediaItemEntityType$3 || (MediaItemEntityType$3 = {}));

	var MediaItemType$2;
	(function (MediaItemType) {
	    MediaItemType["audio"] = "audio";
	    MediaItemType["video"] = "video";
	})(MediaItemType$2 || (MediaItemType$2 = {}));

	var ApiSource$4;
	(function (ApiSource) {
	    ApiSource["pluto"] = "pluto";
	    ApiSource["graphQL"] = "graphQL";
	    ApiSource["cfa"] = "cfa";
	    ApiSource["itemFeed"] = "itemFeed";
	})(ApiSource$4 || (ApiSource$4 = {}));
	var ApiSource$5 = ApiSource$4;

	var MediaItemAuthenticationType$4;
	(function (MediaItemAuthenticationType) {
	    MediaItemAuthenticationType["open"] = "OPEN";
	    MediaItemAuthenticationType["direct"] = "DIRECT";
	    MediaItemAuthenticationType["mvpd"] = "MVPD";
	    MediaItemAuthenticationType["isp"] = "ISP";
	    MediaItemAuthenticationType["none"] = "NONE";
	})(MediaItemAuthenticationType$4 || (MediaItemAuthenticationType$4 = {}));
	var MediaItemAuthenticationType$5 = MediaItemAuthenticationType$4;

	var MediaItemSourceType$3;
	(function (MediaItemSourceType) {
	    MediaItemSourceType["none"] = "none";
	    MediaItemSourceType["startSession"] = "startSession";
	    MediaItemSourceType["bam"] = "bam";
	    MediaIte;
	    MediaItemSourceType["entitlement"] = "entitlement";
	})(MediaItemSourceType$3 || (MediaItemSourceType$3 = {}));
	var MediaItemSourceType$4 = MediaItemSourceType$3;

	const defaultGraphQLServiceUrl$2 = 'https://watch.graph.api.espn.com/api';
	const defaultGraphQLApiKey$2 = 'd15c5790-7cb0-4fe1-8782-25f4698d0739';
	const defaultGraphQLNetworkSortOrder$2 = [
	    'espn_ppv',
	    'espn_dtc',
	    'espn1',
	    'espn2',
	    'espn3',
	    'espnu',
	    'sec',
	    'espnews',
	    'espndeportes',
	    'longhorn',
	    'goalline',
	    'buzzerbeater',
	    'secplus',
	    'acc',
	    'accextra',
	    'espn_free',
	    'bam_dtc',
	];
	const defaultItemFeedServiceUrl$2 = 'https://abcnews.go.com/video/itemfeed';
	class Configuration$3 {
	    constructor(apiSource, serviceUrl, apiKey, networkSortOrder) {
	        if (apiSource === ApiSource$5.graphQL) {
	            this.serviceUrl = serviceUrl || defaultGraphQLServiceUrl$2;
	            this.apiKey = apiKey || defaultGraphQLApiKey$2;
	            this.networkSortOrder = networkSortOrder || defaultGraphQLNetworkSortOrder$2;
	        }
	        else if (apiSource === ApiSource$5.cfa) {
	            this.apiSource = apiSource;
	            this.serviceUrl = serviceUrl;
	        }
	        else if (apiSource === ApiSource$5.itemFeed) {
	            this.serviceUrl = serviceUrl || defaultItemFeedServiceUrl$2;
	        }
	    }
	}

	new Configuration$3(ApiSource$5.graphQL);

	Object.freeze({});
	Object.freeze({});
	ApiSource$5.itemFeed;

	new Configuration$3(ApiSource$5.itemFeed);

	class PlaybackConfig {
	    constructor(contentType, keySystem, licenseUrl) {
	        this.contentType = contentType;
	        this.keySystem = keySystem;
	        this.licenseUrl = licenseUrl;
	    }
	}

	var MediaItemMediaComman {}));

	var MediaItemSourceVariant$1;
	(function (MediaItemSourceVariant) {
	    MediaItemSourceVariant["stitchedPreroll"] = "stitchedPreroll";
	})(MediaItemSourceVariant$1 || (MediaItemSourceVariant$1 = {}));
	var MeditemStreamType$2;
	(function (MediaItemStreamType) {
	    MediaItemStreamType["live"] = "live";
	    MediaItemStreamType["onDemand"] = "onDemand";
	})(MediaItemStreamType$2 || (MediaItemStreamType$2 = {}));
	var MediaItemStreamType$3 = MediaItemStreamType$2;

	var MediaItemTrackingType$1;
	(function (MediaItemTrackingType) {
	    MediaItemTrackingType["nielsen"] = "nielsen";
	    MediaItemTrackingType["comscore"] = "comscore";
	    MediaItemTrackingType["conviva"] = "conviva";
	    MediaItemTrackingType["heartbeats"] = "heartbeats";
	})(MediaItemTrackingType$1 || (MediaItemTrackingType$1 = {}));
	var MediaItemTrackingType$2 = MediaItemTrackingType$1;

	var MediaItemEntityType$2;
	(function (MediaItemEntityType) {
	    MediaItemEntityType["shortform"] = "shortform";
	    MediaItemEntityType["longform"] = "longform";
	})(MediaItemEntityType$2 || (MediaItemEntityType$2 = {}));

	var MediaItemType$1;
	(function (MediaItemType) {
	    MediaItemType["audio"] = "audio";
	    MediaItemType["video"] = "video";
	})(MediaItemType$1 || (MediaItemType$1 = {}));

	var ApiSource$2;
	(function (ApiSource) {
	    ApiSource["pluto"] = "pluto";
	    ApiSource["graphQL"] = "graphQL";
	    ApiSource["cfa"] = "cfa";
	    ApiSource["itemFeed"] = "itemFeed";
	})(ApiSource$2 || (ApiSource$2 = {}));
	var ApiSource$3 = ApiSource$2;

	var MediaItemAuthenticationType$2;
	(function (MediaItemAuthenticationType) {
	    MediaItemAuthenticationType["open"] = "OPEN";
	    MediaItemAuthenticationType["direct"] = "DIRECT";
	    MediaItemAuthenticationType["mvpd"] = "MVPD";
	    MediaItemAuthenticationType["isp"] = "ISP";
	    MediaItemAuthenticationType["none"] = "NONE";
	})(MediaItemAuthenticationType$2 || (MediaItemAuthenticationType$2 = {}));
	var MediaItemAuthenticationType$3 = MediaItemAuthenticationType$2;

	var MediaItemSourceType$1;
	(function (MediaItemSourceType) {
	    MediaItemSourceType["none"] = "none";
	    MediaItemSourceType["startSession"] = "startSession";
	    MediaItemSourceType["bam"] = "bam";
	    MediaItemSourceType["shield"] = "shield";
	    MediaItemSourceType["entitlement"] = "entitlement";
	})(MediaItemSourceType$1 || (MediaItemSourceType$1 = {}));
	var MediaItemSourceType$2 = MediaItemSourceType$1;

	const defaultGraphQLServiceUrl$1 = 'https://watch.graph.api.espn.com/api';
	const defaultGraphQLApiKey$1 = 'd15c5790-7cb0-4fe1-8782-25f4698d0739';
	const defaultGraphQLNetworkSortOrder$1 = [
	    'espn_ppv',
	    'espn_dtc',
	    'espn1',
	    'espn2',
	    'espn3',
	    'espnu',
	    'sec',
	    'espnews',
	    'espndeportes',
	    'longhorn',
	    'goalline',
	    'buzzerbeater',
	    'secplus',
	    'acc',
	    'accextra',
	    'espn_free',
	    'bam_dtc',
	];
	const defaultItemFeedServiceUrl$1 = 'https://abcnews.go.com/video/itemfeed';
	class Configuration$2 {
	    constructor(apiSource, serviceUrl, apiKey, networkSortOrder) {
	        if (apiSource === ApiSource$3.graphQL) {
	            this.serviceUrl = serviceUrl || defaultGraphQLServiceUrl$1;
	            this.apiKey = apiKey || defaultGraphQLApiKey$1;
	            this.networkSortOrder = networkSortOrder || defaultGraphQLNetworkSortOrder$1;
	        }
	        else if (apiSource === ApiSource$3.cfa) {
	            this.apiSourc);
	                if (response) {
	                 	                return false;
	            }
	            catch (err) {
	                console.log(`fetchMetadataKeys error: ${err}`);
	                return false;
	            }
	        });
	    }
	    static setLocalStorageByAppID(json, applicationId) {
	        const key = `${CONCURRENCY_MONITOR_METADATA_STORAGE_KEY}.${applicationId}`;
	        localStorage.setItem(key, JSON.stringify(json));
	    }
	    get metadataKeys() {
	        return this.getMetadataKeysFromLocalStorage_(this.applicationId);
	    }
	    getMetadataKeysFromLocalStorage_(applicationId) {
	        const key = `${CONCURRENCY_MONITOR_METADATA_STORAGE_KEY}.${applicationId}`;
	        let metadataKeys = [];
	        try {
	            metadataKeys = JSON.parse(localStorage.getItem(key)) || [];
	        }
	        catch (err) {
	            console.error(`AdobeCM getMetadataKeys error: ${err}`);
	        }
	        return metadataKeys;
	    }
	    start() {
	        return __awaiter(this, void 0, void 0, function* () {
	            const sessionId = yield this.createSession();
	            if (!sessionId) {
	                return null;
	            }
	            this.scheduleHeartbeat();
	            return sessionId;
	        });
	    }
	    startWithSession(sessionId) {
	        this.sessionId = sessionId;
	        this.scheduleHeartbeat();
	    }
	    stop() {
	        if (this.heartbeatIntervalId) {
	            clearInterval(this.heartbeatIntervasion();
	    }
	    createSession(sessionsToTerminate = []) {
	        return __awaiter(this, void 0, void 0, function* () {
	            loglevel.debug('AdobeConcurrencyMonitorV2.createSession');
	            const requestUrl = `${this.serviceUrl}/sessions/${this.identityProvider}/${this.subject}`;
	            const headers = Object.assign({ 'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8' }, this.requestHeaders);
	            if (sessionsToTerminate.length > 0) {
	                headers['X-Terminate'] = sessionsToTerminate.join(',');
	            }
	            const parameters = this.getMetadata();
	            const body = Object.keys(parameters)
	                .map(key => `${key}=${encodeURIComponent(parameters[key])}`)
	                .join('&');
	            const options = { method: 'POST', headers, body };
	            try {
	                const res = yield this.fetchRequest(requestUrl, options, true);
	                if (!res) {
	                    throw 'fetchRequest failed';
	                }
	                const { sessionId } = res;
	                if (sessionId) {
	                    this.sessionId = sessionId;
	                    loglevel.debug('AdobeConcurrencyMonitorV2.createSession sessionIjson } = res;
	                throw {
	                    status,
	                    json,
	                };
	            }
	            catch (err) {
	                loglevel.error('AdobeConcurrencyMonitorV2.createSession error: ', err);
	                return yield this.handleError(err, false);
	            }
	        });
	    }
	    heartbeat() {
	        return __awaiter(this, void 0, void 0, function* () {
	            const { sessionId } = this;
	            if (!sessionId) {
	                return;
	            }
	            loglevel.debug('AdobeConcurrencyMonitorV2.heartbeat', sessionId);
	            const requestUrl = `${this.serviceUrl}/sessions/${this.identityProvider}/${this.subject}/${sessionId}`;
	            const options = { method: 'POST', headers: this.requestHeaders };
	            try {
	                const res = yield this.fetchRequest(requestUrl, options, false);
	                if (!res) {{ status, json } = res;
	                    throw {
	                        status,
	                        json,
	                    };
	                }
	                this.scheduleHeartbeat();
	            }
	            catch (err) {
	                loglevel.error('AdobeConcurrencyMonitorV2.heartbeat error: ', err);
	                return this.handleError(err, true);
	            }
	        });
	    }
	    scheduleHeartbeat() {
	        loglevel.debug('AdobeConcurrencyMonitorV2.scheduleHeartbeat');
	        clearTimeout(this.heartbeatIntervalId);
	        this.heartbeatIntervalId = window.setTimeout(() => {
	            this.heartbeat();
	        }, 45000);
	    }
	    fetchRequest(requestUrl, options, isSessionRequest) {
	        return __awaiter(this, void 0, void 0, function* () {
	            try {
	                const response = yield fetch(requestUrl, options);
	                const { status } = response;
	                if (!(status >= 200 && status < 300)) {
	                    const json = yield response
	                        .clone()
	                        .json()
	                        .catch(() => !!response.text() || null);
	                    return {
	                        status,
	                        json,
	                        error: true,
	                    };
	                }
	                let sessionId;
	                if (isSessionRequest) {
	                    sessionId = response.headers.get('location').trim();
	                }
	                return {
	                    sessionId,
	                    status,
	                    error: false,
	                };
	            }
	            catch (err) {
	                console.error(`AdobeCM fetchRequest: ${err}`);
	                if (err && err.status === 409 && typeof err.json === 'function') {
	                    const json = yield err.json();
	                    return {
	                        status: 409,
	                        json,
	                        error: true,
	                    };
	                }
	                return err;
	            }
	        });
	    }
	    terminateSession() {
	        return __awaiter(this, void 0, void 0, function* () {
	            const { sessionId } = this;
	            if (!sessionId) {
	                return;
	            }
	            try {
	                const requestUrl = `${this.serviceUrl}/sessions/${this.identityProvider}/${this.subject}/${sessionId}`;
	                const response = yield fetch(requestUrl, { method: 'DELETE', headers: this.requestHeaders });
	                const { status } = response;
	                if (!(status >= 200 && status < 300)) {
	                    throw new Error(`Error - url: ${requestUrl}, status: ${status}`);
	                }
	            }
	            catch (err) {
	                console.error(`AdobeCM TerminateSession ${err}`);
	            }
	        });
	    }
	    handleError(response, shouldShowCustomError) {
	        loglevel.debug('AdobeConcurrencyMonitorV2.handleError', response);
	        const { status, json } = response;
	        switch (status) {
	            case 400:
	                return this.handleError400_(json);
	            case 409:
	                return this.handleError409_(json, shouldShowCustomError);
	            case 410:
	                return this.handleError410_(json, shouldShowCustomError);
	        }
	    }
	    handleError400_(json) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const obligations = (json && json.obligations) || [];
	            const hasRefreshObligation = !!obligations.find((obl) => obl.action === 'logout' || obl.action === 'refresh');
	            if (hasRefreshObligation) {
	                yield AdobeConcurrencyMonitor.fetchMetadataKeys(this.applicationId, this.serviceUrl);
	                const { metadata } = this;
	                if (Object.keys(metadata).length >= this.metadataKeys.length) {
	                    return this.start();
	                }
	            }
	            return null;
	        });
	    }
	    handleError409_(json, shouldShowCustomError) {
	        try {
	           const { message } = advice;
	                const localizedMessage = this.messages[message] || message;
	                const error = new Error(localizedMessage);
	                const obligations = json.obligations || [];
	                const shouldLogout = !!obligations.find((obl) => obl.action === 'logout');
	                loglevel.debug('AdobeConcurrencyMonitorV2.handleError', 409, error, shouldLogout);
	                if (shouldShowCustomError) {
	                    this.onError(error, shouldLogout);
	                }
	                else {
	                    throw error;
	                }
	            }
	        }
	        catch (error) {
	            loglevel.debug(`AdobeConcurrencyMonitorV2.handleError409_: ${error}`);
	            throw error;
	        }
	        return null;
	    }
	    handleError410_(json, shouldShowCustomError) {
	        if (!json) {
	            return this.start();
	        }
	        try {
	            const associatedAdvice = (json && json.associatedAdvice) || [];
	            const advice = associatedAdvice.find((element) => element.type === 'remote-termination');
	            if (advice) {
	                const { message } = advice;
	                const localizedMessage = this.messages[message] || message;
	                const error = new Error(locajson.obligations.find((obl) => obl.action === 'logout');
	                loglevel.debug('AdobeConcurrencyMonitorV2.handleError', 410, error, shouldLogout);
	                if (shouldShowCustomError) {
	                    thi	        }
	        catch (error) {
	            loglevel.debug(`AdobeConcurrencyMonitorV2.handleError410_: ${error}`);
	            throw error;
	        }
	        return null;
	    }
	    getMetadata() {
	        const { metadataKeys } = this;
	        const metadata = metadataKeys.reduce((md, key) => {
	            md[key] = this.metadata[key];
	            return md;
	        }, {});
	        return metadata;
	    }
	    onError(error, shouldLogout) {
	        loglevel.debug('AdobeConcurrencyMonitor.onError');
	        loglevel.debug(`error: ${error}`);
	        loglevel.debug(`shouldLogout: ${shouldLogout}`);
	    }
	}

	var sha256 = createCommonjsModule(function (module, exports) {
	(function (root, factory) {
		{
			// CommonJS
			module.exports = factory(core);
		}
	}(commonjsGlobal, function (CryptoJS) {

		(function (Math) {
		    // Shortcuts
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var Hasher = C_lib.Hasher;
		    var C_algo = C.algo;

		    // Initialization and round constants tables
		    var H = [];
		    var K = [];

		    // Compute constants
		    (function () {
		        function isPrime(n) {
		            var sqrtN = Math.sqrt(n);
		            for (var factor = 2; factor <= sqrtN; factor++) {
		                if (!(n % factor)) {
		                    return false;
		                }
		            }

		            return true;
		        }

		        function getFractionalBits(n) {
		            return ((n - (n | 0)) * 0x100000000) | 0;
		        }

		        var n = 2;
		        var nPrime = 0;
		        while (nPrime < 64) {
		            if (isPrime(n)) {
		                if (nPrime < 8) {
		                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
		                }
		                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

		                nPrime++;
		            }

		            n++;
		        }
		    }());

		    // Reusable object
		    var W = [];

		    /**
		     * SHA-256 hash algorithm.
		     */
		    var SHA256 = C_algo.SHA256 = Hasher.extend({
		        _doReset: function () {
		            this._hash = new WordArray.init(H.slice(0));
		        },

		        _doProcessBlock: function (M, offset) {
		            // Shortcut
		            var H = this._hash.words;

		            // Working variables
		            var a = H[0];
		            var b = H[1];
		            var c = H[2];
		            var d = H[3];
		            var e = H[4];
		            var f = H[5];
		            var g = H[6];
		            var h = H[7];

		            // Computation
		            for (var i = 0; i < 64; i++) {
		                if (i < 16) {
		                    W[i] = M[offset + i] | 0;
		                } else {
		                    var gamma0x = W[i - 15];
		                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
		                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
		                                   (gamma0x >>> 3);

		                    var gamma1x = W[i - 2];
		                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
		                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
		                                   (gamma1x >>> 10);

		                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
		                }

		                var ch  = (e & f) ^ (~e & g);
		                var maj = (a & b) ^ (a & c) ^ (b & c);

		                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
		                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

		                var t1 = h + sigma1 + ch + K[i] + W[i];
		                var t2 = sigma0 + maj;

		                h = g;
		                g = f;
		                f = e;
		                e = (d + t1) | 0;
		                d = c;
		                c = b;
		                b = a;
		                a = (t1 + t2) | 0;
		            }

		            // Intermediate hash value
		            H[0] = (H[0] + a) | 0;
		            H[1] = (H[1] + b) | 0;
		            H[2] = (H[2] + c) | 0;
		            H[3] = (H[3] + d) | 0;
		            H[4] = (H[4] + e) | 0;
		            H[5] = (H[5] + f) | 0;
		            H[6] = (H[6] + g) | 0;
		            H[7] = (H[7] + h) | 0;
		        },

		        _doFinalize: function () {
		            // Shortcuts
		            var data = this._data;
		            var dataWords = data.words;

		            var nBitsTotal = this._nDataBytes * 8;
		            var nBitsLeft = data.sigBytes * 8;

		            // Add padding
		            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
		            data.sigBytes = dataWords.length * 4;

		            // Hash final blocks
		            this._process();

		            // Return final computed hash
		            return this._hash;
		        },

		        clone: function () {
		            var clone = Hasher.clone.call(this);
		            clone._hash = this._hash.clone();

		            return clone;
		        }
		    });

		    /**
		     * Shortcut function to the hasher's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     *
		     * @return {WordArray} The hash.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hash = CryptoJS.SHA256('message');
		     *     var hash = CryptoJS.SHA256(wordArray);
		     */
		    C.SHA256 = Hasher._createHelper(SHA256);

		    /**
		     * Shortcut function to the HMAC's object interface.
		     *
		     * @param {WordArray|string} message The message to hash.
		     * @param {WordArray|string} key The secret key.
		     *
		     * @return {WordArray} The HMAC.
		     *
		     * @static
		     *
		     * @example
		     *
		     *     var hmac = CryptoJS.HmacSHA256(message, key);
		     */
		    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
		}(Math));


		return CryptoJS.SHA256;

	}));
	});

	class AdobeConcurrencyMonitorBuilder {
	    constructor(programmer, applicationId, metadata = {}) {
	        this.programmer = programmer;
	        this.applicationId = applicationId;
	        this.metadata = metadata;
	    }
	    withSession(sesder, mediaItem     = authenticatedProvider && authenticatedProvider.id;
	        this.metadata[MetadataKeys.accountId] = subject;
	        this.metadata[MetadataKeys.channel] = mediaItem.network && mediaItem.network.id;
	        this.metadata[MetadataKeys.contentType] =
	            mediaItem.streamType === MediaItemStreamType$3.live ? ContentType.live : ContentType.vod;
	        this.metadata[MetadataKeys.contractType] = '';
	        this.metadata[MetadataKeys.hba] = session.authenticatedProvider ? session.a this.subject = subject;
	        this.identityProvider = identityProvider;
	        return this;
	    }
locationProvider) {
	        const salt = 'm!ck3ym0u$3';
	        const ip = locationProvider.getPublicIPAddress();
	        this.metadata[MetadataKeys.ship] = ip ? sha256(`${salt}${ip}`) : null;
	        this.metadata[MetadataKeys.region] = locationProvider.getRegion() ? locationProvider.getRegion() : null;
	        return this;
	    }
	    withServiceUrl(serviceUrl) {
	        this.serviceUrl = ser	    }
	    withMessages(messages) {
	        this.messages = messages;
	        return this;
	    }
	    build() {
	        if (!this.subject || !this.identityProvider) {
	            return null;
	        }
	        const monitor = new AdobeConcurrencyMonitor(this.programmer, this.applicationId, this.identityProvider, this.subject, this.metadata);
	        if (this.serviceUrl) {
	            monitor.serviceUrl = this.serviceUrl;
	        }
	        if (this.messages) {
	            monitor.messages = this.messages || {};
	        }
	        return monitor;
	    }
	}

	class ESPNAuthButler {
	    constructor(partner, platform) {
	        this.partner = partner;
	        this.platform = platform;
	    }
	    startSession(url, swid, token, tokenType, resource, advertisingInfo) {
	        const { partner, platform } = this;
	        const params = [
	            `partner=${partner}`,
	            `platform=${platform}`,
	            `token=${encodeURIComponent(token)}`,
	            `tokenType=${tokenType}`,
	            'v=2.0.0',
	            'ttl=21600',
	        ];
	        if (resource) {
	            const base64Resource = encBase64.stringify(encUtf8.parse(resource));
	            params.push(`resource=${encodeURIComponent(base64Resource)}`);
	        }
	        if (advertisingInfo) {
	            Object.keys(advertisingInfo).forEach(key => {
	                params.push(`${key}=${encodeURIComponent(advertisingInfo[key])}`);
	            });
	        }
	        const swidRegExp = /swid=*/g;
	        const containsSwid = params.some(e => swidRegExp.test(e));
	        if (!containsSwid) {
	            params.push(`swid=${encodeURIComponent(swid)}`);
	        }
	        const headers = {
	            'Content-Type': 'application/x-www-form-urlencoded;charset=UTF-8',
	        };
	        const body = params.join('&');
	        const options = { method: 'POST', headers, credentials: 'include', body };
	        return fetch(url, options)
	            .then(response => response.js{
	                throw new Error(json.message || `An unextion}]`);
	           ch(error => {
	            if (error.message) {
	                throw new Error(error.message);
	            }
	            return error.json().then(json => {
	                throw new Error(json.message || `An unexpected error occurred. [${json.abbreviation}]`);
	            });
	        });
	    }
	}

	const buildPlaybackSession = function buildPlaybackSession(json, token) {
	    const { playbackUrl } = json;
	    const session = new PlaybackSession(playbackUrl);
	    session.token = token;
	    return session;
	};
	class StartSessionPlaybackSessionFactory {
	    constructor(authButler) {
	        this.authButler = authButler;
	    }
	    initPlaybackSession(mediaItem, advertisingInfo, authorizationPayload) {
	        let { url } = mediaItem.source;
	        if (mediaItem.source.startSessionUrl && mediaItem.source.type === MediaItemSourceType$2.shield) {
	            url = mediaItem.source.startSessionUrl;
	        }
	        try {
	            const protocol = window && window.location.protocol;
	            if (protocol && protocol === 'https:') {
	                url = url.replace(/^http(s?):/, protocol);
	            }
	        }
	        catch (e) { }
	        const { customData: { token, tokenType, resource = mediaItem.mrss }, } = authorizationPayload;
	        const swid = advertisingInfo && advertisingInfo.swid;
	        const { authButler } = this;
	        if (!authButler) {
	            BreadcrumbsService.setErrorReason('noAuthButler');
	            throw new Error('startSession support not configured');
	        }
	        return (authButler
	            .startSession(url, swid, token, tokenType, resource, advertisingInfo.dictionaryForStartSession())
	            .then(json => {
	            BreadcrumbsService.add(BREADCRUMBS.T_FSS);
	            const session = buildPlaybackSession(json, token);
	            session.mediaItem = mediaItem;
	            session.seekToTime = mediaItem.seekInSeconds;
	            session.authenticationType = authorizationPayload.authenticationType;
	            session.authenticatedProvider = authorizationPayload.authenticatedProvider;
	            session.authenticatedIdentity = authorizationPayload.authenticatedIdentity;
	            return session;
	        })
	            .catch(err => {
	            BreadcrumbsService.add(BREADCRUMBS.T_FSSF);
	            BreadcrumbsService.setErrorReason('startSessionFetchFailed');
	            throw err;
	        }));
	    }
	}

	class NonePlaybackSessionFactory {
	    initPlaybackSession(mediaItem, advertisingInfo, authorizationPayload) {
	        const playbackSession = new PlaybackSession(mediaItem.source.url);
	        playbackSession.mediaItem = mediaItem;
	        playbackSession.seekToTime = mediaItem.seekInSeconds;
	        playbackSession.authenticationType = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticationType;
	        playbackSession.authenticatedProvider = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedProvider;
	        playbackSession.authenticatedIdentity = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedIdentity;
	        return Promise.resolve(playbackSession);
	    }
	}

	const TokenType = {
	    adobePass: 'ADOBEPASS',
	    gatekeeper: 'GATEKEEPER',
	    jwt: 'JWT',
	    authToken: 'AUTHTOKEN',
	};
	const handleErrorResponse = function handleErrorResponse(response) {
	    if (response instanceof Error) {
	        throw response;
	    }
	    return (response.json &&
	        response.json().then(json => {
	            let message = json.message || `An unexpected error occurred. [${json.exception}]`;
	            if (json.exception === 'com.espn.watch.api.AccessDeniedException') {
	                message = 'This content is not available for your package or region.';
	            }
	            throw new Error(message);
	        }));
	};
	const defaultServiceUrl$1 = 'https://watch.auth.api.espn.com';
	class ShieldAPI {
	    constructor(apiKey, serviceUrl) {
	        this.drmSupport = DRMSupport$1.none;
	        this.palEnabled = false;
	        this.palMaxLength = 3000;
	        this.serviceUrl = defaultServiceUrl$1;
	        this.apiKey = apiKey;
	        this.didOverrideServiceUrl = !!serviceUrl;
	        this.serviceUrl = this.didOverrideServiceUrl ? serviceUrl : defaultServiceUrl$1;
	    }
	    getAsset(id, token, tokenType, resource, params) {
	        const url = `${this.serviceUrl}/video/auth/media/${id}/asset`;
	        ret, params);
	    }
	    getAssetForUrl(assetUrl, token, tokenType, resource, params, id) {
	        const parameters = paraeUrl ? `${this === TokenType.adobePass) {
	                parameters.adobeToken = token;
	                if (resource) {
	                    const base64Resource = encBase64.stringify(encUtf8.parse(resource));
	                    parameters.adobeResource = base64Resource;
	                }
	            }
	            else if (tokenType == TokenType.jwt) {
	                headers.Authorization = `Bearer ${token}`;
	            }
	            else if (tokenType == TokenType.authToken) {
	                sep = url.indexOf('?') === -1 ? '?' : '&';
	                url = `${url}${sep}authtoken=${token}`;
	            }
	            else {
	                parameters.token = token;
	            }
	        }
	        parameters.drmSupport = this.drmSupport;
	        const body = Object.ke`)
	 d: 'POST',
	            headers,
	            credentials: 'include',
	            body,
	        };
	        return fetch(url, options)
	            .then(response => {
	            if (!response.ok) {
	                throw response;
	            }
	            return response.json();
	        })
	            .then(json => {
	            if (!json.stream) {
	                const message = json.message || `An unexpected error occurred.`;
	                throw new Error(message);
	            }
	            return json;
	        })
	            .catch(handleErrorResponse);
	    }
	}
	ShieldAPI.defaultServiceUrl = defaultServiceUrl$1;

	const buildPlaybackConfig = function buildPlaybackConfig(streamInfo) {
	    if (!streamInfo) {
	        return null;
	    }
	    const { streamType, licenseAcquisitionUrl: licenseUrl, certificateUrl } = streamInfo;
	    switch (streamType) {
	        case 'DASH_PLAYREADY':
	            return new PlaybackConfig('application/dash+xml', DRMKeySystem.playReady, licenseUrl);
	        case 'DASH_WIDEVINE':
	            return new PlaybackConfig('application/dash+xml', DRMKeySystem.widevine, licenseUrl);
	        case 'HLS_FAIRPLAY':
	            return new PlaybackConfig('application/x-mpegURL', DRMKeySystem.fairPlay, certificateUrl);
	        case 'HLS':
	            return new PlaybackConfig('application/x-mpegURL', DRMKeySystem.none);
	        default:
	            return null;
	    }
	};
	const buildTextTracks = function buildTextTracks(captions) {
	    if (!captions) {
	        return [];
	    }
	    const track = {
	        source: captions,
	    };
	    if (captions.endsWith('.vtt')) {
	        track.contentType = 'text/vtt';
	    }
	    return [track];
	};
	class ShieldPlaybackSessionFactory {
	    constructor(shieldAPI) {
	        this.shieldAPI = shieldAPI;
	    }
	    initPlaybackSession(mediaItem, advertisingInfo, authorizationPayload) {
	        var _a;
	        return __awaiter(this, void 0, void 0, function* () {
	            const { shieldAPI } = this;
	            if (!shieldAPI) {
	                BreadcrumbsService.setErrorReason('noShieldFetchAPI');
	                throw new Error('shield support not configured');
	            }
	            const { palEnabled, palMaxLength } = shieldAPI;
	            const token = authorizationPayload.customData.token;
	            const zipcode = authorizationPayload.customData.zipcode;
	            const { customData: { tokenType, resource = mediaItem.mrss } = {} } = authorizationPayload;
	            if (palEnabled && advertisingInfo.palNonce === null) {
	                try {
	                    advertisingInfo.palNonce = yield AdvertisingInfo.getGooglePalNonce(advertisingInfo, palMaxLength);
	                }
	                catch (err) {
	                    console.warn(err);
	                }
	            }
	            const parameters = this.getAdParams_(advertisingInfo, (_a = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.advertisingInfo) === null || _a === void 0 ? void 0 : _a.adConfigType, zipcode);
	            const url = mediaItem.source.url;
	            try {
	                const json = yield shieldAPI.getAssetForUrl(url, token, tokenType, resource, parameters, mediaItem.id);
	                BreadcrumbsService.add(BREADCRUMBS.T_FSH);
	                const { stream, captions, streamInfo, gatekeeperToken } = json;
	                const session = new PlaybackSession(stream);
	                session.mediaItem = mediaItem;
	                session.seekToTime = mediaItem.seekInSeconds;
	                session.authenticationType = authorizationPayload.authenticationType;
	                session.authenticatedProvider = authorizationPayload.authenticatedProvider;
	                session.authenticatedIdentity = authorizationPayload.authenticatedIdentity;
	                session.token = gatekeeperToken;
	                session.playbackConfig = buildPlaybackConfig(streamInfo);
	                session.textTracks = buildTextTracks(captions);
	                return session;
	            }
	            catch (err) {
	                BreadcrumbsService.add(BREADCRUMBS.T_FSHF);
	                BreadcrumbsService.setErrorReason('shieldFetchFailed');
	                throw err;
	            }
	        });
	    }
	    getAdParams_(advertisingInfo, adConfigType, zipcode) {
	        let parameters = null;
	        if (adConfigType === AdConfigType.immutable) {
	            parameters = advertisingInfo;
	        }
	        else {
	            parameters = advertisingInfo.dictionaryForStartSession();
	            if (zipcode) {
	                parameters.zipcode = zipcode;
	            }
	        }
	        return parameters;
	    }
	}

	const checkAuthorizationWithAuthorizers = function checkAuthorizationWithAuthorizers(mediaItem, advertisingInfo, authorizers, errors = []) {
	    const authorizer = authorizers.shift();
	    return (authorizer
	        .checkAuthorization(mediaItem, advertisingInfo)
	        .then(result => {
	        const { success } = result;
	        if (success) {
	            return result;
	        }
	        if (authorizers.length < 1) {
	            if (errors.length > 0) {
	                return Promise.reject(null);
	            }
	            return result;
	        }
	        return checkAuthorizationWithAuthorizers(mediaItem, advertisingInfo, authorizers, errors);
	    })
	        .catch((error) => {
	        if (authorizers.length > 0) {
	            if (error) {
	                errors.push(error);
	            }
	            return checkAuthorizationWithAuthorizers(mediaItem, advertisingInfo, authorizers, errors);
	        }
	        const throwable = errors[0] || error;
	        if (throwable) {
	            throw throwable;
	        }
	    }));
	};

	class AuthenticationManager {
	    constructor() {
	        this.partner = null;
	        this.platform = null;
	        this.apiKey = null;
	        this.deviceId = null;
	        this.authenticators = {};
	        this.iaItemSourceType$4.none] = new NonePlaybackSessionFactory();
	    }
	    getAuthenticator(type) {
	        return this.authenticators[type];
	    }
	    setAuthenticator(authenticator, authenticationType) {
	        const array = this.convertToArray(authenticationType);
	        array.forEach((value) => {
	            this.authenticators[value.toString()] = authenticator;
	        });
	    }
	    getAuthorizer(type) {
	        return this.authorizers[type];
	    }
	    setAuthorizer(authorizer, authenticationType) {
	        const array = this.convertToArray(authenticationType);
	        array.forEach((value) => {
	            this.authorizers[value.toString()] = authorizer;
	        });
	    }
	    getPlaybackSessionFactory(type) {
	        return this.playbackSessionFactories[type];
	    }
	    setPlaybackSessionFactory(factory, type) {
	        this.playbackSessionFactories[type] = factory;
	    }
	    checkAuthentication() {
	        const promises = Object.keys(this.authenticators).map(key => {
	            const authenticator = this.authenticators[key];
	            return authenticator
	                .checkAuthentication()
	                .then(result => {
	                loglevel.debug(`${key} authenticator`, `isAuthenticated: ${result}`, `authenticatedProvider: ${authenticator.authenticatedProvider}`);
	                return result;
	            })
	                .catch(() => {
	                return false;
	            });
	        });
	        return Promise.all(promises).then(results => {
	            return results.every(result => result === true);
	        });
	    }
	    isAuthenticatedForMediaItem(mediaItem) {
	        if (mediaItem.authenticationTypes.length < 1 ||
	            mediaItem.authenticationTypes.indexOf(MediaItemAuthenticationType$5.none) !== -1) {
	            return true;
	        }
	        const authenticators = mediaItem.authenticationTypes
	            .map(authType => this.authenticators[authType])
	            .filter(authenticator => authenticator);
	        return authenticators.some(authenticator => authenticator.isAuthenticated);
	    }
	    isAuthenticatedWithAuthType(authenticationType) {
	        const authenticator = this.authenticators[authenticationType];
	        if (!authenticator) {
	            return false;
	        }
	        return authenticator.isAuthenticated;
	    }
	    authenticateWithAuthType(authType, options) {
	        const authenticator = this.authenticators[authType];
	        if (!authenticator) {
	            return;
	        }
	        return authenticator.authenticate(options);
	    }
	    checkAuthorization(mediaItem, advertisingInfo) {
	        var _a, _b;
	        BreadcrumbsService.add(BREADCRUMBS.CAZ);
	        if (((mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.authenticationTypes) &&
	            Array.isArray(mediaItem.authenticationTypes) &&
	            mediaItem.authenticationTypes.length < 1) ||
	            mediaItem.authenticationTypes.indexOf(MediaItemAuthenticationType$5.none) !== -1) {
	            BreadcrumbsService.add(BREADCRUMBS.CAN_T.replace('T', MediaItemAuthenticationType$5.none));
	            BreadcrumbsService.add(BREADCRUMBS.CAZ_T.replace('T', MediaItemAuthenticationType$5.none));
	            const provider = new AuthenticatedProvider(mediaItem.id, mediaItem.title, ((_b = (_a = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.images) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.url) || '', mediaItem.source.url);
	            const payload = new AuthorizationPayload(MediaItemAuthenticationType$5.none, provider, mediaItem.id, {});
	            const result = new AuthorizationResult(true, payload);
	            return Promise.resolve(result);
	        }
	        const authTypes = [
	            MediaItemAuthenticationType$5.open,
	            MediaItemAuthenticationType$5.mvpd,
	            MediaItemAuthenticationType$5.direct,
	            MediaItemAuthenticationType$5.isp,
	        ].filter(authType => mediaItem.authenticationTypes.indexOf(authType) !== -1);
	        const authorizers = authTypes
	            .map(authType => this.authorizers[authType])
	            .filter(authorizer => authorizer && authorizer.checkAuthorization);
	        loglevel.debug('mediaItem.authTypes:', authTypes);
	        if (authorizers.length === 0) {
	            return Promise.reject(new Error(`no authorizer configured to support authTypes: ${mediaItem.authenticationTypes}`));
	        }
	        return checkAuthorizationWithAuthorizers(mediaItem, advertisingInfo, authorizers);
	    }
	    initPlaybackSession(mediaItem, advertisingInfo) {
	        if (!mediaItem.source.type && mediaItem.authenticationTypes.length > 0) {
	            BreadcrumbsService.setErrorReason('missingMediaSourceType');
	            return Promise.reject(new Error('This event is not currently available.'));
	        }
	        return this.checkAuthorization(mediaItem, advertisingInfo).then(result => {
	            var _a, _b, _c, _d, _e, _f;
	            loglevel.debug('AuthenticationManager.initPlaybackSession.checkAuthorization result:', result.success);
	            const { success, payload } = result;
	            if (!success) {
	                BreadcrumbsService.setErrorReason('notAuthorized');
	                throw new Error('Not authorized.');
	            }
	            if (!((_a = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.source) === null || _a === void 0 ? void 0 : _a.type)) {
	                BreadcrumbsService.setErrorReason('missingMediaSourceType');
	                throw new Error('Media Item source type is missing.');
	            }
	            const playbackSessionFactory = this.playbackSessionFactories[(_b = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.source) === null || _b === void 0 ? void 0 : _b.type];
	            if (!playbackSessionFactory) {
	                BreadcrumbsService.setErrorReason('missingMediaSourceType');
	                throw new Error(`SessionFactory for source type \'${(_c = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.source) === null || _c === void 0 ? void 0 : _c.type}\' is missing.`);
	            }
	            const adInfo = this.getAdInfo_((_d = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.advertisingInfo) === null || _d === void 0 ? void 0 : _d.adConfigType, advertisingInfo, (_f = (_e = result === null || result === void 0 ? void 0 : result.payload) === null || _e === void 0 ? void 0 : _e.authenticatedProvider) === null || _f === void 0 ? void 0 : _f.id);
	            BreadcrumbsService.add(BREADCRUMBS.MPS);
	            return playbackSessionFactory.initPlaybackSession(mediaItem, adInfo, payload).then((playbackSession) => {
	                loglevel.debug('AuthenticationManager.initPlaybackSession', playbackSession);
	                const monitor = this.concurrencyMonitorBuilder && this.concurrencyMonitorBuilder.withSession(playbackSession).build();
	                if (!monitor) {
	                    return playbackSession;
	                }
	                return monitor
	                    .createSession()
	                    .then(concurrencySessionId => {
	                    BreadcrumbsService.add(BREADCRUMBS.CM_I);
	                    playbackSession.concurrencyMonitorSessionId = concurrencySessionId;
	                    return playbackSession;
	                })
	                    .catch(err => {
	                    BreadcrumbsService.add(BREADCRUMBS.CM_IF);
	                    BreadcrumbsService.setErrorReason('concurrencyInitializationFailed');
	                    throw err;
	                });
	            });
	        });
	    }
	    getAdInfo_(adConfigType, advertisingInfo, authenticatedProviderId) {
	        let adInfo = null;
	        if (adConfigType === AdConfigType.immutable) {
	            adInfo = advertisingInfo;
	        }
	        else {
	            adInfo = new AdvertisingInfo();
	            adInfo.authenticationProvider = authenticatedProviderId;
	            adInfo.merge(advertisingInfo);
	        }
	        return adInfo;
	    }
	    get authStates() {
	        const mvpdAuthenticator = this.authenticators[MediaItemAuthenticationType$5.mvpd];
	        const ispAuthenticator = this.authenticators[MediaItemAuthenticationType$5.isp];
	        const states = [];
	        if (ispAuthenticator.isAuthenticated) {
	            states.push('isp');
	        }
	        if (mvpdAuthenticator.isAuthenticated === true) {
	            states.push('mvpd_login');
	        }
	        else if (mvpdAuthenticator.wasPreviouslyAuthenticated === true) {
	            states.push('mvpd_previous');
	        }
	        return states;
	    }
	    get preauthorizedResources() {
	        return Object.keys(this.authenticators)
	            .map(key => this.authenticators[key].preauthorizedResources)
	            .reduce((array, values) => {
	            return array.concat(values);
	        }, [])
	            .filter((value, index, array) => array.indexOf(value) === index);
	    }
	    get primaryAuthenticatedProvider() {
	        return [MediaItemAuthenticationType$5.mvpd, MediaItemAuthenticationType$5.isp]
	            .map(authType => this.getAuthenticator(authType))
	            .filter(authenticator => authenticator.isAuthenticated)
	            .map(authenticator => authenticator.authenticatedProvider)[0];
	    }
	    convertToArray(value) {
	        if (!value)
	            return [];
	        let array = [];
	        if (Array.isArray(value)) {
	            array = value;
	        }
	        else if (typeof value == 'string') {
	            array.push(value);
	        }
	        return array;
	    }
	}
	AuthenticationManager.AuthenticateOptionsKey = {
	    redirectUrl: 'redirectUrl',
	};

	class PayloadAuthenticator {
	    constructor() {
	        this.preauthorizedResources = [];
	        this.isAuthenticated = !!this.authorizationPayload;
	        this.authenticatedIdentity = this.authorizationPayload && this.authorizationPayload.authenticatedIdentity;
	        this.authenticatedProvider = this.authorizationPayload && this.authorizationPayload.authenticatedProvider;
	    }
	    checkAuthentication() {
	        return Promise.resolve(this.isAuthenticated);
	    }
	    authenticate() {
	        return this.checkAuthentication();
	    }
	    deauthenticate() {
	        this.authorizationPayload = null;
	        return Promise.resolve(true);
	    }
	    checkAuthorization(mediaItem) {
	        const result = new AuthorizationResult(true, this.authorizationPayload);
	        BreadcrumbsService.add(BREADCRUMBS.CAN_T.replace('T', this.authorizationPayload.aonPayload.authenticationType));
	        if (mediaItem &&
	            (mediaItem.authenticationTypes.length == 0 ||
	                mediaItem.authenticationTypes.indexOf(MediaItemAuthenticationType$5.none) !== -1)) {
	            return Promise.resolve(result);
	        }
	        else if (!this.authorizationPayload ||
	            !this.mediaItem ||
	            this.mediaItem.id !== mediaItem.id ||
	            mediaItem.authenticationTypes.indexOf(this.authorizationPayload.authenticationType) === -1) {
	            return Promise.resolve(new AuthorizationResult(false, this.authorizationPayload));
	        }
	        else {
	            return Promise.resolve(result);
	        }
	    }
	}

	class Configuration$1 {
	    constructor(serviceUrl, appVersion, appName, deviceID, palEnabled = false) {
	        this.serviceUrl = serviceUrl;
	        this.appVersion = appVersion;
	        this.appName = appName;
	        this.deviceID = deviceID;
	        this.palEnabled = palEnabled;
	    }
	}
	const defaultServiceUrl = 'https://prod.gatekeeper.us-abc.symphony.edgedatg.go.com/vp2/ws-secure/entitlement/2020/playmanifest_secure.json';
	const defaultAppVersion = '1.0.0';
	const defaultAppName = '';
	const defaultDeviceID = '001';
	const defaultConfiguration = new Configuration$1(defaultServiceUrl, defaultAppVersion, defaultAppName, defaultDeviceID);

	var MediaItemMediaCommand;
	(function (MediaItemMediaCommand) {
	    MediaItemMediaCommand[MediaItemMediaCommand["all"] = 0] = "all";
	    MediaItemMediaCommand[MediaItemMediaCommand["linearPlayback"] = 1] = "linearPlayback";
	})(MediaItemMediaCommand || (MediaItemMediaCommand = {}));

	var MediaItemNetworkType;
	(function (MediaItemNetworkType) {
	    MediaItemNetworkType["linear"] = "linear";
	    MediaItemNetworkType["event"] = "event";
	})(MediaItemNetworkType || (MediaItemNetworkType = {}));

	var MediaItemSourceVariant;
	(function (MediaItemSourceVariant) {
	    MediaItemSourceVariant["stitchedPreroll"] = "stitchedPreroll";
	})(MediaItemSourceVariant || (MediaItemSourceVariant = {}));

	var MediaItemStreamType;
	(function (MediaItemStreamType) {
	    MediaItemStreamType["live"] = "live";
	    MediaItemStreamType["onDemand"] = "onDemand";
	})(MediaItemStreamType || (MediaItemStreamType = {}));
	var MediaItemStreamType$1 = MediaItemStreamType;

	var MediaItemTrackingType;
	(function (MediaItemTrackingType) {
	    MediaItemTrackingType["nielsen"] = "nielsen";
	    MediaItemTrackingType["comscore"] = "comscore";
	    MediaItemTrackingType["conviva"] = "conviva";
	    MediaItemTrackingType["heartbeats"] = "heartbeats";
	})(MediaItemTrackingType || (MediaItemTrackingType = {}));

	var MediaItemEntityType;
	(function (MediaItemEntityType) {
	    MediaItemEntityType["shortform"] = "shortform";
	    MediaItemEntityType["longform"] = "longform";
	})(MediaItemEntityType || (MediaItemEntityType = {}));
	var MediaItemEntityType$1 = MediaItemEntityType;

	var MediaItemType;
	(function (MediaItemType) {
	    MediaItemType["audio"] = "audio";
	    MediaItemType["video"] = "video";
	})(MediaItemType || (MediaItemType = {}));

	var ApiSource;
	(function (ApiSource) {
	    ApiSource["pluto"] = "pluto";
	    ApiSource["graphQL"] = "graphQL";
	    ApiSource["cfa"] = "cfa";
	    ApiSourceAuthenticationType;
	(function (MediaItemAuthenticationType) {
	    MediaItemAuthenticationType["open"] = "OPEN";
	    MediaItemAuthenticationType["direct"] = "DIRECT";
	    MediaItemAuthenticationType["mvpd"] = "MVPD";
	    MediaItemAuthenticationType["isp"] = "ISP";
	    MediaItemAuthenticationType["none"] = "NONE";
	})(MediaItemAuthenticationType || (MediaItemAuthenticationType = {}));
	var MediaItemAuthenticationType$1 = MediaItemAuthenticationType;

	var MediaItemSourceType;
	(function (MediaItemSourceType) {
	    MediaItemSourceType["none"] = "none";
	    MediaItemSourceType["startSession"] = "startSession";
	    MediaItemSourceType["bam"] = "bam";
	    MediaItemSourceType["shield"] = "shield";
	    MediaItemSourceType["entitlement"] = "entitlement";
	})(MediaItemSourceType || (MediaItemSourceType = {}));

	const defaultGraphQLServiceUrl = 'https://watch.graph.api.espn.com/api';
	const defaultGraphQLApiKey = 'd15c5790-7cb0-4fe1-8782-25f4698d0739';
	const defaultGraphQLNetworkSortOrder = [
	    'espn_ppv',
	    'espn_dtc',
	    'espn1',
	    'espn2',
	    'espn3',
	    'espnu',
	    'sec',
	    'espnews',
	    'espndeportes',
	    'longhorn',
	    'goalline',
	    'buzzerbeater',
	    'secplus',
	    'acc',
	    'accextra',
	    'espn_free',
	    'bam_dtc',
	];
	const defaultItemFeedServiceUrl = 'https://abcnews.go.com/video/itemfeed';
	class Configuration {
	    const serviceUrl || defaultGraphQLServiceUrl;
	            this.apiKey = apiKey || defaultGraphQLApiKey;
	            this.networkSortOrder = networkSortOrder || defaultGraphQLNetworkSortOrder;
	        }
	        else if (apiSource === ApiSource$1.cfa) {
	            this.apiSource = apiSource;
	            this.serviceUrl = serviceUrl;
	        }
	        else if (apiSource === ApiSource$1.itemFeed) {
	            this.serviceUrl = serviceUrl || defaultItemFeedServiceUrl;
	        }
	    }
	}

	new Configuration(ApiSource$1.graphQL);

	Object.freeze({});
	Object.freeze({});
	ApiSource$1.itemFeed;

	new Configuration(ApiSource$1.itemFeed);

	class EntitlementPlaybackSessionFactory {
	    constructor(configuration = defaultConfiguration) {
	        this.configuration_ = configuration;
	    }
	    initPlaybackSession(mediaItem, advertisingInfo, authorizationPayload) {
	        var _a;
	        const queryParameters = {
	            brand: this.getBrandID(mediaItem),
	            device: this.configuration_.deviceID,
	        };
	        const videoType = this.videoTypeFromMedia(mediaItem);
	        const affiliate = this.getAffiliateFromAbcotvAndAbcLive(mediaItem, videoType);
	        if (affiliate) {
	            queryParameters['affiliate'] = affiliate;
	        }
	        queryParameters['app_name'] = this.configuration_.appName;
	        queryParameters['video_type'] = videoType;
	        queryParameters['video_id'] = mediaItem.id;
	        queryParameters['ad.us_privacy'] = advertisingInfo.usPrivacy;
	        queryParameters['d_us_privacy'] = advertisingInfo.usPrivacy;
	        queryParameters['ad.rdp'] = advertisingInfo.rdp ? advertisingInfo.rdp : advertisingInfo.usPrivacy === '1YYY' ? '1' : null;
	        queryParameters['ad.hl'] = advertisingInfo.hl;
	        queryParameters['lang'] = advertisingInfo.hl;
	        queryParameters['ad.npa'] = advertisingInfo.npa;
	        queryParameters['isMute'] = advertisingInfo.isMute;
	        queryParameters['isAutoplay'] = advertisingInfo.isAutoplay;
	        if (authorizationPayload.authenticationType == MediaItemAuthenticationType$1.mvpd) {
	            queryParameters['resource_id'] = mediaItem.mrss;
	            queryParameters['adobe_requestor_id'] =
	                (authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.requestor]) || ((_a = mediaItem.brand) === null || _a === void 0 ? void 0 : _a.toUpperCase());
	            const tokenType = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.tokenType];
	            queryParameters['token_type'] = tokenType == 'ADOBEPASS' ? 'ap' : tokenType;
	            queryParameters['token'] = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.token];
	            queryParameters['zipcode'] = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.zipcode];
	            queryParameters['mvpd'] =
	                (authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedProvider.id) || (authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.customData[AuthorizationPayload.CustomDataKey.mvpd]);
	            queryParameters['locale'] = mediaItem.locale;
	            queryParameters['dmm.schema.ads'] = advertisingInfo.dmm;
	            queryParameters['ad.timedmeta'] = advertisingInfo.adTimedmeta;
	            queryParameters['tvid'] = advertisingInfo.tvid;
	            queryParameters['chan'] = advertisingInfo.chan;
	            queryParameters['userAgent'] = advertisingInfo.userAgent;
	            queryParameters['description_url'] = advertisingInfo.descriptionUrl;
	            queryParameters['affiliate'] = advertisingInfo.aff;
	            queryParameters['deviceOS'] = advertisingInfo.deviceOS;
	            queryParameters['deviceType'] = advertisingInfo.deviceType;
	            queryParameters['vps'] = advertisingInfo.videoPlayerSize;
	            queryParameters['fcap'] = advertisingInfo.fcap;
	            queryParameters['dssab'] = 0;
	        }
	        const headers = {
	            appversion: this.configuration_.appVersion,
	            Accept: 'application/json',
	            'Content-Type': 'application/x-www-form-urlencoded',
	        };
	        return this.requestPalNonce_(advertisingInfo).then(palToken => {
	            const formData = this.getFormData_(queryParameters);
	            if (palToken) {
	                formData.append('ad.paln', palToken);
	            }
	            const body = String(queryParameters['token_type']).indexOf('offsite') > -1 ? formData.toString().replace(/%2B/g, '+') : formData;
	            const options = {
	                method: 'POST',
	                headers: headers,
	                body: body,
	            };
	            return fetch(this.configuration_.serviceUrl, options)
	                .then(response => {
	                if (!response.ok) {
	                    BreadcrumbsService.add(BREADCRUMBS.T_FEF);
	                    BreadcrumbsService.setErrorReason('entitlementFetchFailed');
	                    throw response;
	                }
	                BreadcrumbsService.add(BREADCRUMBS.T_FE);
	                return response.json();
	            })
	                .then(json => {
	                const playbackSession = this.entitlementPlaybackSessionFromResponse(json);
	                playbackSession.mediaItem = mediaItem;
	                playbackSession.authenticationType = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticationType;
	                playbackSession.authenticatedProvider = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedProvider;
	                playbackSession.authenticatedIdentity = authorizationPayload === null || authorizationPayload === void 0 ? void 0 : authorizationPayload.authenticatedIdentity;
	                return playbackSession;
	            });
	        });
	    }
	    getBrandID(mediaItem) {
	        const brand = mediaItem.brand;
	        if (mediaItem.brand === 'abcotv') {
	            return mediaItem.siteBrandId;
	        }
	        return brandLegacyId(getBrandFromString(brand));
	    }
	    videoTypeFromMedia(mediaItem) {
	        if (mediaItem.streamType == MediaItemStreamType$1.live) {
	            return 'live';
	        }
	        else if (mediaItem.streamType == MediaItemStreamType$1.onDemand && mediaItem.entityType == MediaItemEntityType$1.shortform) {
	            return 'sf';
	        }
	        else if (mediaItem.streamType == MediaItemStreamType$1.onDemand && mediaItem.entityType == MediaItemEntityType$1.longform) {
	            return 'lf';
	        }
	    }
	    getAffiliateFromAbcotvAndAbcLive(mediaItem, videoType) {
	        var _a, _b;
	        const brand = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.brand;
	        if (((_a = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.network) === null || _a === void 0 ? void 0 : _a.affiliate) && brand === 'abcotv') {
	            return mediaItem.network.affiliate;
	        }
	        if (((_b = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.network) === null || _b === void 0 ? void 0 : _b.id) && brand === 'abc' && videoType == 'live') {
	            return mediaItem.network.id;
	        }
	        return null;
	    }
	    entitlementPlaybackSessionFromResponse(json) {
	        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
	        if ((_a = json.entitlement) === null || _a === void 0 ? void 0 : _a.errors) {
	            const error = json.entitlement.errors.errors[0];
	            throw new Error(error.message);
	        }
	        const playbackUrl = ((_d = (_c = (_b = json.video) === null || _b === void 0 ? void 0 : _b.assets) === null || _c === void 0 ? void 0 : _c.asset[0]) === null || _d === void 0 ? void 0 : _d.value) || ((_h = (_g = (_f = (_e = json.channels) === null || _e === void 0 ? void 0 : _e.channel[0]) === null || _f === void 0 ? void 0 : _f.assets) === null || _g === void 0 ? void 0 : _g.asset[0]) === null || _h === void 0 ? void 0 : _h.value);
	        const playbackSession = new PlaybackSession(playbackUrl);
	        let playbackConfig;
	        if ((_j = json.entitlement) === null || _j === void 0 ? void 0 : _j.drmData) {
	            const drmData = (_k = json.entitlement) === null || _k === void 0 ? void 0 : _k.drmData;
	            switch (drmData.drmEncoding) {
	                case 'WIDEVINE':
	                    playbackConfig = new PlaybackConfig('application/dash+xml', DRMKeySystem$1.widevine, drmData.licenseUrl);
	                    break;
	                case 'FAIRPLAY':
	                    playbackConfig = new PlaybackConfig('application/x-mpegURL', DRMKeySystem$1.fairPlay, drmData.licenseUrl);
	                    break;
	                case 'PLAY_READY':
	                    playbackConfig = new PlaybackConfig('application/dash+xml', DRMKeySystem$1.playReady, drmData.licenseUrl);
	                    break;
	            }
	        }
	        else {
	            playbackConfig = new PlaybackConfig('application/x-mpegURL', DRMKeySystem$1.none, null);
	        }
	        playbackSession.playbackConfig = playbackConfig;
	        return playbackSession;
	    }
	    requestPalNonce_(advertisingInfo) {
	        if (this.configuration_.palEnabled && advertisingInfo.palNonce === null) {
	            return AdvertisingInfo.getGooglePalNonce(advertisingInfo).catch(err => {
	                console.warn(err);
	                return null;
	            });
	        }
	        return Promise.resolve(advertisingInfo.palNonce);
	    }
	    getFormData_(params) {
	        const formData = new URLSearchParams();
	        Object.keys(params).forEach(key => {
	            if (params[key] != undefined) {
	                formData.append(key, params[key]);
	            }
	        });
	        return formData;iceUrl,
	    platform = 'web',
	    applicationId = '3bfbbbdf-be8e-40be-9540-97a73469ada2',
	    programmer = 'ESPN'
	  } = configOptions;
	  const metadata = {
	    [MetadataKeys.applicationId]: applicationId,
	    [MetadataKeys.applicationPlatform]: platform,
	    [MetadataKeys.deviceModel]: '',
	    [MetadataKeys.mobileDevice]: 'false',
	    [MetadataKeys.programmerName]: programmer
	  };
	  const builder = new AdobeConcurrencyMonitorBuilder(programmer, applicationId, metadata);
	  if (serviceUrl) {
	    builder.withServiceUrl(serviceUrl);
	  }
	  if (messages) {
	    builder.withMessages(messages);
	  }
	  return builder;
	}

	const defaultAuthPayload = new AuthorizationPayload(MediaItemAuthenticationType$c.none, null, null, null);
	class AuthorizationService {
	  constructor(configs) {
	    this.drmSupport_ = null;
	    this.authorizationPayload = defaultAuthPayload;
	    const {
	      authorizationPayload
	    } = configs;
	    this.setAuthorizationPayload(authorizationPayload);
	    this.setAuthorizationPayload = this.setAuthorizationPayload.bind(this);
	    this.getAuthenticationManager = this.getAuthenticationManager.bind(this);
	  }
	  setAuthorid = pal.shield;
	    this.drmSupport_ = shieldAPI.drmSupport;
	    const authButler = new ESPNAuthButler(partner, platform);
	    const {
	      authenticationType,
	      customData
	    } = this.authorizationPayload || {};
	    const tokenType = customData === null || customData === void 0 ? void 0 : customData.tokenType;
	    if (this.authorizationPayload && !authenticationType) {
	      this.authorizationPayload.authenticationType = getAuthenticationType(mediaItem, tokenType);
	    }
	    const payloadAuthenticator = new PayloadAuthenticator();
	    payloadAuthenticator.authorizationPayload = this.authorizationPayload;
	    payloadAuthenticator.mediaItem = mediaItem;
	    const allAuthenticationTypes = [MediaItemAuthenticationType$c.mvpd, MediaItemAuthenticationType$c.isp, MediaItemAuthenticationType$c.open, MediaItemAuthenticationType$c.none];
	    const shieldFactory = new ShieldPlaybackSessionFactory(shieldAPI);
	    const startSessionFactory = new StartSessionPlaybackSessionFactory(authButler);
	    const clipFamentConfiguration);
	    const authenticationManager = new AuthenticationManager();
	    authenticationManager.setAuthenticator(payloadAuthenticator, allAuthenticationTypes);
	    authenticationManager.setAuthorizer(payloadAuthenticator, allAuthenticationTypes);
	    authenticationManager.setPlaybackSessionFactory(shieldFactory, MediaItemSourceType$a.shield);
	    authenticationManager.setPlaybackSessionFactory(startSessionFactory, MediaItemSourceType$a.startSession);
	    authenticationManager.setPlaybackSessionFactory(clipFactory, MediaItemSourceType$a.none);
	    authenticationManager.setPlaybackSessionFactory(entitlementSessionFactory, MediaItemSourceType$a.entitlement);
	    authenticationManager.concurrencyMonitorBuilder = getAdobeCMBuilder(concurrencyMonitor);
	    return authenticationManager;
	  }
ement_ = null;
	    this.configs_ = configs;
	    this.removePlayerCSSFromDom = this.removePlayerCSSFromDom.bind(this);
	    this.updateCrossOrigin = this.updateCrossOrigin.bind(this);
	  }
	  get element() {
	    return this.element_;
	  }
	  set element(value) {
	    this.element_ = value;
	  }
	..newConfig
	    };
	  }
	  createEl(element) {
	    const {
	      configs_: {
	        isAudio,
	        brand = 'espn',
	        theme,
	        language = 'en',
	        iphoneplaysinline,
	        enableDRM
	      } = {}
	    } = this;
	    const elementType = isAudio ? 'audio' : 'video';
	    const mode = theme ? ` ${theme}` : '';
	    const brandedClassNames = isAudio ? `branded audio ${brand}-audio${mode}` : `video ${brand}-video${mode}`;
	    const drmClassName = enableDRM ? ' enabled-drm' : '';
	    this.element_ = element.tagName.toLowerCase() === elementType ? element : document.createElement(elementType);
	    this.element_.controls = true;
	    this.element_.preload = 'metadata';
	    this.element_.className = `evp-player video-js ${brandedClassNames}${drmClassName}`;
	    this.element_.setAttribute('crossorigin', 'anonymous');

	    // Allow skippable ads to play inline on iPhone
	    // https://support.brightcove.com/advertising-ima3-plugin?bp#skippable-ads
	    if (iphoneplaysinline && IS_IOS && IS_IPHONE) {
	      this.element_.setAttribute('playsinline', true);
	    }
	    this.element_.setAttribute('lang', language);

	    // Add the element to the DOM
	    if (element.tagName.toLowerCase() !== elementType && element.parentNode) {
	      // Reset DOM before inserting new content
	      element.parentNode.replaceChild(this.element_, element);
	    }
	  }
	  removePlayerCSSFromDom() {
	    const cssEl = document.getElementById('web_player_css');
	    if (cssEl) {
	      document.head.removeChild(cssEl);
	    }
	  }
	  updateCrossOrigin(useCORS) {
	    if (!IS_CHROME) {
	      if (IS_IOS && IOS_VERSION === '11' && useCORS) {
	        this.element_.crossOrigin = 'use-credentials';
	      } else {
	        this.element_.crossOrigin = undefined;
	      }
	    }
	  }
	}

	class PlayerErrorUI {
	  constructor(coordinator) {
	    this.defaultErrorMessage = '';
	    this.defaultErrorRetryMessage = '';
	    this.retriesCount_ = 0;
	    this.retryButton_ = document.createElement('button');
	    this.onRetryButtonClickedCallback_ = null;
	    this.coordinator = coordinator;
	    this.retryButton_.classList.add('try-again-button');
	    this.retryButton_.tabIndex = 1;
	    this.onRetryButtonClicked_ = this.onRetryButtonClicked_.bind(this);
	    this.showCustomErrorContent = this.showCustomErrorContent.bind(this);
	    this.setErrorsMessages = this.setErrorsMessages.bind(this);
	    if (this.coordinator) {
	      this.coordinator.addEventListener(Sr.addEventListe retryButton() {
	    return this.retryButton_;
	  }
	  setErrorsMessages({
	    retryButtonMessage,
	    defaultErrorMessage,
	    defaultErrorRetryMessage
	  }) {
	    this.retryButton_.innerText = retryButtonMessage;
	    this.defaultErrorMessage = defaultErrorMessage;
	    this.defaultErrorRetryMessage = defaultErrorRetryMessage;
	  }
	  onRetryButtonClicked_(e) {
	    const bounds = this.retryButton.getClientRects()[0];
	    if (e.clientX > bounds.x && e.clientX < bounds.x + bounds.width && e.clientY > bounds.y && e.clientY < bounds.y + bounds.height) {
	      this.retriesCount_ += 1;
	      if (typeof this.onRetryButtonClickedCallback_ === 'function') {
	        this.onRetryButtonClickedCallback_();
	      }
	    }
	  }
	  showCustomErrorContent({
	    content,
	    value,
	    showRetryButton,
	    context
	  }) {
	    const {
	      player,
	      onRetryRequested,
	      onFatalErrorDisposePlayer
	    } = context;
	    if (!content || !player) {
	      return;
	    }
	    if (typeof onRetryRequested === 'function') {
	      this.onRetryButtonClickedCallback_ = onRetryRequested;
	    }
	    const modal = player.getChild('errorDisplay');
	    if (typeof modal.el === 'function') {
	      modal.el().removeEventListener('click', this.onRetryButtonClicked_);
	    }
	    let modalContent;

	    // Check if content is HTML
	    if (content.nodeName) {
	      modalContent = content;
	    } else {
	      modalContent = document.createElement('div');
	      const text = document.createElement('div');
	      text.tabIndex = 0;
	      if (typeof content === 'string' && content.toLowerCase() === ERRORS.FAILED_TO_FETCH) {
	        text.innerHTML = this.defaultErrorMessage;
	      } else {
	        text.innerHTML = content;
	      }
	      modalContent.appendChild(text);
	      if (showRetryButton) {
	        if (this.retriesCount_ < RETRIES_LIMIT) {
	          if (typeof modal.el === 'function') {
	            modal.el().addEventListener('click', this.onRetryButtonClicked_);
	          }
	          text.innerHTML = this.defaultErrorRetryMessage;
	          this.retryButton_.classList.remove('disabled');
	        } else {
	          this.retryButton_.classList.add('disabled');
	          text.innerHTML = this.defaultErrorMessage;
	        }
	        modalContent.appendChild(this.retryButton_);
	      }
	    }
	    modalContent.className = 'vjs-errors-dialog';
	    modalContent.id = 'vjs-errors-dialog';
	    modal.fillWith(modalContent);
	    if (player.width() <= 600 || player.height() <= 250) {
	      modal.addClass('vjs-xs');
	    }
	    if (typeof value !== 'object' && FATAL_ERRORS_LIST.indexOf(value) > -1 || value && FATAL_ERRORS_LIST.indexOf(value.message) > -1) {
	      if (this.retriesCount_ >= RETRIES_LIMIT && typeof onFatalErrorDisposePlayer === 'function') {
	        onFatalErrorDisposePlayer();
	      }
	    }
	  }
	}

	class ErrorHandlerService {
	  constructor(coordinator, initErrorUI) {
	    this._TIMEOUT = 45000;
	    this._waitingTimer = null;
	    this._currentTime = 0;
	    this.reportPlayerErrorEvent = null;
	    this.player = null;
	    this.coordinator = coordinator;
	    this.handlePlayerError = this.handlePlayerError.bind(this);
	    this.handlePlayerWait = this.handlePlayerWait.bind(this);
	    this.getErrorObject = this.getErrorObject.bind(this);
	    this.handleModalClose = this.handleModalClose.bind(this);
	    this.handleOnline = this.handleOnline.bind(this);
	    this.handleOffline = this.handleOffline.bind(this);
	    this.isOnline = true;
	    window.addEventListener('online', this.handleOnline);
	    window.addEventListener('offline', this.handleOffline);
	    if (initErrorUI) {
	      this.playerErrorUI = new PlayerErrorUI(this.coordinator);
	    }
	  }
	  subscribeOnErrors(player) {
	    this.player = player;
	    player.on('error', this.handlePlayerError);
	    player.on('waiting', this.handlePlayerWait);
	 }
	r);
	    player.off('waiting', this.handlePlayerWait);
	    if (player !== null && player !== void 0 && (_player$errorDisplay = player.errorDisplay) !== null && _player$errorDisplay !== void 0 && _player$errorDisplay.off) {
	      player.errorDisplay.off('modalclose', this.handleModalClose);
	    }
	    window.removeEventListener('online', this.handleOnline);
	    window.removeEventListener('offline', this.handleOffline);
	  }
	  getErrorCodeAndTitle_(code, errorException) {
	    let errorTitle;
	    let errorCode;
	    switch (code) {
	      case 0:
	        errorTitle = ERRORS.MEDIA_ERR_CUSTOM;
	        errorCode = ERROR_CODES.PLAYER_MEDIA_ERR_CUSTOM;
	        break;
	      case 1:
	        errorTitle = ERRORS.MEDIA_ERR_ABORTED;
	        errorCode = ERROR_CODES.PLAYER_MEDIA_ERR_ABORTED;
	        break;
	      case 2:
	        errorTitle = ERRORS.MEDIA_ERR_NETWORK;
	        errorCode = ERROR_CODES.PLAYER_MEDIA_ERR_NETWORK;
	        break;
	      case 3:
	        errorTitle = ERRORS.MEDIA_ERR_DECODE;
	        errorCode = ERROR_CODES.PLAYER_MEDIA_ERR_DECODE;
	        break;
	      case 4:
	        errorTitle = ERRORS.MEDIA_ERR_SRC_NOT_SUPPORTED;
	        errorCode = ERROR_CODES.PLAYER_MEDIA_ERR_SRC_NOT_SUPPORTED;
	        break;
	      case 5:
	        errorTitle = ERRORS.MEDIA_ERR_ENC(!errorException) {
	          errorTitle = ERRORS.MEDIA_INTERNAL_PLAYER_ERR;
	          errorCo	    };
	  }
	  handleOnline() {
	    this.isOnline = true;
	  }
	  handleOffline() {
	    this.isOnline = false;
	  }
	  handlePlayerWait() {
	    if (!this.isOnline) {
	      const {
	        reportPlayerErrorEvent
	      } = this;
	      reportPlayerErrorEvent(NETWORK_ERROR_MSG, ERRORS.MEDIA_ERR_NETWORK);
	      this.player.errorDisplay.open();
	    } else {
	      if (this._waitingTimer) {
	        clearInterval(this._waitingTimer);
	        this._waitingTimer = null;
	      }
	      this._currentTime = this.player.currentTime();
	      this._waitingTimer = setTimeout(() => {
	        if (this.player.error() || this.player.paused() || this.player.ended()) {
	         or(this._currentTime) === Math.floor(this.player.currentTime()) && !this.player.errorDisplay.opened()) {
	          this.player.error({
	            code: ERRORS.MEDIA_ERR_NETWORK,
	            message: NETWORK_ERROR_CONNECTION
	          });
	        }
	      }, this._TIMEOUT);
	    }
	  }
	  handlePlayerPlay() {
	    this._currentTime = this.player.currentTime();
	    if (this._waitingTimer) {
	      clearTimeout(this._waitingTimer);
	      this._waitingTimer = null;
	    }
	  }
	  handleModalClose() {
	    if (this.isPlayerError && this.player.errorDisplay !== null && typeof this.player.errorDisplay.opened === 'function' && !this.player.errorDisplay.opened()) {
	      const {
	        reportPlayerErrorEvent
	      } = this;
	      reportPlayerErrorEvent(ERRORS.MEDIA_ERR_NETWORK, ERRORS.MEDIA_ERR_NETWORK);
	      this.player.errorDisplay.open();
	    }
	  }
	  updatePlayerError(param) {
	    this.isPlayerError = param;
	  }
	  handlePlayerError(err, context) {
	    const {
	      player,
	      reportPlayerErrorEvent
	    } = context || this;
	    let errorException = err && err.errorException ? err.errorException : null;
	    let showRetryButton = true;
	    if (player && typeof player.error === 'function') {
	      const {
	        code
	      } = player.error() || {};
	      const {
	        errorTitle,
	        errorCode
	      } = this.getErrorCodeAndTitle_(code, errorException);
	      if (errorCode) {
	        errorException = NewRelicService$1.generatePlayerBundleUnexpectedError(errorCode, errorTitle, err);
	      }
	      if (err) {
	        err.errorException = errorException;
	      }
	      const error = player.error();
	      let message;
	      if (error) {
	        message = error.message;
	      }
	      if (!message && err) {
	        message = err.message;
	      }
	      if (!message && errorException) {
	        message = errorException.message;
	      }
	      NewRelicService$1.isRecoverableError = this.isRecoverableError(message);
	      if (!message) {
	        message = 'Oops. Something went wrong. Please try again later.';
	      }
	      if (error && !error.message) {
	        error.message = message;
	      }
	      if (error && error.code !== undefined && (error.code === STREAM_LIMIT_ERROR_CODE || error.message && error.message.toLowerCase() === CONCURRENCY_LIMIT_MSG)) {
	        message = STREAM_LIMIT_ERROR_MSG;
	        showRetryButton = false;
	      }
	      if (error && error.message && error.message.toLowerCase() === ERRORS.FAILED_TO_FETCH) {
	        message = NETWORK_ERROR_MSG;
	      }
	      if (typeof reportPlayerErrorEvent === 'function') {
	        this.executeOnReady(player, () => {
	          reportPlayerErrorEvent(message, errorTitle, showRetryButton);
	        });
	      }
	    }
	  }
	  executeOnReady(player, fn) {
	    if (player.isReady_) {
	      fn();
	    } else if (typeof player.ready === 'function') {
	      player.ready(fn);
	    }
	  }
	  getErrorObject(value, isRecoverable) {
	    let err;
	    if (typeof value === 'object') {
	      err = {
	        message: value.message,
	        headline: value.headline || value.message
	      };
	      if (value.errorException) {
	        err.errorException = value.errorException;
	      }
	      if (value.code || value.status) {
	        err.code = value.code || value.status;
	      }
	      if (value.type || value.abbreviation) {
	        err.type = value.type || value.abbreviation;
	      }
	      if (value.exception) {
	        err.message = value.exception;
	        err.headline = value.exception;
	      }
	    } else {
	      err = {
	        headline: value,
	        message: value
	      };
	    }

	    /**
	     *  In some cases we need to send if it's still possible to run the playback after the error
	     *  @see documentation https://confluence.disney.com/x/3Mm1Mw
	     */
	    err.recoverable = isRecoverable;
	    return err;
	  }
	  isRecoverableError(message) {
	    // KeySession error code 1 is Unknown error
	    // KeySession error code 6 is MEDIA_KEYERR_DOMAIN
	    // An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.
	    // systemCode 0 means there is no system code for this error.
	    const keySessionRegex = /KeySession error: code\s(6|1), systemCode\s[0-9]+/;
	    if (keySessionRegex.test(message)) {
	      // This error occurs due to a race condition within play
	      // sequence. DRM certificates resolve successfully but before
	      // JS gets a chance to resolve that promise - operation gets aborted,
	      // resulting in a false-positive error that can be ignored
	      // Example: "KeySession error: code 1, systemCode 0" or "KeySession error: code 6, systemCode 4294955417"
	      // Issue: https://github.com/videojs/videojs-contrib-eme/issues/80
	      // this error is coming from calling getCertificate()

	      return true;
	    }
	    return false;
	  }
	}

	class MediaManager {
	  static init(configs, coordinator) {
	    const analyticsService = new AnalyticsService(configs, coordinator);
	    const advertisementService = new AdvertisementService(configs, coordinator);
	    const authorizationService = new AuthorizationService(configs);
	    const domHelperService = new DOMhelperService(configs);
	    const errorHandlerService = new ErrorHandlerService(coordinator, true);
	    return {
	      analyticsService,
	      advertisementService,
	      authorizationService,
	      domHelperService,
	      errorHandlerService
	    };
	  }
	}

	/**
	 * The DTCIVideoPlayer class.
	 * @class
	 */
	class DTCIVideoPlayer {
	  /**
	   * @param {(string|Element)}  the DOM element where the player will be embedded
	   * @param {Object}      [techOptions]
	   */
	  constructor(element, techOptions = {}) {
	    this.Adapter_ = null;
	    this.type_ = undefined;
	    if (element) {
	      this.setElementAndContainer_(element);
	    }
	    DTCIVideoPlayer.techLoadedPromise = new promise((resolve, reject) => {
	      this.resolveTechLoadedPromise_ = resolve;
	      this.rejectTechLoadedPromise_ = reject;
	    });
	    this.techOptions = techOptions;
	    this.coordinator = new EventCoordinator();
	    this.type = techOptions.type;
	    this.configsService = new ConfigurationService(this.type);
	    this.configsService.coordinator = this.coordinator;
	    this.combineAndMassageConfigsForLoad_ = this.configsService.combineAndMassageConfigsForLoad;
	    this.loadBootstrapConfig_ = this.configsService.loadBootstrapConfig;

	    // player css will be removed when player is disposed. We may need to inject it again if css is removed.
	    injectPlayerBundleCssIntoDom();
	  }
	  set Adapter(v) {
	    this.Adapter_ = v;
	  }
	  get Adapter() {
	    return this.Adapter_;
	  }
	  set type(v) {
	    this.type_ = v;
	  }
	  get type() {
	    return this.type_;
	  }
	  get bundle() {
	    return this.bundle_;
	  }
	  set bundle(value) {
	    this.bundle_ = value;
	    return this.bundle_;
	  }
	  get isPlaying() {
	    return this.bundle && this.bundle.isPlaying;
	  }
	  get adId() {
	    return this.bundle && this.bundle.adId;
	  }
	  get mediaItem() {
	    return this.bundle && this.bundle.mediaItem;
	  }
	  get playerName() {
	    return this.bundle && this.bundle.playerName;
	  }
	  get platformVersion() {
	    return this.bundle && this.bundle.platformVersion;
	  }
	  async load(loadRequest) {
	    this.combinedConfig = this.combineAndMassageConfigsForLoad_(loadRequest);
	    if (!DTCIVideoPlayer.loadedPromise || DTCIVideoPlayer.loadedPromise && !this.bundle) {
	      this.bundle = await this.initBundlePlayer_(this.combinedConfig);
	      this.initPlayer();
	      this.renderPlayer();
	      let mediaItem = null;
	      mediaItem = await this.loadContent();
	      await this.initContent(mediaItem);
	    } else if (this.bundle) {
	      this.bundle.updateConfiguration(this.combinedConfig);
	      this.bundle.configurePlayer();
	      this.updateAnalytics({
	        ...this.combinedConfig.analytics
	      });
	      let mediaItem = null;
	      mediaItem = await this.loadContent();
	      await this.initContent(mediaItem);
	    }
	    return this.bundle;
	  }
	  async getTechLoadedPromise_(brandConfig) {
	    let result;
	    const {
	      techOptions
	    } = this;
	    this.Adapter = VideoJsAdapter;
	    try {
	      result = await this.Adapter.loadTech(techOptions, brandConfig);
	      this.resolveTechLoadedPromise_(result);
	    } catch (err) {
	      this.rejectTechLoadedPromise_(this.sendNewRelicEvent_(ERROR_CODES.PLAYER_BUNDLE_FAILED_TO_LOAD, 'Playback failed to start', err));
	    }
	    return DTCIVideoPlayer.techLoadedPromise;
	  }
	  async loadAsyncPlayerAssets(loadRequest) {
	    const combinedConfig = this.combineAndMassageConfigsForLoad_(loadRequest);
	    if (!DTCIVideoPlayer.loadedPromise || DTCIVideoPlayer.loadedPromise && !this.bundle) {
	      this.bundle = await this.initBundlePlayer_(combinedConfig);
	      this.initPlayer();
	    }
	    return this.bundle;
	  }
	  async loadRemoteMediaItemData() {
	    return null;
	  }
	  async renderPlayerAndLoadContent(mediaItem, advertisingInfo, element, identifier) {
	    const loadRequest = {
	      configuration: this.bundle.configs_,
	      mediaItem,
	      advertisingInfo,
	      identifier
	    };
	    const combinedConfig = this.combineAndMassageConfigsForLoad_(loadRequest);
	    this.setElementAndContainer_(element);
	    this.bundle.updateConfiguration(combinedConfig);
	    this.updateAnalytics({
	      ...combinedConfig.analytics
	    });
	    this.renderPlayer(element);
	    await this.loadContent();
	    // Brightcove's autoplay only seems to want to play muted in the unified player setup
	    this.bundle.player.autoplay(false);
	    await this.initContent();
	    if (combinedConfig.autoplay) {
	      this.bundle.player.play();
	    }
	  }
	  initPlayer() {
	    if (this.bundle) {
	      this.bundle.initPlayer();
	    }
	  }
	  renderPlayer(el) {
	    if (this.bundle) {
	      this.bundle.renderPlayer(el);
	    }
	  }
	  async loadContent(identifier = null, contentApi = null) {
	    let mediaItem;
	    if (this.bundle) {
	      mediaItem = await this.bundle.loadContent(identifier, contentApi);
	    }
	    return mediaItem;
	  }
	  async initContent(mediaItem) {
	    if (this.bundle) {
	      await this.bundle.initContent(mediaItem);
	    }
	  }
	  playNewVODContent(mediaItem, advertisingInfo) {
	    let canPlay = false;
	    if (this.bundle) {
	      const {
	        isInAdMode = false
	      } = this.bundle;
	      if (!isInAdMode) {
	        const loadRequest = {
	          configuration: this.bundle.configs_,
	          mediaItem,
	          advertisingInfo
	        };
	        const combinedConfig = this.combineAndMassageConfigsForLoad_(loadRequest);
	        canPlay = true;
	        this.bundle.updateConfiguration(combinedConfig);
	        this.updateAnalytics({
	          ...combinedConfig.analytics
	        });
	        this.bundle.clipLoadedCallback(mediaItem, true);
	        this.coordinator.coordinate('dtci.ended');
	        this.bundle.player.trigger('ended');
	      }
	    }
	    return canPlay;
	  }
	  async initBundlePlayer_(combinedConfig) {
	    await this.loadDebuggerScript_();
	    const {
	      analytics: {
	        newRelic
	      } = {}
	    } = combinedConfig || {};
	    if (newRelic) {
	      NewRelicService$1.init(newRelic);
	    }
	    QoeInitWatcher.onInit(this.coordinator, combinedConfig);
	    const bootstrappedConfig = await this.loadBootstrapConfig_(combinedConfig);
	    this.techLoadedPromise = await this.getTechLoadedPromise_(bootstrappedConfig.brandConfig);
	    const mediaManager = MediaManager.init(bootstrappedConfig, this.coordinator);

	    /**
	     * Bundle is not present that is because either player script is not loaded or
	     * bundle is disposed by calling player unembed. On either case, we need to
	     * to initialize the bundle
	     */

	    if (this.techLoadedPromise || !this.bundle) {
	      try {
	        this.bundle = new this.Adapter(this.element_, bootstrappedConfig, this.coordinator, mediaManager);
	      } catch (err) {
	        if (!NewRelicService$1.isErrorException(err)) {
	          // eslint-disable-next-line no-unused-vars
	          this.sendNewRelicEvent_(ERROR_CODES.PLAYER_UNKNOWN, 'playerAdapter instance creation failed', err);
	        }
	        // TODO - here need somehow show error to user - problem that at this place player could be
	        // TODO - not existed. so need own dialog implementation
	      }

	      DTCIVideoPlayer.loadedPromise = true;
	    }
	    return this.bundle;
	  }
	  setElementAndContainer_(element) {
	    this.element_ = Object.prototype.toString.call(element) === '[object String]' ? document.getElementById(element) : element;
	    if (!this.element_) {
	      throw new Error('element MUST be an HTML element or a valid selector');
	    }
	    if (this.element_.parentNode) {
	      this.container_ = this.element_.parentNode;
	      this.containerClone_ = this.container_.cloneNode(true);
	    }
	  }
	  async loadDebuggerScript_() {
	    if (sessionStorage.getItem('devDebug')) {
	      try {
	        const playerBaseUrl = getPlayerBaseURL();
	        const baseUrl = playerBaseUrl[playerBaseUrl.length - 1] === '/' ? playerBaseUrl.substr(0, playerBaseUrl.length - 1) : playerBaseUrl;
	        await loadScript$1.url(`${baseUrl}/debug-logger.js`);
	        window.eventLogger(this);
	      } catch (err) {
	        console.error('loadDebuggerScript error: ', err);
	      }
	    }
	  }
	  updateAnalytics(configs) {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.updateAnalytics(configs);
	  }
	  addEventListener(event, listener) {
	    this.coordinator.addEventListener(event, listener);
	    return this;
	  }
	  addEventInterceptor(event, interceptor) {
	    this.coordinator.addEventInterceptor(event, interceptor);
	    return this;
	  }
	  removeEventListener(event, listener) {
	    this.coordinator.removeEventListener(event, listener);
	    return this;
	  }
	  removeEventInterceptor(event) {
	    this.coordinator.removeEventInterceptor(event);
	    return this;
	  }
	  async play() {
	    const {
	      bundle
	    } = this;
	    if (bundle) {
	      try {
	        return await bundle.play();
	      } catch (error) {
	        return promise.reject(error);
	      }
	    }
	    return promise.reject(this.sendNewRelicEvent_(ERROR_CODES.PLAYER_NOT_READY, 'Player is not ready'));
	  }
	  pause() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.pause();
	  }
	  muted(value) {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.muted(value);
	  }
	  currentTime(value) {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.currentTime(value);
	  }
	  autoplay() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.autoplay();
	  }
	  currentType() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.currentType();
	  }
	  playbackRate() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.playbackRate();
	  }
	  duration() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.duration();
	  }
	  language() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.language();
	  }
	  requestFullscreen() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.requestFullscreen();
	  }
	  exitFullscreen() {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.exitFullscreen();
	  }

	  /**
	   * Set caption display state
	   * @param {Boolean}   [showCaptions=false]
	   */
	  captions(showCaptions) {
	    const {
	      bundle
	    } = this;
	    return bundle && bundle.captions(showCaptions);
	  }

	  /**
	   * Unembed the video player
	   * @param {removeContainer}   [removeContainer=false]
	   */
	  unembed(removeContainer = false) {
	    const {
	      bundle,
	      container_,
	      containerClone_
	    } = this;
	    if (!bundle) {
	      return;
	    }
	    bundle.dispose();
	    this.bundle = null;
	    if (container_ && container_.parentNode) {
	      if (removeContainer) {
	        container_.parentNode.removeChild(container_);
	      } else {
	        container_.parentNode.replaceChild(containerClone_, container_);
	      }
	    }
	  }

	  /**
	   * Remove the video player and it's container. This is an alias for DTCIVideoPlayer.unembed(true)
	   */
	  remove() {
	    this.unembed(true);
	  }

	  /**
	   * Display an error message
	   * @param {string|object} error
	   * - an error code (`'AUTHZ_FAILURE'`, etc.) or
	   * - a media error object (`{type: 'NOT_FOUND', message: 'This video is unavailable.'}`)
	   * @param {(string|HTMLElement)}  [content] - optional, showCustomErrorContent on errorDisplay modal
	   */
	  error(err, content) {
	    const {
	      bundle
	    } = this;
	    if (bundle) {
	      bundle.error(err, content);
	    }
	    return this;
	  }
	  sendNewRelicEvent_(errorCode, message, cause) {
	    const error = NewRelicService$1.generatePlayerBundleUnexpectedError(errorCode, message, cause);
	    NewRelicService$1.playerBundleEvent({}, error);
	    return error;
	  }
	}
	DTCIVideoPlayer.techLoadedPromise = null;
	DTCIVideoPlayer.loadedPromise = null;
	DTCIVideoPlayer.VERSION = "5.3.16";
	injectPlayerBundleCssIntoDom();

	return DTCIVideoPlayer;

}));
//# sourceMappingURL=espn-web-player-bundle.js.map
