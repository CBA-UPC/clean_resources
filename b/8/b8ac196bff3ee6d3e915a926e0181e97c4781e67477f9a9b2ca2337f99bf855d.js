this.workbox=this.workbox||{},this.workbox.strategies=function(t,e,s,r,i,n,a,o,c){"use strict";ry{self["workbox:strategies:6.0.2"]&&_()}catch(t){}lass u{etch(t){return this.waitUntil((async()=>{const{event:e}=this;let r=l(t);if("navigate"===r.mode&&e instanceof FetchEvent&&e.preloadResponse){const t=await e.preloadResponse;if(t)return t}const i=this.hasCallback("fetchDidFail")?r.clone():null;try{for(const t of this.iterateCallbacks("requestWillFetch"))r=await t({request:r.clone(),event:e})}catch(t){throw new s.WorkboxError("plugin-error-request-will-fetch",{thrownError:t})}const n=r.clone();try{let t;t=await fetch(r,"navigate"===r.mode?void 0:this.ht.fetchOptions);for(const s of this.iterateCallbacks("fetchDidSucceed"))t=await s({event:e,request:n,response:t});return t}catch(t){throw i&&await this.runCallbacks("fetchDidFail",{error:t,event:e,originalRequest:i.clone(),request:n.clone()}),t}})())}acheMatch(t){return this.waitUntil((async()=>{const e=l(t);let s;const{cacheName:r,matchOptions:i}=this.ht,n=await this.getCacheKey(e,"read"),a=h({},i,{cacheName:r});s=await caches.match(n,a);for(const t of this.iterateCallbacks("cachedResponseWillBeUsed"))s=await t({cacheName:r,matchOptions:i,cachedResponse:s,request:n,event:this.event})||void 0;return s})())}async cachePut(t,e){const r=l(t);await c.timeout(0);const a=await this.getCacheKey(r,"write");if(!e)throw new s.WorkboxError("cache-put-with-no-response",{url:i.getFriendlyURL(a.url)});const h=await this.Rt(e);if(!h)return;const{cacheName:u,matchOptions:w}=this.ht,f=await self.caches.open(u),d=this.hasCallback("cacheDidUpdate"),p=d?await n.cacheMatchIgnoreParams(f,a.clone(),["__WB_REVISION__"],w):null;try{await f.put(a,d?h.clone():h)}catch(t){throw"QuotaExceededError"===t.name&&await o.executeQuotaErrorCallbacks(),t}for(const t of this.iterateCallbacks("cacheDidUpdate"))await t({cacheName:u,oldResponse:p,newResponse:h.clone(),request:a,event:this.event})}{cacheWillUpdate:;return t.CacheFirst=t.CacheOnly=t.NetworkFirst=class extends w{sync _handle(t,e){const r=[],i=[];let n;if(this.Ct){const{id:s,promise:a}=this.Dt({request:t,logs:r,handler:e});n=s,i.push(a)}const a=this.Et({timeoutId:n,request:t,logs:r,handler:e});i.push(a);for(const t of i)e.waitUntil(t);let o=await Promise.race(i);if(o||(o=await a),!o)throw new s.WorkboxError("no-response",{url:t.url});return o}t.NetworkOnly=t.StaleWhileRevalidate=t.Strategy=w,t.StrategyHandler=u,t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
//# sourceMappingURL=workbox-strategies.prod.js.map
