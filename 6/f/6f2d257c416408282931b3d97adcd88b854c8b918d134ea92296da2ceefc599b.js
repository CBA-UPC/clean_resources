////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIjQuery", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIjQuery-3.0.2493.103
/////////////////////////
// BEGIN FILE jquery.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * @license jQuery JavaScript Library v1.6.4
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Amazon elects to use jQuery and Sizzle under the MIT license.
 *
 * Date: Mon Sep 12 18:54:48 2011 -0400
 */

// [TT-0099714324] Gracefully downgrading (no jQuery and most AUI) for incompatible "browsers"
// to avoid unnecessary error churning on unhealthy browser APIs.
if (window.navigator && window.navigator.userAgent) {

// The reason we don't use 'P.register' here is to make sure jQuery plugins concatenated later on in this
// package can execute immediately
P.declare('jQuery', function () {
    // Use the correct document accordingly with window argument (sandbox)
    var document = window.document,
        navigator = window.navigator,
        location = window.location;
    var jQuery = (function () {

        // Define a local copy of jQuery
        var jQuery = 

        // Map over jQuery in case of overwrite
        _jQuery = window.jQuery,

            // Map over the $ in case of overwrite
            _$ = window.$,

            // A central reference to the root jQuery(document)
            rootjQuery,

            // A simple way to check for HTML strings or ID strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
            quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

            // Check if a string has a non-whitespace character in it
            rnotwhite = /\S/,

            // Used for trimming whitespace
            trimLeft = /^\s+/,
            trimRight = /\s+$/,

            // Check for digits
            rdigit = /\d/,

            // Match a standalone tag
            rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

            // JSON RegExp
            rvalidchars = /^[\],:{}\s]*$/,
            rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
            rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
            rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

            // Useragent RegExp
            rwebkit = /(webkit)[ \/]([\w.]+)/,
            ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
            rmsie = /(msie) ([\w.]+)/,
            rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

            // Matches dashed string for camelizing
            rdashAlpha = /-([a-z]|[0-9])/ig,
            rmsPrefix = /^-ms-/,

            // Used by jQuery.camelCase as callback to replace()
            fcamelCase = 

            // Keep a UserAgent string for use with jQuery.browser
            userAgent = navigator.userAgent,

            // For matching the engine and version of the browser
            browserMatch,

            // The deferred used on DOM ready
            readyList,

            // The ready event handler
            DOMContentLoaded,

            // Save a reference to some core methods
            toString = Object.prototype.toString,
            hasOwn = Object.prototype.hasOwnProperty,
            push = Array.prototype.push,
            slice = Array.prototype.slice,
            trim = String.prototype.trim,
            indexOf = Array.prototype.indexOf,

            // [[Class]] -> type pairs
            class2type = {};

        jQuery.fn = jQuery.prototype = {
            constructor: jQuery,
            init: 

            // Start with an empty selector
            selector: "",

            // The current version of jQuery being used
            jquery: "1.6.4",

            // The default length of a jQuery object is 0
            length: 0,

            // The number of elements contained in the matched element set
            size: function () {
                return this.length;
            },

            toArray: 

            // Get the Nth element in the matched element set OR
            // Get the whole matched element set as a clean array
            get: 

            // Take an array of elements and push it onto the stack
            // (returning the new matched element set)
            pushStack: 

            // Execute a callback for every element in the matched set.
            // (You can seed the arguments with an array of args, but this is
            // only used internally.)
            each: 

            ready: 

            eq: 

            first: function () {
                return this.eq(0);
            },

            last: 

            slice: 

            map: 

            end: 

            // For internal use only.
            // Behaves like an Array's method, not like a jQuery method.
            push: push,
            sort: [].sort,
            splice: [].splice
        };

        // Give the init function the jQuery prototype for later instantiation
        jQuery.fn.init.prototype = jQuery.fn;

        jQuery.extend = jQuery.fn.extend = 

        jQuery.extend({
            noConflict: 

            // Is the DOM ready to be used? Set to true once it occurs.
            isReady: false,

            // A counter to track how many items to wait for before
            // the ready event fires. See #6781
            readyWait: 1,

            // Hold (or release) the ready event
            holdReady: 

            // Handle when the DOM is ready
            ready: 

            bindReady: 

            // See test/unit/core.js for details concerning isFunction.
            // Since version 1.3, DOM methods and functions like alert
            // aren't supported. They return false on IE (#2968).
            isFunction: function (obj) {
                return jQuery.type(obj) === "function";
            },

            isArray: Array.isArray || 

            // A crude way of determining if an object is a window
            isWindow: 

            isNaN: 

            type: 

            isPlainObject: 

            isEmptyObject: 

            error: 

            parseJSON: 

            // Cross-browser xml parsing
            parseXML: 

            noop: function () {},

            // Evaluates a script in a global context
            // Workarounds based on findings by Jim Driscoll
            // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
            globalEval: 

            // Convert dashed to camelCase; used by the css and data modules
            // Microsoft forgot to hump their vendor prefix (#9572)
            camelCase: 

            nodeName: 

            // args is for internal usage only
            each: 

            // Use native String.trim function wherever possible
            trim: trim ? :

            // Otherwise use our own trimming functionality

            

            // results is for internal usage only
            makeArray: 

            inArray: function (elem, array) {
                if (!array) {
                    return -1;
                }

                if (indexOf) {
                    return indexOf.call(array, elem);
                }

                for (var i = 0, length = array.length; i < length; i++) {
                    if (array[i] === elem) {
                        return i;
                    }
                }

                return -1;
            },

            merge: 

            grep: 

            // arg is for internal usage only
            map: 

            // A global GUID counter for objects
            guid: 1,

            // Bind a function to a context, optionally partially applying any
            // arguments.
            proxy: 

            // Mutifunctional method to get and set values to a collection
            // The value/s can optionally be executed if it's a function
            access: 

            now: 

            // Use of jQuery.browser is frowned upon.
            // More details: http://docs.jquery.com/Utilities/jQuery.browser
            uaMatch: 

            sub: 

            browser: {}
        });

        // Populate the class2type map
        jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), ;

        browserMatch = jQuery.uaMatch(userAgent);
        if (browserMatch.browser) {
            jQuery.browser[browserMatch.browser] = true;
            jQuery.browser.version = browserMatch.version;
        }

        // Deprecated, use jQuery.browser.webkit instead
        if (jQuery.browser.webkit) {
            jQuery.browser.safari = true;
        }

        // IE doesn't match non-breaking spaces with \s
        if (rnotwhite.test("\xA0")) {
            trimLeft = /^[\s\xA0]+/;
            trimRight = /[\s\xA0]+$/;
        }

        // All jQuery objects should point back to these
        rootjQuery = jQuery(document);

        // Cleanup functions for the document ready method
        if (document.addEventListener) {
            DOMContentLoaded = 

        } else if (document.attachEvent) {
            DOMContentLoaded = 
        }

        // The DOM ready check for Internet Explorer

        
        return jQuery;

    })();


    var // Promise methods
    promiseMethods = "done fail isResolved isRejected promise then always pipe".split(" "),
        // Static reference to slice
        sliceDeferred = [].slice;

    jQuery.extend({
        // Create a simple deferred (one callbacks list)
        _Deferred: 

        // Full fledged deferred (two callbacks list)
        Deferred: function (func) {
            var deferred = jQuery._Deferred(),
                failDeferred = jQuery._Deferred(),
                promise;
            // Add errorDeferred methods, then and promise
            jQuery.extend(deferred, {
                then: 
                always: 
                fail: failDeferred.done,
                rejectWith: failDeferred.resolveWith,
                reject: failDeferred.resolve,
                isRejected: failDeferred.isResolved,
                pipe: function (fnDone, fnFail) {
                    return jQuery.Deferred(function (newDefer) {
                        jQuery.each({
                            done: [fnDone, "resolve"],
                            fail: [fnFail, "reject"]
                        }, function (handler, data) {
                            var fn = data[0],
                                action = data[1],
                                returned;
                            if (jQuery.isFunction(fn)) {
                                deferred[handler](function () {
                                    returned = fn.apply(this, arguments);
                                    if (returned && jQuery.isFunction(returned.promise)) {
                                        returned.promise().then(newDefer.resolve, newDefer.reject);
                                    } else {
                                        newDefer[action + "With"](this === deferred ? newDefer : this, [returned]);
                                    }
                                });
                            } else {
                                deferred[handler](newDefer[action]);
                            }
                        });
                    }).promise();
                },
                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise:             });
            // Make sure only one callback list will be used
            deferred.done(failDeferred.cancel).fail(deferred.cancel);
            // Unexpose cancel
            delete deferred.cancel;
            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }
            return deferred;
        },

        // Deferred helper
        when: function (firstParam) {
            var args = arguments,
                i = 0,
                length = args.length,
                count = length,
                deferred = length <= 1 && firstParam && jQuery.isFunction(firstParam.promise) ? firstParam : jQuery.Deferred();

            function resolveFunc(i) {
                return function (value) {
                    args[i] = arguments.length > 1 ? sliceDeferred.call(arguments, 0) : value;
                    if (!(--count)) {
                        // Strange bug in FF4:
                        // Values changed onto the arguments object sometimes end up as undefined values
                        // outside the $.when method. Cloning the object into a fresh array solves the issue
                        deferred.resolveWith(deferred, sliceDeferred.call(args, 0));
                    }
                };
            }
            if (length > 1) {
                for (; i < length; i++) {
                    if (args[i] && jQuery.isFunction(args[i].promise)) {
                        args[i].promise().then(resolveFunc(i), deferred.reject);
                    } else {
                        --count;
                    }
                }
                if (!count) {
                    deferred.resolveWith(deferred, args);
                }
            } else if (deferred !== firstParam) {
                deferred.resolveWith(deferred, length ? [firstParam] : []);
            }
            return deferred.promise();
        }
    });



    jQuery.support = (function () {

        var div = document.createElement("div"),
            documentElement = document.documentElement,
            all,
            a,
            select,
            opt,
            input,
            marginDiv,
            support,
            fragment,
            body,
            testElementParent,
            testElement,
            testElementStyle,
            tds,
            events,
            eventName,
            i,
            isSupported;

        // Preliminary tests
        div.setAttribute("className", "t");
        div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";


        all = div.getElementsByTagName("*");
        a = div.getElementsByTagName("a")[0];

        // Can't get basic test support
        if (!all || !all.length || !a) {
            return {};
        }

        // First batch of supports tests
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];

        support = {
            // IE strips leading whitespace when .innerHTML is used
            leadingWhitespace: (div.firstChild.nodeType === 3),

            // Make sure that tbody elements aren't automatically inserted
            // IE will insert them into empty tables
            tbody: !div.getElementsByTagName("tbody").length,

            // Make sure that link elements get serialized correctly by innerHTML
            // This requires a wrapper element in IE
            htmlSerialize: !! div.getElementsByTagName("link").length,

            // Get the style information from getAttribute
            // (IE uses .cssText instead)
            style: /top/.test(a.getAttribute("style")),

            // Make sure that URLs aren't manipulated
            // (IE normalizes it by default)
            hrefNormalized: (a.getAttribute("href") === "/a"),

            // Make sure that element opacity exists
            // (IE uses filter instead)
            // Use a regex to work around a WebKit issue. See #5145
            opacity: /^0.55$/.test(a.style.opacity),

            // Verify style float existence
            // (IE uses styleFloat instead of cssFloat)
            cssFloat: !! a.style.cssFloat,

            // Make sure that if no value is specified for a checkbox
            // that it defaults to "on".
            // (WebKit defaults to "" instead)
            checkOn: (input.value === "on"),

            // Make sure that a selected-by-default option has a working selected property.
            // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
            optSelected: opt.selected,

            // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
            getSetAttribute: div.className !== "t",

            // Will be defined later
            submitBubbles: true,
            changeBubbles: true,
            focusinBubbles: false,
            deleteExpando: true,
            noCloneEvent: true,
            inlineBlockNeedsLayout: false,
            shrinkWrapBlocks: false,
            reliableMarginRight: true
        };

        // Make sure checked status is properly cloned
        input.checked = true;
        support.noCloneChecked = input.cloneNode(true).checked;

        // Make sure that the options inside disabled selects aren't marked as disabled
        // (WebKit marks them as disabled)
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Test to see if it's possible to delete an expando from an element
        // Fails in Internet Explorer
        try {
            delete div.test;
        } catch (e) {
            support.deleteExpando = false;
        }

        if (!div.addEventListener && div.attachEvent && div.fireEvent) {
            div.attachEvent("onclick", ;
            div.cloneNode(true).fireEvent("onclick");
        }

        // Check if a radio maintains it's value
        // after being appended to the DOM
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";

        input.setAttribute("checked", "checked");
        div.appendChild(input);
        fragment = document.createDocumentFragment();
        fragment.appendChild(div.firstChild);

        // WebKit doesn't clone checked state correctly in fragments
        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;

        div.innerHTML = "";

        // Figure out if the W3C box model works as expected
        div.style.width = div.style.paddingLeft = "1px";

        body = document.getElementsByTagName("body")[0];
        // We use our own, invisible, body unless the body is already present
        // in which case we use a div (#9239)
        testElement = document.createElement(body ? "div" : "body");
        testElementStyle = {
            visibility: "hidden",
            width: 0,
            height: 0,
            border: 0,
            margin: 0,
            background: "none"
        };
        if (body) {
            jQuery.extend(testElementStyle, {
                position: "absolute",
                left: "-1000px",
                top: "-1000px"
            });
        }
        for (i in testElementStyle) {
            testElement.style[i] = testElementStyle[i];
        }
        testElement.appendChild(div);
        testElementParent = body || documentElement;
        testElementParent.insertBefore(testElement, testElementParent.firstChild);

        // Check if a disconnected checkbox will retain its checked
        // value of true after appended to the DOM (IE6/7)
        support.appendChecked = input.checked;

        // jQuery.boxModel DEPRECATED in 1.3, use jQuery.support.boxModel instead
        jQuery.boxModel = support.boxModel = (document.compatMode === "CSS1Compat");

        if ("zoom" in div.style) {
            // Check if natively block-level elements act like inline-block
            // elements when setting their display to 'inline' and giving
            // them layout
            // (IE < 8 does this)
            div.style.display = "inline";
            div.style.zoom = 1;
            support.inlineBlockNeedsLayout = (div.offsetWidth === 2);

            // Check if elements with layout shrink-wrap their children
            // (IE 6 does this)
            div.style.display = "";
            div.innerHTML = "<div style='width:4px;'></div>";
            support.shrinkWrapBlocks = (div.offsetWidth !== 2);
        }

        div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
        tds = div.getElementsByTagName("td");

        // Check if table cells still have offsetWidth/Height when they are set
        // to display:none and there are still other visible table cells in a
        // table row; if so, offsetWidth/Height are not reliable for use when
        // determining if an element has been hidden directly using
        // display:none (it is still safe to use offsets if a parent element is
        // hidden; don safety goggles and see bug #4512 for more information).
        // (only IE 8 fails this test)
        isSupported = (tds[0].offsetHeight === 0);

        tds[0].style.display = "";
        tds[1].style.display = "none";

        // Check if empty table cells still have offsetWidth/Height
        // (IE < 8 fail this test)
        support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);
        div.innerHTML = "";

        // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. For more
        // info see bug #3333
        // Fails in WebKit before Feb 2011 nightlies
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        if (document.defaultView && document.defaultView.getComputedStyle) {
            marginDiv = document.createElement("div");
            marginDiv.style.width = "0";
            marginDiv.style.marginRight = "0";
            div.appendChild(marginDiv);
            support.reliableMarginRight = (parseInt((document.defaultView.getComputedStyle(marginDiv, null) || {
                marginRight: 0
            }).marginRight, 10) || 0) === 0;
        }

        // Remove the body element we added
        testElement.innerHTML = "";
        testElementParent.removeChild(testElement);

        // Technique from Juriy Zaytsev
        // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/
        // We only care about the case where non-standard event systems
        // are used, namely in IE. Short-circuiting here helps us to
        // avoid an eval call (in setAttribute) which can cause CSP
        // to go haywire. See: https://developer.mozilla.org/en/Security/CSP
        if (div.attachEvent) {
            for (i in {
                submit: 1,
                change: 1,
                focusin: 1
            }) {
                eventName = "on" + i;
                isSupported = (eventName in div);
                if (!isSupported) {
                    div.setAttribute(eventName, "return;");
                    isSupported = (typeof div[eventName] === "function");
                }
                support[i + "Bubbles"] = isSupported;
            }
        }

        // Null connected elements to avoid leaks in IE
        testElement = fragment = select = opt = body = marginDiv = div = input = null;

        return support;
    })();

    var rbrace = /^(?:\{.*\}|\[.*\])$/,
        rmultiDash = /([A-Z])/g;

    jQuery.extend({
        cache: {},

        // Please use with caution
        uuid: 0,

        // Unique for each copy of jQuery on the page
        // Non-digits removed to match rinlinejQuery
        expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),

        // The following elements throw uncatchable exceptions if you
        // attempt to add expando properties to them.
        noData: {
            "embed": true,
            // Ban all objects except for Flash (which handle expandos)
            "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
            "applet": true
        },

        hasData: 

        data: function (elem, name, data, pvt /* Internal Use Only */ ) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var thisCache, ret,
            internalKey = jQuery.expando,
                getByName = typeof name === "string",

                // We have to handle DOM nodes and JS objects differently because IE6-7
                // can't GC object references properly across the DOM-JS boundary
                isNode = elem.nodeType,

                // Only DOM nodes need the global jQuery cache; JS object data is
                // attached directly to the object so GC can occur automatically
                cache = isNode ? jQuery.cache : elem,

                // Only defining an ID for JS objects if its cache already exists allows
                // the code to shortcut on the same path as a DOM node with no cache
                id = isNode ? elem[jQuery.expando] : elem[jQuery.expando] && jQuery.expando;

            // Avoid doing any more work than we need to when trying to get data on an
            // object that has no data at all
            if ((!id || (pvt && id && (cache[id] && !cache[id][internalKey]))) && getByName && data === undefined) {
                return;
            }

            if (!id) {
                // Only DOM nodes need a new unique ID for each element since their data
                // ends up in the global cache
                if (isNode) {
                    elem[jQuery.expando] = id = ++jQuery.uuid;
                } else {
                    id = jQuery.expando;
                }
            }

            if (!cache[id]) {
                cache[id] = {};

                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }
            }

            // An object can be passed to jQuery.data instead of a key/value pair; this gets
            // shallow copied over onto the existing cache
            if (typeof name === "object" || typeof name === "function") {
                if (pvt) {
                    cache[id][internalKey] = jQuery.extend(cache[id][internalKey], name);
                } else {
                    cache[id] = jQuery.extend(cache[id], name);
                }
            }

            thisCache = cache[id];

            // Internal jQuery data is stored in a separate object inside the object's data
            // cache in order to avoid key collisions between internal data and user-defined
            // data
            if (pvt) {
                if (!thisCache[internalKey]) {
                    thisCache[internalKey] = {};
                }

                thisCache = thisCache[internalKey];
            }

            if (data !== undefined) {
                thisCache[jQuery.camelCase(name)] = data;
            }

            // TODO: This is a hack for 1.5 ONLY. It will be removed in 1.6. Users should
            // not attempt to inspect the internal events object using jQuery.data, as this
            // internal data object is undocumented and subject to change.
            if (name === "events" && !thisCache[name]) {
                return thisCache[internalKey] && thisCache[internalKey].events;
            }

            // Check for both converted-to-camel and non-converted data property names
            // If a data property was specified
            if (getByName) {

                // First Try to find as-is property data
                ret = thisCache[name];

                // Test for null|undefined property data
                if (ret == null) {

                    // Try to find the camelCased property
                    ret = thisCache[jQuery.camelCase(name)];
                }
            } else {
                ret = thisCache;
            }

            return ret;
        },

        removeData: function (elem, name, pvt /* Internal Use Only */ ) {
            if (!jQuery.acceptData(elem)) {
                return;
            }

            var thisCache,

            // Reference to internal data cache key
            internalKey = jQuery.expando,

                isNode = elem.nodeType,

                // See jQuery.data for more information
                cache = isNode ? jQuery.cache : elem,

                // See jQuery.data for more information
                id = isNode ? elem[jQuery.expando] : jQuery.expando;

            // If there is already no cache entry for this object, there is no
            // purpose in continuing
            if (!cache[id]) {
                return;
            }

            if (name) {

                thisCache = pvt ? cache[id][internalKey] : cache[id];

                if (thisCache) {

                    // Support interoperable removal of hyphenated or camelcased keys
                    if (!thisCache[name]) {
                        name = jQuery.camelCase(name);
                    }

                    delete thisCache[name];

                    // If there is no data left in the cache, we want to continue
                    // and let the cache object itself get destroyed
                    if (!isEmptyDataObject(thisCache)) {
                        return;
                    }
                }
            }

            // See jQuery.data for more information
            if (pvt) {
                delete cache[id][internalKey];

                // Don't destroy the parent cache unless the internal data object
                // had been the only thing left in it
                if (!isEmptyDataObject(cache[id])) {
                    return;
                }
            }

            var internalCache = cache[id][internalKey];

            // Browsers that fail expando deletion also refuse to delete expandos on
            // the window, but it will allow it on all other JS objects; other browsers
            // don't care
            // Ensure that `cache` is not a window object #10080
            if (jQuery.support.deleteExpando || !cache.setInterval) {
                delete cache[id];
            } else {
                cache[id] = null;
            }

            // We destroyed the entire user cache at once because it's faster than
            // iterating through each key, but we need to continue to persist internal
            // data if it existed
            if (internalCache) {
                cache[id] = {};
                // TODO: This is a hack for 1.5 ONLY. Avoids exposing jQuery
                // metadata on plain JS objects when the object is serialized using
                // JSON.stringify
                if (!isNode) {
                    cache[id].toJSON = jQuery.noop;
                }

                cache[id][internalKey] = internalCache;

                // Otherwise, we need to eliminate the expando on the node to avoid
                // false lookups in the cache for entries that no longer exist
            } else if (isNode) {
                // IE does not allow us to delete expando properties from nodes,
                // nor does it have a removeAttribute function on Document nodes;
                // we must handle all of these cases
                if (jQuery.support.deleteExpando) {
                    delete elem[jQuery.expando];
                } else if (elem.removeAttribute) {
                    elem.removeAttribute(jQuery.expando);
                } else {
                    elem[jQuery.expando] = null;
                }
            }
        },

        // For internal use only.
        _data: function (elem, name, data) {
            return jQuery.data(elem, name, data, true);
        },

        // A method for determining if a DOM node can handle the data expando
        acceptData:     });

    jQuery.fn.extend({
        data: function (key, value) {
            var data = null;

            if (typeof key === "undefined") {
                if (this.length) {
                    data = jQuery.data(this[0]);

                    if (this[0].nodeType === 1) {
                        var attr = this[0].attributes,
                            name;
                        for (var i = 0, l = attr.length; i < l; i++) {
                            name = attr[i].name;

                            if (name.indexOf("data-") === 0) {
                                name = jQuery.camelCase(name.substring(5));

                                dataAttr(this[0], name, data[name]);
                            }
                        }
                    }
                }

                return data;

            } else if (typeof key === "object") {
                return this.each(function () {
                    jQuery.data(this, key);
                });
            }

            var parts = key.split(".");
            parts[1] = parts[1] ? "." + parts[1] : "";

            if (value === undefined) {
                data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

                // Try to fetch any internally stored data first
                if (data === undefined && this.length) {
                    data = jQuery.data(this[0], key);
                    data = dataAttr(this[0], key, data);
                }

                return data === undefined && parts[1] ? this.data(parts[0]) : data;

            } else {
                return this.each(;
            }
        },

        removeData: function (key) {
            return this.each(function () {
                jQuery.removeData(this, key);
            });
        }
    });

    function dataAttr(elem, key, data) {
        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {

            var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();

            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null : !jQuery.isNaN(data) ? parseFloat(data) : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}

                // Make sure we set the data so it isn't changed later
                jQuery.data(elem, key, data);

            } else {
                data = undefined;
            }
        }

        return data;
    }

    // TODO: This is a hack for 1.5 ONLY to allow objects with a single toJSON
    // property to be considered empty objects; this property always exists in
    // order to make sure JSON.stringify does not expose internal metadata

    function isEmptyDataObject(obj) {
        for (var name in obj) {
            if (name !== "toJSON") {
                return false;
            }
        }

        return true;
    }



    function handleQueueMarkDefer(elem, type, src) {
        var deferDataKey = type + "defer",
            queueDataKey = type + "queue",
            markDataKey = type + "mark",
            defer = jQuery.data(elem, deferDataKey, undefined, true);
        if (defer && (src === "queue" || !jQuery.data(elem, queueDataKey, undefined, true)) && (src === "mark" || !jQuery.data(elem, markDataKey, undefined, true))) {
            // Give room for hard-coded callbacks to fire first
            // and eventually mark/queue something else on the element
            setTimeout(function () {
                if (!jQuery.data(elem, queueDataKey, undefined, true) && !jQuery.data(elem, markDataKey, undefined, true)) {
                    jQuery.removeData(elem, deferDataKey, true);
                    defer.resolve();
                }
            }, 0);
        }
    }

    jQuery.extend({

        _mark: 

        _unmark: function (force, elem, type) {
            if (force !== true) {
                type = elem;
                elem = force;
                force = false;
            }
            if (elem) {
                type = type || "fx";
                var key = type + "mark",
                    count = force ? 0 : ((jQuery.data(elem, key, undefined, true) || 1) - 1);
                if (count) {
                    jQuery.data(elem, key, count, true);
                } else {
                    jQuery.removeData(elem, key, true);
                    handleQueueMarkDefer(elem, type, "mark");
                }
            }
        },

        queue: function (elem, type, data) {
            if (elem) {
                type = (type || "fx") + "queue";
                var q = jQuery.data(elem, type, undefined, true);
                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!q || jQuery.isArray(data)) {
                        q = jQuery.data(elem, type, jQuery.makeArray(data), true);
                    } else {
                        q.push(data);
                    }
                }
                return q || [];
            }
        },

        dequeue: function (elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type),
                fn = queue.shift(),
                defer;

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
            }

            if (fn) {
                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                fn.call(elem, function () {
                    jQuery.dequeue(elem, type);
                });
            }

            if (!queue.length) {
                jQuery.removeData(elem, type + "queue", true);
                handleQueueMarkDefer(elem, type, "queue");
            }
        }
    });

    jQuery.fn.extend({
        queue: 
        dequeue: function (type) {
            return this.each(function () {
                jQuery.dequeue(this, type);
            });
        },
        // Based off of the plugin by Clint Helfers, with permission.
        // http://blindsignals.com/index.php/2009/07/jquery-delay/
        delay: 
        clearQueue: 
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function (type, object) {
            if (typeof type !== "string") {
                object = type;
                type = undefined;
            }
            type = type || "fx";
            var defer = jQuery.Deferred(),
                elements = this,
                i = elements.length,
                count = 1,
                deferDataKey = type + "defer",
                queueDataKey = type + "queue",
                markDataKey = type + "mark",
                tmp;

                        while (i--) {
                if ((tmp = jQuery.data(elements[i], deferDataKey, undefined, true) || (jQuery.data(elements[i], queueDataKey, undefined, true) || jQuery.data(elements[i], markDataKey, undefined, true)) && jQuery.data(elements[i], deferDataKey, jQuery._Deferred(), true))) {
                    count++;
                    tmp.done(resolve);
                }
            }
            resolve();
            return defer.promise();
        }
    });



    var rclass = /[\n\t\r]/g,
        rspace = /\s+/,
        rreturn = /\r/g,
        rtype = /^(?:button|input)$/i,
        rfocusable = /^(?:button|input|object|select|textarea)$/i,
        rclickable = /^a(?:rea)?$/i,
        rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
        nodeHook, boolHook;

    jQuery.fn.extend({
        attr: function (name, value) {
            return jQuery.access(this, name, value, true, jQuery.attr);
        },

        removeAttr: 

        prop: 

        removeProp: 

        addClass: 

        removeClass: 

        toggleClass: 

        hasClass: function (selector) {
            var className = " " + selector + " ";
            for (var i = 0, l = this.length; i < l; i++) {
                if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        },

        val: function (value) {
            var hooks, ret,
            elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.nodeName.toLowerCase()] || jQuery.valHooks[elem.type];

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                    // handle most common string cases
                    ret.replace(rreturn, "") :
                    // handle cases where value is null/undef or number
                    ret == null ? "" : ret;
                }

                return undefined;
            }

            var isFunction = jQuery.isFunction(value);

            return this.each(;
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get:             },
            select: {
                get: 

                set:             }
        },

        attrFn: {
            val: true,
            css: true,
            html: true,
            text: true,
            data: true,
            width: true,
            height: true,
            offset: true
        },

        attrFix: {
            // Always normalize to ensure hook usage
            tabindex: "tabIndex"
        },

        attr: function (elem, name, value, pass) {
            var nType = elem.nodeType;

            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return undefined;
            }

            if (pass && name in jQuery.attrFn) {
                return jQuery(elem)[name](value);
            }

            // Fallback to prop when attributes are not supported
            if (!("getAttribute" in elem)) {
                return jQuery.prop(elem, name, value);
            }

            var ret, hooks,
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            // Normalize the name if needed
            if (notxml) {
                name = jQuery.attrFix[name] || name;

                hooks = jQuery.attrHooks[name];

                if (!hooks) {
                    // Use boolHook for boolean attributes
                    if (rboolean.test(name)) {
                        hooks = boolHook;

                        // Use nodeHook if available( IE6/7 )
                    } else if (nodeHook) {
                        hooks = nodeHook;
                    }
                }
            }

            if (value !== undefined) {

                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return undefined;

                } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    elem.setAttribute(name, "" + value);
                    return value;
                }

            } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) {
                return ret;

            } else {

                ret = elem.getAttribute(name);

                // Non-existent attributes return null, we normalize to undefined
                return ret === null ? undefined : ret;
            }
        },

        removeAttr: function (elem, name) {
            var propName;
            if (elem.nodeType === 1) {
                name = jQuery.attrFix[name] || name;

                jQuery.attr(elem, name, "");
                elem.removeAttribute(name);

                // Set corresponding property to false for boolean attributes
                if (rboolean.test(name) && (propName = jQuery.propFix[name] || name) in elem) {
                    elem[propName] = false;
                }
            }
        },

        attrHooks: {
            type: {
                set:             },
            // Use the value property for back compat
            // Use the nodeHook for button elements in IE6/7 (#1954)
            value: {
                get: 
                set:             }
        },

        propFix: {
            tabindex: "tabIndex",
            readonly: "readOnly",
            "for": "htmlFor",
            "class": "className",
            maxlength: "maxLength",
            cellspacing: "cellSpacing",
            cellpadding: "cellPadding",
            rowspan: "rowSpan",
            colspan: "colSpan",
            usemap: "useMap",
            frameborder: "frameBorder",
            contenteditable: "contentEditable"
        },

        prop: function (elem, name, value) {
            var nType = elem.nodeType;

            // don't get/set properties on text, comment and attribute nodes
            if (!elem || nType === 3 || nType === 8 || nType === 2) {
                return undefined;
            }

            var ret, hooks,
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);

            if (notxml) {
                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;

                } else {
                    return (elem[name] = value);
                }

            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;

                } else {
                    return elem[name];
                }
            }
        },

        propHooks: {
            tabIndex: {
                get:             }
        }
    });

    // Add the tabindex propHook to attrHooks for back-compat
    jQuery.attrHooks.tabIndex = jQuery.propHooks.tabIndex;

    // Hook for boolean attributes
    boolHook = {
        get: 
        set:     };

    // IE6/7 do not support getting/setting some attributes with get/setAttribute
    if (!jQuery.support.getSetAttribute) {

        // Use this for any attribute in IE6/7
        // This fixes almost every IE6/7 issue
        nodeHook = jQuery.valHooks.button = {
            get: 
            set:         };

        // Set width and height to auto instead of 0 on empty string( Bug #8150 )
        // This is for removals
        jQuery.each(["width", "height"], ;
    }


    // Some attributes require a special call on IE
    if (!jQuery.support.hrefNormalized) {
        jQuery.each(["href", "src", "width", "height"], ;
    }

    if (!jQuery.support.style) {
        jQuery.attrHooks.style = {
            get: 
            set:         };
    }

    // Safari mis-reports the default selected property of an option
    // Accessing the parent's selectedIndex property fixes it
    if (!jQuery.support.optSelected) {
        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
            get:         });
    }

    // Radios and checkboxes getter/setter
    if (!jQuery.support.checkOn) {
        jQuery.each(["radio", "checkbox"], ;
    }
    jQuery.each(["radio", "checkbox"], ;



    var rnamespaces = /\.(.*)$/,
        rformElems = /^(?:textarea|input|select)$/i,
        rperiod = /\./g,
        rspaces = / /g,
        rescape = /[^\w\s.|`]/g,
        fcleanup = 

    /*
     * A number of helper functions used for managing events.
     * Many of the ideas behind this code originated from
     * Dean Edwards' addEvent library.
     */
    jQuery.event = {

        // Bind an event to an element
        // Original by Dean Edwards
        add: function (elem, types, handler, data) {
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            } else if (!handler) {
                // Fixes bug #7229. Fix recommended by jdalton
                return;
            }

            var handleObjIn, handleObj;

            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
            }

            // Make sure that the function being executed has a unique ID
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure
            var elemData = jQuery._data(elem);

            // If no elemData is found then we must be trying to bind to one of the
            // banned noData elements
            if (!elemData) {
                return;
            }

            var events = elemData.events,
                eventHandle = elemData.handle;

            if (!events) {
                elemData.events = events = {};
            }

            if (!eventHandle) {
                elemData.handle = eventHandle = 
            }

            // Add elem as a property of the handle function
            // This is to prevent a memory leak with non-native events in IE.
            eventHandle.elem = elem;

            // Handle multiple events separated by a space
            // jQuery(...).bind("mouseover mouseout", fn);
            types = types.split(" ");

            var type, i = 0,
                namespaces;

            while ((type = types[i++])) {
                handleObj = handleObjIn ? jQuery.extend({}, handleObjIn) : {
                    handler: handler,
                    data: data
                };

                // Namespaced event handlers
                if (type.indexOf(".") > -1) {
                    namespaces = type.split(".");
                    type = namespaces.shift();
                    handleObj.namespace = namespaces.slice(0).sort().join(".");

                } else {
                    namespaces = [];
                    handleObj.namespace = "";
                }

                handleObj.type = type;
                if (!handleObj.guid) {
                    handleObj.guid = handler.guid;
                }

                // Get the current list of functions bound to this event
                var handlers = events[type],
                    special = jQuery.event.special[type] || {};

                // Init the event handler queue
                if (!handlers) {
                    handlers = events[type] = [];

                    // Check for a special event handler
                    // Only use addEventListener/attachEvent if the special
                    // events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                        // Bind the global event handler to the element
                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle, false);

                        } else if (elem.attachEvent) {
                            elem.attachEvent("on" + type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add the function to the element's handler list
                handlers.push(handleObj);

                // Keep track of which events have been used, for event optimization
                jQuery.event.global[type] = true;
            }

            // Nullify elem to prevent memory leaks in IE
            elem = null;
        },

        global: {},

        // Detach an event or set of events from an element
        remove: function (elem, types, handler, pos) {
            // don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            if (handler === false) {
                handler = returnFalse;
            }

            var ret, type, fn, j, i = 0,
                all, namespaces, namespace, special, eventType, handleObj, origType,
                elemData = jQuery.hasData(elem) && jQuery._data(elem),
                events = elemData && elemData.events;

            if (!elemData || !events) {
                return;
            }

            // types is actually an event object here
            if (types && types.type) {
                handler = types.handler;
                types = types.type;
            }

            // Unbind all events for the element
            if (!types || typeof types === "string" && types.charAt(0) === ".") {
                types = types || "";

                for (type in events) {
                    jQuery.event.remove(elem, type + types);
                }

                return;
            }

            // Handle multiple events separated by a space
            // jQuery(...).unbind("mouseover mouseout", fn);
            types = types.split(" ");

            while ((type = types[i++])) {
                origType = type;
                handleObj = null;
                all = type.indexOf(".") < 0;
                namespaces = [];

                if (!all) {
                    // Namespaced event handlers
                    namespaces = type.split(".");
                    type = namespaces.shift();

                    namespace = new RegExp("(^|\\.)" + jQuery.map(namespaces.slice(0).sort(), fcleanup).join("\\.(?:.*\\.)?") + "(\\.|$)");
                }

                eventType = events[type];

                if (!eventType) {
                    continue;
                }

                if (!handler) {
                    for (j = 0; j < eventType.length; j++) {
                        handleObj = eventType[j];

                        if (all || namespace.test(handleObj.namespace)) {
                            jQuery.event.remove(elem, origType, handleObj.handler, j);
                            eventType.splice(j--, 1);
                        }
                    }

                    continue;
                }

                special = jQuery.event.special[type] || {};

                for (j = pos || 0; j < eventType.length; j++) {
                    handleObj = eventType[j];

                    if (handler.guid === handleObj.guid) {
                        // remove the given handler for the given type
                        if (all || namespace.test(handleObj.namespace)) {
                            if (pos == null) {
                                eventType.splice(j--, 1);
                            }

                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }

                        if (pos != null) {
                            break;
                        }
                    }
                }

                // remove generic event handler if no more handlers exist
                if (eventType.length === 0 || pos != null && eventType.length === 1) {
                    if (!special.teardown || special.teardown.call(elem, namespaces) === false) {
                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    ret = null;
                    delete events[type];
                }
            }

            // Remove the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                var handle = elemData.handle;
                if (handle) {
                    handle.elem = null;
                }

                delete elemData.events;
                delete elemData.handle;

                if (jQuery.isEmptyObject(elemData)) {
                    jQuery.removeData(elem, undefined, true);
                }
            }
        },

        // Events that are safe to short-circuit if no handlers are attached.
        // Native DOM events should not be added, they may have inline handlers.
        customEvent: {
            "getData": true,
            "setData": true,
            "changeData": true
        },

        trigger: function (event, data, elem, onlyHandlers) {
            // Event object or event type
            var type = event.type || event,
                namespaces = [],
                exclusive;

            if (type.indexOf("!") >= 0) {
                // Exclusive events trigger only for the exact event (no namespaces)
                type = type.slice(0, -1);
                exclusive = true;
            }

            if (type.indexOf(".") >= 0) {
                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }

            if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) {
                // No jQuery handlers for this event type, and it can't have inline handlers
                return;
            }

            // Caller can pass in an Event, Object, or just an event type string
            event = typeof event === "object" ?
            // jQuery.Event object
            event[jQuery.expando] ? event :
            // Object literal
            new jQuery.Event(type, event) :
            // Just the event type (string)
            new jQuery.Event(type);

            event.type = type;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)");

            // triggerHandler() and global events don't bubble or run the default action
            if (onlyHandlers || !elem) {
                event.preventDefault();
                event.stopPropagation();
            }

            // Handle a global trigger
            if (!elem) {
                // TODO: Stop taunting the data cache; remove global events and always attach to document
                jQuery.each(jQuery.cache, function () {
                    // internalKey variable is just used to make it easier to find
                    // and potentially change this stuff later; currently it just
                    // points to jQuery.expando
                    var internalKey = jQuery.expando,
                        internalCache = this[internalKey];
                    if (internalCache && internalCache.events && internalCache.events[type]) {
                        jQuery.event.trigger(event, data, internalCache.handle.elem);
                    }
                });
                return;
            }

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // Clean up the event in case it is being reused
            event.result = undefined;
            event.target = elem;

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data != null ? jQuery.makeArray(data) : [];
            data.unshift(event);

            var cur = elem,
                // IE doesn't like method names with a colon (#3533, #8272)
                ontype = type.indexOf(":") < 0 ? "on" + type : "";

            // Fire event on the current element, then bubble up the DOM tree
            do {
                var handle = jQuery._data(cur, "handle");

                event.currentTarget = cur;
                if (handle) {
                    handle.apply(cur, data);
                }

                // Trigger an inline bound script
                if (ontype && jQuery.acceptData(cur) && cur[ontype] && cur[ontype].apply(cur, data) === false) {
                    event.result = false;
                    event.preventDefault();
                }

                // Bubble up to document, then to window
                cur = cur.parentNode || cur.ownerDocument || cur === event.target.ownerDocument && window;
            } while (cur && !event.isPropagationStopped());

            // If nobody prevented the default action, do it now
            if (!event.isDefaultPrevented()) {
                var old,
                special = jQuery.event.special[type] || {};

                if ((!special._default || special._default.call(elem.ownerDocument, event) === false) && !(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Can't use an .isFunction)() check here because IE6/7 fails that test.
                    // IE<9 dies on focus to hidden element (#1486), may want to revisit a try/catch.
                    try {
                        if (ontype && elem[type]) {
                            // Don't re-trigger an onFOO event when we call its FOO() method
                            old = elem[ontype];

                            if (old) {
                                elem[ontype] = null;
                            }

                            jQuery.event.triggered = type;
                            elem[type]();
                        }
                    } catch (ieError) {}

                    if (old) {
                        elem[ontype] = old;
                    }

                    jQuery.event.triggered = undefined;
                }
            }

            return event.result;
        },

        handle: function (event) {
            event = jQuery.event.fix(event || window.event);
            // Snapshot the handlers list since a called handler may add/remove events.
            var handlers = ((jQuery._data(this, "events") || {})[event.type] || []).slice(0),
                run_all = !event.exclusive && !event.namespace,
                args = Array.prototype.slice.call(arguments, 0);

            // Use the fix-ed Event rather than the (read-only) native event
            args[0] = event;
            event.currentTarget = this;

            for (var j = 0, l = handlers.length; j < l; j++) {
                var handleObj = handlers[j];

                // Triggered event must 1) be non-exclusive and have no namespace, or
                // 2) have namespace(s) a subset or equal to those in the bound event.
                if (run_all || event.namespace_re.test(handleObj.namespace)) {
                    // Pass in a reference to the handler function itself
                    // So that we can later remove it
                    event.handler = handleObj.handler;
                    event.data = handleObj.data;
                    event.handleObj = handleObj;

                    var ret = handleObj.handler.apply(this, args);

                    if (ret !== undefined) {
                        event.result = ret;
                        if (ret === false) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    }

                    if (event.isImmediatePropagationStopped()) {
                        break;
                    }
                }
            }
            return event.result;
        },

        props: "altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),

        fix: function (event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // store a copy of the original event object
            // and "clone" to set read-only properties
            var originalEvent = event;
            event = jQuery.Event(originalEvent);

            for (var i = this.props.length, prop; i;) {
                prop = this.props[--i];
                event[prop] = originalEvent[prop];
            }

            // Fix target property, if necessary
            if (!event.target) {
                // Fixes #1925 where srcElement might not be defined either
                event.target = event.srcElement || document;
            }

            // check if target is a textnode (safari)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            // Add relatedTarget, if necessary
            if (!event.relatedTarget && event.fromElement) {
                event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
            }

            // Calculate pageX/Y if missing and clientX/Y available
            if (event.pageX == null && event.clientX != null) {
                var eventDocument = event.target.ownerDocument || document,
                    doc = eventDocument.documentElement,
                    body = eventDocument.body;

                event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }

            // Add which for key events
            if (event.which == null && (event.charCode != null || event.keyCode != null)) {
                event.which = event.charCode != null ? event.charCode : event.keyCode;
            }

            // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)
            if (!event.metaKey && event.ctrlKey) {
                event.metaKey = event.ctrlKey;
            }

            // Add which for click: 1 === left; 2 === middle; 3 === right
            // Note: button is not normalized, so don't use it
            if (!event.which && event.button !== undefined) {
                event.which = (event.button & 1 ? 1 : (event.button & 2 ? 3 : (event.button & 4 ? 2 : 0)));
            }

            return event;
        },

        // Deprecated, use jQuery.guid instead
        guid: 1E8,

        // Deprecated, use jQuery.proxy instead
        proxy: jQuery.proxy,

        special: {
            ready: {
                // Make sure the ready event is setup
                setup: jQuery.bindReady,
                teardown: jQuery.noop
            },

            live: {
                add: 

                remove:             },
            /**
             *  This event has been patched by jsanders on 13 June 2013.  The original jQuery 1.6.4 would overwrite
             *  any existing window.onbeforeunload hander with eventHandle.  This will allow both the setup and
             *  teardown methods to respect any existing onbeforeunload handler.
             *
             *  https://tt.amazon.com/0022275030
             */
            beforeunload: {
                amazonOriginal: null,
                setup: function (data, namespaces, eventHandle) {
                    // We only want to do this special case on windows
                    if (jQuery.isWindow(this)) {
                        var f = function(){};
                        if (typeof this.onbeforeunload === "function") {
                            f = jQuery.event.special.beforeunload.amazonOriginal = this.onbeforeunload;
                        }

                        this.onbeforeunload = 
                    }
                },

                teardown: function (namespaces, eventHandle) {
                    this.onbeforeunload = jQuery.event.special.beforeunload.amazonOriginal;
                }
            }
            /**
             *  End Amazon Patch
             */
        }
    };

    jQuery.removeEvent = document.removeEventListener ? : 

    jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!this.preventDefault) {
            return new jQuery.Event(src, props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // timeStamp is buggy for some events on Firefox(#3843)
        // So we won't rely on the native value
        this.timeStamp = jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    };

    function returnFalse() {
        return false;
    }

    
    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        preventDefault: 
        stopPropagation: 
        stopImmediatePropagation: 
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };

    // Checks if an event happened on an element within another element
    // Used in jQuery.event.special.mouseenter and mouseleave handlers
    var withinElement = function (event) {

        // Check if mouse(over|out) are still within the same parent element
        var related = event.relatedTarget,
            inside = false,
            eventType = event.type;

        event.type = event.data;

        if (related !== this) {

            if (related) {
                inside = jQuery.contains(this, related);
            }

            if (!inside) {

                jQuery.event.handle.apply(this, arguments);

                event.type = eventType;
            }
        }
    },

    // In case of event delegation, we only need to rename the event.type,
    // liveHandler will take care of the rest.
    delegate = 

    // Create mouseenter and mouseleave events
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, ;

    // submit delegation
    if (!jQuery.support.submitBubbles) {

        jQuery.event.special.submit = {
            setup: function (data, namespaces) {
                if (!jQuery.nodeName(this, "form")) {
                    jQuery.event.add(this, "click.specialSubmit", function (e) {
                        // Avoid triggering error on non-existent type attribute in IE VML (#7071)
                        var elem = e.target,
                            type = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.type : "";

                        if ((type === "submit" || type === "image") && jQuery(elem).closest("form").length) {
                            trigger("submit", this, arguments);
                        }
                    });

                    jQuery.event.add(this, "keypress.specialSubmit", function (e) {
                        var elem = e.target,
                            type = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.type : "";

                        if ((type === "text" || type === "password") && jQuery(elem).closest("form").length && e.keyCode === 13) {
                            trigger("submit", this, arguments);
                        }
                    });

                } else {
                    return false;
                }
            },

            teardown:         };

    }

    // change delegation, happens here so we have bind.
    if (!jQuery.support.changeBubbles) {

        var changeFilters,

        getVal = function (elem) {
            var type = jQuery.nodeName(elem, "input") ? elem.type : "",
                val = elem.value;

            if (type === "radio" || type === "checkbox") {
                val = elem.checked;

            } else if (type === "select-multiple") {
                val = elem.selectedIndex > -1 ? jQuery.map(elem.options, function (elem) {
                    return elem.selected;
                }).join("-") :
                    "";

            } else if (jQuery.nodeName(elem, "select")) {
                val = elem.selectedIndex;
            }

            return val;
        },

        testChange = function testChange(e) {
            var elem = e.target,
                data, val;

            if (!rformElems.test(elem.nodeName) || elem.readOnly) {
                return;
            }

            data = jQuery._data(elem, "_change_data");
            val = getVal(elem);

            // the current data will be also retrieved by beforeactivate
            if (e.type !== "focusout" || elem.type !== "radio") {
                jQuery._data(elem, "_change_data", val);
            }

            if (data === undefined || val === data) {
                return;
            }

            if (data != null || val) {
                e.type = "change";
                e.liveFired = undefined;
                jQuery.event.trigger(e, arguments[1], elem);
            }
        };

        jQuery.event.special.change = {
            filters: {
                focusout: testChange,

                beforedeactivate: testChange,

                click: function (e) {
                    var elem = e.target,
                        type = jQuery.nodeName(elem, "input") ? elem.type : "";

                    if (type === "radio" || type === "checkbox" || jQuery.nodeName(elem, "select")) {
                        testChange.call(this, e);
                    }
                },

                // Change has to be called before submit
                // Keydown will be called before keypress, which is used in submit-event delegation
                keydown: function (e) {
                    var elem = e.target,
                        type = jQuery.nodeName(elem, "input") ? elem.type : "";

                    if ((e.keyCode === 13 && !jQuery.nodeName(elem, "textarea")) || (e.keyCode === 32 && (type === "checkbox" || type === "radio")) || type === "select-multiple") {
                        testChange.call(this, e);
                    }
                },

                // Beforeactivate happens also before the previous element is blurred
                // with this event you can't trigger a change event, but you can store
                // information
                beforeactivate:             },

            setup: 

            teardown:         };

        changeFilters = jQuery.event.special.change.filters;

        // Handle when the input is .focus()'d
        changeFilters.focus = changeFilters.beforeactivate;
    }

    function trigger(type, elem, args) {
        // Piggyback on a donor event to simulate a different one.
        // Fake originalEvent to avoid donor's stopPropagation, but if the
        // simulated event prevents default then we do the same on the donor.
        // Don't pass args or remember liveFired; they apply to the donor event.
        var event = jQuery.extend({}, args[0]);
        event.type = type;
        event.originalEvent = {};
        event.liveFired = undefined;
        jQuery.event.handle.call(elem, event);
        if (event.isDefaultPrevented()) {
            args[0].preventDefault();
        }
    }

    // Create "bubbling" focus and blur events
    if (!jQuery.support.focusinBubbles) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function (orig, fix) {

            // Attach a single capturing handler while someone wants focusin/focusout
            var attaches = 0;

            jQuery.event.special[fix] = {
                setup: 
                teardown:             };

            function handler(donor) {
                // Donor event is always a native one; fix it and switch its type.
                // Let focusin/out handler cancel the donor focus/blur event.
                var e = jQuery.event.fix(donor);
                e.type = fix;
                e.originalEvent = {};
                jQuery.event.trigger(e, null, e.target);
                if (e.isDefaultPrevented()) {
                    donor.preventDefault();
                }
            }
        });
    }

    jQuery.each(["bind", "one"], function (i, name) {
        jQuery.fn[name] = function (type, data, fn) {
            var handler;

            // Handle object literals
            if (typeof type === "object") {
                for (var key in type) {
                    this[name](key, data, type[key], fn);
                }
                return this;
            }

            if (arguments.length === 2 || data === false) {
                fn = data;
                data = undefined;
            }

            if (name === "one") {
                handler = 
                handler.guid = fn.guid || jQuery.guid++;
            } else {
                handler = fn;
            }

            if (type === "unload" && name !== "one") {
                this.one(type, data, fn);

            } else {
                for (var i = 0, l = this.length; i < l; i++) {
                    jQuery.event.add(this[i], type, handler, data);
                }
            }

            return this;
        };
    });

    jQuery.fn.extend({
        unbind: 

        delegate: 

        undelegate: 

        trigger: 

        triggerHandler: 

        toggle: 

        hover:     });

    var liveMap = {
        focus: "focusin",
        blur: "focusout",
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    };

    jQuery.each(["live", "die"], function (i, name) {
        jQuery.fn[name] = function (types, data, fn, origSelector /* Internal Use Only */ ) {
            var type, i = 0,
                match, namespaces, preType,
                selector = origSelector || this.selector,
                context = origSelector ? this : jQuery(this.context);

            if (typeof types === "object" && !types.preventDefault) {
                for (var key in types) {
                    context[name](key, data, types[key], selector);
                }

                return this;
            }

            if (name === "die" && !types && origSelector && origSelector.charAt(0) === ".") {

                context.unbind(origSelector);

                return this;
            }

            if (data === false || jQuery.isFunction(data)) {
                fn = data || returnFalse;
                data = undefined;
            }

            types = (types || "").split(" ");

            while ((type = types[i++]) != null) {
                match = rnamespaces.exec(type);
                namespaces = "";

                if (match) {
                    namespaces = match[0];
                    type = type.replace(rnamespaces, "");
                }

                if (type === "hover") {
                    types.push("mouseenter" + namespaces, "mouseleave" + namespaces);
                    continue;
                }

                preType = type;

                if (liveMap[type]) {
                    types.push(liveMap[type] + namespaces);
                    type = type + namespaces;

                } else {
                    type = (liveMap[type] || type) + namespaces;
                }

                if (name === "live") {
                    // bind live handler
                    for (var j = 0, l = context.length; j < l; j++) {
                        jQuery.event.add(context[j], "live." + liveConvert(type, selector), {
                            data: data,
                            selector: selector,
                            handler: fn,
                            origType: type,
                            origHandler: fn,
                            preType: preType
                        });
                    }

                } else {
                    // unbind live handler
                    context.unbind("live." + liveConvert(type, selector), fn);
                }
            }

            return this;
        };
    });

    function liveHandler(event) {
        var stop, maxLevel, related, match, handleObj, elem, j, i, l, data, close, namespace, ret,
        elems = [],
            selectors = [],
            events = jQuery._data(this, "events");

        // Make sure we avoid non-left-click bubbling in Firefox (#3861) and disabled elements in IE (#6911)
        if (event.liveFired === this || !events || !events.live || event.target.disabled || event.button && event.type === "click") {
            return;
        }

        if (event.namespace) {
            namespace = new RegExp("(^|\\.)" + event.namespace.split(".").join("\\.(?:.*\\.)?") + "(\\.|$)");
        }

        event.liveFired = this;

        var live = events.live.slice(0);

        for (j = 0; j < live.length; j++) {
            handleObj = live[j];

            if (handleObj.origType.replace(rnamespaces, "") === event.type) {
                selectors.push(handleObj.selector);

            } else {
                live.splice(j--, 1);
            }
        }

        match = jQuery(event.target).closest(selectors, event.currentTarget);

        for (i = 0, l = match.length; i < l; i++) {
            close = match[i];

            for (j = 0; j < live.length; j++) {
                handleObj = live[j];

                if (close.selector === handleObj.selector && (!namespace || namespace.test(handleObj.namespace)) && !close.elem.disabled) {
                    elem = close.elem;
                    related = null;

                    // Those two events require additional checking
                    if (handleObj.preType === "mouseenter" || handleObj.preType === "mouseleave") {
                        event.type = handleObj.preType;
                        related = jQuery(event.relatedTarget).closest(handleObj.selector)[0];

                        // Make sure not to accidentally match a child element with the same selector
                        if (related && jQuery.contains(elem, related)) {
                            related = elem;
                        }
                    }

                    if (!related || related !== elem) {
                        elems.push({
                            elem: elem,
                            handleObj: handleObj,
                            level: close.level
                        });
                    }
                }
            }
        }

        for (i = 0, l = elems.length; i < l; i++) {
            match = elems[i];

            if (maxLevel && match.level > maxLevel) {
                break;
            }

            event.currentTarget = match.elem;
            event.data = match.handleObj.data;
            event.handleObj = match.handleObj;

            ret = match.handleObj.origHandler.apply(match.elem, arguments);

            if (ret === false || event.isPropagationStopped()) {
                maxLevel = match.level;

                if (ret === false) {
                    stop = false;
                }
                if (event.isImmediatePropagationStopped()) {
                    break;
                }
            }
        }

        return stop;
    }

    
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " +
        "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
        "change select submit keydown keypress keyup error").split(" "), ;



    /*!
     * Sizzle CSS Selector Engine
     *  Copyright 2011, The Dojo Foundation
     *  Released under the MIT, BSD, and GPL Licenses.
     *  More information: http://sizzlejs.com/
     */
    (function () {

        var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
            done = 0,
            toString = Object.prototype.toString,
            hasDuplicate = false,
            baseHasDuplicate = true,
            rBackslash = /\\/g,
            rNonWord = /\W/;

        // Here we check if the JavaScript engine is using some sort of
        // optimization where it does not always call our comparision
        // function. If that is the case, discard the hasDuplicate value.
        //   Thus far that includes Google Chrome.
        [0, 0].sort(;

        var Sizzle = 

        Sizzle.uniqueSort = 

        Sizzle.matches = 

        Sizzle.matchesSelector = 

        Sizzle.find = 

        Sizzle.filter = 

        Sizzle.error = 

        var Expr = Sizzle.selectors = {
            order: ["ID", "NAME", "TAG"],

            match: {
                ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
                NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
                ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
                TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
                CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
                POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
                PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
            },

            leftMatch: {},

            attrMap: {
                "class": "className",
                "for": "htmlFor"
            },

            attrHandle: {
                href: function (elem) {
                    return elem.getAttribute("href");
                },
                type:             },

            relative: {
                "+": 

                ">": 

                "": function (checkSet, part, isXML) {
                    var nodeCheck,
                    doneName = done++,
                        checkFn = dirCheck;

                    if (typeof part === "string" && !rNonWord.test(part)) {
                        part = part.toLowerCase();
                        nodeCheck = part;
                        checkFn = dirNodeCheck;
                    }

                    checkFn("parentNode", part, doneName, checkSet, nodeCheck, isXML);
                },

                "~":             },

            find: {
                ID: 

                NAME: 

                TAG:             },
            preFilter: {
                CLASS: 

                ID: 

                TAG: 

                CHILD: 

                ATTR: 

                PSEUDO: 

                POS:             },

            filters: {
                enabled: 

                disabled: function (elem) {
                    return elem.disabled === true;
                },

                checked: 

                selected: 

                parent: 

                empty: 

                has: 

                header: function (elem) {
                    return (/h\d/i).test(elem.nodeName);
                },

                text: 

                radio: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
                },

                checkbox: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
                },

                file: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
                },

                password: function (elem) {
                    return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
                },

                submit: function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === "input" || name === "button") && "submit" === elem.type;
                },

                image: 

                reset: 

                button: 

                input: 

                focus:             },
            setFilters: {
                first: 

                last: 

                even: function (elem, i) {
                    return i % 2 === 0;
                },

                odd: 

                lt: 

                gt: 

                nth: function (elem, i, match) {
                    return match[3] - 0 === i;
                },

                eq:             },
            filter: {
                PSEUDO: 

                CHILD: 

                ID: 

                TAG: 

                CLASS: 

                ATTR: 

                POS:             }
        };

        var origPOS = Expr.match.POS,
            fescape = 

        for (var type in Expr.match) {
            Expr.match[type] = new RegExp(Expr.match[type].source + (/(?![^\[]*\])(?![^\(]*\))/.source));
            Expr.leftMatch[type] = new RegExp(/(^(?:.|\r|\n)*?)/.source + Expr.match[type].source.replace(/\\(\d+)/g, fescape));
        }

        var makeArray = 

        // Perform a simple check to determine if the browser is capable of
        // converting a NodeList to an array using builtin methods.
        // Also verifies that the returned array holds DOM nodes
        // (which is not the case in the Blackberry browser)
        try {
            Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType;

            // Provide a fallback method if it does not work
        } catch (e) {
            makeArray = 
        }

        var sortOrder, siblingCheck;

        if (document.documentElement.compareDocumentPosition) {
            sortOrder = 

        } else {
            sortOrder = 

            siblingCheck = 
        }

        // Utility function for retreiving the text value of an array of DOM nodes
        Sizzle.getText = 

        // Check to see if the browser returns elements by name when
        // querying by getElementById (and provide a workaround)
        (();

        (();

        if (document.querySelectorAll) {
            (();
        }

        (();

        (();

        
        
        if (document.documentElement.contains) {
            Sizzle.contains = 

        } else if (document.documentElement.compareDocumentPosition) {
            Sizzle.contains = 

        } else {
            Sizzle.contains = function () {
                return false;
            };
        }

        Sizzle.isXML = 

        var posProcess = 

        // EXPOSE
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.filters;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;


    })();


    var runtil = /Until$/,
        rparentsprev = /^(?:parents|prevUntil|prevAll)/,
        // Note: This RegExp should be improved, or likely pulled from Sizzle
        rmultiselector = /,/,
        isSimple = /^.[^:#\[\.,]*$/,
        slice = Array.prototype.slice,
        POS = jQuery.expr.match.POS,
        // methods guaranteed to produce a unique set when starting from a unique set
        guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
        };

    jQuery.fn.extend({
        find: 

        has: 

        not: function (selector) {
            return this.pushStack(winnow(this, selector, false), "not", selector);
        },

        filter: 

        is: 

        closest: function (selectors, context) {
            var ret = [],
                i, l, cur = this[0];

            // Array
            if (jQuery.isArray(selectors)) {
                var match, selector,
                matches = {},
                level = 1;

                if (cur && selectors.length) {
                    for (i = 0, l = selectors.length; i < l; i++) {
                        selector = selectors[i];

                        if (!matches[selector]) {
                            matches[selector] = POS.test(selector) ? jQuery(selector, context || this.context) : selector;
                        }
                    }

                    while (cur && cur.ownerDocument && cur !== context) {
                        for (selector in matches) {
                            match = matches[selector];

                            if (match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match)) {
                                ret.push({
                                    selector: selector,
                                    elem: cur,
                                    level: level
                                });
                            }
                        }

                        cur = cur.parentNode;
                        level++;
                    }
                }

                return ret;
            }

            // String
            var pos = POS.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

            for (i = 0, l = this.length; i < l; i++) {
                cur = this[i];

                while (cur) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) {
                        ret.push(cur);
                        break;

                    } else {
                        cur = cur.parentNode;
                        if (!cur || !cur.ownerDocument || cur === context || cur.nodeType === 11) {
                            break;
                        }
                    }
                }
            }

            ret = ret.length > 1 ? jQuery.unique(ret) : ret;

            return this.pushStack(ret, "closest", selectors);
        },

        // Determine the position of an element within
        // the matched set of elements
        index: 

        add: 

        andSelf:     });

    // A painfully simple check to see if an element is disconnected
    // from a document (should be improved, where feasible).

    
    jQuery.each({
        parent: 
        parents: function (elem) {
            return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function (elem, i, until) {
            return jQuery.dir(elem, "parentNode", until);
        },
        next: function (elem) {
            return jQuery.nth(elem, 2, "nextSibling");
        },
        prev: 
        nextAll: function (elem) {
            return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function (elem) {
            return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function (elem, i, until) {
            return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: 
        siblings: 
        children: function (elem) {
            return jQuery.sibling(elem.firstChild);
        },
        contents:     }, ;

    jQuery.extend({
        filter: 

        dir: 

        nth: 

        sibling:     });

    // Implement the identical functionality for filter and not

    


    var rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnocache = /<(?:script|object|embed|option|style)/i,
        // checked="checked" or checked
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /\/(java|ecma)script/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
        wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            legend: [1, "<fieldset>", "</fieldset>"],
            thead: [1, "<table>", "</table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            area: [1, "<map>", "</map>"],
            _default: [0, "", ""]
        };

    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    // IE can't serialize <link> and <script> tags normally
    if (!jQuery.support.htmlSerialize) {
        wrapMap._default = [1, "div<div>", "</div>"];
    }

    jQuery.fn.extend({
        text: 

        wrapAll: 

        wrapInner: 

        wrap: 

        unwrap: 

        append: 

        prepend: 

        before: 

        after: 

        // keepData is for internal use only--do not document
        remove: 

        empty: 

        clone: 

        html: 

        replaceWith: 

        detach: function (selector) {
            return this.remove(selector, true);
        },

        domManip:     });

    
    function cloneCopyEvent(src, dest) {

        if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
            return;
        }

        var internalKey = jQuery.expando,
            oldData = jQuery.data(src),
            curData = jQuery.data(dest, oldData);

        // Switch to use the internal data object, if it exists, for the next
        // stage of data copying
        if ((oldData = oldData[internalKey])) {
            var events = oldData.events;
            curData = curData[internalKey] = jQuery.extend({}, oldData);

            if (events) {
                delete curData.handle;
                curData.events = {};

                for (var type in events) {
                    for (var i = 0, l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type + (events[type][i].namespace ? "." : "") + events[type][i].namespace, events[type][i], events[type][i].data);
                    }
                }
            }
        }
    }

    
    jQuery.buildFragment = function (args, nodes, scripts) {
        var fragment, cacheable, cacheresults, doc;

        // nodes may contain either an explicit document object,
        // a jQuery collection or context object.
        // If nodes[0] contains a valid object to assign to doc
        if (nodes && nodes[0]) {
            doc = nodes[0].ownerDocument || nodes[0];
        }

        // Ensure that an attr object doesn't incorrectly stand in as a document object
        // Chrome and Firefox seem to allow this to occur and will throw exception
        // Fixes #8950
        if (!doc.createDocumentFragment) {
            doc = document;
        }

        // Only cache "small" (1/2 KB) HTML strings that are associated with the main document
        // Cloning options loses the selected state, so don't cache them
        // IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
        // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
        if (args.length === 1 && typeof args[0] === "string" && args[0].length < 512 && doc === document && args[0].charAt(0) === "<" && !rnocache.test(args[0]) && (jQuery.support.checkClone || !rchecked.test(args[0]))) {

            cacheable = true;

            cacheresults = jQuery.fragments[args[0]];
            if (cacheresults && cacheresults !== 1) {
                fragment = cacheresults;
            }
        }

        if (!fragment) {
            fragment = doc.createDocumentFragment();
            jQuery.clean(args, doc, fragment, scripts);
        }

        if (cacheable) {
            jQuery.fragments[args[0]] = cacheresults ? fragment : 1;
        }

        return {
            fragment: fragment,
            cacheable: cacheable
        };
    };

    jQuery.fragments = {};

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, ;

    function getAll(elem) {
        if ("getElementsByTagName" in elem) {
            return elem.getElementsByTagName("*");

        } else if ("querySelectorAll" in elem) {
            return elem.querySelectorAll("*");

        } else {
            return [];
        }
    }

    // Used in clean, fixes the defaultChecked property

        // Finds all inputs and passes them to fixDefaultChecked

    function findInputs(elem) {
        if (jQuery.nodeName(elem, "input")) {
            fixDefaultChecked(elem);
        } else if ("getElementsByTagName" in elem) {
            jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked);
        }
    }

    jQuery.extend({
        clone: function (elem, dataAndEvents, deepDataAndEvents) {
            var clone = elem.cloneNode(true),
                srcElements,
                destElements,
                i;

            if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                // IE copies events bound via attachEvent when using cloneNode.
                // Calling detachEvent on the clone will also remove the events
                // from the original. In order to get around this, we use some
                // proprietary methods to clear the events. Thanks to MooTools
                // guys for this hotness.

                cloneFixAttributes(elem, clone);

                // Using Sizzle here is crazy slow, so we use getElementsByTagName
                // instead
                srcElements = getAll(elem);
                destElements = getAll(clone);

                // Weird iteration because IE will replace the length property
                // with an element if you are cloning the body and one of the
                // elements on the page has a name or id of "length"
                for (i = 0; srcElements[i]; ++i) {
                    // Ensure that the destination node is not null; Fixes #9587
                    if (destElements[i]) {
                        cloneFixAttributes(srcElements[i], destElements[i]);
                    }
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                cloneCopyEvent(elem, clone);

                if (deepDataAndEvents) {
                    srcElements = getAll(elem);
                    destElements = getAll(clone);

                    for (i = 0; srcElements[i]; ++i) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                }
            }

            srcElements = destElements = null;

            // Return the cloned set
            return clone;
        },

        clean: function (elems, context, fragment, scripts) {
            var checkScriptType;

            context = context || document;

            // !context.createElement fails in IE with an error but returns typeof 'object'
            if (typeof context.createElement === "undefined") {
                context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
            }

            var ret = [],
                j;

            for (var i = 0, elem;
            (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") {
                    elem += "";
                }

                if (!elem) {
                    continue;
                }

                // Convert html string into DOM nodes
                if (typeof elem === "string") {
                    if (!rhtml.test(elem)) {
                        elem = context.createTextNode(elem);
                    } else {
                        // Fix "XHTML"-style tags in all browsers
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");

                        // Trim whitespace, otherwise indexOf won't work as expected
                        var tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(),
                            wrap = wrapMap[tag] || wrapMap._default,
                            depth = wrap[0],
                            div = context.createElement("div");

                        // Go to html and back, then peel off extra wrappers
                        div.innerHTML = wrap[1] + elem + wrap[2];

                        // Move to the right depth
                        while (depth--) {
                            div = div.lastChild;
                        }

                        // Remove IE's autoinserted <tbody> from table fragments
                        if (!jQuery.support.tbody) {

                            // String was a <table>, *may* have spurious <tbody>
                            var hasBody = rtbody.test(elem),
                                tbody = tag === "table" && !hasBody ? div.firstChild && div.firstChild.childNodes :

                                // String was a bare <thead> or <tfoot>
                                wrap[1] === "<table>" && !hasBody ? div.childNodes : [];

                            for (j = tbody.length - 1; j >= 0; --j) {
                                if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) {
                                    tbody[j].parentNode.removeChild(tbody[j]);
                                }
                            }
                        }

                        // IE completely kills leading whitespace when innerHTML is used
                        if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
                            div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild);
                        }

                        elem = div.childNodes;
                    }
                }

                // Resets defaultChecked for any radios and checkboxes
                // about to be appended to the DOM in IE 6/7 (#8060)
                var len;
                if (!jQuery.support.appendChecked) {
                    if (elem[0] && typeof (len = elem.length) === "number") {
                        for (j = 0; j < len; j++) {
                            findInputs(elem[j]);
                        }
                    } else {
                        findInputs(elem);
                    }
                }

                if (elem.nodeType) {
                    ret.push(elem);
                } else {
                    ret = jQuery.merge(ret, elem);
                }
            }

            if (fragment) {
                checkScriptType = 
                for (i = 0; ret[i]; i++) {
                    if (scripts && jQuery.nodeName(ret[i], "script") && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript")) {
                        scripts.push(ret[i].parentNode ? ret[i].parentNode.removeChild(ret[i]) : ret[i]);

                    } else {
                        if (ret[i].nodeType === 1) {
                            var jsTags = jQuery.grep(ret[i].getElementsByTagName("script"), checkScriptType);

                            ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
                        }
                        fragment.appendChild(ret[i]);
                    }
                }
            }

            return ret;
        },

        cleanData: function (elems) {
            var data, id, cache = jQuery.cache,
                internalKey = jQuery.expando,
                special = jQuery.event.special,
                deleteExpando = jQuery.support.deleteExpando;

            for (var i = 0, elem;
            (elem = elems[i]) != null; i++) {
                if (elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) {
                    continue;
                }

                id = elem[jQuery.expando];

                if (id) {
                    data = cache[id] && cache[id][internalKey];

                    if (data && data.events) {
                        for (var type in data.events) {
                            if (special[type]) {
                                jQuery.event.remove(elem, type);

                                // This is a shortcut to avoid jQuery.event.remove's overhead
                            } else {
                                jQuery.removeEvent(elem, type, data.handle);
                            }
                        }

                        // Null the DOM reference to avoid IE6/7/8 leak (#7054)
                        if (data.handle) {
                            data.handle.elem = null;
                        }
                    }

                    if (deleteExpando) {
                        delete elem[jQuery.expando];

                    } else if (elem.removeAttribute) {
                        elem.removeAttribute(jQuery.expando);
                    }

                    delete cache[id];
                }
            }
        }
    });

    


    var ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity=([^)]*)/,
        // fixed for IE9, see #8346
        rupper = /([A-Z]|^ms)/g,
        rnumpx = /^-?\d+(?:px)?$/i,
        rnum = /^-?\d/,
        rrelNum = /^([\-+])=([\-+.\de]+)/,

        cssShow = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        cssWidth = ["Left", "Right"],
        cssHeight = ["Top", "Bottom"],
        curCSS,

        getComputedStyle,
        currentStyle;

    jQuery.fn.css = 

    jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get:             }
        },

        // Exclude the following css properties to add px
        cssNumber: {
            "fillOpacity": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            // normalize float css property
            "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
        },

        // Get and set the style property on a DOM Node
        style: 

        css: 

        // A method for quickly swapping in/out CSS properties to get correct calculations
        swap:     });

    // DEPRECATED, Use jQuery.css() instead
    jQuery.curCSS = jQuery.css;

    jQuery.each(["height", "width"], ;

    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: 

            set: function (elem, value) {
                var style = elem.style,
                    currentStyle = elem.currentStyle,
                    opacity = jQuery.isNaN(value) ? "" : "alpha(opacity=" + value * 100 + ")",
                    filter = currentStyle && currentStyle.filter || style.filter || "";

                // IE has trouble with opacity if it does not have layout
                // Force it by setting the zoom level
                style.zoom = 1;

                // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
                if (value >= 1 && jQuery.trim(filter.replace(ralpha, "")) === "") {

                    // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
                    // if "filter:" is present at all, clearType is disabled, we want to avoid this
                    // style.removeAttribute is IE Only, but so apparently is this code path...
                    style.removeAttribute("filter");

                    // if there there is no filter style applied in a css rule, we are done
                    if (currentStyle && !currentStyle.filter) {
                        return;
                    }
                }

                // otherwise, set new filter values
                style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity;
            }
        };
    }

    jQuery(;

    if (document.defaultView && document.defaultView.getComputedStyle) {
        getComputedStyle = function (elem, name) {
            var ret, defaultView, computedStyle;

            name = name.replace(rupper, "-$1").toLowerCase();

            if (!(defaultView = elem.ownerDocument.defaultView)) {
                return undefined;
            }

            if ((computedStyle = defaultView.getComputedStyle(elem, null))) {
                ret = computedStyle.getPropertyValue(name);
                if (ret === "" && !jQuery.contains(elem.ownerDocument.documentElement, elem)) {
                    ret = jQuery.style(elem, name);
                }
            }

            return ret;
        };
    }

    if (document.documentElement.currentStyle) {
        currentStyle = function (elem, name) {
            var left,
            ret = elem.currentStyle && elem.currentStyle[name],
                rsLeft = elem.runtimeStyle && elem.runtimeStyle[name],
                style = elem.style;

            // From the awesome hack by Dean Edwards
            // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

            // If we're not dealing with a regular pixel number
            // but a number that has a weird ending, we need to convert it to pixels
            if (!rnumpx.test(ret) && rnum.test(ret)) {
                // Remember the original values
                left = style.left;

                // Put in the new values to get a computed value out
                if (rsLeft) {
                    elem.runtimeStyle.left = elem.currentStyle.left;
                }
                style.left = name === "fontSize" ? "1em" : (ret || 0);
                ret = style.pixelLeft + "px";

                // Revert the changed values
                style.left = left;
                if (rsLeft) {
                    elem.runtimeStyle.left = rsLeft;
                }
            }

            return ret === "" ? "auto" : ret;
        };
    }

    curCSS = getComputedStyle || currentStyle;

    function getWH(elem, name, extra) {

        // Start with offset property
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            which = name === "width" ? cssWidth : cssHeight;

        if (val > 0) {
            if (extra !== "border") {
                jQuery.each(which, function () {
                    if (!extra) {
                        val -= parseFloat(jQuery.css(elem, "padding" + this)) || 0;
                    }
                    if (extra === "margin") {
                        val += parseFloat(jQuery.css(elem, extra + this)) || 0;
                    } else {
                        val -= parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
                    }
                });
            }

            return val + "px";
        }

        // Fall back to computed then uncomputed css if necessary
        val = curCSS(elem, name, name);
        if (val < 0 || val == null) {
            val = elem.style[name] || 0;
        }
        // Normalize "", auto, and prepare for extra
        val = parseFloat(val) || 0;

        // Add padding, border, margin
        if (extra) {
            jQuery.each(which, function () {
                val += parseFloat(jQuery.css(elem, "padding" + this)) || 0;
                if (extra !== "padding") {
                    val += parseFloat(jQuery.css(elem, "border" + this + "Width")) || 0;
                }
                if (extra === "margin") {
                    val += parseFloat(jQuery.css(elem, extra + this)) || 0;
                }
            });
        }

        return val + "px";
    }

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.hidden = 

        jQuery.expr.filters.visible = 
    }



    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rhash = /#.*$/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
        rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
        // #7653, #8125, #8152: local protocol detection
        rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rquery = /\?/,
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rselectTextarea = /^(?:select|textarea)/i,
        rspacesAjax = /\s+/,
        rts = /([?&])_=[^&]*/,
        rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

        // Keep a copy of the old load method
        _load = jQuery.fn.load,

        /* Prefilters
         * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
         * 2) These are called:
         *    - BEFORE asking for a transport
         *    - AFTER param serialization (s.data is a string if s.processData is true)
         * 3) key is the dataType
         * 4) the catchall symbol "*" can be used
         * 5) execution will start with transport dataType and THEN continue down to "*" if needed
         */
        prefilters = {},

        /* Transports bindings
         * 1) key is the dataType
         * 2) the catchall symbol "*" can be used
         * 3) selection will start with transport dataType and THEN go to "*" if needed
         */
        transports = {},

        // Document location
        ajaxLocation,

        // Document location segments
        ajaxLocParts,

        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
        allTypes = ["*/"] + ["*"];

    // #8138, IE may throw an exception when accessing
    // a field from window.location if document.domain has been set
    try {
        ajaxLocation = location.href;
    } catch (e) {
        // Use the href attribute of an A element
        // since IE will modify it given document.location
        ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href;
    }

    // Segment location into parts
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

    
    // Base inspection function for prefilters and transports

    
    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887

    
    jQuery.fn.extend({
        load: 

        serialize: 

        serializeArray:     });

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), ;

    jQuery.each(["get", "post"], ;

    jQuery.extend({

        getScript: 

        getJSON: 

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function (target, settings) {
            if (settings) {
                // Building a settings object
                ajaxExtend(target, jQuery.ajaxSettings);
            } else {
                // Extending ajaxSettings
                settings = target;
                target = jQuery.ajaxSettings;
            }

            // [AUI-11116] Wrap success and error callbacks in AUI guard function if available
            if (typeof P.guardCurrent !== 'undefined') {
                if (settings.success) {
                    settings.success = P.guardCurrent(settings.success);
                }
                if (settings.error) {
                    settings.error = P.guardCurrent(settings.error);
                }
            }

            ajaxExtend(target, settings);
            return target;
        },

        ajaxSettings: {
            url: ajaxLocation,
            isLocal: rlocalProtocol.test(ajaxLocParts[1]),
            global: true,
            type: "GET",
            contentType: "application/x-www-form-urlencoded",
            processData: true,
            async: true,
            /*
            timeout: 0,
            data: null,
            dataType: null,
            username: null,
            password: null,
            cache: null,
            traditional: false,
            headers: {},
            */

            accepts: {
                xml: "application/xml, text/xml",
                html: "text/html",
                text: "text/plain",
                json: "application/json, text/javascript",
                "*": allTypes
            },

            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText"
            },

            // List of data converters
            // 1) key format is "source_type destination_type" (a single space in-between)
            // 2) the catchall symbol "*" can be used for source_type
            converters: {

                // Convert anything to text
                "* text": window.String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                context: true,
                url: true
            }
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function (url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var // Create the final options object
            s = jQuery.ajaxSetup({}, options),
                // Callbacks context
                callbackContext = s.context || s,
                // Context for global events
                // It's the callbackContext if one was provided in the options
                // and if it's a DOM node or a jQuery collection
                globalEventContext = callbackContext !== s && (callbackContext.nodeType || callbackContext instanceof jQuery) ? jQuery(callbackContext) : jQuery.event,
                // Deferreds
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery._Deferred(),
                // Status-dependent callbacks
                statusCode = s.statusCode || {},
                // ifModified key
                ifModifiedKey,
                // Headers (they are sent all at once)
                requestHeaders = {},
                requestHeadersNames = {},
                // Response headers
                responseHeadersString,
                responseHeaders,
                // transport
                transport,
                // timeout handle
                timeoutTimer,
                // Cross-domain detection vars
                parts,
                // The jqXHR state
                state = 0,
                // To know if global events are to be dispatched
                fireGlobals,
                // Loop variable
                i,
                // Fake xhr
                jqXHR = {

                    readyState: 0,

                    // Caches the header
                    setRequestHeader: 

                    // Raw string
                    getAllResponseHeaders: 

                    // Builds headers hashtable if needed
                    getResponseHeader: 

                    // Overrides response content-type header
                    overrideMimeType: 

                    // Cancel the request
                    abort:                 };

            // Callback for when everything is done
            // It is defined here because jslint complains if it is declared
            // at the end of the function (which would be more logical and readable)

            
            // Attach deferreds
            deferred.promise(jqXHR);
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.done;

            // Status-dependent callbacks
            jqXHR.statusCode = 

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
            // We also use the url parameter if available
            s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(rspacesAjax);

            // Determine if a cross-domain request is in order
            if (s.crossDomain == null) {
                parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !! (parts && (parts[1] != ajaxLocParts[1] || parts[2] != ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))));
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefiler, stop there
            if (state === 2) {
                return false;
            }

            // We can fire global events as of now if asked to
            fireGlobals = s.global;

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Get ifModifiedKey before adding the anti-cache parameter
                ifModifiedKey = s.url;

                // Add anti-cache in url if needed
                if (s.cache === false) {

                    var ts = jQuery.now(),
                        // try replacing _= if it is there
                        ret = s.url.replace(rts, "$1_=" + ts);

                    // if nothing was replaced, add timestamp to the end
                    s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : "");
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]);
                }
                if (jQuery.etag[ifModifiedKey]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]);
                }
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader(
                "Accept",
            s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                // Abort if not done already
                jqXHR.abort();
                return false;

            }

            // Install callbacks on deferreds
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;
                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }
                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = setTimeout( s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {
                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);
                        // Simply rethrow otherwise
                    } else {
                        jQuery.error(e);
                    }
                }
            }

            return jqXHR;
        },

        // Serialize an array of form elements or a set of
        // key/values into a query string
        param:     });

    
    // This is still on the jQuery object... for now
    // Want to move this to jQuery.ajax some day
    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {}

    });

    /* Handles responses to an ajax request:
     * - sets all responseXXX fields accordingly
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */

    
    // Chain conversions given the request and the original response

    


    var jsc = jQuery.now(),
        jsre = /(\=)\?(&|$)|\?\?/i;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback:     });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", ;



    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /javascript|ecmascript/
        },
        converters: {
            "text script":         }
    });

    // Handle cache's special case and global
    jQuery.ajaxPrefilter("script", ;

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", ;



    var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
    xhrOnUnloadAbort = window.ActiveXObject ? : false,
        xhrId = 0,
        xhrCallbacks;

    // Functions to create xhrs

    
    
    // Create the request object
    // (This is still attached to ajaxSettings for backward compatibility)
    jQuery.ajaxSettings.xhr = window.ActiveXObject ?
    /* Microsoft failed to properly
     * implement the XMLHttpRequest in IE7 (can't request local files),
     * so we use the ActiveXObject when it is available
     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
     * we need a fallback.
     */

    :
    // For all other browsers, use the standard XMLHttpRequest object
    createStandardXHR;

    // Determine support properties
    ((jQuery.ajaxSettings.xhr());

    // Create transport if the browser can provide an xhr
    if (jQuery.support.ajax) {

        jQuery.ajaxTransport(;
    }



    var elemdisplay = {},
    iframe, iframeDoc,
    rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
        timerId,
        fxAttrs = [
        // height animations
        ["height", "marginTop", "marginBottom", "paddingTop", "paddingBottom"],
        // width animations
        ["width", "marginLeft", "marginRight", "paddingLeft", "paddingRight"],
        // opacity animations
        ["opacity"]],
        fxNow;

    jQuery.fn.extend({
        show: 

        hide: function (speed, easing, callback) {
            if (speed || speed === 0) {
                return this.animate(genFx("hide", 3), speed, easing, callback);

            } else {
                for (var i = 0, j = this.length; i < j; i++) {
                    if (this[i].style) {
                        var display = jQuery.css(this[i], "display");

                        if (display !== "none" && !jQuery._data(this[i], "olddisplay")) {
                            jQuery._data(this[i], "olddisplay", display);
                        }
                    }
                }

                // Set the display of the elements in a second loop
                // to avoid the constant reflow
                for (i = 0; i < j; i++) {
                    if (this[i].style) {
                        this[i].style.display = "none";
                    }
                }

                return this;
            }
        },

        // Save the old toggle function
        _toggle: jQuery.fn.toggle,

        toggle: 

        fadeTo: 

        animate: function (prop, speed, easing, callback) {
            var optall = jQuery.speed(speed, easing, callback);

            if (jQuery.isEmptyObject(prop)) {
                return this.each(optall.complete, [false]);
            }

            // Do not change referenced properties as per-property easing will be lost
            prop = jQuery.extend({}, prop);

            return this[optall.queue === false ? "each" : "queue"](function () {
                // XXX 'this' does not always have a nodeName when running the
                // test suite

                if (optall.queue === false) {
                    jQuery._mark(this);
                }

                var opt = jQuery.extend({}, optall),
                    isElement = this.nodeType === 1,
                    hidden = isElement && jQuery(this).is(":hidden"),
                    name, val, p,
                    display, e,
                    parts, start, end, unit;

                // will store per property easing and be used to determine when an animation is complete
                opt.animatedProperties = {};

                for (p in prop) {

                    // property name normalization
                    name = jQuery.camelCase(p);
                    if (p !== name) {
                        prop[name] = prop[p];
                        delete prop[p];
                    }

                    val = prop[name];

                    // easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
                    if (jQuery.isArray(val)) {
                        opt.animatedProperties[name] = val[1];
                        val = prop[name] = val[0];
                    } else {
                        opt.animatedProperties[name] = opt.specialEasing && opt.specialEasing[name] || opt.easing || 'swing';
                    }

                    if (val === "hide" && hidden || val === "show" && !hidden) {
                        return opt.complete.call(this);
                    }

                    if (isElement && (name === "height" || name === "width")) {
                        // Make sure that nothing sneaks out
                        // Record all 3 overflow attributes because IE does not
                        // change the overflow attribute when overflowX and
                        // overflowY are set to the same value
                        opt.overflow = [this.style.overflow, this.style.overflowX, this.style.overflowY];

                        // Set display property to inline-block for height/width
                        // animations on inline elements that are having width/height
                        // animated
                        if (jQuery.css(this, "display") === "inline" && jQuery.css(this, "float") === "none") {
                            if (!jQuery.support.inlineBlockNeedsLayout) {
                                this.style.display = "inline-block";

                            } else {
                                display = defaultDisplay(this.nodeName);

                                // inline-level elements accept inline-block;
                                // block-level elements need to be inline with layout
                                if (display === "inline") {
                                    this.style.display = "inline-block";

                                } else {
                                    this.style.display = "inline";
                                    this.style.zoom = 1;
                                }
                            }
                        }
                    }
                }

                if (opt.overflow != null) {
                    this.style.overflow = "hidden";
                }

                for (p in prop) {
                    e = new jQuery.fx(this, opt, p);
                    val = prop[p];

                    if (rfxtypes.test(val)) {
                        e[val === "toggle" ? hidden ? "show" : "hide" : val]();

                    } else {
                        parts = rfxnum.exec(val);
                        start = e.cur();

                        if (parts) {
                            end = parseFloat(parts[2]);
                            unit = parts[3] || (jQuery.cssNumber[p] ? "" : "px");

                            // We need to compute starting value
                            if (unit !== "px") {
                                jQuery.style(this, p, (end || 1) + unit);
                                start = ((end || 1) / e.cur()) * start;
                                jQuery.style(this, p, start + unit);
                            }

                            // If a +=/-= token was provided, we're doing a relative animation
                            if (parts[1]) {
                                end = ((parts[1] === "-=" ? -1 : 1) * end) + start;
                            }

                            e.custom(start, end, unit);

                        } else {
                            e.custom(start, val, "");
                        }
                    }
                }

                // For JS strict compliance
                return true;
            });
        },

        stop: function (clearQueue, gotoEnd) {
            if (clearQueue) {
                this.queue([]);
            }

            this.each(function () {
                var timers = jQuery.timers,
                    i = timers.length;
                // clear marker counters if we know they won't be
                if (!gotoEnd) {
                    jQuery._unmark(true, this);
                }
                while (i--) {
                    if (timers[i].elem === this) {
                        if (gotoEnd) {
                            // force the next step to be the last
                            timers[i](true);
                        }

                        timers.splice(i, 1);
                    }
                }
            });

            // start the next in the queue if the last step wasn't forced
            if (!gotoEnd) {
                this.dequeue();
            }

            return this;
        }

    });

    // Animations created synchronously will run synchronously

    
    
    // Generate parameters to create a standard animation

    
    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show", 1),
        slideUp: genFx("hide", 1),
        slideToggle: genFx("toggle", 1),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, ;

    jQuery.extend({
        speed: function (speed, easing, fn) {
            var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };

            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

            // Queueing
            opt.old = opt.complete;
            opt.complete = function (noUnmark) {
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }

                if (opt.queue !== false) {
                    jQuery.dequeue(this);
                } else if (noUnmark !== false) {
                    jQuery._unmark(this);
                }
            };

            return opt;
        },

        easing: {
            linear: 
            swing:         },

        timers: [],

        fx: 
    });

    jQuery.fx.prototype = {
        // Simple function for setting a style value
        update: 

        // Get the current size
        cur: 

        // Start an animation from one number to another
        custom: function (from, to, unit) {
            var self = this,
                fx = jQuery.fx;

            this.startTime = fxNow || createFxNow();
            this.start = from;
            this.end = to;
            this.unit = unit || this.unit || (jQuery.cssNumber[this.prop] ? "" : "px");
            this.now = this.start;
            this.pos = this.state = 0;

            function t(gotoEnd) {
                return self.step(gotoEnd);
            }

            t.elem = this.elem;

            if (t() && jQuery.timers.push(t) && !timerId) {
                timerId = setInterval(fx.tick, fx.interval);
            }
        },

        // Simple 'show' function
        show: 

        // Simple 'hide' function
        hide: 

        // Each step of an animation
        step: function (gotoEnd) {
            var t = fxNow || createFxNow(),
                done = true,
                elem = this.elem,
                options = this.options,
                i, n;

            if (gotoEnd || t >= options.duration + this.startTime) {
                this.now = this.end;
                this.pos = this.state = 1;
                this.update();

                options.animatedProperties[this.prop] = true;

                for (i in options.animatedProperties) {
                    if (options.animatedProperties[i] !== true) {
                        done = false;
                    }
                }

                if (done) {
                    // Reset the overflow
                    if (options.overflow != null && !jQuery.support.shrinkWrapBlocks) {

                        jQuery.each(["", "X", "Y"], ;
                    }

                    // Hide the element if the "hide" operation was done
                    if (options.hide) {
                        jQuery(elem).hide();
                    }

                    // Reset the properties, if the item has been hidden or shown
                    if (options.hide || options.show) {
                        for (var p in options.animatedProperties) {
                            jQuery.style(elem, p, options.orig[p]);
                        }
                    }

                    // Execute the complete function
                    options.complete.call(elem);
                }

                return false;

            } else {
                // classical easing cannot be used with an Infinity duration
                if (options.duration == Infinity) {
                    this.now = t;
                } else {
                    n = t - this.startTime;
                    this.state = n / options.duration;

                    // Perform the easing function, defaults to swing
                    this.pos = jQuery.easing[options.animatedProperties[this.prop]](this.state, n, 0, 1, options.duration);
                    this.now = this.start + ((this.end - this.start) * this.pos);
                }
                // Perform the next step of the animation
                this.update();
            }

            return true;
        }
    };

    jQuery.extend(jQuery.fx, {
        tick: function () {
            for (var timers = jQuery.timers, i = 0; i < timers.length; ++i) {
                if (!timers[i]()) {
                    timers.splice(i--, 1);
                }
            }

            if (!timers.length) {
                jQuery.fx.stop();
            }
        },

        interval: 13,

        stop: 

        speeds: {
            slow: 600,
            fast: 200,
            // Default speed
            _default: 400
        },

        step: {
            opacity: 

            _default:         }
    });

    if (jQuery.expr && jQuery.expr.filters) {
        jQuery.expr.filters.animated = 
    }

    // Try to restore the default display value of an element

    


    var rtable = /^t(?:able|d|h)$/i,
        rroot = /^(?:body|html)$/i;

    if ("getBoundingClientRect" in document.documentElement) {
        jQuery.fn.offset = 

    } else {
        jQuery.fn.offset = 
    }

    jQuery.offset = {
        initialize: function () {
            var body = document.body,
                container = document.createElement("div"),
                innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat(jQuery.css(body, "marginTop")) || 0,
                html = "<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";

            jQuery.extend(container.style, {
                position: "absolute",
                top: 0,
                left: 0,
                margin: 0,
                border: 0,
                width: "1px",
                height: "1px",
                visibility: "hidden"
            });

            container.innerHTML = html;
            body.insertBefore(container, body.firstChild);
            innerDiv = container.firstChild;
            checkDiv = innerDiv.firstChild;
            td = innerDiv.nextSibling.firstChild.firstChild;

            this.doesNotAddBorder = (checkDiv.offsetTop !== 5);
            this.doesAddBorderForTableAndCells = (td.offsetTop === 5);

            checkDiv.style.position = "fixed";
            checkDiv.style.top = "20px";

            // safari subtracts parent border width here which is 5px
            this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15);
            checkDiv.style.position = checkDiv.style.top = "";

            innerDiv.style.overflow = "hidden";
            innerDiv.style.position = "relative";

            this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5);

            this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop);

            body.removeChild(container);
            jQuery.offset.initialize = jQuery.noop;
        },

        bodyOffset: 

        setOffset:     };


    jQuery.fn.extend({
        position: 

        offsetParent:     });


    // Create scrollLeft and scrollTop methods
    jQuery.each(["Left", "Top"], ;

    


    // Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
    jQuery.each(["Height", "Width"], function (i, name) {

        var type = name.toLowerCase();

        // innerHeight and innerWidth
        jQuery.fn["inner" + name] = 

        // outerHeight and outerWidth
        jQuery.fn["outer" + name] = 

        jQuery.fn[type] = function (size) {
            // Get window width or height
            var elem = this[0];
            if (!elem) {
                return size == null ? null : this;
            }

            if (jQuery.isFunction(size)) {
                return this.each(;
            }

            if (jQuery.isWindow(elem)) {
                // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
                // 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
                var docElemProp = elem.document.documentElement["client" + name],
                    body = elem.document.body;
                return jQuery.support.boxModel && docElemProp || body && body["client" + name] || docElemProp;

                // Get document width or height
            } else if (elem.nodeType === 9) {
                // Either scroll[Width/Height] or offset[Width/Height], whichever is greater
                return Math.max(
                elem.documentElement["client" + name],
                elem.body["scroll" + name], elem.documentElement["scroll" + name],
                elem.body["offset" + name], elem.documentElement["offset" + name]);

                // Get or set width or height on the element
            } else if (size === undefined) {
                var orig = jQuery.css(elem, type),
                    ret = parseFloat(orig);

                return jQuery.isNaN(ret) ? orig : ret;

                // Set the width or height on the element (default to pixels if value is unitless)
            } else {
                return this.css(type, typeof size === "string" ? size : size + "px");
            }
        };

    });

    /******************** BEGIN iPad offset fix ********************/

    // jQuery (actually, AppleWebKit or iPhone OS) have a
    // bug on iPad: offset() is off by scroll position.  Incorrect value
    // when scrolled or zoomed. TT https://tt.amazon.com/0008137072
    // (which references jQuery TT & forum discussions).

    // Fix:  Add two new methods, offsetNoIPadFix & offsetIPadFix.
    // On unaffected platforms, all 3 are identical, i.e.
    //     offset === offsetNoIPadFix === offsetIPadFix
    // On iDevices which have the bug:
    //     offsetNoIPadFix is the original offset function,
    //     offsetIPadFix is the fixed function, and
    //     offset is either the original or the fixed version,
    //         depending on browser detection.

    // Clients who need to execute without the fix must use offsetNoIPadFix.
    // Clients who need the fix should use offsetIPadFix.
    // Clients for whom whichever choice is made by browser detection may use
    //     offset().

    // This fix is from http://gist.github.com/431639, as updated by
    // http://gist.github.com/434145 with the modification in that thread
    // by "fasteater", October 07, 2010, and with changes to account for
    // adding the offsetIPadFix & offsetNoIpadFix methods.
    //
    // It handles a number of version issues:
    //   - applies to all "mobile" AppleWebKit releases:
    //        /webkit.*mobile/i.test(navigator.userAgent)
    //   - fixed in iPhone OS 4.1:
    //        parseFloat($.browser.version) < 532.9
    //   - "old safari versions compatibility" (gist 434145):
    //        "getBoundingClientRect" in document.documentElement

    jQuery.fn.offsetNoIPadFix = jQuery.fn.offset;
    jQuery.fn.offsetIPadFix = jQuery.fn.offset;
    if (/webkit.*mobile/i.test(navigator.userAgent) && parseFloat(jQuery.browser.version) < 532.9 && "getBoundingClientRect" in document.documentElement) {
        jQuery.fn.offsetIPadFix = function () {
            var result = this.offsetNoIPadFix();
            if (result) {
                result.top -= window.scrollY;
                result.left -= window.scrollX;
            }

            return result;
        };
        jQuery.fn.offset = jQuery.fn.offsetIPadFix;
    }
    /******************** END iPad offset fix ********************/


    // Expose jQuery to the global object
    return jQuery;
}());

}
/////////////////////////
// END FILE jquery.js
/////////////////////////
/////////////////////////
// BEGIN FILE rtl-plugin.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* This is an empty file just for variant */
/////////////////////////
// END FILE rtl-plugin.js
/////////////////////////

// END ASSET AmazonUIjQuery-3.0.2493.103
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIPromise", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIPromise-3.0.2412.112
/////////////////////////
// BEGIN FILE promise.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Promise polyfill.
// GitHub: https://github.com/taylorhakes/promise-polyfill

/*
  Copyright (c) 2014 Taylor Hakes
  Copyright (c) 2014 Forbes Lindesay

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/

P.register('3p-promise', function () {

    if(typeof window.Promise === 'function') {
      return window.Promise;
    }

    // Store setTimeout reference so promise-polyfill will be unaffected by
    // other code modifying setTimeout (like sinon.useFakeTimers())
    var setTimeoutFunc = setTimeout;

    function noop() {
    }

    // Use polyfill for setImmediate for performance gains
    var asap = (typeof setImmediate === 'function' && setImmediate) ||
      

    var onUnhandledRejection = 

    // Polyfill for Function.prototype.bind
    
    
    function handle(self, deferred) {
      while (self._state === 3) {
        self = self._value;
      }
      if (self._state === 0) {
        self._deferreds.push(deferred);
        return;
      }
      self._handled = true;
      asap(;
    }

    
    
    function finale(self) {
      if (self._state === 2 && self._deferreds.length === 0) {
        asap(function() {
          if (!self._handled) {
            onUnhandledRejection(self._value);
          }
        });
      }

      for (var i = 0, len = self._deferreds.length; i < len; i++) {
        handle(self, self._deferreds[i]);
      }
      self._deferreds = null;
    }

    
    /**
     * Take a potentially misbehaving resolver function and make sure
     * onFulfilled and onRejected are only called once.
     *
     * Makes no guarantees about asynchrony.
     */
    
    Promise.prototype['catch'] = 

    Promise.prototype.then = 

    Promise.all = 

    Promise.resolve = 

    Promise.reject = 

    Promise.race = 

    /**
     * Set the immediate function to execute callbacks
     * @param fn {function} Function to execute
     * @private
     */
    Promise._setImmediateFn = function _setImmediateFn(fn) {
      asap = fn;
    };

    Promise._setUnhandledRejectionFn = 

    return Promise;
});
/////////////////////////
// END FILE promise.js
/////////////////////////
// END ASSET AmazonUIPromise-3.0.2412.112
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIBaseJS", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIBaseJS-3.1.1625.91
/////////////////////////
// BEGIN FILE a.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Base

'use strict';

P.when('jQuery').register('a-base', ;
/////////////////////////
// END FILE a.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_declarative_analytics.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * AmazonUI declarative action register instrumentation
 */
'use strict';

P.when('p-recorder-events', 'jQuery', 'a-analytics', 'a-util', 'a-constants', 'prv:a-post-atf')
  .register("prv:a-declarative-analytics", function (recorderEvents, $, analytics, util, constants, postAtf) { // jshint ignore:line
    var COUNT_NAME = 'usage:tti',
      // if ue is available, ue.t0 should be always available. if ue is not available, t0 will not be used.
      t0 = window.ue_t0 || window.aPageStart || Date.now(),
      daQueue = {}, // the queue for non-logged declarative action
      loggedDa = {}, // the already logged declarative action
      daSpots = {}; // a map for all the declarative elements on the page

    // AUI_66484:T1 is for Interaction Latency Log. Only record da register latency when the the weblab
    // is T1. We check it via check recorderEvents (work around for variant exploding)
    if (!(recorderEvents.length > 0 && window.ue)) {
      return {
        notify: constants.constants.NOOP,
        setOptions: constants.constants.NOOP
      };
    }

    /**
     * When A.declarative is called, push the action record to log queue. It does record every A.declarative
     * call, as far as the eventType is declared in recorderEvents. It doesn't care if there is elements for
     * this declarative action.
     * @param daName {string} the declarative event name
     * @param eventType {string} the event type, e.g. 'click'...
     */
    function recordDa(daName, eventType) {
      if (!daName || !eventType || util.indexOfArray(recorderEvents, eventType) === -1) {
        return;
      }
      var daKey = daName + '/' + eventType;
      if (loggedDa[daKey] || daQueue[daKey]) {
        return;
      }
      var latency = Date.now() - t0;
      daQueue[daKey] = {
        daName: daName,
        eventType: eventType,
        latency: latency
      };

      postAtf.execute(logQueuedDa);
    }

    /**
     * Scan the queued declarative actions, if the actionable elements exist on the page, then log it.
     * After scanning, empty the queue.
     * Note: If there is no actionable element for a declarative event, there are 2 possibilities:
     * 1. The DA is registered for a component doesn't exist on the page (it happens a lot for AUI components)
     * 2. The event handler is registered before the element is added to the page. In this case it will not cause
     * any non-actionable gap, so we ignore it.
     */
    function logQueuedDa() {
      /**
       * 1. Check the DA queue with the declarative markup recorded early, log and remove any action matched.
       * 2. If there is DA left in the queue, update the declarative markup map.
       * 3. Check the DA queue with updated declarative markup again, log and clean.
       * 4. If there is still DA left, there must be no declarative markup for it, clean them all.
       */
      processDaQueue();
      if (util.objectIsEmpty(daQueue)) {
        return;
      }
      // update the daSpots with all the data-action available on the page.
      $('[data-action]').each(function () {
        var daName = this.getAttribute('data-action');
        daSpots[daName] = true;
      });
      processDaQueue();
      daQueue = {};
    }

    /**
     * Go through DA queue, if the DA matches with a data-action on the page, log it.
     */
    function processDaQueue() {
      util.each(daQueue, function (daItem, daKey) {
        if (daSpots[daItem.daName]) {
          analytics.count(COUNT_NAME, daItem.latency);
          delete daQueue[daKey];
          loggedDa[daKey] = daItem;
        }
      });
    }

    return {
      notify: recordDa
    };
  });
/////////////////////////
// END FILE a_declarative_analytics.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_guard.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * Provides a set of helpers for building 'guards' around customer callbacks.
 * This depends on the 'decorate' function you see in 'a_ending.js'.
 */
P.register("prv:a-guard", function (util) {

    /** Wraps a function in a guard */
    function applyGuard(self, fn) {
        return self._guard && typeof fn === 'function' ?
            self._guard(fn) :
            fn;
    }

    return {

        /** Applies a guard to a function */
        fn: applyGuard,

        /** Produces version of an object with all functions guarded */
        obj: function (self, obj) {
            if ( !self._guard ) {
                return obj;
            }
            var result = {};
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    result[key] = applyGuard(self, obj[key]);
                }
            }
            return result;
        }
    };
});

/////////////////////////
// END FILE a_guard.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_timing_analytics.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Wrapped Client Side Metric (CSM) APIs for tracking life cycle of AUI component.
 * This module will only work in weblab AUI_66484.
 */

'use strict';

P.when('p-recorder-events', 'a-analytics')
  .register("a-timing-analytics", function (recorderEvents, analytics) {

  /**
   * WORKAROUND
   * Due to variant explosion in filename, we put weblab control in code, rather
   * than variant control.
   *
   * @return {Boolean} Whether we are in weblab AUI_66484
   */
  function isWeblab() {
    return recorderEvents.length !== 0;
  }

  // -------------------------------------------------------------------------
  /**
   * Client Side Metric (CSM) provides API to log life cycle of widget/feature,
   * rather than the whole page. We use it for tracking when a P component
   * (aka feature) is ready.
   *
   * see https://w.amazon.com/index.php/ClientSideMetrics/UserDocs/Instrumentation/InstrumentingWidgets
   */

  /**
   * A list of feature names that are initialized for the logger. Log request on
   * non-initialized feature will be ignored.
   *
   * For AUI, the name represents the functionality we want to track.
   * For CSM, it's the namespace for log data.
   */
  var features = {};

  /**
   * The marks of CSM life cycle.
   * see https://w.amazon.com/index.php/ClientSideMetrics/UserDocs/Instrumentation/CSMforAJAX#How_the_scopes_are_combined
   */
  var MARK_START = 'bb'; // indicates the starting time of feature
  var MARK_DONE = 'cf'; // indicates the feature (P component) is ready
  var MARK_FLUSH = 'ld'; // tells CSM to publish to log result to server

  /**
   * A CSM parameter indicates we do logging in feature level rather than page level.
   */
  var WIDGET_INDICATOR = {wb: 1};

  var isWidgetApiAvailable = 

  /**
   * Register the given feature on logger.
   * @param feature An identifier; see `features`
   */
  function startWidgetLogging(feature) {
    features[feature] = true;
    if (!isWeblab() || !isWidgetApiAvailable()) { // always check availability lazily
      return;
    }
    window.uet(MARK_START, feature, WIDGET_INDICATOR);
  }

  /**
   * CALL `startWidgetLogging(feature)` BEFORE USING THIS.
   *
   * Mark the given feature as ready. If the feature is not registered with
   * `startWidgetLogging(feature)`, the request will be ignored.
   *
   * @param feature An identifier; see `features`
   */
  function stopWidgetLogging(feature) {
    if (!isWeblab() ||
        !isWidgetApiAvailable() ||
        !(feature in features)
      ) {
      return;
    }
    window.uet(MARK_DONE, feature, WIDGET_INDICATOR);
    window.uex(MARK_FLUSH, feature, WIDGET_INDICATOR);
  }

  function initMetrics() {
    startWidgetLogging("declarative");
    startWidgetLogging("A");
    startWidgetLogging("dropdown");
    startWidgetLogging("carousel");
  }
  initMetrics();

  return {
    startWidgetLogging: startWidgetLogging,
    stopWidgetLogging: stopWidgetLogging
  };
});
/////////////////////////
// END FILE a_timing_analytics.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_event_analytics.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Event handlers to track user interactions before the page is considered ready.
 *
 * Declarative Action (DA) will start to work until —
 * 1. corresponding dom family is ready
 * 2. declarative system is ready (aka `a-declarative`)
 * 3. interactive component register it's handler with declarative system
 *
 * User might try to use (e.g. click or mouse over) these components
 * (e.g. dropdown or expander) before they are ready.
 *
 * We want to learn more details from this kind of user experience. This module
 * provides temporary event handlers which capture failed attempts, and log them
 * into Client Side Metric (CSM) system.
 *
 * Event handlers to track failed user attempts on declarative actions
 * @see SIM-4780490 for a discussion
 */

// -----------------------------------------------------------------------------

"use strict";

P.when('p-recorder-events', 'jQuery', 'a-analytics', 'a-util', 'prv:a-event-context', 'prv:a-post-atf')
  .register("a-event-analytics", function (recorderEvents, $, analytics, util, EventContext, postAtf) { // jshint ignore:line

    /**
     * WORKAROUND
     * Due to variant explosion in filename, we put weblab control in code, rather
     * than variant control.
     *
     * @return {Boolean} Whether the module functionalities should be activate
     */
  }

    // ---------------------------------------------------------------------------
    // cache
    // ---------------------------------------------------------------------------

    /**
     * Getting a captured event without corresponding handler comes from two scenario:
     * 1. handler registration is delayed (which indicates a true udac)
     * 2. page owner does not care about this event, no handler will be registered
     *
     * Ideally, we should only track first scenario. But user might drop the page
     * even before registration happened. Therefore, we log both of them with different
     * metric keys (see method `logUdac`)
     *
     * The following cache utils will help us to tracking the first scenario
     * lazily and passively.
     */

    var profiles = {};

    function updateProfile(context) {
      var key = context.daName + ':' + context.eventType;
      if (!(key in profiles)) {
        profiles[key] = [];
      }
      profiles[key].push(context);
    }

    function pickProfile(daName, eventType) {
      var key = daName + ':' + eventType;
      if (!(key in profiles)) {
        return [];
      } else {
        var profile = profiles[key];
        delete profiles[key];
        return profile;
      }
    }

    // ---------------------------------------------------------------------------
    // inspecting
    // ---------------------------------------------------------------------------

    /**
     * Log one failed attempt in CSM.
     * see https://w.amazon.com/index.php/AUI/Metrics/Definitions#udac_-_Unavailable_declarative_action_count
     *
     * @param {String} daName     e.g. a-secondary-view or thumb-action
     * @param {String} eventType  e.g. click or keydown (see EVENTS)
     * @param {Number} handlerRegisterLatency, the latency from t0 to the declarative handler register time
     *
     */
    function logUdac(daName, eventType, handlerRegisterLatency) {
      var contextList = pickProfile(daName, eventType);
      if (!contextList || !contextList.length) {
        return;
      }

      try {
        var udacKey = 'true_udac';
        // CSM
        analytics.increment('usage:' + udacKey, contextList.length);

        // RTLA
        var info = 'User attempted to interact with declarative action before it was ready. ' +
          '(aui|' + udacKey + ':' + eventType + ':' + daName + ') see: https://tiny.amazon.com/1jppzyki8';
        var attribution = {
          daName: daName,
          eventType: eventType,
          events: []
        };
        util.each(contextList, function (context) {
          postAtf.execute(function () {
            context = EventContext.from(context)
              .collect(collectATF)
              .collect(collectPath)
              .collect(collectFeatureName)
              .dump();

            attribution.events.push({
              atf: context.isATF,
              xpath: context.xpath,
              selector: context.cssSelector,
              feature: context.feature,
              data: context.daData,
              eventLatency: context.eventLatency,
              handlerLatency: handlerRegisterLatency
            });
          });
        });
        postAtf.execute(function () {
          P.logError(
            null,
            info,
            'ERROR',
            (JSON && JSON.stringify) ? JSON.stringify(attribution) : ''
          );
        });
      } catch (e) {
        // fail silently, don't shake the world
      }
    }

    // ---------------------------------------------------------------------------

    // [AUI-7181] IE8 events lost their context in async calls.
    // We simply drop metric of IE8 due to its low traffic.
  }

    // Event could be captured from PageJS without jQuery
  }

    // We want to limit the logging in "active events",
    // otherwise, result will be too noisy. See EVENTS.
    function notPassiveEvent($event) {
      return util.indexOfArray(recorderEvents, $event.type) !== -1;
    }

    // We are not interested in document event
  }

  }

    // only wrapping da element holds the context
    function extractDaElement($event) {
      var target = $event.target;
      var daElement = $(target).closest('[data-action]').get(0);
      return daElement === undefined ? null : daElement; // EventContext is null-sensitive
    }

    // context of udac
    function collectDaName(daElem) {
      return {daName: daElem.getAttribute('data-action')};
    }

    function collectDaData(daElem) {
      var daName = daElem.getAttribute('data-action');
      return {daData: daElem.getAttribute('data-' + daName) || ''};
    }

    function collectATF(daElem) {
      return {isATF: util.isATF(daElem)};
    }

    function collectPath(daElem) {
      return {
        xpath: util.xpath(daElem),
        cssSelector: util.cssSelector(daElem)
      };
    }

    var FEATURE_ELEM_SELECTOR = '[id$=_feature_div],.feature';
    var FEATURE_NAME_PROPNAME = 'data-feature-name';
    var FEATURE_ID_POSTFIX = '_feature_div';

    /**
     * Collect feature name from feature block if possible
     * @param daElem the event target element
     * @returns {{feature: string}} the feature name
     * Feature name can give a clud that which team is the feature owner.
     * A feature's elements are always contained inside a feature block
     * element.
     * feature block is the closest ancestor element which has an ID of
     * 'XXXX_feature_div', or has a 'feature' CSS class name.
     * The feature name could be:
     * 1. a 'data-feature-name' property value;
     * 2. XXXX at the 'XXXX_feature_div' element ID.
     */
    function collectFeatureName(daElem) {
      var featureName;
      var featureElement = $(daElem).closest(FEATURE_ELEM_SELECTOR).get(0);
      if (featureElement) {
        featureName = featureElement.getAttribute(FEATURE_NAME_PROPNAME);
        if (!featureName) {
          var id = featureElement.id;
          if(id && id.length > FEATURE_ID_POSTFIX.length && id.indexOf(FEATURE_ID_POSTFIX) === (id.length - FEATURE_ID_POSTFIX.length)) {
            featureName = id.slice(0, id.length - FEATURE_ID_POSTFIX.length);
          }
        }
      }
      return {feature: featureName || ''};
    }

  }

    var t0 = window.ue_t0 || window.aPageStart || Date.now();

    /**
     * When an event captured, we have a series of checking for identifying a valid UDAC.
     * We also collect a group of derived context which helps later investigation easier.
     *
     * @param {Event} event  A captured event
     */
    function inspectUdacCandidate(event, latency) {
      if (!isWeblab()) {
        return;
      } // TODO remove this workaround after we improve variant explosion issue

      if (arguments.length < 2) {
        latency = Date.now() - t0;
      }

      var eventContext = new EventContext(event)
        .filter(notIeEvent)
        .transform(fixEvent)
        .filter(notPassiveEvent)
        .filter(notTopLevelTarget)
        .collect(collectEventType)
        .collect(collectEventLatency(latency))
        .transform(extractDaElement)
        .collect(collectDaName)
        .collect(collectDaData);

      var context = eventContext.dump();
      if (!context) {
        return;
      }

      // For now, we ignore normal udac events, since it's too noisy to analysis,
      // We will identify and log only the true udac later.
      updateProfile(context);
    }

    // ---------------------------------------------------------------------------

    function resolveUdacCandidate(daName, eventType) {
      logUdac(daName, eventType, Date.now() - t0);
    }

    // ---------------------------------------------------------------------------
    // module
    // ---------------------------------------------------------------------------

    /**
     * This module is strongly coupled with p-event-recorder:
     * The p-event-recorder will relentlessly record any event on the page,
     * but it needs a partner to inspect and handle the recorded events.
     *
     *  "handle" will take this responsibility
     *
     * After DA system is ready, this module will still work passively in the DA system.
     * It listens all the event, but only dispatches the ones
     * who have business logic (event handler) registered.
     */

    return {
      handle: inspectUdacCandidate,
      notify: resolveUdacCandidate
    };
  });

P.when('a-util', 'a-class').register('prv:a-event-context', function (util, aClass) {
  /*
   * A Monad class which hosts a subject during a series of given transformations.
   * It covers the null and exception cases in the following logic:
   * - if subject is null, do nothing, but don't break the chained transformations.
   * - if exception happens, catch it and make the rest transformations invalid
   *   by setting the subject as null.
   *
   * In this class, we also provides two helping methods:
   *
   * `filter`
   * is a gatekeeper, any false returned by it's predicator will
   * make the reset transformation invalid
   *
   * `collect`
   * allows us to gather information from subject during the transformation.
   * Any single failed point will be ignore individually. The accumulated result
   * will only available if subject is still valid.
   *
   * Please see test/a_event_analytics/a_event_context.test.js for more details.
   */
  var EventContext = aClass.createClass({
    init},
    transform: function (transformer) {
      if (this.subject === null) {
        return this;
      }

      var newSubject;
      try {
        newSubject = transformer(this.subject);
      } catch (e) {
        this.subject = null;
        return this;
      }

      this.subject = newSubject;
      return this;
    },
    filter: function (predicator) {
      return this.transform(function filterTransformer(subject) {
        if (!predicator(subject)) {
          return null;
        }
        return subject;
      });
    },
    collect: function (collector) {
      var self = this;
      return this.transform(function collectorTransformer(subject) {
        try {
          var hash = collector(subject);
          self.collected = util.extend(self.collected, hash);
        } catch (e) {
          // just ignore this collector
        }
        return subject;
      });
    },
    dump: function () {
      if (this.subject === null) {
        return null;
      }
      this.collected._subject = this.subject;
      return this.collected;
    }
  });
  EventContext.from };
  return EventContext;
});

/////////////////////////
// END FILE a_event_analytics.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_visibility.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  A factory to return the isPageHidden implementation.
 *
 *  isPageHidden will return true if the page is hidden, defaulting to false
 *  if the visiblity can not be determined.
 *
 *  We expose this function as an AUI module for testing as PhantomJS makes
 *  it near impossible to mock the visibility object and we need a way to
 *  mock the document object. In production, doc === document.
 *
 *  @public
 *  @return {boolean}
 */
"use strict";

P.register('priv:a-visibility', function() {
    function Visibility(doc) {
        var propertyName = getHiddenProperty(doc);

        if (!propertyName) {
            // Unsupported browser, assume the page is never hidden
            retur};
        }
        else {
            // Supported browser, use the property specific to this browser
            retur};
        }
    }

    /**
     * Helper function to return the correct property of the document object.
     *
     * Outside of prefering the 'hidden' property above the others, the
     * ordering is arbitrary. It's assumed a browser will not support
     * multiple vendor prefixes.
     */
    function getHiddenProperty(doc) {
        var properties = [
            'hidden',       // Modern HTML5 Browser
            'webkitHidden', // Legacy Safari and Chrome
            'mozHidden',    // Legacy Firefox
            'msHidden',     // Legacy Internet Explorer
            'oHidden'       // Legacy Opera
        ];

        for (var i = 0; i < properties.length; i += 1) {
            if (properties[i] in doc) {
                return properties[i];
            }
        }
    }

    return Visibility;
});
/////////////////////////
// END FILE a_visibility.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_util.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Utility Functions
'use strict';

P.when('a-base', 'priv:a-visibility').register('a-util', function (base, visibility) {
    // Shared variables used by imported code
    var $ = base.$;
    var now = Date.now; // polyfilled via AmazonUIPageJS

    //  Collections methods
    /* Importing utils/_collections.js */
//  Collections methods
//  Adapted from http://underscorejs.org/ and altered for ease of
//  understanding / readability in a few spots
var collection = (function () {
    var breaker = {};

    // For each
    function each(obj, iterator, context) {
        if (obj === null) {
            return;
        }

        // Delegate to native method if it exists
        if (Array.prototype.forEach && obj.forEach === Array.prototype.forEach) {
            obj.forEach(iterator, context);
            return;
        }

        // Array
        if (obj.length === +obj.length) {
            for (var i = 0, l = obj.length; i < l; i++) {
                if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {
                    return;
                }
            }
            return;
        }

        // Object
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (iterator.call(context, obj[key], key, obj) === {}) {
                    return;
                }
            }
        }
    }

    // Map / Collect
    function map(obj, iterator, context) {
        var results = [];
        if (obj === null) {
            return results;
        }

        // Delegate to the native method if it exists
        if (Array.prototype.map && obj.map === Array.prototype.map) {
            return obj.map(iterator, context);
        }

        each(obj});

        if (obj.length === +obj.length) {
            results.length = obj.length;
        }

        return results;
    }

    // Reduce
    function reduce(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj === null) {
            obj = [];
        }

        if (Array.prototype.reduce && obj.reduce === Array.prototype.reduce) {
            return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }

        each(obj});

        if (!initial) {
            P.error('Reduce of empty array with no initial value', 'A.util', 'reduce');
        }

        return memo;
    }

    // Filter
    function filter(obj, iterator, context) {
        var results = [];

        if(obj === null) {
            return results;
        }

        if(Array.prototype.filter && obj.filter === Array.prototype.filter) {
            return obj.filter(iterator, context || obj);
        }

        each(obj, function(value, index, list) {
            if(iterator.call(context || obj, value, index, list)) {
                results.push(value);
            }
        });

        return results;
    }

    function range(start, stop, step) {
        if (stop === undefined) {
            stop = start || 0;
            start = 0;
        }
        step = step || 1;

        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var array = new Array(length);

        for (var i = 0; i < length; i++, start += step) { // jshint ignore:line 
            array[i] = start;
        }

        return array;
    }

    return {
        each: each,
        map: map,
        reduce: reduce,
        filter: filter,
        range: range,
        breaker: breaker
    };
}());
/* Done importing utils/_collections.js */


    // Functional utility methods
    /* Importing utils/_fn.js */
// Functional Utilities
var fn = (function () {

    //Function call throttling
    function throttle(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        options = options || {};
        var later };

        return function() { 
            var current = now();
            if (!previous && options.leading === false) {
                previous = current;
            }
            var remaining = wait - (current - previous);
            context = this;
            args = arguments;
            if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = current;
                result = func.apply(context, args);
                context = args = null;
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    }

    //Function call debouncing

    function debounce(func, wait, immediate) {
        var timeout, args, context, timestamp, result;

        var later = function () {
            var last = now() - timestamp;
            if (last < wait) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    context = args = null;
                }
            }
        };

        return function () {
            context = this;
            args = arguments;
            timestamp = now();
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    }

    // Wrapper for setTimeout

  }

    // Delay one frame
  }

    //Wrapper for setInterval

  }

    // Guarantees that a function will only be called once. Subsequent calls
    // will return the result from the first call
    function once(fn) {
        var called = false;
        var result;
        return function () {
            if (!called) {
                called = true;
                result = fn.apply(this, arguments);
            }
            return result;
        };
    }

    // Sequences a series of functions by passing each function a next function to call
    // on completion. Example:
    //     function foo(nextFunc) {
    //          do some foo work;
    //          nextFunc();
    //     };
    //
    function sequence() {
        var slice = [].slice;
        var fns = slice.call(arguments).reverse();

        // This will serve as the execution context for all of the functions
        // passed in. Context can be provided by binding sequence() to the desired context.
        var context = this; // jshint ignore:line

        // The collection variable comes from the _collection.js utils file which is
        // joined with this file making its self available.
        return collection.reduce(fns}});
    }

    
    /* 
    Functional programming emulation of the ES2015 "...rest" operator
    https://babeljs.io/docs/learn-es2015/#default-rest-spread

    Based on Lodash's 4.x implementation of rest.
    */
    function rest(fn, start) {
    
        if(!fn) { return; } // Should probably error here?

        /*
          When calling the function returned by rest(), offset
          is the index at which supplied arguments will be 
          collected into a single array. 
        */
        var offset = Math.max(start === undefined ? (fn.length - 1) : start, 0);



        return function() {

            var args  = arguments,
               index  = -1,
               length = Math.max(args.length - offset, 0),
               array  = Array(length);

            // Collect arguments into array (starting at offset)        
            while(++index < length) {
                array[index] = args[index + offset];
            }

            /*
              Common cases, when we pass in a function, we're 
              usually separating the first/second param from 
              the remainder of params. These 3 cases are for
              faster eval as they won't take more calculations
              for a 'sane' offset number.
            */

            switch(offset) {
                case 0: return fn.call(this, array);
                case 1: return fn.call(this, args[0], array);
                case 2: return fn.call(this, args[0], args[1], array);
            }

            /* 
              If we reach here: Uncommon case.
              we're dealing with > 2 params in the 'fn' call 
              (excluding rest), so we'll need to copy the 
              non-rest params into their own array, add the 
              rest params array to the end of it, and call fn 
              with .apply() instead of .call(). 
            */ 

            var all = Array(offset + 1);
            
            index = -1;

            // Collect arguments from beginning to offset
            while (++index < offset) {
                all[index] = args[index];
            }

            // Put grouped (...rest) arguments at the end
            all[offset] = array;

            return fn.apply(this, all);

        };
    }

    //Parse the name of a function
    function parseFunctionName (fn) {
        if (fn.name) {
            return fn.name === 'anonymous' ? '' : fn.name;
        }
        // IE8
        else {
            var parsed = fn.toString().match(/^function\s*([^\s(]+)/);
            return parsed ? parsed[1] : '';
        }
    }

    return {
        throttle: throttle,
        sequence: sequence,
        debounce: debounce,
        delay: delay,
        animationFrameDelay: animationFrameDelay,
        interval: interval,
        once: once,
        rest: rest,
        parseFunctionName: parseFunctionName
    };

}());
/* Done importing utils/_fn.js */


    // Object utility functions
    /* Importing utils/_object.js */
// Object utility functions
var object = (function () {

    /**
     *  Finds the first index at which the given search element can be found in the given array.
     *  Falls back to the native Array.indexOf, if available.
     *
     *  @param {array} arr The array to search
     *  @param {object} searchElement The object to search for
     *  @param {number} The index at which the search should start (optional)
     *
     *  @return {number} The first index at which a given element can be found in the array, or -1 if it is not present.
     */

    function indexOfArray(arr, searchElement, startIdx) {
        if (Array.prototype.indexOf && arr.indexOf === Array.prototype.indexOf) {
            return arr.indexOf(searchElement, startIdx);
        }

        if (!(arr && arr instanceof Array)) {
            P.error('Invalid arr passed to A.indexOfArray: ' + arr, 'A.util', 'indexOfArray');
        }

        startIdx = parseInt(startIdx, 10);
        var n = isNaN(startIdx) ? 0 : startIdx;
        if (!isFinite(n)) {
            return -1;
        }

        for (var l = arr.length; n < l; n++) {
            if (arr[n] === searchElement) {
                return n;
            }
        }
        return -1;
    }

    /**
     *  Deep + Recursive object extend
     *
     *  @param {object...} arguments
     *
     *  @return {object} The object with the various objects extended onto it
     */

    function extend() {
        // insert the deep boolean into the arguments
        Array.prototype.unshift.call(arguments, true);
        // there is a single reference to 'this' within jQuery.extend which logically expects that it would be a reference to jQuery
        return $.extend.apply($, arguments);
    }

    /**
     *  Makes a copy of objects and arrays, returns everything else
     *
     *  @param {object} obj The thing to be copied
     *
     *  @return {object} The copy of the object, or the original input if the input does not conform
     */

    function copy(obj) {
        if ($.isArray(obj)) {
            return $.extend(true, [], obj);
        }
        if ($.isPlainObject(obj)) {
            return $.extend(true, {}, obj);
        }

        return obj;
    }

    /**
     *  Add methods from `source` to `target`.
     *
     *  @public
     *  @param {object} target The object to which methods will be added
     *  @param {object} source The object from which methods will be copied
     *  @param {array} methods (optional) An array of method names to mix in.
     *      If ommitted, all methods from source will be added to target.
     */

    function mixin(target, source, methods) {
        if(!methods) {
            for(var prop in source) {
                if(typeof source[prop] === 'function') {
                    target[prop] = source[prop];
                }
            }
        } else {
            for(var i=0,l=methods.length;i<l;i++) {
                target[methods[i]] = source[methods[i]];
            }
        }
    }

    // Recursive object diff

    function diff(a, b) {
        a = a || {};
        b = b || {};
        var objDiff = {};

        for (var key in a) {
            if (a.hasOwnProperty(key)) {
                objDiff[key] = (typeof a[key] === 'object') && a[key] ? diff(a[key], b[key]) : a[key] !== b[key];
            }
        }

        for (var key in b) {
            if (b.hasOwnProperty(key) && !objDiff[key]) {
                objDiff[key] = (typeof b[key] === 'object') && b[key] ? diff(b[key], a[key]) : b[key] !== a[key];
            }
        }

        return objDiff;
    }

    /**
     *  Equality function.  Does a deep equality check for objects and arrays.
     *
     *  @private
     *  @param {object} first
     *  @param {object} second
     *
     *  @return {boolean}
     */

    function equals(first, second) {
        var i;
        // Simple
        if (first === second) {
            return true;
        }

        // Array
        if ($.isArray(first)) {
            if (!$.isArray(second) || first.length !== second.length) {
                return false;
            }
            i = first.length;
            while (i--) {
                if (!equals(first[i], second[i])) {
                    return false;
                }
            }
            return true;
        }

        // Plain object
        if ($.isPlainObject(first)) {
            if (!$.isPlainObject(second)) {
                return false;
            }
            if ($.isEmptyObject(first) && !$.isEmptyObject(second)) {
                return false;
            }
            for (i in first) { // jshint ignore:line
                if (!equals(first[i], second[i])) {
                    return false;
                }
            }
            return true;
        }

        // FAIL!!!!!!
        return false;
    }

    /**
     *  Determine of the passed object is a finite number.
     *
     *  @public
     *  @param {object}
     *
     *  @return {boolean}
     */

  }

    /**
     *  Determine if an object has any properties on it which aren't inherited from the base JS object class.
     *
     *  @public
     *  @param {object} obj
     *
     *  @return {boolean}
     */

  }

    /**
     *  Get the names of an object’s properties.
     *
     *  @public
     *  @param {object} obj
     *
     *  @return {array}
     */

    function getKeys (obj) {
        var isObject = typeof obj === 'function' || typeof obj === 'object' && !!obj;
        if (!isObject) {
            return [];
        }
        if (Object.keys) {
            return Object.keys(obj);
        }

        var keys = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys;
    }

    /**
     *  Get the values of an object’s properties.
     *
     *  @public
     *  @param {object} obj
     *
     *  @return {array}
     */

    function getValues (obj) {
        var keys = getKeys(obj);
        var values = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    }

    /**
     *  Determine if the passed object is an Array.
     *
     *  @public
     *  @param {object} obj
     *
     *  @return {boolean}
     *    }

    
    /**
      * Defines an immutable value on obj
      * @param {Object} obj The object to set value on
      * @param {String} name The value to set
      * @param {*} value The value to set
      * @return {Object} value Returns the value for additional use
      */

    function defineProp(obj, name, value) {
        Object.defineProperty(obj, name, { value: value, writable: false });
        return value;
    }

    /**
      * Polyfill for defineProp
      */
    function assignProp(obj, name, value) {
        if (!obj.hasOwnProperty(name)) {
            obj[name] = value;    
        }
        return value;
    }
    
    var constProp = typeof Object.defineProperty === 'function' ? defineProp : assignProp;

    return {
        keys: getKeys,
        values: getValues,
        extend: extend,
        mixin: mixin,
        diff: diff,
        equals: equals,
        copy: copy,
        indexOfArray: indexOfArray,
        isArray: isArray,
        isFiniteNumber: isFiniteNumber,
        objectIsEmpty: objectIsEmpty,
        constProp: constProp
    };
}());
/* Done importing utils/_object.js */


    // String utility functions
    // uses: _object.js
    /* Importing utils/_string.js */
// String utils

// Depends on object being previously defined
var string = (function () {
    /**
     *  The HTML entity map for encoding
     *
     *  @private
     *  @constant
     *  @type {object}
     */
    var HTML_ENTITY_MAP = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
        '/': '&#x2F;'
    };

    // String utility regexps
    var regexps = {
        trimLeft: /^\s+/,
        trimRight: /\s+$/,
        html: new RegExp('[' + object.keys(HTML_ENTITY_MAP).join('') + ']', 'g'),
        jquery: /([!"#$%&'\(\)*+,./:;<=>?@\[\\\]^`{|}~])/g
    };

    // Trims right + left whitespace off of a string, and defers to the native
    // method if available

    function trim(text) {
        if (String.prototype.trim) {
            return String.prototype.trim.call(text);
        }

        return text.replace(regexps.trimLeft, "").replace(regexps.trimRight, "");
    }

    //Returns true if string contains substrin    }

    /**
     *  Given an unsafe html string, generate the safe html string
     *
     *  @public
     *  @param {string} content The unsafe html string content
     *
     *  @return {string}  The safe html string
     */
    function escapeHtml(content) {
        return ('' + content).replace(regexps.    });
    }

    /**
     *  Escape jquery selector http://api.jquery.com/category/selectors/
     *
     *  @public
     *  @param {string} s The string would be used as a selector or part of a selector
     *
     *  @return {string}  The escaped string applicable for jquery selector
     */
    function escapeJquerySelector(s) {
        return ('' + s).replace(regexps.jquery, '\\$1');
    }

    return {
        trim: trim,
        contains: contains,
        escapeHtml: escapeHtml,
        escapeJquerySelector: escapeJquerySelector
    };
}());
/* Done importing utils/_string.js */


    function xpath(dom) {
      if (dom.id !== '') {
        return '//*[@id="' + dom.id + '"]';
      } else if (dom === document.documentElement) {
        return '/html';
      }

      var idx = $(dom).parent().find(' > ' + dom.tagName).index(dom);
      if (idx === -1) {
        throw 'can not evaluate xpath of element ' +
              '`' +
              (dom.tagName) + (dom.id ? '#' + dom.id : '') +
              '`';
      }
      return xpath(dom.parentNode) + '/' + dom.tagName + '[' + (idx + 1) + ']';
    }

    /**
     * Return the CSS selector string for the target element
     * @param dom the target element
     * @returns {string} the CSS selector
     * We return the CSS selector sting in format of:
     * [tag_name][.css_class_name][#element_id]
     * It's often not the best CSS selector, and not a unique CSS selector
     * But usually it's good enough to describe what kind of element it is.
     */
    function cssSelector(dom) {
        var result = [dom.tagName || ''];
        // SVG elements' className is an object, not a string
        if(dom.className && dom.className.trim) {
            result.push('.' + dom.className.trim().replace(/\s+/g, '.'));
        }
        if(dom.id) {
            result.push('#' + dom.id);
        }
        return result.join('');
    }

    // Parses JSON using the best method availabl    }

    // Cookie reading utility
    // (uses: _string.js, _object.js)
    /* Importing utils/_cookies.js */
// Cookie reading utils; cookie setting is not supported, due to Amazon's cookie policy:
// https://w.amazon.com/index.php/AmazonCookiePolicy
// Author: stamps@

// Depends on these a-util variables being previously defined:
// - object
// - string
var cookies = (function () {
    var allCookies;

    // RFC2109 allows for double-quoted strings with embedded backslash escapes, and the original
    // spec allows for URL encoding. Support both, with stripped whitespace.
    function decodeCookieString(str) {
        str = string.trim(str);
        if (/^"/.test(str)) {
            // Assume that the string is quoted at both ends; only " and \ should be escaped,
            // but it's simpler to unescape everything.
            str = str.slice(1, -1).replace(/\\(.)/g, '$1');
        }
        return window.decodeURIComponent(str);
    }

    // Minimal deconstruction of the cookie string, based partly on HTTP cookie specs, and partly
    // on observation in major browsers. Note that the specs are about HTTP headers, not JavaScript
    // string representations, so some aspects may vary.
    //   http://curl.haxx.se/rfc/cookie_spec.html (v0 Netscape cookies)
    //   https://tools.ietf.org/html/rfc2109      (v1 cookie standard)
    //   https://tools.ietf.org/html/rfc2965      (v2 cookie standard)
    // In practice, Amazon cookies seem to be represented as v0 URI-encoded strings, occasionally
    // wrapped by double quotes.
    function parseCookies() {
        allCookies = {};
        // IMPORTANT: We should protect against splitting an undefined document.cookie, which will
        // obviously fail. There's no easy, robust way to add a unit test around this because
        // cookies persist in Phantom and another test could have defined document.cookie for us.
        var avPairs = (document.cookie || '').split(';');
        for (var i = avPairs.length - 1; i >= 0; i--) {
            // The .split() length arg discards part of the value if there are embedded '=', so
            // don't use it. Instead, use a regular split and join the value back together below.
            var avPair = avPairs[i].split('=');
            // trim() can't handle undefined inputs, but avPair[0] is always a string.
            var attr = string.trim(avPair[0]);
            if (attr) {
                // If there was no value (i.e. no '='), value is an emtpy string, to distinguish
                // from an undefined cookie. avPair[1] could be undefined, but the join() always
                // returns a string.
                allCookies[attr] = decodeCookieString(avPair.slice(1).join('='));
            }
        }
    }

    // Returns a single cookie, looked up by name. If a cookie is modified after the first call to
    // get() or getAll(), get() will not reflect the change until after refresh() is called.
    function get(cookieName) {
        // lazy parsing
        if (!allCookies) { parseCookies(); }
        return allCookies[cookieName];
    }

    // Returns a map of all cookies, keyed by name. If a cookie is modified after the first call to
    // get() or getAll(), getAll() will not reflect the change until after refresh() is called.
    function getAll() {
        // lazy parsing
        if (!allCookies) { parseCookies(); }
        return object.extend({}, allCookies);
    }

    // Resets the memoized cookie state, so that a subsequent call to get() or getAll() will
    // re-parse cookies    }

    return {
        // NOTE: Browser cookie architecture simply cannot support unrestricted use by teams at
        // Amazon. (See the cookie policy link above for details.) This API should never be
        // extended to support setting cookies, because making it too easy will inevitably lead
        // to (well-intentioned) abuse.
        get: get,
        getAll: getAll,
        refresh: refresh
    };
}());
/* Done importing utils/_cookies.js */


    // On Screen utility
    /* Importing utils/_on_screen.js */
/**
 *  Determine whether the object Element is onScreen within a certain Buffer distance
 *
 *  @public
 *  @param {object} element The DOM element to determine if onScreen
 *  @param {number} buffer The distance from viewport that the object would still be deemed onScreen
 *
 *  @return {boolean}
 */
function onScreen(element, buffer) {
    // Default buffer is 100
    var buffer = (typeof buffer === "number" && !isNaN(buffer) && isFinite(buffer))? buffer : 100;

    var $elem = $(element);
    if (!$elem.is(":visible")) {
        return false;
    }

    //Window
    var $window = $(window);
    var windowTop = $window.scrollTop();
    var windowHeight = window.innerHeight ? window.innerHeight : $window.height();
    var windowBottom = windowTop + windowHeight;

    // Add in the buffer
    windowTop -= buffer;
    windowBottom += buffer;

    //Element
    var top = $elem.offset().top;
    var height = $elem.height();
    var bottom = top + height;

    return (top >= windowTop && top < windowBottom) || (bottom > windowTop && bottom <= windowBottom) || (height > windowHeight && top <= windowTop && bottom >= windowBottom);
}
/* Done importing utils/_on_screen.js */


    // ATF utility
    /* Importing utils/_atf.js */
/**
 * Determine whether element is Above The Fold within a certain Buffer distance.
 *
 *  @public
 *  @param {object} element The DOM element to determine if isATF
 *  @param {number} buffer The top offset of viewport from the document top
 *                         that we treat viewport is not moved yet.
 *                         Default buffer is 100px.
 *
 *  @return {boolean}
 */
function isATF(element, buffer) {
  buffer = (typeof buffer === "number" && !isNaN(buffer) && isFinite(buffer))? buffer : 100;

  var $window = $(window);
  var windowHeight = window.innerHeight ? window.innerHeight : $window.height();

  var boundTop = 0;
  var boundBottom = windowHeight + buffer;

  var $element = $(element);
  var top = $element.offset().top;

  return boundTop <= top && top < boundBottom;
}
/* Done importing utils/_atf.js */


    // CSS utilties
    /* Importing utils/_css.js */
/**
 *  Set CSS attribute, with the ability to add !important to the style specified
 *
 *  @public
 *  @param {object} dom  DOM object
 *  @param {string} name  css style name
 *  @param {string} value  value of style
 */
function setCssImportant(dom, name, value) {
    var dom = dom.jquery ? dom[0] : dom;
    if (typeof dom === "undefined") {
        return;
    }

    var style = dom.style;
    var clearRule = new RegExp(name+'\\s*:\\s*[.^;]*(\\s*;)?', 'gmi');
    style.cssText = style.cssText.replace(clearRule, "");
    style.cssText += name + ': ' + value + ' !important;';
}

var cssUtils = (function() {
    var el = document.createElement('fakeelement');
    var transitions = {
        'transition':'transitionend',
        'OTransition':'oTransitionEnd',
        'MozTransition':'transitionend',
        'WebkitTransition':'webkitTransitionEnd'
    };
    var cachedTransitionEndEvent = null;

    return {
        /**
         *  Get the correct name of the transitionend event for the current platform
         *  Adapted from https://davidwalsh.name/css-animation-callback
         *
         *  @public
         *  @return {string} event name
         */
        getTransitionEndEvent: function() {
            if ((/UCBrowser/).exec(navigator.userAgent)) {
                // UCBrowser accepts `transition` as style but only fires `webkitTransitionEnd`
                cachedTransitionEndEvent = transitions.WebkitTransition;
            }
          
            if (cachedTransitionEndEvent === null) {
                for (var t in transitions) {
                    if (el.style[t] !== undefined){
                        cachedTransitionEndEvent = transitions[t];
                        break;
                    }
                }
            }

            return cachedTransitionEndEvent;
        }
    };
}());
/* Done importing utils/_css.js */


    // widescreen utilties
    /* Importing utils/_widescreen.js */
/**
 *  Return true if "a-ws" class present on html element. This class is setup by AmazonUIPageJS to indicate widescreen mode.
 *
 *  @public
 *  @return {boolean 0;
}
/* Done importing utils/_widescreen.js */


    // Page Visibility utilties
    var isPageHidden = visibility(document);

    // return the module
    return {
        now: now,
        extend: object.extend,
        mixin: object.mixin,
        copy: object.copy,
        constProp: object.constProp,
        diff: object.diff,
        equals: object.equals,
        objectIsEmpty: object.objectIsEmpty,
        indexOfArray: object.indexOfArray,
        isArray: object.isArray,
        isFiniteNumber: object.isFiniteNumber,
        keys: object.keys,
        values: object.values,
        xpath: xpath,
        cssSelector: cssSelector,
        parseJSON: parseJSON,
        throttle: fn.throttle,
        sequence: fn.sequence,
        debounce: fn.debounce,
        delay: fn.delay,
        animationFrameDelay: fn.animationFrameDelay,
        interval: fn.interval,
        once: fn.once,
        rest: fn.rest,
        trim: string.trim,
        contains: string.contains,
        escapeHtml: string.escapeHtml,
        escapeJquerySelector: string.escapeJquerySelector,
        map: collection.map,
        reduce: collection.reduce,
        filter: collection.filter,
        range: collection.range,
        each: collection.each,
        breaker: collection.breaker,
        onScreen: onScreen,
        isATF: isATF,
        setCssImportant: setCssImportant,
        getTransitionEndEvent: cssUtils.getTransitionEndEvent,
        cookies: cookies,
        widescreen: widescreen,
        isPageHidden: isPageHidden,
        parseFunctionName: fn.parseFunctionName
    };
});
/////////////////////////
// END FILE a_util.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_detect.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI JS detection library
 *
 */

"use strict";

/**
 *  Useful detection features for JS code which don't need a corresponding CSS class to be placed on the <html> node.
 */
P.when("p-detect", "a-util").register("a-detect", function (pDetect, util) {

  // Sometimes in IE, accessing the userAgent can cause a permission denied error
  var userAgent;
  try {
    userAgent = navigator.userAgent;
  } catch (e) {
    userAgent = "";
  }

  /**
   *  Safely execute feature tests.
   *
   *  Chrome, Firefox, and IE10 occaisionally throw exceptions when
   *  checking for the existing of some feature properties.
   *
   *  If a test throws an exception, just assume the test returned false.
   *
   *  @private
   *  @param {function} testFn
   *
   *  @return {boolean}
   }
  }

  /**
   *  A copy of the results of p-detect which is going to end up on the A library.
   *
   *  @public
   *  @type {object}
   */
  var detect = util.copy(pDetect);

  /**
   * Retrieves the version of Android
   *
   * @return {string | null} Android version or null if not Android
   */
  var getAndroidVers;
  };

  /**
   * A pre-evaluated flag to save computation and file size for further detections
   * @private
   * @type {boolean}
   */
  var isTrident = (/Trident/).test(userAgent);

  /**
   *  A list of test functions to execute and place onto the capabilities object from p-detect
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var TESTS = {
    isAmazo    },
    isGen5App: function () {
      return (/Windowshop.*(?:KFOT|KFTH|KFJWA|KFJWI|KFTT)/).test(userAgent);
    },
    androidVer    },
    isAndroidKitkatPlus: function () {
      var version = getAndroidVersion();
      return version && version.match(/(^4\.[4-9]|^[5-9])/) !== null;
    },
    isChrome: function () {
      return (/Chrome/).test(userAgent);
    },
    chromeVersion: function () {
      var matches = (/Chrome\/(\d+\.\d+(?:\.\d+)*)/).exec(userAgent);
      if (matches[1]) {
        return matches[1];
      }
    },
    isUCBrowser: function() {
      return (/UCBrowser/).test(userAgent);
    },
    isSa    },
    /*
    It's not technically feasible or really possible to detect that the browser is the Android stock
    browser with absolute certainty due to the custom UA strings from vendors and the general vagueness
    of the info in the UA string.  Also, the dolphin browser has the same UA string as the stock browser.
    This is my attempt at a best guess.  If it's an Android browser, but not another, known brand of browser,
    and the WebKit version isn't too high, we're going to guess that this is the stock browser.

    Upshot:  We can't guarantee that this is correct, but it's our best guess.
    */
    isAndroidStockGuess: function () {
      var result = false;
      if (detect.capabilities.android && !(/Chrome|Opera|Firefox|UCBrowser/).test(userAgent)) {
        var matches = (/AppleWebKit\/(\d+\.\d+)/).exec(userAgent);
        result = matches[1] && matches[1] < "535"; // Android stock browser never got above AppleWebKit version 534.x
      }
      return result;
    },
    isFirefox: function () {
      return (/Firefox/).test(userAgent);
    },
    isAnd    },
    isOldAnd    },
    /*
    IE11 maintains compatibility with the prefixed version of the Pointer Event, and thus this would
    false positive without the third check
    */
        },
    is    },
    isIE10    },
    isIE11    },
    isiOS8: function() {
      return detect.capabilities.ios && (/Version\/8\./).test(userAgent);
    },
    /*
    Useful for determining if you will ever see an on screen keyboard causing the viewport to shrink
    upon text input.
    */
    isIETouchCap    },
    /*
    It is not possible to detect the difference between Metro IE and IE because Microsoft wanted it that way. Sigh.
    - Metro is always ActiveX disabled (it *can* be disabled outside, but this is the best indicator)
    - Confirm IE10+ and not mobile
    */
    isMetroIEGuess: function() {
      var activeXEnabled = true;
      try {
        activeXEnabled = new ActiveXObject("htmlfile");
      } catch(e) {
        activeXEnabled = false;
      }
      return detect.capabilities.isIE10Plus && !detect.capabilities.mobile && !activeXEnabled;
    },
    pointerPrefix: function() {
      if ("onmspointerup" in document || "onpointerup" in document) {
        return "onpointerup" in document ? "pointer" : "MSPointer";
      }
      return false;
    },
    action    }
  };

  /**
   *  A mapping of event name suffixes to their relevant input types
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var SUFFIXES = {
    start: {
      mouse: "down",
      touch: "start",
      pointer: "down",
      MSPointer: "Down"
    },
    end: {
      mouse: "up",
      touch: "end",
      pointer: "up",
      MSPointer: "Up"
    },
    move: {
      mouse: "move",
      touch: "move",
      pointer: "move",
      MSPointer: "Move"
    },
    //http://msdn.microsoft.com/en-us/library/ie/dn304886(v=vs.85).aspx (enter/leave)
    enter: {
      mouse: "enter",
      touch: "enter",
      pointer: "enter"
    },
    leave: {
      mouse: "leave",
      touch: "leave",
      pointer: "leave"
    },
    cancel: {
      touch: "cancel",
      pointer: "cancel",
      MSPointer: "Cancel"
    },
    over: {
      mouse: "over",
      pointer: "over",
      MSPointer: "Over"
    },
    out: {
      mouse: "out",
      pointer: "out",
      MSPointer: "Out"
    }
  };

  /**
   *  A generated object of functions that returns the appropriate event action
   *
   *  @public
   *  @type {object}
   */
  var action = {};

  // Expose the tests safely
  util.each(T;
  });

  //Generate appropriate return functions for given action types
  util.each(SUFFIXES, function (obj, name) {
    /*
    1. If the suffix doesn't have variation, store the string
    2. If the suffix has variations, store the appropriate variation
    -- START MECHA TERNARY --
    3. If the variation exists, output the prefix + suffix pair
    4. Otherwise, if the variation turns out to be undefined, fall back to mouse events
    5. Then, if the fallback mouse event (touch/pointer/mspointercancel) doesn't exist,
       output "" instead, as undefined throws a TypeError when used in jQuery bind

    Ultimately this should mean all events will output something except requests for
    mousecancel which doesn't exist.
    */
    var am = detect.capabilities.actionMode;
    var suffix = typeof obj === "string" ? obj : obj[am];

    action[name] = suffix ? am + suffix : obj.mouse === undefined ? "": "mouse" + obj.mouse;
  });

  //attach the generated action functions to detect
  detect.action = action;

  /**
   *  A generated object of properties that normalize the differences in pointer types between IE10 and 11
   *
   *  @public
   *  @type {object}
   */
  var pointerType = {};

  if (detect.capabilities.pointerPrefix === "pointer") {
    pointerType.touch = "touch";
    pointerType.pen = "pen";
    pointerType.mouse = "mouse";
    pointerType.unknown = "";
  }
  else if (detect.capabilities.pointerPrefix === "MSPointer") {
    pointerType.touch = 2;
    pointerType.pen = 3;
    pointerType.mouse = 4;
  }

  detect.pointerType = pointerType;

  return detect;
});
/////////////////////////
// END FILE a_detect.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_defer.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Defer Queue

'use strict';

P.when('prv:a-guard').register('a-defer', function(guard) {
  var deferQueue = [];
  var executing = false;
  var TIME_SLICE = 50;
  var WAIT_TIME = 50;
  var executionTime = 0;

  function partialExecute(queue) {
    var wait = 0;
    var safetyTimeout = setTimeout(function() {
      partialExecute(queue);
    }, 0);

    if (queue.length === 0) {
      clearTimeout(safetyTimeout);
      executing = false;
      return;
    }

    var start = Date.now();

    queue.shift().call();

    executionTime = executionTime + (Date.now() - start);

    if (executionTime > TIME_SLICE) {
      wait = WAIT_TIME;
      executionTime = 0;
    }

    setTimeout(function() {
      partialExecute(queue);
    }, wait);
    clearTimeout(safetyTimeout);
  }

  // Execute on a timesliced queue

  var defer = function defer(fn) {

    deferQueue.push( guard.fn(this, fn) );

    if (!executing) {
      executing = true;
      setTimeout(function() {
        partialExecute(deferQueue);
      }, 0);
    }
  };

  function executeDeferred() {
    // Deprecated (AUI-2910)
  }

  function pauseDeferred() {
    // Deprecated (AUI-2910)
  }

  return {
    defer: defer,
    pauseDeferred: pauseDeferred,
    executeDeferred: executeDeferred
  };
});
/////////////////////////
// END FILE a_defer.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_events.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Events
'use strict';

P.when('jQuery', 'a-util', 'p-detect', 'a-event-revised-handling')
.register('a-events', function ($, util, detect, revisedEventHandling) {

  var occurred = {};
  var $window = $(window);

  var messages = (function () {

    var topics = {};
    var eventId = 0;
    var publishing = false;
    var callbackQueue = [];
    var TIME_SLICE = 50;
    var WAIT_TIME = 15;

    function purgeEvent(id) {
      var callbackId;
      var newQueue = [];

      for (var i = 0, l = callbackQueue.length; i < l; i++) {
        callbackId = callbackQueue[i].id;

        if (id !== callbackId) {
          newQueue.push(callbackQueue[i]);
        }
      }

      callbackQueue = newQueue;
    }

    /** Reports an error that occurred during event execution. */
    function reportError(callbackObj, error) {
      var logErrorArgs = [
        error,
        'Event execution failed for event ' + callbackObj.topic,
        'FATAL'
      ];

      if (callbackObj.logError) {
        callbackObj.logError.apply(callbackObj, logErrorArgs);
      } else {
        P.logError.apply(P, logErrorArgs);
      }
    }

    /**
      * _partialPublishDeprecated
      *
      * This publishing mechanism is used in AUI_57984:C for all AUI events.
      */
    function _partialPublishDeprecated(isTimeSliced) {
      // If one of the event handlers errors, we want to execute the rest.  This timer
      // ensures that we can come back and continue processing after an error
      var safetyTimeout = setTimeout(_partialPublishDeprecated, 0);
      var start = util.now();
      var callback;

      while ((callback = callbackQueue.shift()) !== undefined) {
        try {
          var result = callback.fn.apply(window, callback.args);

          // If a callback returns false, don't call any of the others for that event
          if (result === false) {
            clearTimeout(safetyTimeout);
            purgeEvent(callback.id);
          }
          // If we're timeslicing and the time allocated to this slice has run out, schedule another slice and stop all processing
          if (isTimeSliced === true && util.now() - start >= TIME_SLICE) {
            clearTimeout(safetyTimeout);
            util.delay(_partialPublishDeprecated, WAIT_TIME);
            return;
          }
        } catch(e) {
          reportError(callback, e);
          return;
        }
      }

      clearTimeout(safetyTimeout);
      publishing = false;
    }

    /**
      * timeslicedPartialPublish
      *
      * This publishing mechanism is used in AUI_57984:T1 for timesliced events.
      */
    function timeslicedPartialPublish() {
      var start = util.now();
      var callback;

      while ((callback = callbackQueue.shift()) !== undefined) {
        try {
          var result = callback.fn.apply(window, callback.args);

          // If a callback returns false, don't call any of the others for that event
          if (result === false) {
            purgeEvent(callback.id);
          }

          // If there is more in queue and we're timeslicing and the time allocated to this slice has run out,
          // schedule another slice and stop all processing
          if (callbackQueue.length && util.now() - start >= TIME_SLICE) {
            util.delay(timeslicedPartialPublish, WAIT_TIME);
            return;
          }
        } catch (e) {
          // Log error and continue
          reportError(callback, e);
        }
      }

      publishing = false;
    }

    /**
      * synchronousLocalPublish
      *
      * This publishing mechanism is used in AUI_57984:T1 for non-timesliced events.
      */
    function synchronousLocalPublish(localCallbackQueue) {
      var callback;

      while ((callback = localCallbackQueue.shift()) !== undefined) {
        try {
          var result = callback.fn.apply(window, callback.args);

          // If a callback returns false, don't call any of the others for that event
          if (result === false) {
            return;
          }
        } catch (e) {
          // Log error and continue
          reportError(callback, e);
        }
      }
    }

    // Note: this function effectively reverses the order of the handlers when it moves them from the topics array
    // to the callbackQueue.  We could change this later on (so it's a FIFO instead of a LIFO), but it's technically
    // backwards incompatible.  Still, hopefully no one is really depending on order.
    function publish(topicName) {
      var topic = topics[topicName];
      if (topic) {
        var isTimeSliced = topic.isTimeSliced;
        var args = Array.prototype.slice.call(arguments, 1);
        var id = eventId++;
        var localCallbackQueue = [];

        var pushIntoQueue = function pushIntoQueue(callback, queue) {
          queue.push({
            topic: topicName,
            id: id,
            fn: callback.guard ? callback.guard(callback.fn) : callback.fn,
            args: args,
            logError: callback.logError
          });
        };

        if (isTimeSliced) {
          var callback;
          while ((callback = topic.shift()) !== undefined) {
            pushIntoQueue(callback, callbackQueue);
          }
        } else {
          for (var i = 0, l = topic.length; i < l; i++) {
            // revisedEventHandling AUI_57984
            pushIntoQueue(topic[i], revisedEventHandling ? localCallbackQueue : callbackQueue);
          }
        }

        if (revisedEventHandling) { // revisedEventHandling AUI_57984:T1
          if (isTimeSliced) {
            if (!publishing) {
              publishing = true;
              timeslicedPartialPublish();
            }
          } else {
            synchronousLocalPublish(localCallbackQueue);
          }
        } else if (!publishing) { // revisedEventHandling AUI_57984:C
          publishing = true;
          _partialPublishDeprecated(isTimeSliced);
        }
      }
    }

    function subscribe(topic, callback, logHandlers) {
      if (!topics[topic]) {
        topics[topic] = [];
      }

      if (typeof callback !== 'function') {
        return;
      }

      topics[topic].unshift({
        fn: callback,
        logError: logHandlers && logHandlers.logError,
        guard: logHandlers && logHandlers.guard
      });

      return {
        'event': topic,
        'callback': callback
      };
    }

    function unsubscribe(topic, callback) {
      var t;
      var topicList = topic.split(" ");

      while ((t = topicList.pop()) !== undefined) {
        if (!topics[t]) {
          continue;
        }

        // If no callback is specified, we remove all handlers for the event
        if (!callback) {
          topics[t] = [];
          continue;
        }

        var currentTopic = topics[t];

        for (var i = 0, j = currentTopic.length; i < j; i++) {
          if (currentTopic[i] && currentTopic[i].fn === callback) {
            // We're moving i back a notch here so we don't skip the next callback
            currentTopic.splice(i--, 1);
          }
        }
      }
    }    }

    function makeTopicTimeSliced(topic) {
      if (!topics[topic]) {
        topics[topic] = [];
      }
      topics[topic].isTimeSliced = true;
    }

    return {
      publish: publish,
      subscribe: subscribe,
      unsubscribe: unsubscribe,
      isSubscribed: isSubscribed,
      makeTopicTimeSliced: makeTopicTimeSliced
    };
  }());

  var eventDefaults = {
    input: 'change',
    select: 'change',
    a: 'click',
    button: 'click',
    form: 'submit'
  };

  var on = (function () {
    var onFn = function (eventList, fn, one) {
      var events = eventList.split(" ");
      var event;
      var retEventList = [];
      var finalCallback = fn;

      // Extra parameters to pass when subscribing to an event. In this context, `this` will
      // be either the `a-events` object returned by this module, or `A` itself. When `this` is
      // `A`, these functions will apply proper attribution to any errors that get thrown
      // by event observers
      var logHandlers = this ? { logError: this._logError, guard: this._guard } : {};

      if (one === true) {
        finalCallb    };
      }

      while ((event = events.pop()) !== undefined) {
        if (occurred[event]) {
          // deliberately use fn as we don't store these events past their singular execution
          messages.subscribe(event, fn, logHandlers);
          messages.publish(event);
          messages.unsubscribe(event);
        } else {
          retEventList.push(messages.subscribe(event, finalCallback, logHandlers).event);
        }
      }

      return {
        "event": retEventList.join(" "),
        "callback": finalCallback
      };
    };

    var events = ['ready', 'load', 'unload', 'afterLoad', 'scroll', 'resize', 'orientationchange', 'zoom'];

    util.each(events, function (event, index) {
      onFn[event] = function () {
        onFn.apply(this, [event].concat([].slice.call(arguments, 0)));
      };
    });

    return onFn;
  }());

  function one(event, fn) {
    var singleEventCheck = event.split(" ");

    if (singleEventCheck.length > 1) {
      P.error('A.one only accepts a single event name, but was provided with: ' + singleEventCheck.length + ', (' + event + ')', 'A.events', 'one');
      return;
    }

    return on(event, fn, true);
  }

  function off (handleOrName, fn) {
    var eventToUnsubscribe;
    var fnToUnsubscribe;
    if (typeof handleOrName === 'object') {
      // An eventHandle (returned by A.on) is given
      eventToUnsubscribe = handleOrName.event;
      fnToUnsubscribe = handleOrName.callback;
    } else {
      eventToUnsubscribe = handleOrName;
      fnToUnsubscribe = fn;
    }
    return messages.unsubscribe(eventToUnsubscribe, fnToUnsubscribe);
 ;
  }

  /**
   *  Trigger a one-time event, like "ready" for DOMReady.  If event listeners bind to this event after the event has
   *  fired, they will be immediately invoked; it behaves like a P module, in that regard.
   *
   *  @private
   *  @param {string} event The name of the event to trigger.
   *  @param {boolean} [shouldTimeSlice=true] Whether the event listeners for this event should be timesliced.
   */
  function oneTimeEvent(event, shouldTimeSlice) {
    var eventRegiste    };

    if (shouldTimeSlice !== false) {
      messages.makeTopicTimeSliced(event);
    }

    occurred[event] = true;
    messages.subscribe(event, eventRegisterFn);
    messages.publish(event);
    messages.unsubscribe(event);
  }


  // Triggers the 'ready' event. This can be called multiple times and only
  // the first time will actually have an effect
  var ready = util.once(function() {
    if (detect.responsiveGridEnabled()) {
      detect.toggleResponsiveGrid(true);
    }
    oneTimeEvent('beforeReady');
    oneTimeEvent('ready');
    oneTimeEvent('afterReady');

    // Fire load after ready if window.load occurred before the JS was loaded
    if (document.readyState === 'complete') {
      load();
    }
  });

  // Trigger the 'ready' event when jquery tells us its okay
  $(document).ready(ready);

  // Re-trigger the 'bodyBegin' event from PageJS so it can be consumed with A.on
  P.when('a-bodyBegin').ex;
  });

  // Sometimes, jQuery will load after DOMContentLoaded has fired. If that
  // happens, we need to listen to the a-domready event, which is guaranteed
  // to be hooked in before the dom is fully loaded
  P.when("a-domready").execute(ready);


  // Triggers the 'load' event
  function load() {
    //Load should only happen once
    if (occurred.beforeLoad && occurred.load) {
      return;
    }

    oneTimeEvent('beforeLoad');
    oneTimeEvent('load');

    // After window load
    setTi    }, 1500);
  }

  // Trigger the 'load' event
  $window.load(load);


  // Window unload
  $window.u;
  });

  function Events(guard, logError) {
    var originalOn = this.on;

    // The event module's implementation of on() expects to have `A` as its caller in order to gain access to
    // its error attribution data. We'll also provide _guard/_logError to this instance's on(), so A.on.* calls
    // also attribute errors correctly.
    thiss); };
    this.on._guard = guard;
    this.on._logError = logError;

    for (var eventName in originalOn) {
      if (originalOn.hasOwnProperty(eventName)) {
        this.on[eventName] = originalOn[eventName];
      }
    }

    // This is to ensure the constructor for this module doesn't get applied to A
    this.constructor = undefined;
  }

  Events.prototype = {
    isListening: messages.isSubscribed,
    on: on,
    one: one,
    off: off,
    trigger: trigger,
    events: {
      defaults: eventDefaults
    }
  };

  Events.prototype.constructor = Events;

  return Events.prototype;
});
/////////////////////////
// END FILE a_events.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_prefix.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI prefix detection for events and CSS rules.
 *
 */

"use strict";

/**
 *  Returns methods which can be used to detect whether or not a CSS rule or event is supported by the browser
 *  as well as any vender prefixes which need to be applied for that rule/event.
 */
P.when("a-util", "a-events").register("a-prefix", function (util, events) {

  /**
   *  Keep track of the status of event tests.
   *    null means that the test hasn't been run.
   *    false means that the test has run and the event isn't supported
   *    a string means that the event is supported and the string is the possibly prefixed name of the test.
   *
   *  @private
   *  @type {object}
   */
  var prefixedEvents = {
    transitionend: null
  };

  /**
   *  Keep the element's style attributes in memory for prefix testing.
   *
   *  @private
   *  @type {object}
   */
  var style = document.createElement("div").style;


  /**
   *  A map of unprefixed CSS attributes with their prefixed JS equivalents.
   *
   *  @private
   *  @type {object}
   */
  var prefixedRules = {};

  /**
   *  The browser prefixes we're testing for.
   *
   *  @private
   *  @type {array}
   */
  var prefixes = ["o", "ms", "moz", "webkit"];

  /**
   *  Convert a dash delimited string to a camel case string.
   *
   *  @private
   *  @param {string} str  The string to convert
   *
   *  @return {string}
   ;
  }

  /**
   *  Convert a non-prefixed CSS rule and return the optionally prefixed version of the
   *  corresponding JS style property.
   *  Memoized
   *
   *  @private
   *  @param {string} rule
   *
   *  @return {string}
   */

  function prefixRule(rule) {
    if (!prefixedRules[rule]) {
      var jsRule = toCamelCase(rule);
      if (jsRule in style) {
        prefixedRules[rule] = jsRule;
      } else {
        var capitalized = jsRule.charAt(0).toUpperCase() + jsRule.slice(1);
        var i = prefixes.length;
        while (i--) {
          var prefixedRule = prefixes[i] + capitalized;
          if (prefixedRule in style) {
            prefixedRules[rule] = prefixedRule;
          }
        }
      }
    }
    return prefixedRules[rule];
  }

  /**
   *  Run these event tests during beforeReady so that people will have it as soon as possible.
   */
  events.on("beforeReady", function () {
    if (window.addEventListener) {
      /**
       *  Test for the transitionend event by trying to trigger it on a temporary element.
       *  Vendor prefixes taken from https://developer.mozilla.org/en-US/docs/Web/Reference/Events/transitionend?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Ftransitionend
       */
      var div = document.createElement("div");
      var transitionendhandler = function (event) {
        prefixedEvents.transitionend = event.type;
        this.removeEventListener("webkitTransitionEnd", transitionendhandler, false);
        this.removeEventListener("transitionend", transitionendhandler, false);
        this.removeEventListener("otransitionend", transitionendhandler, false);
        this.removeEventListener("oTransitionEnd", transitionendhandler, false);
      };
      var transition = "transition:top 1ms ease";
      div.setAttribute("style", "position:absolute;top:0px;z-index:-1;transition:top 1ms ease;-webkit-transition:top 1ms ease;-moz-transition:top 1ms ease;-o-transition:top 1ms ease;");
      div.addEventListener("transitionend", transitionendhandler, false);
      div.addEventListener("webkitTransitionEnd", transitionendhandler, false);
      div.addEventListener("otransitionend", transitionendhandler, false);
      this.addEventListener("oTransitionEnd", transitionendhandler, false);
      document.body.appendChild(div);

      // Delay to let paint happen
      util.delay(function () {
        div.style.top = "100px";
        // Long ass delay to ensure that the element isn't removed before the test can finish running
        util.delay(function () {
          div.parentNode.removeChild(div);
          div = transitionendhandler = null;
          util.each(prefixedEv    });
        }, 100); // TODO can we use another technique here to get back the 100ms?
      }, 0);
    }
  });

  return {
    prefixes: {
      getStyle: prefixRule,
      getE    }
    }
  };
});
/////////////////////////
// END FILE a_prefix.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_declarative.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Declarative Event Handler
 */
'use strict';

/**
 *  Allows users to register event handlers using only HTML and data attributes.
 */

P.when('a-base', 'a-util', 'a-events', 'a-event-analytics', 'a-timing-analytics', 'prv:a-declarative-analytics', 'p-recorder-stop')
    .register('a-declarative', function (base, util, events, eventAnalytics, timingAnalytics, declarativeAnalytics, pRecorderStop) { //jshint ignore:line
  var $ = base.$;
  var actionOptions = {};

  var DECLARATIVE_CLASS = "a-declarative";

  /**
   *  The selector used to find a declarative element
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var DECLARATIVE_SELECTOR = "." + DECLARATIVE_CLASS;

  /* Importing weblabs/_prevent_default.js */
/**
 *  For backward compatibility, we want to prevent default when
 *  clicks are performed on declarative links.
 *
 *  @private
 *  @param {DOM node} $target  The event's target wrapping in a jQuery call
 *  @param {object} event  The event
 *  @param {object} options  The global options associated with this declarative action
 *  @param {object} data  The invocation/DOM node specific data for this declarative action
 *
 *  @return {boolean}
 */

function shouldPreventDefault($target, event, options, data) {
  var allowLinkDefault = false;
  if (data) {
    allowLinkDefault = !! data.allowLinkDefault;
  } else if (options) {
    allowLinkDefault = !! options.allowLinkDefault;
  }
  if (event.type === "click" && !allowLinkDefault) {
    var $link = $target.closest("a");
    return $link.length && ($link[0].href === "#" || event.currentTarget === $link[0] || $link.parent(DECLARATIVE_SELECTOR).length);
  }
  return false;
}
/* Done importing weblabs/_prevent_default.js */


  /**
   *  Check the event and the DOM nodes associated with it to determine if we need to trigger
   *  an event based on the data attributes of the DOM nodes.
   *
   *  @private
   *  @param {object} event  The jQuery event to examine
   */

  function handleEvent(event) {
    var $currentTarget = $(event.currentTarget);
    var $target = $(event.target);

    // In IE < 9 the event.target for submit events is the submit button.  Everyone else has the form.  Normalize on the form.
    if (event.type === "submit") {
      var $form = $target.closest("form");
      if ($form.length) {
        $target = $form;
      }
    }

    // If there aren't any actions in the data attribute, we have nothing to do
    var declAction = $currentTarget.data('action');
    if (!declAction) {
      return;
    }

    // Trigger the events associated with each declarative action listed on the current target
    var namedActions = declAction.split(' ');
    util.each(namedActions, function (action) {
      var options = actionOptions[action] || {};
      var data = $currentTarget.data(action);
      var type = event.type;

      // Build up a normalized event object to pass into each declarative event callback
      var eventObj = {
        $target: $target,
        $currentTarget: $currentTarget,
        targetTag: $target.prop('tagName').toLowerCase(),
        type: type,
        action: action,
        data: data,
        $event: event,
        $declarativeParent: $currentTarget
      };

      var eventPrefix = "a:declarative:";
      var eventGroupName = eventPrefix + action;
      var eventName = eventGroupName + ":" + type;

      events.trigger(eventGroupName, eventObj); // For backwards compatibility and to allow someone to just bind to all the events
      events.trigger(eventName, eventObj); // Allows someone to bind to a specific event

      if (!events.isListening(eventName)) {
        // WEBLAB: AUI_66484:T1
        // For declarative system, there have a chance that user handler is not
        // yet register on event bus through `A.declarative`, but the event is
        // already triggered on dom.
        eventAnalytics.handle(event); // check and log if we're interested in it.
      }

      if (shouldPreventDefault($target, event, options, data)) {
        event.preventDefault();
      }
    });
  }

  /**
   *  Delegate the declarative and gesture detection event handlers onto the document.
   */
  // WEBLAB: AUI_66484:T1
  pRecorderStop();
  $(document).delegate(DECLARATIVE_SELECTOR, 'blur click dblclick focus focusin focusout mousedown mouseup mouseenter mouseleave mousemove change submit touchstart touchend touchmove touchcancel keydown keyup keypress MSPointerDown pointerdown MSPointerUp pointerup MSPointerMove pointermove MSPointerCancel pointercancel MSPointerOver pointerenter MSPointerOut pointerleave', handleEvent)
    .delegate('.a-gesture', 'tap swipe swipe-horizontal swipe-vertical pan-horizontal pan-vertical doubleTap', handleEvent);

  /**
   *  Allow the user to register a new declarative event handler.  Example invocations:
   *
   *  declarative(actionNames, callback) -- Listen to all declarative events for the listed actions
   *  declarative(actionNames, events, callback) -- Listen to the enumerated declarative events for the listed actions
   *  declarative(actionNames, events, options, callback) -- Listen to the enumerated declarative events for the listed actions and configure the declarative response
   *
   *  @public
   *  @param {string} actionNames  A whitespace delimited list of action names to handle
   *  @param {string} events  A comma delimited list of browser events to handle
   *  @param {object} options  A hash of options which can be used to further refine when events are triggered or which default actions will be taken in response to the event
   *  @param {function} callback  The function executed in response to the event
   */
  var declarative = function declarative() {
    var actionNames, declEvents, options, fn;

    switch (arguments.length) {
    case 2:
      actionNames = arguments[0];
      fn = arguments[1];
      break;
    case 3:
      actionNames = arguments[0];
      declEvents = arguments[1];
      fn = arguments[2];

      break;
    case 4:
      actionNames = arguments[0];
      declEvents = arguments[1];
      options = arguments[2];
      fn = arguments[3];
    }

    if (!actionNames) {
      return;
    }

    if (typeof actionNames === 'string') {
      actionNames = util.trim(actionNames).split(" ");
    }

    // Store the current binding allows us to call `events.on` as if it were also bound to `A`. This
    // pipes through any error attribution settings on `A`.
    var self = this;

    util.each(actionNames, function (action) {
      var eventString = "a:declarative:" + action;
      actionOptions[action] = options || {};

      if (declEvents) {
        declEvents = typeof declEvents === 'string' ? util.trim(declEvents).split(" ") : declEvents;

        util.each(declEv    });
      } else {
        events.on.call(self, eventString, fn);
      }
    });
  };

  /**
   *  Add a declarative action to a DOM node.  Data attributes are not changed, but jQuery
   *  data cache is altered.
   *
   *  @public
   *  @param {object} dom  DOM object of the trigger
   *  @param {string} action  Name of the declarative action
   *  @param {object} data  (optional) The data associated with this declarative action
   *
   *  @return {object}  The possibly altered DOM node
   */

  function createDeclarative(dom, action, data) {
    var $dom = dom.jquery && dom.length ? dom : $(dom);

    if ($dom.length && action) {
      var existingAction = $dom.data("action");
      $dom.data("action", existingAction ? existingAction + " " + action : action)
        .data(action, data ? data : {});
      $dom.addClass(DECLARATIVE_CLASS);
    }
    return dom;
  }

  /**
   *  Remove the attributes necessary for a DOM node to trigger a declarative action.
   *  If an action name is supplied, only the data associated with that action will be remove.
   *  If no action is supplied, all action data will be removed.
   *
   *  @public
   *  @param {object} el  DOM element of the trigger
   *  @param {string} actionToRemove A whitespace delimited string of declarative actions to be removed. Defaults to removing all actions
   *  @return {object}  The possibly altered DOM node
   */

  function removeDeclarative(el, actionToRemove) {
      var $el = el.jquery && el.length ? el : $(el);
      if (!$el.length) {
          return el;
      }

      var dataActions = $el.data("action");
      if (!dataActions) {
          return el;
      }

      var remainingActions = dataActions.split(' ');

      // Case where user requests specific actions

      if (actionToRemove) {
          var actionsToRemove = actionToRemove.split(' ');
          util.each(actionsToRemove, function (action) {
              var ind = util.indexOfArray(remainingActions, action);
              if (ind >= 0) {
                  remainingActions.splice(ind, 1);
                  $el.data(action, null);
              }
          });
      }
      else {
          util.each(remainingAct    });
          // Removed all actions
          remainingActions = [];
      }

      if (remainingActions.length) {
          $el.data("action", remainingActions.join(" "));
      } else {
          $el.data("action", null).removeClass(DECLARATIVE_CLASS);
      }
      return el;
  }

  declarative.create = createDeclarative;
  declarative.remove = removeDeclarative;

  // WEBLAB: AUI_66484:T1
  timingAnalytics.stopWidgetLogging('declarative');

  return {
    declarative: declarative
  };
});
/////////////////////////
// END FILE a_declarative.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_draggable.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Draggable Library

'use strict';

P.when('a-util', 'jQuery', 'a-declarative').register('a-draggable', function (util, $, decl) {
  var DECLARATIVE_ACTION = 'a-draggables';
  var MOUSE_DOWN_LAYER_ID = 'a-draggables-mousedown-layer';
  
  // The initial z-index value for transparent layer. Currently, this value
  // allows 33 draggables to float before they begin to stack on top of regular immersive
  // modals (current the regular modals have z-index of 1009). This might need to be
  // changed to accomodate more draggables (or even made as an option to a-draggable)
  var INITIAL_Z_INDEX = 975;
  
  // A transparent layer that overlays everything beneath the current modeless modal
  var $layer;
  
  /**
   * Method for switching on the transparent layer. This enables
   * the transparent mouse layer for catching mousemove events.
   */
  var _showLayer = function () {
    if ($layer) {
      $layer.removeClass('aok-hidden');
    }
  };
  
  /**
   * Method for switching off the transparent layer. This disables
   * the transparent mouse layer.
   */
  var _hideLa}
  };
  
  /**
   * Manages the z-index of draggables to allow them to be stackable. This could
   * be implemented with simple increment on a global counter, but the counter
   * can grow large enough that the draggables cover other popovers (e.g. it
   * might cover other popover elements within the modal itself).
   */
  var _zIndexManager = {
    _maxZIndex: 0,
    _isInit: false,
    _draggables: [],
    
    /**
    * Initialise data
    */
    _init: function () {
      if (!this._isInit) {
        this._isInit = true;
        this._maxZIndex = INITIAL_Z_INDEX;
      }
    },
    
    /**
     * Create the stackable draggable and push it into the managed array.
     *
     * @param   $obj  The object to be added to the managed queue
     */
    create: function ($obj) {
      this._init();
      
      // zim for Z Index Manager
      if (!$obj._zimIndex) {
        $obj._zimIndex = INITIAL_Z_INDEX;
        this._maxZIndex += 1;
        this._draggables.push($obj);
      }
      
      this.acquireFocus($obj);
    },
    
    /**
     * Grants maximum z-index to the object
     *
     * @param   $obj    The object we want to bring to front
     */
    acquireFocus: function ($obj) {
      // Set the focused object to max index
      $obj.css('zIndex', this._maxZIndex);
      // Set the layer to just one index below focused object
      $layer.css('zIndex', this._maxZIndex - 1);
      
      // Adjust the z-index for each of the managed draggables
      for (var i = 0; i < this._draggables.length; i++) {
        var item = this._draggables[i];
        
        // Do not modify the z-index if the item is already below obj
        if (item[0] !== $obj[0] && item._zimIndex > $obj._zimIndex) {
          // If the item was above layer, move it down by 2 z-indices (one for the focused
          // object and one for the layer itself). Otherwise, simply move it down
          // by 1 z-index
          item._zimIndex -= (item._zimIndex > this._maxZIndex - 1) ? 2 : 1;
          item.css('zIndex', item._zimIndex);
        }
      }
      
      // Lastly, remember to update the _zimIndex
      $obj._zimIndex = this._maxZIndex;
    }
  };
  
  /**
   * Returns the draggable object in the event
   *
   * @param   event   Event fired from an object
   * @return  The draggable object (undefined if event is not from a draggable);
   */
  var _getDragga;
  };
  
  /**
   * Returns the coordinates of where the event happened
   *
   * @param   event   The event to extract coordinates from
   * @return  An object with x and y properties
   */
  var _getEventCoordinates = function (event) {
    var e = event.$event;
    
    // Check for touch events as the touch coordinates are stored
    // differently
    if (util.contains('touchstart touchend touchmove', event.type)) {
      e = e.originalEvent.touches[0];
    }
    
    return {
      x: e.clientX,
      y: e.clientY
    };
  };
  
  /**
   * Handling mouse move event when mouse is down.
   *
   * @param   event   The AUI mouse event
   */
  var mousemoveHandler = function (event) {
    var $draggable = _getDraggable(event);
    var data = $draggable.data(DECLARATIVE_ACTION);
    var coords = _getEventCoordinates(event);
    
    if (data.isMouseDown) {
      $draggable.css({
        left: coords.x - data.clickOffset.x,
        top: coords.y - data.clickOffset.y
      });
      
      event.$event.preventDefault();
    }
  };
  
  /**
   * Handle mouse down event.
   *
   * When mouse is pressed, the method checks whether it is pressed
   * within the specified handle; if so, it sets the state for isMouseDown
   * in the declarative data. This helps mousedragHandler in identifiying
   * whether this is a dragging event.
   *
   * The method then creates a transparent layer covering the full screen,
   * positioned 1 layer below the draggable object (z-index - 1). This layer
   * is needed because JavaScript sometimes cannot catch up to mouse movement,
   * and the event will be generated from outside of the draggable object. This
   * layer will help catch those events generated outside of the draggable and
   * keep updating the position of the object.
   *
   * @param   event   The AUI mouse event
   */
  var mousedownHandler = function (event) {
    var node = event.$event.target || event.$event.srcElement;
    var $draggable = _getDraggable(event);
    var data = $draggable.data(DECLARATIVE_ACTION);
    
    // Bring the object up on click
    _zIndexManager.acquireFocus($draggable);
    
    // Check if the click target is within the handle
    node = $(node).closest(data.$handle, $draggable);
    // Length is 0 if $.closest cannot find anything
    data.isMouseDown = node.length > 0;
    
    if (data.isMouseDown) {
      _showLayer();
      
      var coords = _getEventCoordinates(event);
      
      // Update object position by offset
      data.clickOffset = {
        x: coords.x - parseFloat($draggable.css('left')),
        y: coords.y - parseFloat($draggable.css('top'))
      };
      
      // Update both declarative data
      $draggable.data(DECLARATIVE_ACTION, data);
      $layer.data(DECLARATIVE_ACTION, data);
      
      event.$event.preventDefault();
    }
  };
  
  /**
   * Handle mouse up event. Also removes the transparent layer.
   *
   * @param   event   The AUI mouse event
   */
  var mouseupHandler = function (event) {
    var $draggable = _getDraggable(event);
    var data = $draggable.data(DECLARATIVE_ACTION);
    
    data.isMouseDown = false;
    $draggable.data(DECLARATIVE_ACTION, data);
    _hideLayer();
  };
  
  /**
   * Method for creating the transparent layer (see description in mousedownHandler).
   *
   * @param   options     The options for the draggable declarative
   */
  var _createLayer = function (options) {
    if (!$layer) {
      // Added quotes around class only so that the unminified version runs
      // under old IEs; the build process will have class double quoted either way
      $layer = $('<div>', { id: MOUSE_DOWN_LAYER_ID, 'class': 'aok-hidden' })
          .appendTo('body');
        
      decl.declarative.create($layer, DECLARATIVE_ACTION, options);
    }
  };
  
  return {
    /**
     * Function for making a DOM object draggable.
     *
     * @param   obj       The object to be made draggable. It must have a fixed position
     * @param   options   Options for the draggable. Currently supports the following properties:
     *                      - handle: (Optional) A DOM or jQuery object where mouse dragging
     *                                should happen. If not supplied, the entire obj will be draggable
     */
    draggable: function (obj, options) {
      var $obj = obj.jquery? obj : $(obj);
      var opts = {
        isMouseDown: false,
        $draggable: $obj,
        $handle: options && options.handle ? options.handle : $obj
      };
      
      opts.$handle = opts.$handle.jquery? opts.$handle : $(opts.handle);

      // Set cursor type to move to indicate that the window is movable
      opts.$handle.css('cursor', 'move');
      
      _createLayer(opts);
      _zIndexManager.create(opts.$draggable);
      
      // Create delcarative for the action
      decl.declarative.create(opts.$draggable, DECLARATIVE_ACTION, opts);
      
      // If mousedown within the specified handle, set status 'isMouseDown'
      decl.declarative(DECLARATIVE_ACTION, ['mousedown', 'touchstart'], mousedownHandler);
      
      // Any mouseup event will unset isMouseDown
      decl.declarative(DECLARATIVE_ACTION, ['mouseup', 'touchend'], mouseupHandler);
      
      // Listen to mouse move
      decl.declarative(DECLARATIVE_ACTION, ['mousemove', 'touchmove'], mousemoveHandler);
    }
  };
});
/////////////////////////
// END FILE a_draggable.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_state.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Page State
 *
 */

'use strict';

/**
 *  Allows features on the page to create a namespaced in-memory data hash and register callbacks which listen for
 *  changes on that namespace.
 */
P.when('a-base', 'a-util', 'a-events', 'a-declarative', 'a-constants')
  .register('a-state', function (base, util, events, declarative, constants) { // jshint ignore:line
  var $ = base.$;

  /**
   *  Internal data cache which associates data with certain namespaces
   *
   *  @private
   *  @type {object}
   */
  var states = {};

  /**
   *  Update the data associated with the given namespace based on the new data.
   *  Passing null will clear the namespace. Passing scalar values (numbers,
   *  strings, booleans, or functions) is not supported by this API.
   *
   *  @private
   *  @param {string} namespace  The namespace of the data we're dealing with
   *  @param {object} data  New data to be placed on the namespace
   *  @param {boolean} silent  If set to true, the state change event will not be triggered (optional)
   *  @param {boolean} replace  If set to true, the namespace will be overridden with whatever is passed in (optional)
   *
   *  triggers a:state:update:[namespace]
   *
   *  @return {object}  The new hash associated with the namespace
   */
  function updateNamespace(namespace, data, silent, replace) {
    var newNamespace = !hasNamespace(namespace);
    if (data === null || $.isArray(data) || $.isPlainObject(data)) {
      var prev = getNamespace(namespace);
      if (!prev || !data || replace || !($.isArray(prev) || $.isPlainObject(prev))) {
        states[namespace] = util.copy(data);
      } else {
        util.extend(states[namespace], data);
      }
      var changed = util.diff(prev, states[namespace]);
      var newState = getNamespace(namespace);

      if (!silent) {
        events.trigger('a:state:update:' + namespace, newState, changed, prev);
      }

      // declare namespave via P if it's a new set namespace
      if(newNamespace){
        var moduleName = constants.constants.PAGESTATE_LOADED_MODULE_PREFIX + namespace;
        P.declare(moduleName, newState);
      }

      return newState;
    } else {
      P.error("Invalid value passed to A.state with a namespace of " + namespace + ".  Value: " + data, "A.state", "updateNamespace");
    }
  }

  /**
   *  Get a copy of the data associated with the namespace
   *
   *  @private
   *  @param {string} namespace  The namespace of the data to be retrieved
   *
   *  @return {object}  The data hash associated with the namespace
  ;
  }

    /**
     *  Check is namespace has been set
     * @param namespace
     * @returns {boolean}
    ;
  }

  /**
   *  Converts an array of strings like ["customer", "firstName"] into an object like:
   *  customer : { firstName : value }, and assigns the passed in value to the last key
   *
   *  @private
   *  @param {object} obj  The object onto which the "keys" will be attached
   *  @param {array} keys  An array of strings which will be converted into a nested object
   *                       with the same order as the array
   *  @param {object} value  The value to attach to the leaf "key"
   *
   *  @return {object} The obj, with the converted "keys" array attached
   */
  function keyNameToObject(obj, keys, value) {
    if (keys.length === 1) {
      obj[keys.shift()] = value;
      return obj;
    }

    obj[keys.shift()] = keyNameToObject({}, keys, value);
    return obj;
  }

  /**
   *  A combined event handler for all a-state related declarative events.
   *
   *  @private
   *  @param {object} event
   */
  function handleEvent(event) {
    var $target = event.$target;
    var namespace = event.data.key;
    var eventProps = event.data[event.type];

    // If no key name is provided for this event, let's fallback to the "name"
    // attribute if the triggering event is the default event for that tag type
    if (!eventProps && events.events.defaults[event.targetTag] === event.type) {
      eventProps = $target.attr("name");
    }

    // Nothing to do for this event
    if (!eventProps || !namespace) {
      return;
    }

    // Handle select elements by getting the currently selected option[s]
    if ($target.is('select')) {
      $target = $target.find(':selected');
    }

    // Handle form elements
    if (typeof $target.val() !== undefined && typeof eventProps === 'string') {
      var val = $target.val();

      // Handle checkboxes
      if ($target.is('input[type=checkbox]') && !($target.prop('checked'))) {
        val = null;
      }

      eventProps = keyNameToObject({}, eventProps.split('.'), val);
    }

    // Save the data
    updateNamespace(namespace, eventProps);
  }

  // Register declarative API bindings
  declarative.declarative('a-state', handleEvent);

  /**
   *  A combined getter and setter for the state data.
   *
   *  @public
   *  @param {string} namespace  The namespace of the data we're dealing with
   *  @param {object} data  The object to be extended onto the existing namespace (optional)
   *  @param {boolean} silent  If set to true, the state change event will not be triggered (optional)
   *
   *  @return {object}  The current data associated with the namespace.
   */
  var state = function (namespace, data, silent) {
    return data === undefined ? getNamespace(namespace) : updateNamespace(namespace, data, !!silent);
  };

  /**
   *  Bind a callback function which is triggered when the given namespace changes.
   *  This is attached to the state function declared above.
   *
   *  @public
   *  @param {string} namespace  The namespace which will be monitored.
   *  @param {function} fn  The callback function
   */
  state.b;
  };

  /**
   *  A setter which overrides the current state value with whatever's passed in instead of extending the namespace.
   *
   *  @public
   *  @param {string} namespace  The namespace of the data we're dealing with
   *  @param {object} data  The object to be placed onto the existing namespace
   *  @param {boolean} silent  If set to true, the state change event will not be triggered (optional)
   *
   *  @return {object}  The current data associated with the namespace.
   */
  state.replace = function (namespace, data, silent) {
    return updateNamespace(namespace, data, !!silent, true);
  };

  /**
   *  Parse script tags generated by the page_state template and load the data into
   *  the state cache.
   *
   *  @public
   */
  function parseScriptTags() {
    var scripts = document.getElementsByTagName('script');
    for (var i = 0, l = scripts.length; i < l; i++) {
      var parsed = $.data(scripts[i], 'a-eval');

      if (parsed) {
        continue;
      }

      var $elem = $(scripts[i]);
      var props = $elem.attr('data-a-state');
      if (!props) {
        continue;
      }

      var propsObj = util.parseJSON(props);

      if (!propsObj.key) {
        continue;
      }

      var obj;
      try {
        obj = util.parseJSON($elem.html());
      } catch (e) {
        P.logError(e, 'State parsing failed for state ' + propsObj.key, 'ERROR');
        continue;
      }

      $.data(scripts[i], 'a-eval', true);

      // If something already exists in the namespace, then make sure that data takes precidence
      var current = states[propsObj.key];
      if (current) {
        util.extend(obj, current);
      }

      updateNamespace(propsObj.key, obj);
    }
  }

  /**
   *  When the DOM is ready, but before any ready callback fire, scan the DOM and
   *  ensure the state data is initialized.
   */
  events.on('beforeReady', parseScriptTags);

  /**
   *  Expose the function to parse the state data output by the page_state template.
   */
  state.parse = parseScriptTags;

  return {
    state: state
  };
});
/////////////////////////
// END FILE a_state.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_ajax.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Amazon UI Ajax
'use strict';

P.when(
  'prv:a-guard', 'a-base', 'a-util', 'a-events', 'a-declarative', 'a-state'
).register('a-ajax', function (guard, base, util, events, declarative, state) { // jshint ignore:line
  var $ = base.$;

  var AUI_TAG = "aui";
  var AUI_AJAX_TAG = AUI_TAG + ":ajax";

  /**
   *  Serialize get/post parameters
   *
   *  @private
   *  @param {object} params
   *  @param {String} type, type of params, could be
   *                  'string': params is a string
   *                  'json': params is an object, will be serialized with JSON.stringify
   *                  Anything else: params is an object, will be serialzied to URL query parameter.
   *
   *  @return {string} Serialized query parameters
   */
  function serializeParams(params, paramsFormat) {
    if(!params) {
      return '';
    }
    var isString = typeof params === 'string';
    if(paramsFormat === 'string') {
      return isString ? params : '';
    }
    if(paramsFormat === 'json') {
      if(isString) {
        return params;
      }
      try {
        return (JSON && JSON.stringify) ? JSON.stringify(params) : '';
      } catch(e){
        P.logError(e, 'AJAX POST failed to convert JSON object to string');
      }
      return '';
    }
    return isString ? "" : $.param(params);
  }

  var Ajax = (function () {
    // IE6 stank
    if (!window.XMLHttpRequest) {
      window.XMLHttpRequ    };
    }

    // Global request Queue
    var requestQueue = (function () {
      var MAX_IN_FLIGHT = 4;
      var queue = [];
      var inFlight = 0;
      /**
       * Track total requests added to the queue
       * @private
       */
      var totalQueued = 0;
      /**
       * Track max requests in queue at any one time
       * @private
       */
      var maxQueued = 0;

      function abort(req) {
        util.each(queue, function (queued, index) {
          if (queued === req) {
            queue.splice(index, 1);
            return util.breaker;
          }
        });

        complete();
      }

      function complete() {
        if (queue.length > 0) {
          queue.pop().send();
        } else {
          inFlight--;
        }
      }

      function add(req) {
        if (inFlight < MAX_IN_FLIGHT) {
          req.send();
          inFlight++;
        } else {
          queue.push(req);
          totalQueued++;
          if (queue.length > maxQueued) {
            maxQueued = queue.length;
          }
          var ue = window.ue;
          if (ue && ue.count) {
            ue.count(AUI_AJAX_TAG + ":queued", totalQueued);
            ue.count(AUI_AJAX_TAG + ":maxQueued", maxQueued);
          }
        }
      }

      return {
        add: add,
        complete: complete,
        abort: abort
      };
    }());

    /**
     *  Useful constants
     *
     *  @private
     *  @constant
     *  @type {object}
     */
    var xhrConstants = {
      // Statuses
      OK: 200,
      NOT_MODIFIED: 304,

      // States
      DONE: 4,
      IN_PROGRESS: 3,
      HEADERS: 2,
      OPENED: 1,
      UNSENT: 0,

      // Misc
      NOOP: function () {},
      DELIM: '&&&',
      DEFAULT_TIMEOUT: 20000, // If you want to change this, you'll need to also change the unit tests which depend on this constant
      DEFAULT_POLL_INTERVAL: 25
    };

    // Response handlers
    var responseHandlers = {
      streaming: function streaming(xhr) {
        var http = xhr.http;
        var buffer = xhr.buffer;

        var responseInProgress = false;
        var responseIsDone = false;

        // In Firefox it seems that the http.readyState can change over the course
        // of the execution of this function. Because of this we need to only
        // reference it once to ensure consistent behavior.
        switch (http.readyState) {
          case xhrConstants.DONE:
            responseIsDone = true;
            break;
          case xhrConstants.IN_PROGRESS:
            responseInProgress = true;
            break;
        }

        var successfulResponse = (http.status === xhrConstants.OK || http.status === xhrConstants.NOT_MODIFIED);
        var responsePosition = xhr.responsePosition;

        if (responseInProgress || (responseIsDone && successfulResponse)) {
          var response = http.responseText;

          if (responsePosition < response.length) {
            var newData = response.substring(responsePosition, response.length);
            var tokens = newData.split(xhrConstants.DELIM);
            var lastDelimPosition = newData.lastIndexOf(xhrConstants.DELIM);

            // No new delim found yet
            if (lastDelimPosition === -1 && responseInProgress) {
              return;
            }

            // The last delim wasn't found at the end, so the last token is not complete yet
            if (lastDelimPosition < (newData.length - xhrConstants.DELIM.length) && responseInProgress) {
              tokens.pop();
            }

            util.each(tokens, function (token, index) {
              var parsed;

              // Only attempt to parse if we're dealing with non-whitespace content as a whitespace response is not worthy of P.logError()
              if (util.trim(token) !== "") {
                try {
                  parsed = util.parseJSON(token);
                } catch (e) {
                  P.logError(e, 'Invalid streaming ajax JSON response: ' + token);
                }
              } else {
                // Pass along the whitespace token
                parsed = token;
              }

              xhr.callbacks.chunk(parsed);
            });

            xhr.responsePosition += lastDelimPosition;
          }
        }

        if (responseIsDone) {
          clearInterval(xhr.pollTimer);
          clearTimeout(xhr.timeoutTimer);
          requestQueue.complete();

          if (successfulResponse) {
            xhr.callbacks.success(null, http.statusText, xhr);
          } else {
            xhr.callbacks.failure(xhr, http.statusText, http.statusText);
          }

          events.trigger('a:pageUpdate');
          events.trigger('a:ajax:complete');
        }
      },
      normal: function normal(xhr) {
        var http = xhr.http;

        if (http.readyState === xhrConstants.DONE) {
          clearInterval(xhr.pollTimer);
          clearTimeout(xhr.timeoutTimer);
          requestQueue.complete();

          var response = http.responseText;

          // Attempt to parse as JSON, but ignore if there's a parse failure
          try {
            var json = util.parseJSON(response);
            if (json) {
              response = json;
            }
          } catch (e) {}

          if (http.status !== xhrConstants.OK && http.status !== xhrConstants.NOT_MODIFIED) {
            xhr.callbacks.failure(xhr, http.statusText, http.statusText);
          } else {
            xhr.callbacks.success(response, http.statusText, xhr);
          }
          events.trigger('a:ajax:complete');
        }
      }
    };

    // Main XHR Object
    var StreamingXhr = (function () {

      /**
       *  A hash of default request headers to send with all types of requests.
       *
       *  @private
       *  @constant
       *  @type {object}
       */
      var DEFAULT_HEADERS = {
        all: {
          "X-Requested-With": "XMLHttpRequest"
        },
        get: {
          "Accept": "text/html,*/*"
        },
        post: {
          "Accept": "text/html,*/*",
          "Content-Type": "application/x-www-form-urlencoded"
        }
      };

      /**
       *  Check to see if a request has been open longer than the timeout specified by the user.
       *
       *  @private
       *  @param {Xhr} xhr
       */

      function checkTimeout(xhr) {
        if (xhr.http.readyState < xhrConstants.DONE) {
          clearInterval(xhr.pollTimer);

          // The browser might throw errors if we attempt to access the statusText property while the
          // request is still open
          var statusText = "Request Timeout";
          xhr.callbacks.failure(xhr, statusText, statusText);
          requestQueue.complete();
        }
      }

      /**
       *  Ensure that a string containing serialized query parameters is appended
       *  to the end of any URL properly.  This include URLs which already have some
       *  query parameters on them.
       *
       *  @private
       *  @param {string} url
       *  @param {string} params
       *
       *  @return {string}
       */

      function appendQueryParams(url, params) {
        if (params) {
          var idx = url.indexOf("?");
          var lastChar = url.charAt(url.length - 1);
          if (idx > -1) {
            if (lastChar !== "?" && lastChar !== "&") {
              url += "&";
            }
          } else {
            url += "?";
          }
          url += params;
        }
        return url;
      }

      /**
       *  Sets the request headers for an XHR.  The DEFAULT_HEADERS_ALL is always used, and the
       *  method specific defaults can be passed in to this function as well.  However, the
       *  user supplied headers reign supreme.
       *
       *  @private
       *  @param {XMLHttpRequest} http
       *  @param {string} method - The method of the request
       *  @param {object} headers - The user supplied headers hash
       *
       *  @return {XMLHttpRequest}
       */

      function setHeaders(http, method, headers) {
        headers = headers || {};

        headers = util.extend({}, DEFAULT_HEADERS.all, DEFAULT_HEADERS[method], headers);
        util.each(headers, function (value, name) {
          // We only set the header if the value is not falsey or is an empty string.
          // This allows people the most control since they can either accept our default, change it,
          // or just not send it
          if (value || value === "") {
            http.setRequestHeader(name, value);
          }
        });

        return http;
      }

      /**
       *  The differences in the get and post methods on the XHR prototype are very minor.  Abstract out the common stuff here and
       *  let the prototype methods handle the diff.
       *
       *  @private
       *  @param {Xhr} xhr
       *  @param {string} method
       *  @param {string} url
       *  @param {number} timeout
       *  @param {function} onChunk
       *  @param {function} onSuccess
       *  @param {function} onFailure
       *  @param {function} onAbort
       *  @param {object} headers
       *  @param {boolean} withCredentials
       *
       *  @return {object}
       */

      function setupRequest(xhr, method, url, timeout, onChunk, onSuccess, onFailure, onAbort, headers, withCredentials) { // jshint ignore:line
        var http = xhr.http;
        http.open(method, url);
        setHeaders(http, method, headers);

        xhr.timeout = timeout;
        xhr.callbacks.chunk = onChunk || xhr.callbacks.chunk;
        xhr.callbacks.success = onSuccess || xhr.callbacks.success;
        xhr.callbacks.failure = onFailure || xhr.callbacks.failure;
        xhr.callbacks.abort = onAbort || xhr.callbacks.abort;

        /*
         *  IMPORTANT:  If we ever end up allowing synchronous requests, then we need to ensure that this property doesn't get set
         *  for synchronous requests.
         */
        if (withCredentials) {
          http.withCredentials = true;
        }

        requestQueue.add(xhr);

        return {
          abort: function () {
            xhr.abort();
          }
        };
      }

      var Xhr = function () {
        var http = new XMLHttpRequest();

        this.pollTimer = null;
        this.http = http;
        this.responsePosition = 0;
        this.buffer = '';

        this.callbacks = {
          success: xhrConstants.NOOP,
          failure: xhrConstants.NOOP,
          chunk: xhrConstants.NOOP,
          abort: xhrConstants.NOOP
        };
      };

      Xhr.prototype = {
        send: function () {
          var xhr = this;
          xhr.http.send(xhr.params);

          // Begin polling for streaming data
          xhr.pollTimer = setInterval(function () {
            if (xhr.http.readyState >= xhrConstants.HEADERS) {
              // IE stank
              if (typeof xhr.http.responseText !== 'unknown') {
                var lcContentType = xhr.http.getResponseHeader('Content-Type');
                lcContentType = lcContentType ? lcContentType.toLowerCase() : "";
                var streaming = lcContentType.indexOf('application/json-amazonui-streaming') !== -1 || /* Deprecated */ lcContentType.indexOf('application/amazonui-streaming-json') !== -1;
                var handler = streaming ? responseHandlers.streaming : responseHandlers.normal;
                handler(xhr);
              }
            }
          }, xhrConstants.DEFAULT_POLL_INTERVAL);

          // Set our timeout
          xhr.timeout = typeof xhr.timeout === 'undefined' ? xhrConstants.DEFAULT_TIMEOUT : xhr.timeout;

          // Set error timeout check
          xhr.timeoutTimer = util.delay(checkTimeout, xhr.timeout, xhr);
        },

        get: function (url, params, timeout, onChunk, onSuccess, onFailure, onAbort, headers, withCredentials) { // jshint ignore:line
          return setupRequest(this, "get", appendQueryParams(url, params), timeout, onChunk, onSuccess, onFailure, onAbort, headers, withCredentials);
        },

        abort: function () {
          var xhr = this;
          if (xhr.http) {
            xhr.http.abort();
          }

          clearInterval(xhr.pollTimer);
          clearTimeout(xhr.timeoutTimer);
          requestQueue.abort(xhr);
          xhr.callbacks.abort(xhr);
        },

            }
      };

      return Xhr;
    }());

    return StreamingXhr;
  }());

  var responseActions = {
    // Updates the provided target with the provided html
    up    },
    // Appends the provided html to the provided target
    append: function (command, target, html) {
      var $target = $(target);
      $target.html($target.html() + html);
    },
    // Prepends the provided html to the provided target
    prepend: function (command, target, html) {
      var $target = $(target);
      $target.html(html + $target.html());
    },
    // Updates the page state under the provided model with the provided
    // data
    s    },
    // Executes the provided script under the global context of the page
    script: function (command, code) {
      eval(code); // jshint ignore:line
    },
    // Trigger an AUI event of type eventName with any additional arguments
    trigger: function(command, eventName) {
      var context, args;
      args = Array.prototype.slice.call(arguments, 1);
      events.trigger.apply(context, args);
    }
  };

  function handleChunk(chunk, customActionHandler) {
    if (!chunk || chunk.length === 0) {
      return;
    }

    // Check to see if we have a whitespace string that was not passed through util.parseJSON()
    if (typeof chunk === "string" && util.trim(chunk) === "") {
      if (customActionHandler) {
        customActionHandler(chunk);
      }
      return;
    }

    // Check to see if we have a list of commands
    if (!(chunk[0] instanceof Array)) {
      chunk = [chunk];
    }

    util.each(chunk, function (args) {
      var action = responseActions[args[0]];

      // For commands we don't know about, fallback to the custom chunk handler
      if (action) {
        action.apply(window, args);
        return;
      }

      action = customActionHandler;

      //If we still don't have a handler for the command, let's fail
      if (!action) {
        P.error('There is no handler for the streaming ajax command: ' + chunk[0], 'A.ajax', 'chunkHandler');
      }

      action(args);
    });
  }

  var declarativeActions = {
    // Updates one or more targets provided by the server on click with the
    // contents of the provided ajax url
    'a-ajax-update': function (options) {
      var ajax = new Ajax();

      var tagCSM = function () {
        var ue = window.ue;
        if (ue && ue.tag) {
          ue.tag(AUI_TAG);
          ue.tag(AUI_AJAX_TAG);
        }
      };

      var chunkHand    };

      var abortHandler = options.abort;

      // Show the working indicator
      var $indicator = $(options.indicator);
      $indicator.show();

      // Hide ajax indicator on success / failure
      var successHandler = function () {
        $indicator.hide();
        tagCSM();

        if (options.success) {
          options.success.apply(window, arguments);
        }
      };

      var failureHandler = function () {
        $indicator.hide();
        tagCSM();

        if (options.failure) {
          options.failure.apply(window, arguments);
        }
      };

      var method = typeof options.method === 'string' && options.method.toLowerCase() === 'post' ? 'post' : 'get';

      // Disable browser cache by appending timestamp into GET calls
      if (method === "get" && options.cache === false) {
        options.params += [options.params === '' ? '' : '&', '_=', util.now()].join('');
      }

      return ajax[method](options.url, options.params, options.timeout, chunkHandler, successHandler, failureHandler, abortHandler, options.headers, options.withCredentials);
    }
  };

  function handleEvent(event) {
    var $target = event.$target;
    var action = event.action;
    var eventProps = event.data;

    // If no config properties are included, we should only act on the default
    // event for the targeted element --> <a data-action=update>
    if (!eventProps && events.events.defaults[event.targetTag] !== event.type) {
      return;
    }

    // Handle the object case where events with options are specified
    if (typeof eventProps === 'object' && !eventProps[event.type]) {
      return;
    }

    eventProps = eventProps || {};
    var url = eventProps.url || $target.attr('href') || $target.attr('action');
    var params = serializeParams(eventProps.params, eventProps.paramsFormat);
    var method = $target.attr('method') || eventProps.method;
    var indicator = eventProps.indicator;
    var timeout = eventProps.timeout;

    // If we don't have a URL or cached data, nothing to do
    if (!url) {
      P.error('No ajax url provided.', 'A.ajax', 'declarativeHandler');
    }

    // If we have a form submission, let's serialize the input elements as parameters
    if (event.targetTag === 'form' && event.type === events.events.defaults.form) {
      var formParams = $target.serialize();
      params += formParams;
    }

    // Prevent form submissions or clicks
    event.$event.preventDefault();

    // Do this thang
    return declarativeActions[action]({
      url: url,
      params: params,
      method: method,
      indicator: indicator,
      operation: action,
      timeout: timeout
    });
  }

  // Register declarative API bindings
  declarative.declarative('a-ajax-update', handleEvent);



  /**
   *  Construct a new Ajax request object which will send an XMLHttpRequest to the
   *  given URL.
   *
   *  @public
   *  @param {string} url
   *  @param {object} options
   *
   *  @return {Ajax}
   */
  var ajax = function ajax(url, options) {
    options = options || {};

    // Normalize the request headers with the convenience "accepts" and "contentType"
    // options taking precidence over equivalent entries on the headers hash.
    var headers = options.headers || {};
    if (options.accepts !== undefined) {
      headers.Accept = options.accepts;
    }
    if (options.contentType !== undefined) {
      headers["Content-Type"] = options.contentType;
    }

    var params = serializeParams(options.params, options.paramsFormat);

    return declarativeActions['a-ajax-update'](guard.obj(this, {
      url: url,
      cache: options.cache,
      params: params,
      method: options.method,
      chunk: options.chunk,
      success: options.success,
      failure: options.failure || options.error,
      abort: options.abort,
      indicator: options.indicator,
      timeout: options.timeout,
      headers: headers,
      withCredentials: !! options.withCredentials
    }));
  };

  return {
    ajax: ajax,

    /**
     *  Convenience method for creating a GET request.
     *
     *  @public
     *  @param {string} url
     *  @param {object} options
     *
     *  @return {Ajax}
     */
    get: function get(url, options) {
      options = options || {};
      options.method = 'get';
      return ajax.call(this, url, options);
    },

    /**
     *  Convenience method for creating a POST request.
     *
     *  @public
     *  @param {string} url
     *  @param {object} options
     *
     *  @return {Ajax}
     */
    post: function post(url, options) {
      options = options || {};
      options.method = 'post';
      return ajax.call(this, url, options);
    }
  };
});
/////////////////////////
// END FILE a_ajax.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_animate.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Animations
 *
 */

"use strict";

/**
 *  An animation library which will use CSS3 animations when possible, but fall back to jQuery if
 *  the browser doesn't support that.
 */
P.when("a-base", "a-util", "p-detect", "a-prefix").register("a-animate", function (base, util, detect, prefix) {

  /**
   *  Default timeslice delay for executing animation function
   *  @private
   *  @type {number}
   *  @constant
   */
  var ANIMATE_DELAY = 4;

  /**
   *  Default animation duration
   *  @private
   *  @type {number}
   *  @constant
   */
  var DEFAULT_TIME = 250;

  /**
   *  Default easing type for transitions
   *  @private
   *  @type {string}
   *  @constant
   */
  var DEFAULT_EASING = "linear";

  /**
   *  A set of CSS properties which we are certain can be hardware accelerated.
   *  @private
   *  @type {array}
   *  @constant
   */
  var GPU_PROPERTIES = ["top", "left", "scale"];

  /**
   *  CSS rules often have vendor prefixes, especially for CSS3 rules.
   *  This function will take the CSS rule name and the desired value and
   *  applies all vendor prefixed versions of the rule paired up with the value.
   *
   *  @private
   *  @param {DOM Node} $target  The DOM node where the rule will be applied
   *  @param {string} rule  The CSS rule to apply.
   *  @param {object} value  The value of the CSS rule
   */

  function prefixedCSS($target, rule, value) {
    var node = $target.jquery ? $target[0] : $target;
    rule = prefix.prefixes.getStyle(rule);
    node.style[rule] = value;
  }

  /**
   *  Generate the CSS rule to translate the top and left property as well as
   *  scale the target.  If the browser supports translate3d, set the translate
   *  Z properties as well to prevent bugs.
   *
   *  @private
   *  @param {properties} props  The properties which should be in the rule
   *
   *  @return {string} The transform CSS rule to change the properties
   */

  function translateScale(props) {
    var translateString = "";
    var transform3d = detect.capabilities.transform3d; // Alias for minimization

    // If both x and y coords are available, use the shortcut
    if (props.top !== undefined && props.left !== undefined) {
      translateString = "translate";
      if (transform3d) {
        translateString += "3d";
      }
      translateString += "(" + props.left + ", " + props.top;
      if (transform3d) {
        translateString += ", 0";
      }
      translateString += ")";
    } else {
      // If only x or y are available, translate them individually
      if (props.top !== undefined) {
        translateString = "translateY(" + props.top + ")";
      } else if (props.left !== undefined) {
        translateString = "translateX(" + props.left + ")";
      }
      if (transform3d) {
        translateString += " translateZ(0)";
      }
    }

    // Add in the scale if desired
    if (props.scale !== undefined) {
      translateString += " scale(" + props.scale + ")";
    }

    return translateString;
  }

  /**
   *  Given a set of CSS properties, pull out and return the properties
   *  which can be animated using hardware acceleration.
   *
   *  @private
   *  @param {array} props  The list of properties
   *
   *  @return {object}  The GPU enabled properties or null if none are present
   */

  function gpuProperties(props) {
    var gpu = {};
    var hasGPUProps = false;

    util.each(GPU_PROPERTIES, function (prop) {
      if (prop in props) {
        hasGPUProps = true;
        gpu[prop] = props[prop];
        delete props[prop];
      }
    });

    return hasGPUProps ? gpu : null;
  }

  /**
   *  CSS 3 transforms take a value relative to the current value of top and left.
   *  Transitions just take an absolute value.  We're assuming that the user is
   *  passing in an absolute value to maintain compatibility with jQuery's API.
   *  So, if we're using a CSS 3 transform, we may have to mutate the top/left property.
   *  If we're using a transition and the user passed in a number, we'll need to append "px".
   *
   *  @private
   *  @param {object} $dom   The jQuery wrapped DOM node which is being animated
   *  @param {string} name   The name of the property being normalized (ex: top)
   *  @param {string|number} value  The value passed in by the user.  Could be a string or a number.
   *
   *  @return {string}  The new value of the property ready to be used in the animation.
   */

  function normalizeProp($dom, name, value) {
    if (detect.capabilities.transform) {
      if (typeof value === "string") {
        value = parseInt(value, 10);
      }
      if (!util.isFiniteNumber(value)) {
        value = 0;
      }

      var current = parseInt($dom.css(name), 10);
      if (!util.isFiniteNumber(current)) {
        current = 0;
      }
      value -= current;
      value += "px";
    } else if (util.isFiniteNumber(value)) {
      value += "px";
    }
    return value;
  }

  /**
   *  JS versions of the animation API.  Right now, we delegate to jQuery.
   */
  var js = {
    animate: function ($target, properties, time, easing, finished) { // jshint ignore:line
      if (!$target._a) {
        $target._a = 0;
      }
      $target._a++;
      var callback = function () {
        $target._a--;
        if (finished) {
          finished();
        }
      };
      $target.queue("fx", [
        function () {
          $target.animate(properties, {
            duration: time,
            easing: easing === "linear" ? easing : "swing",
            complete: callback,
            queue: false
          });
        }
      ]);
    },
    fadeIn: function ($target, time, easing, finished) {
      // if aok-hidden or a-hidden class is present,
      // replace it with display:none
      if ($target.hasClass('aok-hidden') || $target.hasClass('a-hidden')) {
        $target.css('display', 'none');
        $target.removeClass('aok-hidden a-hidden');
      }

      $target.fadeIn({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: finished,
        queue: false
      });
    },
    fadeOut: function ($target, time, easing, finished) {
      // Record original opacity for IE, if the original opacity is not 1,
      // fadeOut will set the opacity to 1 after animation
      var origOpacity = $target.css('opacity');
      $target.fadeOut({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: function () {
          if (+origOpacity < 0.95) {
            $target.css("opacity", origOpacity);
          }

          if (finished) {
            finished();
          }
        },
        queue: false
      });
    },
    fadeToggle: function ($target, time, easing, finished) {
      $target.fadeToggle({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: finished,
        queue: false
      });
    },
    slideUp: function ($target, time, easing, finished) {
      $target.slideUp({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: finished,
        queue: false
      });
    },
    slideDown: function ($target, time, easing, finished) {
      $target.slideDown({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: finished,
        queue: false
      });
    },
    slideToggle: function ($target, time, easing, finished) {
      $target.slideToggle({
        duration: time,
        easing: easing === "linear" ? easing : "swing",
        complete: finished,
        queue: false
      });
    },
    isAnimated: function ($target) {
      var node = $target.jquery ? $target[0] : $target;
      return node._a && node._a > 0;
    }
  };

  /**
   *  CSS3 enabled versions of the animation library API
   */
  var css3 = {
    animate: function ($target, properties, time, easing, finished) { // jshint ignore:line
      var gpuProps;
      var target = $target[0];
      properties = util.copy(properties); // The gpuProps function can be destructive.  Make a copy to be safe.
      time = time === undefined ? DEFAULT_TIME : time;
      easing = easing || DEFAULT_EASING;

      // CSS 3 transforms are relative to the current top and left while translate is an absolute setter.
      // Normalize
      if (properties.top !== undefined) {
        properties.top = normalizeProp($target, "top", properties.top);
      }
      if (properties.left !== undefined) {
        properties.left = normalizeProp($target, "left", properties.left);
      }

      prefixedCSS($target, "transition", time < ANIMATE_DELAY ? "all 0ms" : "all " + time + "ms " + easing);

      // Increment counter for the number of running animations and queue up an end action
      if (time > ANIMATE_DELAY) {
        // Keep track of the number of running animations
        if (target._a === undefined) {
          target._a = 0;
        }
        target._a++;

        var callback = function () {
          target._a--;
          if (!target._a) {
            prefixedCSS($target, "transition", "");
          }

          if (finished) {
            finished();
          }
        };

        util.delay(function () {
          util.delay(callback, time);
        }, 0);
      }

      // Use the GPU for top, left, and scale, if possible
      if (detect.capabilities.transform) {
        gpuProps = gpuProperties(properties);

        if (gpuProps) {
          prefixedCSS($target, "transform", translateScale({
            top: gpuProps.top,
            left: gpuProps.left,
            scale: gpuProps.scale
          }));
        }
      }

      // Calling .css with an empty properties object causes some issue in some Android stock browsers, so don't do that.
      if (!util.objectIsEmpty(properties)) {
        $target.css(properties);
      }

      // If no animation is happening, we need to execute callbacks now
      if (time <= ANIMATE_DELAY) {
        if (finished) {
          util.delay(finished, 0);
        }
      }
    },
    fadeIn: function ($target, time, easing, finished) {
      if ($target.css("display") === "none" || +$target.css("opacity") < 0.05) {
        var targetOpacity = $target.css("opacity") || 1;
        if (!targetOpacity || +targetOpacity < 0.05) {
          targetOpacity = 1;
        }

        $target.css("opacity", "0").removeClass('a-hidden aok-hidden').show();

        // Delay the animation 16ms, which is one frame at 60fps, to allow the browser
        // to paint the above changes to display and opacity. Otherwise, the fading animation
        // may not manifest visually and the element will instantly appear.
        var animateFunction = this.animate;
        util.delay(function () {
          animateFunction($target, {
            opacity: targetOpacity
          }, time, ea    });
        }, 16);
      } else {
        if (finished) {
          finished();
        }
      }
    },
    fadeOut: function ($target, time, easing, finished) {
      var origOpacity = $target.css('opacity');

      if ($target.css("display") !== "none" && +origOpacity > 0.05) {
        this.animate($target, {
          opacity: 0
        }, time, easing, function () {
          $target.hide().css("opacity", origOpacity);

          if (finished) {
            finished();
          }
        });
      } else {
        if (finished) {
          finished();
        }
      }
    },
    fadeToggle: function ($target, time, easing, finished) {
      var fade = $target.css("display") === "none" || +$target.css("opacity") < 0.05 ? this.fadeIn : this.fadeOut;
      fade.call(this, $target, time, easing, finished);
    },
    slideUp: function ($target, time, easing, finished) {
      var animate = this.animate;
      $target.css({
        "height": $target.innerHeight(),
        "overflow": "hidden"
      });

      // Very small timeout for DOM changes to reflect before adding animation
      util.delay(function () {
        animate($target, {
          height: 0
        }, time, easing, function () {
          $target.hide();
          $target.css({
            "height": "",
            "overflow": ""
          });

          if (finished) {
            finished();
          }
        });
      }, 0);
    },
    slideDown: function ($target, time, easing, finished) {
      var targetHeight = $target.innerHeight(),
        animate = this.animate;

      $target.css({
        "height": 0,
        "overflow": "hidden"
      });

      $target.show();
      // Very small timeout for DOM changes to reflect before adding animation
      util.delay(function () {
        animate($target, {
          height: targetHeight
        }, time, easing, function () {
          if (finished) {
            finished();
          }

          $target.css({
            "height": "",
            "overflow": ""
          });
        });
      }, 0);
    },
    slideToggle: function ($target, time, easing, finished) {
      var slide = $target.is(":visible") ? this.slideUp : this.slideDown;
      slide.call(this, $target, time, easing, finished);
    },
    isAnimated: function ($target) {
      var node = $target.jquery ? $target[0] : $target;
      return node._a && node._a > 0;
    }
  };

  /**
   *  Only return the CSS3 version if we're reasonably certain that hardware acceleration exists.
   */
  return detect.capabilities.transition ? css3 : js;
});
/////////////////////////
// END FILE a_animate.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_image_lazy_loader.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Lazy-loads images that are on screen or within 500px of being on screen.
 * 
 * A check to see if any images need to be loaded occurs when:
 *   - the page first loads
 *   - the user scrolls
 *   - the user stops scrolling
 *   - the user resizes the window
 * 
 * We also leverage an image attribute cache in order to avoid rechecking
 * the image offset and height when the user is scrolling (causing jank).
 * This cache is updated when:
 *   - the page first loads
 *   - the user stops scrolling (also triggers a lazy load check)
 *   - an image is finished lazy loading
 */

P.when('A').register('a-image-lazy-loader', function (A, weblab) {
  var $ = A.$;

  var LAZY_LOAD_THRESHOLD = 500;
  
  var scrollTimer;

  // store of an image's offset and height
  var imageAttributeCache = (function() {
    var cache = {};
    var counter = 0;    }

    function set($image) {
      if (!$image.data('cacheKey')) {
        $image.data('cacheKey', counter);
        counter++;
      }

      cache[$image.data('cacheKey')] = {'top' : $image.offset().top, 'height' : $image.height()};
    }

    function remove($image) {
      if ($image.data('cacheKey')) {
        delete cache[$image.data('cacheKey')];
      }
    }

    return {
      get : get,
      set : set,
      remove : remove
    };
  })(;
  }

  // checks if a lazy load image is on or close to being on screen
  // if so, swap the src to download the image
  function lazyLoad() {
    var $imagesToLoad = [];

    $('.a-lazy-loaded').each(function() {
      var $image = $(this);
      
      // if the image has a src and is 500 pixels away from being in view, load it
      if ($image.data('src') && onScreen($image)) {

        // bind to image 'load' event, indicating image has finished loading
        $image    });

        $imagesToLoad.push($image);

        // remove a-lazy-loaded class so we don't try to load again
        $image.removeClass('a-lazy-loaded');

        // remove from the cache, we don't need it
        imageAttributeCache.remove($image);
      }
    });

    A.each($imagesTo    });
  }

  // returns true if the image is on screen, or within LAZY_LOAD_THRESHOLD pixels of being on screen
  function onScreen($image) {
    if (!imageAttributeCache.get($image)) {
      imageAttributeCache.set($image);
    }

    var $window = $(window);
    var windowTop = $window.scrollTop();
    var windowHeight = window.innerHeight ? window.innerHeight : $window.height();
    var windowBottom = windowTop + windowHeight + LAZY_LOAD_THRESHOLD;
    windowTop -= LAZY_LOAD_THRESHOLD;

    var imageAttributes = imageAttributeCache.get($image);
    var top = imageAttributes.top;
    var height = imageAttributes.height;
    var bottom = top + height;

    // return true if any of the following are true:
    //   - top of image is visible in the window
    //   - bottom of image is visible in the window
    //   - height of image is greater than window size, and top/bottom of image are beyond the window's top/bottom
    return (top >= windowTop && top < windowBottom) ||
           (bottom > windowTop && bottom <= windowBottom) ||
           (height > windowHeight && top <= windowTop && bottom >= windowBottom);
  }

  // try to lazy load as early as possible
  populateCache();
  lazyLoad();

  // lazy load on scroll
  A.on("scroll", function() {
    lazyLoad();
  });

  A.on("scroll", A.debounce(function() {
    // if we've stopped scrolling, repopulate our image attribute cache
    populateCache();
    lazyLoad();
  }, 250));

  // lazy load on resize
  A.on("resize", lazyLoad);

  // supply a trigger mechanism for clients, in case of ajaxed in images (etc)
  A.on("a:image:lazyLoad", lazyLoad);

  // load on dom ready, in case images were parsed after initial JS execution
  A.on.ready(lazyLoad);

});
/////////////////////////
// END FILE a_image_lazy_loader.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_image_url_key_handler.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// no-op image url key handler for use in AUI_72554:C
// The url key is simply the url.

'use strict';

P.register('a-image-url-key-handler', function() {

  /**
   * Generate a key for url and crossOrigin value
   *
   * @param {string} url
   * @param {string} crossOrigin
   *
   * @return {string} generated composite key
  ;
  }

  /**
   * Parse composite key into respective parts for url and crossOrigin value
   *
   * @param {string} composite key
   *
   * @return {object} decomposed key parts
  ;
  }

  return {
    generate : generate,
    parse : parse
  };

});
/////////////////////////
// END FILE a_image_url_key_handler.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_image.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Hi-Res Image Replacement

'use strict';

P.when('a-base', 'a-util', 'a-events', 'a-defer', 'p-detect', 'a-image-url-key-handler').register('a-image', function (base, util, events, defer, detect, urlKeyHandler) { // jshint ignore:line
  var $ = base.$;
  var $window = $(window);

  //Images as live node list
  var images = document.getElementsByTagName('img');
  //Url -> list of image elements map
  var imageElements = {};

  //Download throttle; throttleInFlight is the current number of active image downloads, up to THROTTLE_LIMIT
  var throttleInFlight = 0;
  var THROTTLE_LIMIT = 2;

  //Loading queue
  var queue = (function () {
    var urlKeyQueue = [];
    var urlKeyQueueSet = {};

    function schedule(url, $image) {
      var urlKey = urlKeyHandler.generate(url, $image.attr('crossorigin'));

      if (!urlKeyQueueSet[urlKey]) {
        urlKeyQueue.push(urlKey);
        urlKeyQueueSet[urlKey] = true;
      }

      imageElements[urlKey] = imageElements[urlKey] || [];

      //Prevent the queue from filling with dups
      for (var i = 0; i < imageElements[urlKey].length; i++) {
        if ($image.is(imageElements[urlKey][i])) {
          return;
        }
      }

      imageElements[urlKey].push($image);
    }

    function fill() {
      for (var i = 0; i < THROTTLE_LIMIT - throttleInFlight; i++) {
        if (urlKeyQueue.length > 0) {
          var urlKey = urlKeyQueue.shift();
          urlKeyQueueSet[urlKey] = false;
          image.load(urlKey);
        }
      }
    }

    return {
      schedule: schedule,
      fill: fill
    };
  }());

  //Image functions
  // FIXME remove JSHint exception
  var image = (function () { // jshint ignore:line
    var alreadyLoaded = {};
    var IMAGE_REPLACEMENT_KEY = 'a-image-replaced';
    var IMAGE_REPLACEMENT_EVENT = 'a:image:load';

    //Do the replacement

    function replace(urlKey) {
      var elements = imageElements[urlKey];
      var url = urlKeyHandler.parse(urlKey).url;

      if (!elements) {
        return;
      }

      util.each(elements, function($element) {
        /*
          This ensures that if replacement for the same image is queued twice,
          (most notably due to explicit calls to A.loadDynamicImage) the replacement
          happens only once. It allows replacement again, only if the URL is different,
          due to resize or orientation change events that lead to a new URL being selected.
        */
        if($element.data(IMAGE_REPLACEMENT_KEY) !== url) {
          $element.data(IMAGE_REPLACEMENT_KEY, url);

          defer.defer(function () {
            $element.attr('src', url);
            events.trigger(IMAGE_REPLACEMENT_EVENT, {$imageElement: $element, url: url});
            var imageName = $element.data('a-image-name');
            if(imageName) {
              events.trigger(IMAGE_REPLACEMENT_EVENT+':'+imageName, {$imageElement: $element, url: url});
            }
          });

        }
      });

      //Remove elements from the imageElements queue
      imageElements[urlKey] = [];
    }

    //Loads the image at url

    function load(urlKey) {
      //The image is already loaded, go ahead and replace it
      if (alreadyLoaded[urlKey]) {
        replace(urlKey);
        return;
      }

      //The image failed to load before, let's not try again
      if (alreadyLoaded[urlKey] === false) {
        return;
      }

      var img = new Image();

      img.onload = function () {
        throttleInFlight--;
        replace(urlKey);
        alreadyLoaded[urlKey] = true;
        queue.fill();
      };

      img.onerror = function () {
        throttleInFlight--;
        alreadyLoaded[urlKey] = false;
        queue.fill();
      };

      throttleInFlight++;
      defer.defer(function () {
        var urlKeyParts = urlKeyHandler.parse(urlKey);
        var crossOrigin = urlKeyParts.crossOrigin;
        if (crossOrigin) {
          img.crossOrigin = crossOrigin;
        }
        img.src = urlKeyParts.url;
      });
    }

    //Polls images

    function poll() {
      //Early return if the page isn't visible
      if (util.isPageHidden()) {
        return;
      }

      util.each(images, function (image) {
        var $image = $(image);

        // Inexpensive early return checks
        if (!$image.data('a-hires') || $image.data('a-hires-loaded') || $image.data('a-manual-replacement')) {
          return;
        }

        // Expensive early return checks
        if ($image.is(':hidden') || !util.onScreen($image)) {
          return;
        }

        // Schedule the image for loading
        queue.schedule($image.data('a-hires'), $image);
        $image.data('a-hires-loaded', true);
      });
    }

    return {
      load: load,
      poll: poll
    };
  }());

  //Replace images with scaled 2x size on hi-dpi screens
  if (detect.capabilities.hires) {
    events.on.    });
  }

  //Load dynamically sized images

  function loadDynamicImage(image) {
    var $image = $(image);
    var sizes = $image.data('a-dynamic-image');

    if (!sizes || typeof sizes !== 'object') {
      return;
    }

    //Allow optional use of a parent element marked as the size container
    var $container = $image.data('a-dynamic-image-container');

    if (typeof $container === 'undefined') {
      $container = $image.closest('.a-dynamic-image-container');

      if ($container.length === 0) {
        $container = $image.parent();
      }

      $image.data('a-dynamic-image-container', $container);
    }

    var pixelRatio = detect.capabilities.hires && window.devicePixelRatio ? window.devicePixelRatio : 1;
    var width = $container.width() * pixelRatio;
    var height = $container.height() * pixelRatio;
    var closestSizeDiff = Number.MAX_VALUE;
    var closestLargerSizeDiff = Number.MAX_VALUE;
    var closestUrl = $image.attr('src') || '';
    var closestLargerUrl;
    var aspectRatio = width / height;

    //Check all the image sizes
    util.each(sizes, function (size, url) {
      var proposedHeight = parseInt(size[0], 10);
      var proposedWidth = parseInt(size[1], 10);
      var heightDiff = proposedHeight - height;
      var widthDiff = proposedWidth - width;

      var sizeDiff = aspectRatio >= 1 ? widthDiff : heightDiff;

      //Keep track of the closest image that is larger
      if (Math.abs(sizeDiff) < closestLargerSizeDiff && sizeDiff >= 0) {
        closestLargerSizeDiff = Math.abs(sizeDiff);
        closestLargerUrl = url;
      }

      //Keep track of the closest image
      if (Math.abs(sizeDiff) < closestSizeDiff) {
        closestSizeDiff = Math.abs(sizeDiff);
        closestUrl = url;
      }
    });

    //If there is an image that is larger than the current container, take it.
    //Otherwise, fall back to the closest sized image
    if (closestLargerUrl) {
      closestUrl = closestLargerUrl;
    }

    //Load the appropriate image
    queue.schedule(closestUrl, $image);
    queue.fill();

    return closestUrl;
  }

  function selectDynamicImages() {
    var $dynamicImages = $('img.a-dynamic-image');

    $dynamicImages.each(function () {
      var $t = $(this);
      if (!$t.data('a-manual-replacement')) {
        loadDynamicImage(this);
      }
    });
  }

  events.on.ready(selectDynamicImages);
  $(window).resize(selectDynamicImages);

  return {
    loadHiResImage: function (images) {
      var $images = $(images);
      var urls = [];

      $images.each(function () {
        var $image = $(this);
        var hiResUrl = $image.data('a-hires');

        if (hiResUrl) {
          queue.schedule(hiResUrl, $image);
          queue.fill();
          urls.push(hiResUrl);
        }

        $image.data('a-hires-loaded', true);
      });

      return urls;
    },
    loadDynamicImage: function (images) {
      var $images = $(images);
      var urls = [];

      $images    });

      return urls;
    },
    // Switch any images flagged as "manually loaded" into a visible state
    loadImageManually: function (images, ctx) {
      var urls = [];

      $(images, ctx).each(function () {
        var $t = $(this);
        if (!$t.data("a-image-already-loaded")) {
          $t.data("a-image-already-loaded", true);
          var dynamicUrl = loadDynamicImage($t);
          var $img = $("<img>").attr("src", dynamicUrl || $t.data("a-image-source"));

          urls.push(dynamicUrl);

          //Copy classes
          var classes = "" + this.className;
          var extraClasses = $t.data("a-extra-classes");
          if (extraClasses) {
            classes += " " + extraClasses;
          }
          $img.attr('class', classes);

          //Copy other attributes
          $img.attr("id", this.id);
          $img.attr("style", $t.attr("style"));
          $img.attr("alt", $t.attr("alt"));
          $img.attr("usemap", $t.attr("usemap"));
          $img.attr("title", $t.attr("title"));
          $img.attr("role", $t.attr("role"));

          //Copy cross origin attribute
          var crossOrigin = $t.data("a-image-crossorigin");
          if (crossOrigin) {
            $img.attr("crossorigin", crossOrigin);
          }

          // Preserve data attributes
          util.each(this.attributes, function (attr) {
            if (attr && attr.name && (attr.name.indexOf("data-") === 0 || attr.name.indexOf("aria-") === 0)) {
              $img.attr(attr.name, attr.value);
            }
          });

          // Copy over jQuery's internal data hash
          $img.data($t.data());

          // Add the image + remove the wrapper div
          $t.replaceWith($img);
        }

        return urls;
      });
    },
    loadDescendantImagesManually: function (imagesRoot, ctx) {
      var images = $(imagesRoot, ctx).find("div.a-manually-loaded").f    });

      return this.loadImageManually(images);
    }
  };
});
/////////////////////////
// END FILE a_image.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_class.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/*
 * Class object for simple inheritance.  Modified version of Simple JavaScript Inheritance by John Resig.
 *
 * Simple JavaScript Inheritance
 * By John Resig http://ejohn.org/
 * MIT Licensed.
 */
P.register('a-class', function() {
    "use strict";

    // ignore jshint error about undefined xyz
    /*global xyz:true */
    var fnTest = /xyz/    }) ? /\b_super\b/ : /.*/;

    // The base Class implementation (does nothing)
    function BaseClass() {
    }

    // Create a new Class that inherits from this class
    BaseClass.extend = function (props) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        var proto = (!!Object.create) ? Object.create(_supe    }(_super));

        // Copy the properties over onto the new prototype
        // ignore jshint error about for in loops
        /*jshint forin:false */
        for (var name in props) {
            // Check if we're overwriting an existing function
            proto[name] = typeof props[name] === "function" &&
                typeof _super[name] === "function" && fnTest.test(props[name]) ?

               }(name, props[name])) :
                    props[name];
        }

        // The constructor will be assigned as follows:
        // proto.init is a function and is a property of proto object itself, not its prototype -> proto.init
        // proto.init is a function and it's on proto's prototype -> new fuction that calls _super.init.apply
        // proto.init is not a function -> empty function
        var newClass = typeof proto.init === "function" ?
            proto.hasOwnProperty('init') ?
                proto.init :// All construction is actually done in the init method
          s); } :
      () {};

        // Populate our constructed prototype object
        newClass.prototype = proto;

        // Enforce the constructor to be what we expect
        proto.constructor = newClass;

        // And make this class extendable
        newClass.extend = BaseClass.extend;

        return newClass;
    };

    return {
        createClass: function(properties) {
            return BaseClass.extend(properties);
        }
    };
});
/////////////////////////
// END FILE a_class.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_ending.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Ending
 */

"use strict";

/**
 * Wait for all of the core libraries to register and collect them into the
 * standard A object that people will use when depending on "A".
 */
P.when("a-timing-analytics", "a-bodyBegin").execute('build-A', function (timingAnalytics) {

    // Make sure the 'decorate' function exists in case someone is running an old version of Page JS (sigh).
    var enableDecorator = P.execute().decorate;

    var registered = P.when(
        "a-util", "a-defer", "a-base", "a-events", "a-declarative",
        "a-state", "a-ajax", "a-animate", "a-image", "a-constants", "a-detect",
        "a-browser-events", "a-preload", "a-prefix", "a-request-animation-frame",
        "a-class", "a-draggable"
    ).register("A", function (util) {

        // Hold injected modules that have constructors to extend the instance of A instead of A's prototype
        var hasConstructor = [];

        function A(guard, logError) {
            this._guard = guard;
            this._logError = logError;

            util.each(hasConstru    }, this);
        }

        A.prototype = {};

        util.each(arguments, function (component) {
            // If we don't have decorator support, or the component doesn't have a constructor, simply extend A's
            // prototype. Otherwise add them to a collection to be handled in A's constructor
            if (!enableDecorator || component.constructor === Object) {
                delete component.constructor;
                util.extend(A.prototype, component);
            } else {
                hasConstructor.push(component);
            }
        });

        // WEBLAB: AUI_66484:T1
        timingAnalytics.stopWidgetLogging('A');

        // Default to the old behavior, which is to access the object of methods directly
        return enableDecorator ? A : A.prototype;
    });

    if (enableDecorator) {
        registered.dec    });
    }

});
/////////////////////////
// END FILE a_ending.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_constants.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Useful Constants
 */

"use strict";

P.register("a-constants", function () {
  return {
    constants: {
      keycodes: {
        "BACKSPACE": 8,
        "TAB": 9,
        "ENTER": 13,
        "ESCAPE": 27,
        "SPACE": 32,
        "LEFT_ARROW": 37,
        "UP_ARROW": 38,
        "RIGHT_ARROW": 39,
        "DOWN_ARROW": 40,
        "DELETE": 46
      },
      declarativeEvents: 'blur click dblclick focus focusin focusout mousedown mouseup mouseenter mouseleave mousemove change submit ' +
        'touchstart touchend touchmove touchcancel keydown keyup keypress MSPointerDown pointerdown MSPointerUp pointerup ' +
        'MSPointerMove pointermove MSPointerCancel pointercancel MSPointerOver pointerenter MSPointerOut pointerleave',
      HIDE_CLASS: 'aok-hidden',
      // when a new pagestate namespace is registered, P.declare related module to notify the namespace is ready.
      // the name used at P.declare is "page-state-loaded:" + namespace
      PAGESTATE_LOADED_MODULE_PREFIX: 'page-state-loaded:',
      NOOP: function () {}
    }
  };
});
/////////////////////////
// END FILE a_constants.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_browser_events.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Browser Event Bindings
 */

"use strict";

/**
 *  Creates A.events for standard window events (scroll, resize, orientationchange) which are throttled to prevent
 *  a bad UX.  Also exposes an A.viewport() method which returns window dimension properties which are automatically
 *  updated on those events.
 */
P.when("jQuery", "a-detect", "a-events", "a-util", "a-defer").register("a-browser-events", function ($, detect, events, util, defer) { // jshint ignore:line
  var $window = $(window);

  /**
   *  A hash of constants for event name strings.
   *
   *  @private
   *  @constant
   *  @type{object}
   */
  var EVENT_NAMES = {
    ORIENTATION_CHANGE: "orientationchange",
    SCROLL: "scroll",
    RESIZE: "resize",
    ZOOM: "zoom",
    ALL: "all"
  };


  // ***************************** VIEWPORT MEASUREMENT AND MEMOIZATION ***************************** //


  /**
   *  Convenience method for determining device orientation, event when not supported by the browser.
   *
   *  @private
   *  @return {number} orientation
   ;
  }

  /**
   *  Get the window's height in the most accurate/efficient manner available.
   *
   *  @private
   *  @return {number}
   */

  function getWindowHeight() {
    return window.innerHeight ? window.innerHeight : document.documentElement.clientHeight;
  }

  /**
   *  Get the window's width in the most accurate/efficient manner available.
   *
   *  @private
   *  @return {number}
   ;
  }

  /**
   *  Get the vertical scroll position of the window.
   *
   *  @private
   *  @return {number}
   */

  function getWindowScrollY() {
    return window.scrollY ? window.scrollY : $window.scrollTop();
  }

  /**
   *  Get the horizontal scroll position of the window.
   *
   *  @private
   *  @return {number}
   ;
  }

  /**
   *  Get the height of the page
   *
   *  @private
   *  @return {number}
   ;
  }

  /**
   *  Get the browser's zoom ratio. return 1 if browser not supported, eg IE < 9
   *
   *  @private
   *  @return {number}
   ;
  }

  /**
   *  This is a hash of commonly needed window properties.  It's set on each fired resize, scroll,
   *  and orientationchange event and has a public getter.
   *
   *  @private
   *  @type {object}
   */
  var viewport = {
    scrollLeft: 0,
    scrollTop: 0,
    height: getWindowHeight(),
    width: getWindowWidth(),
    orientation: getOrientation(),
    zoom: getZoomRatio()
  };

  /**
   *  Public getter for the window properties hash.
   *
   *  @public
   *  @param {boolean} forceRefresh  get new viewport data
   *
   *  @return {object} viewport
   */

  function getViewport(forceRefresh) {
    if (forceRefresh) {
      measure(EVENT_NAMES.ALL);
    }
    return util.copy(viewport);
  }

  /**
   *  Sets the properties enumerated in the "properties" parameter off of the window object and caches them onto
   *  a local object and return a hash of the changes.  This will allow for fewer DOM reads on window events.
   *
   *  @private
   *  @param {array} properties  An array of property names to read
   *
   *  @return {object} changed  A hash where the key is the property which changed and the value is the old value of the property
   */

  function getViewportProperties(properties) {
    var changed = {};
    var tmp, property;

    while ((property = properties.pop()) !== undefined) {
      tmp = viewport[property];
      if (property === "orientation") {
        viewport[property] = getOrientation();
      } else if (property === "height") {
        viewport[property] = getWindowHeight();
      } else if (property === "width") {
        viewport[property] = getWindowWidth();
      } else if (property === "scrollTop") {
        viewport[property] = getWindowScrollY();
      } else if (property === "scrollLeft") {
        viewport[property] = getWindowScrollX();
      } else if (property === "zoom") {
        viewport[property] = getZoomRatio();
      }

      if (viewport[property] !== tmp) {
        changed[property] = tmp;
      }
    }

    return changed;
  }

  /**
   *  Caches the viewport properties appropriate for the given event type and returns a hash
   *  of any changes.
   *
   *  @private
   *  @param {string} eventType
   *
   *  @return {object}
   */

  function measure(eventType) {
    var props;

    // Only update the window properties that might have changed
    switch (eventType) {
    case EVENT_NAMES.ALL:
      props = ["orientation", "height", "width", "zoom", "scrollLeft", "scrollTop"];
      break;
    case EVENT_NAMES.SCROLL:
      props = ["scrollLeft", "scrollTop"];
      break;
    case EVENT_NAMES.ZOOM:
      props = ["height", "width", "zoom", "scrollLeft", "scrollTop"];
      break;
    default:
      props = ["orientation", "height", "width", "scrollLeft", "scrollTop"];
    }
    
    return getViewportProperties(props);
  }


  /**
   *  Ensure the window properties hash is up to date after the DOM has loaded.
   */
  events.on("beforeRe;
  });


  // ***************************** DETERMINE SCROLLBAR WIDTH ************************* //

  /**
   * Gets the page scroll page width by checking the difference between the width
   * when there is/isnt scrollbar
   *
   * @public
   * @param {boolean} force  Whether to force calculation despite no scrollbar on the page
   *
   * @return {number}  Width of the scrollbar
   */

  function getScrollBarWidth(force) {
    //only return a width when the page requires scrolling unless forced
    if (force || getScrollHeight() > getWindowHeight()) {
      // Create a component with oveflow scroll. The component will implicitly take on
      // the size of the browser's scrollbars, allowing us to measure them.
      var scrollDiv = document.createElement("div");
      scrollDiv.style.visibility = "hidden";
      scrollDiv.style.width = "100%";
      scrollDiv.style.overflowX = "scroll";

      document.body.appendChild(scrollDiv);
      var scrollBarWidth = scrollDiv.offsetHeight;
      document.body.removeChild(scrollDiv);
      return scrollBarWidth;
    } else {
      return 0;
    }
  }
  

  // ***************************** MOUSE CURSOR TRACKING ***************************** //


  var MOUSE_THROTTLE_DELAY = 50;
  var MOUSE_RUN_MEAN = 4; // 50 * 4 = 200ms
  var MAX_POLL_COUNT = 30; // 100ms * 30 = 3 seconds

  /**
   *  A hash of commonly cursor related attributes
   *
   *  @private
   *  @type {object}
   */
  var cursor = {
    speed: 0,
    degree: 0, // E:0, NE:45, NW:135, W=180, SE:-45, SW:-135
    direction: "",
    positionX: 0,
    positionY: 0
  };

  /**
   *  Public getter for the cursor hash
   *
   *  @public
   *  @return {object} viewport
   */

  function getCursor() {
    return util.copy(cursor);
  }

  /**
   *  A stack containing historical cursor speed and movement degree
   *
   *  @private
   *  @type {array}
   */
  var cursor_hist = [];

  /**
   *  The most recent cursor position.
   *
   *  @private
   *  @type {object}
   */
  var prev_cursor_pos;

  /**
   *  Updates attributes of the cursor hash, include velocity and direction
   *
   *  @private
   */

  function getCursorAttributes(event) {
    var curr = {
      x: event.clientX,
      y: event.clientY
    };

    if (!prev_cursor_pos) {
      if (curr) {
        prev_cursor_pos = curr;
      }
      return;
    }

    var prev = prev_cursor_pos,
      dist = Math.sqrt(Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)),
      speed = dist / MOUSE_THROTTLE_DELAY * 10,
      degree = Math.atan2(curr.y - prev.y, curr.x - prev.x) / (Math.PI / 180),
      meanSpeed = 0,
      meanDeg = 0,
      direction;

    // Get speed/degree from running means
    cursor_hist.push({
      speed: speed,
      degree: degree
    });
    if (cursor_hist.length > MOUSE_RUN_MEAN) {
      cursor_hist = cursor_hist.slice(-1 * MOUSE_RUN_MEAN);
    }

    var l = cursor_hist.length;
    for (var i = 0; i < l; i++) {
      meanSpeed += cursor_hist[i].speed;
      meanDeg += cursor_hist[i].degree;
    }
    meanSpeed = Number((meanSpeed / l).toFixed(2));
    meanDeg = Math.round(meanDeg / l);

    // Found direction from degree
    if (meanDeg >= 0) {
      if (meanDeg > 157.5) {
        direction = "W";
      } else if (meanDeg > 112.5) {
        direction = "SW";
      } else if (meanDeg > 67.5) {
        direction = "S";
      } else if (meanDeg > 22.5) {
        direction = "SE";
      } else {
        direction = "E";
      }
    } else {
      if (meanDeg < -157.5) {
        direction = "W";
      } else if (meanDeg < -112.5) {
        direction = "NW";
      } else if (meanDeg < -67.5) {
        direction = "N";
      } else if (meanDeg < -22.5) {
        direction = "NE";
      } else {
        direction = "E";
      }
    }

    cursor = {
      speed: meanSpeed,
      degree: meanDeg,
      direction: direction,
      positionX: curr.x,
      positionY: curr.y
    };

    // Put current position as prev after calculation
    prev_cursor_pos = curr;
  }

  $window.bind("mousemove", util.throttle(getCursorAttributes, MOUSE_THROTTLE_DELAY));


  // **************************** NON-MOUSE-SPECIFIC EVENT VARS ***************************** //


  /**
   *  Events which occur in rapid succession are throttled. This is the interval in milliseconds.
   *
   *  @private
   *  @type {number}
   */
  var EVENT_THROTTLE_DELAY = 100;
  

  // ***************************** SCROLL DEBOUNCING ***************************** //


  // Do a simple throttle on the scroll event
  $window.bind(EVENT_NAMES.SCROLL, util.thr;
  }, EVENT_THROTTLE_DELAY));


  // ***************************** BASIC POLLING FUNCTIONALITY ***************************** //


  var eventData = {};
  util.each([EVENT_NAMES.RESIZE, EVENT_NAMES.Z;
  });

  /**
   *  Resets the countdown of handler calls. If an interval is running, this is called when a
   *  new event comes in and we want to continue polling for a period of time for changes. If
   *  no interval is running, it starts one with settings based on the event type.
   *
   *  This polling is used in lieu of util.throttle() as we are already scheduling a timer and
   *  only acting on the events in defined intervals for a defined period of time and because
   *  simply using throttle can result in missed events.
   *
   *  @private
   *  @param {string} eventName
   */
  function resetPolling(eventName) {
    var event = eventData[eventName];
    if (event) {
      event.pollCounter = event.maxPollCount;
      if (!event.intervalId) {
        event.intervalId = setInterval(event.handler, event.pollInterval);
      }
    }
  }

  /**
   *  Stops an interval that is checking event-related changes to the page if one exists
   *
   *  @private
   *  @param {string} eventName
   */
  function stopPolling(eventName) {
    var event = eventData[eventName];
    if (event && event.intervalId) {
      clearInterval(event.intervalId);
      event.intervalId = 0;
    }
  }


  // ***************************** RESIZE EVENT NORMALIZATION ***************************** //


  /**
   *  Called based on defined polling intervals to determine when changes to the viewport
   *  have occurred. Checks for differences between polls, and based on the differences
   *  detected, triggers the appropriate events
   *
   *  @private
   */
  function normalizeResizeEvent() {
    var publishedEvents = [];
    var resizeEvent = eventData.resize;
    measure("resize");
    var changed = util.diff(viewport, resizeEvent.lastViewport);
    
    if (changed.orientation) {
      publishedEvents.push(EVENT_NAMES.ORIENTATION_CHANGE);
    }
    if (changed.width || changed.height) {
      publishedEvents.push(EVENT_NAMES.RESIZE);
    } else if (detect.capabilities.isIETouchCapable && changed.scrollTop) {
      // When IE Mobile and IE w/ On Screen Keyboard (in Modern UI/Metro) spawn a keyboard
      // They trigger a resize event which is helpful to us, however they then animate and
      // manipulate the scroll position of the page some 300-700ms later (Phone seems to once,
      // but tablet seems to up to 3 times over that time span). As scroll position is integral
      // to the positioning of elements on screen, we dispatch one or more extra resize events
      // so that other code can get all relevant updates to the viewport for positioning.
      publishedEvents.push(EVENT_NAMES.RESIZE);
    }

    if (publishedEvents.length) {
      resizeEvent.lastViewport = util.copy(viewport);
      util.each(publishedEv    });
    }
    
    if (--resizeEvent.pollCounter === 0) {
      stopPolling(EVENT_NAMES.RESIZE);
    }
  }

  eventData.resize.handler = normalizeResizeEvent;
  eventData.resize.pollInterval = EVENT_THROTTLE_DELAY;
  eventData.resize.maxPollCount = 10;

  $window.bind(EVENT_NAMES.RE;
  });


  // ***************************** ZOOM DETECTION ***************************** //

  /**
   *  Check if the zoom level has change, and fire events accordingly
   *
   *  @private
   */
  function detectZoom() {
    measure(EVENT_NAMES.ZOOM);
    var zoomEvent = eventData.zoom;
    var changed = util.diff(viewport, zoomEvent.lastViewport);

    if (changed.zoom) {
      zoomEvent.lastViewport = util.copy(viewport);
      events.trigger(EVENT_NAMES.ZOOM, viewport, changed);
    }

    if (--zoomEvent.pollCounter === 0) {
      stopPolling(EVENT_NAMES.ZOOM);
    }
  }

  eventData.zoom.handler = detectZoom;
  eventData.zoom.pollInterval = 200;

  // Android: Using two fingers to trigger a touchcancel event, very likely a pinch-zoom
  if (detect.capabilities.android) {
    $window.bind("touchcancel", function (event) {
      if (event.originalEvent.changedTouches.length === 2) {
        var zoomEvent = eventData.zoom;
        eventData.zoom.maxPollCount = 15;
        resetPolling(EVENT_NAMES.ZOOM);
      }
    });
  }

  // iOS: Leaving a finger but still keeping a finger, likely a 2+ finger operation like zoom
  if (detect.capabilities.ios) {
    $window.bind("touchend", function (event) {
      if (event.originalEvent.touches.length === 1) {
        eventData.zoom.maxPollCount = 1;
        resetPolling(EVENT_NAMES.ZOOM);
      }
    });
  }

  // Desktop & Win tablets: Zooming fires resize event
  // TODO: only "zoom in" fires resize in Nokia win8 phone, "zoom out" misses 99% of the time
  if (!detect.capabilities.ios && !detect.capabilities.android) {
    $window.bind("res    });
  }

  return {
    viewport: getViewport,
    cursor: getCursor,
    scrollBarWidth: getScrollBarWidth
  };
});
/////////////////////////
// END FILE a_browser_events.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_analytics.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * AUI Analytics Module. Simple methods for gathering data about usage
 * of AUI components, behaviors, and features.
 *
 * Private - for AUI use only. Not exposed as part of "A" module.
 */
P.register('a-analytics', function() {

    /**
     * Increment a specific counter by 1, and initialize
     * the counter to 1 if it doesn't exist.
     *
     * This method is for a simple incrementer and to accommodate
     * the most common use cases for analytics internal to our JS.
     *
     * Use a counter name unique to the use case you're measuring.
     * We don't do anything fancy to guard against collisions,
     * and this makes the assumption the counter only uses a numeric
     * integer value.
     *
     * @see http://w?ClientSideMetrics/UserDocs/Instrumentation/ClientSideCounters
     * @param {String} name The event to increment
     * @param {Integer} amount The amount to increment by; defaults to 1
     *    }

    /**
     * Sets and reports a specific UE counter value.
     * @see http://w?ClientSideMetrics/UserDocs/Instrumentation/ClientSideCounters
     * @param {String} name The identifier for the counter
     * @param {Integer ?} value (optional)
     */
    function count(name, value) {
        var ueCount = window && window.ue && window.ue.count;
        if (ueCount && name) {
            var key = 'aui:' + name;
            if (arguments.length > 1) {
                ueCount(key, value);
            }
            return ueCount(key);
        }
    }

    /**
     * Method to log custom errors using CSM's ueLogError() if it is present on the page.
     * Does NOT do anything if ueLogError is NOT present on the page.
     *
     * @see https://w.amazon.com/index.php/ClientSideMetrics/UserDocs/JavascriptErrors
     * @param {String} message The error message to log.
     * @param {String} logLevel Whether it should be ERROR, WARNING or FATAL. We do NOT provide a default if value NOT provided.
     *                          We fallback to the default used by ueLogLevel which is "ERROR"
     * @param {String} attribution The attribution to attach the error-message to.
     */
    function logError(message, logLevel, attribution){
        if (!window.ueLogError) { return; }
        window.ueLogError(
            {message: message},
            {
                logLevel: logLevel,
                attribution: attribution
            }
        );
    }

    // -------------------------------------------------------------------------

    return {
        increment: increment,
        count: count,
        logError: logError
    };
});
/////////////////////////
// END FILE a_analytics.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_preload.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Asset Preloading

'use strict';

P.when('3p-promise', 'a-analytics').register('a-preload', function(Promise, analytics) {
    // Author: Eric Schurman (ericsc@)
    // Integration into amznJQ: JC Fant (jcfant@)
    //
    // This supports two major use cases. Both preload assets (JS, CSS, images) that we think may be needed in the future
    // on later pages. They are intended to have minimal impact on the hosting page.
    //
    // The first use case is low priority preloading for items that we don't have immediate knowledge are likely to be
    // needed. For example, from the gateway, we can preload files for the detail page. This is accomplished through addPL().
    //
    // The second is preloading files that we have immediate indication are likely to be needed. For example, the
    // user has moused over an area that will likely trigger a page navigation. These are higher priority and need
    // to be fetched immediately, rather than after a delay. This is accomplished through PLNow().
    //
    //==USAGE==
    // addPL is designed to be coupled with the bootstrap. You should load urls via the addPL bootstrap
    // method. However, if you are unable to use the bootstrap you can call this at any time on the client using the
    // amznJQ.addPL(urlList) method. The preloading of addPL assets will not start until one second after page load.
    //
    // PLNow begins executing as soon as it's called. It will begin preloading before onload has fired, and will interrupt
    // any ongoing preloading happening as a result of addPL. Any assets added through PLNow take precedence over those added
    // through addPL.
    //
    // Files are specified to be preloaded in a few ways:
    //   * Bootstrap: the bootstrap will output any addPL files you have added via mason components. Once the
    //     onload event has been fired the preloader will wait 1 second and start caching files.
    //   * At any time you can call amznJQ.addPL() with a list of urls to be preloaded. If the page load event has
    //     already been fired, the preloader will immediately start caching files.
    //   * At any time you can call PLNow and it will immediately begin to execute.
    //
    //=DETAILED DEVELOPMENT NOTES=
    // Many preloading implementations described on the internet can cause a variety of CX problems.
    // I'm including a detailed discussion in this file to make it easier to avoid problems if there's
    // future work on this file.
    //
    //==DEFINING SUCCESS==
    // To be successful, given a file name, a browser must:
    // * Download the file.
    // * Cache the file (meaning that if asked to download the file again, it doesn't go to the network).
    // * Actually use the file from cache when the file is referenced in the standard way, for example,
    //   when using a LINK element to request a css file. See Safari section below for a breaking example.
    // * Have minimal impact on the hosting page (on CPU, memory, responsiveness, and UX).
    //
    //==TECHNIQUES TO AVOID==
    // REAL LOAD IN IFRAME
    // The first implementation at Amazon simply created an IFRAME in which SCRIPT, LINK,
    // and IMG tags were added to download the appropriate file types. The problem with this
    // is that those scripts and CSS files were actually compiled and executed, leading to
    // a significant network, CPU, and memory impact on the hosting page, right at onload,
    // every time that page loaded.
    //
    // SIMULTANEOUS NON-EXECUTING DOWNLOADS
    // In the technique described here: http://www.phpied.com/preload-cssjavascript-without-execution/
    // IMG or OBJECT tags are added to the DOM, one per file needed. Although this has the advantage
    // that script and CSS are not compiled or executed, this approach means all the prefetched items
    // are requested simultaneously, which has a major negative impact on the customer's network.
    // We saw this have a negative impact on when the uedata gif request was made, when onload completed,
    // and on CPU. It also meant that some useragents with connections in use couldn't request ajax
    // content during the prefetching. Additionally, the OBJECT approach for plaintext files has some
    // major impacts on performance in webkit, described later.
    //
    // LINK REL="PREFETCH"
    // FF advertises an approach using <link rel=prefetch> (https://developer.mozilla.org/en/link_prefetching_faq)
    // However, it doesn't seem to work if you add them dynamically (at least in the version available when this
    // preloader was written, and still appeared to be in 2013). It also seems very unpredictable in all cases.
    // Chrome now supports this approach too - but at least in 2011 in a very buggy way. It pegs the CPU and the
    // app becomes unresponsive while prefetching is happening.
    //
    // GENERAL ISSUES TO WATCH FOR DURING DEVELOPMENT
    //
    // All Browsers
    //      * The net tab in most browsers doesn't give a true indication of what's happening on the network. You
    //        should use a tool like WireShark or Netmon + VRTA for insight into the actual network.
    //
    // Chrome
    //      * While a file is being downloaded before page load, the cursor flashes and turns to a spinner
    //
    // FF
    //      * Many techniques peg the CPU.
    //      * While a file is being downloaded, the UX may change:
    //          * The loading indicator in the tab may spin (in later versions-tested in 21), img downloads don't, others do)
    //          * The status bar may show the file name
    //          * The cursor may flash
    //      * Firebug can alter the behavior - make the spinner more apparent, and make the title bar say "connecting"
    //
    // Safari
    //      * Shows a loading bar when loading items in page, but not in an iframe.
    //      * Doesn't show loading bar for assets post page load.
    //      * May download but not actually cache assets with some approaches- for example, in image tags.
    //      * May download and cache an asset, but then not use it and not download a replacement!
    //        This specifically happened with a CSS attribute being loaded into a SCRIPT element - then
    //        not being used. See TT https://tt.amazon.com/0012003920
    //
    // IE
    //      * IE has weird behavior with recursion triggered in event handlers that can cause stack overflows.
    //        (see http://cappuccino.org/discuss/2010/03/01/internet-explorer-global-variables-and-stack-overflows/)
    //      * The network tab in IE's developer tools are extremely misleading. For example, when retrieving an
    //        asset that's available in cache it will report a 304 for the asset, which dev's may interpret to
    //        mean that a network request was sent. To get a true idea of the network behavior, you must use a
    //        real network sniffer, like WireShark or Netmon + VRTA.
    //      * Make sure to test different document modes - for example, IE 9 running in compatibity view.
    //        See here for detailed info:
    //        http://blogs.msdn.com/b/ie/archive/2010/10/19/testing-sites-with-browser-mode-vs-doc-mode.aspx
    //
    //==TECHNIQUES USED HERE==
    //
    // To avoid overloading the network, we fetch the assets sequentially. To do this, we need to be able
    // to tell when a particular asset is downloaded. This requires the use of elements that fire onload, onerror,
    // or onreadystatechange. Note that onerror may fire when an asset has actually successfully downloaded, depending
    // on the asset type and the element used.
    //
    // Firefox
    // Use OBJECT tags. FF doesn't support onerror when an asset fails, so we need to use a timeout.
    //
    // Safari
    // May download but not actually cache the files using either the IMG or OBJECT elements (IMG does seem to work
    // for CSS and JavaScript in newer Safari, and it always worked for images). The SCRIPT element technique does not
    // work in Safari (no transfer occurs), the OBJECT approach doesn't work with display=none and it's too expensive
    // in webkit to do without display=none, and the LINK approach doesn't work either.
    //
    // Chrome/Opera15+/Other webkit
    // We use IMG to download and use onload and onerror to tell when the asset is available or has failed. In some
    // minor cases need to use a timeout.
    //
    // Internet Explorer
    // Complex - see LOADER SELECTION LOGIC comment in the code below for detailed discussion.
    // The short version is that for images, we use IMG files, but that doesn't work for non-image types in IE 9 and IE 10.
    // So we use a SCRIPT with an invalid TYPE in IE 9 (doesn't work in IE 10 or IE 8 or less), and in IE 10 we use a
    // LINK with speech stylesheet (cannot use in versions earlier than 10).
    //
    // Opera
    // Desktop Opera through version 12 used the Presto rendering engine and was excluded. In version 15 it moved to
    // Google's Blink rendering engine (with roots in webkit) and is now supported in the same way as Chrome.
    //
    // ===Known Issues===
    // When testing, if you see that If-Modified-Since requests are being made for later requests for cached images
    // and a 204 response results, especially in FireFox, then you may not be testing properly. You can see this
    // behavior if you are doing a simple refresh on the page doing the precaching, rather than requesting the page
    // via a new URL. According to http://www-archive.mozilla.org/projects/netlib/http/http-caching-faq.html,
    // "Revalidation is triggered when the user presses the reload button."
    //
    // Browsers and browser modes that require testing include:
    // =Tier 1:
    // FireFox (latest)
    // Chrome ( Note, until v28 (first on Blink engine) acheives full penetration, must also test on version 27 (last on webkit) )
    // IE6
    // IE7
    // IE8 in Standards Mode       {  If any change is made to the browser detection }
    // IE8 in IE 7 Standards Mode  {  code, then it is important to test all of the  }
    // IE8 in Quirks Mode          {  different document modes in IE8+.              }
    // IE9 in Standards Mode       {  This is because the browser can be             }
    // IE9 in IE 7 Standards Mode  {  misidentified as an earlier version (because   }
    // IE9 in IE 8 Standards Mode  {  different document modes can trigger different }
    // IE9 in Quirks Mode          {  identification behavior). So far the caching   }
    // IE10 in Standards Mode      {  behavior itself seems consistent for a IE      }
    // IE10 in IE 7 Standards Mode {  version regardless of what document mode it is }
    // IE10 in IE 8 Standards Mode {  in.                                            }
    // IE10 in IE 9 Standards Mode {  You can change document modes in the IE F12    }
    // IE10 in Quirks Mode         {  developer tools.                               }
    // Safari on Mac
    // Safari on iPhone or iPad
    // Silk
    // Android Browser
    // Opera 15+
    // =Tier 2
    // Opera 14 and lower (should not preload)
    // Windows Phone
    // Chrome on Android
    // Firefox 3.6

    var ST          = setTimeout,
        doc         = document,
        docElem     = doc.documentElement,
        styleObj    = docElem.style,
        nav         = navigator,
        ua          = nav.userAgent,
        plUrls      = [], // List of urls being processed. Will eventually point to either hiPriUrls or lowPriUrls.
        lowPriUrls  = [], // List of urls set using the bootstrap or via a js call to amznJQ.addPL()
        hiPriUrls   = [], // List of urls set using amznJQ.PLNow()
        isLowPriEligibleYet = false, // True if the low pri loader is allowed to run (delayed after onload completes).
        isGecko     = 'MozAppearance' in styleObj,
        isWebkit    = !isGecko && ('webkitAppearance' in styleObj), // Note: This still works in Google's new Blink engine
        isSafari    = isWebkit && /^Apple/.test(nav.vendor), // Defaults to false if navigator.vendor is undefined (tt/0092555960)
        // isIE - IE detection has been getting harder and harder. As of IE11, navigator.appName changed from the historical
        // "Microsoft Internet Explorer" to "Netscape". IE9 and up use " Trident/" in the UA. This may not detect Microsoft
        // uses of Trident as separate from rebranded trident engines, but we've never yet seen a disastrous failure in any
        // trident based browsers, so will serve the preloader to all of them.
        isIE        = !isGecko && !isWebkit && ( (nav.appName.indexOf("Microsoft") === 0 || ua.indexOf("Trident\/") > -1) ),
        isSupportedBrowser = (isWebkit || isGecko || isIE),

        // ieVer - This reports the minimum version of IE in use. Should be -1 if not IE.
        // Should accurately report IE 8, 9, and 10, but may report future versions of IE as a lower version, and
        // may report IE 7 as IE 6. We currently have the same behavior for IE7 and below, so this is fine.
        // Getting version is tricky to get right, because IE may be in any number of compatibility views - for example,
        // IE 10 may show up as IE 9, 8, 7, or 5, depending on the scenario. But it doesn't behave in terms of caching
        // like those browsers. So we need to detect the real product version.
        // Trident version was added to the useragent string in IE 8 and appears regardless of document mode.
        // It should be set to 4 in IE 8, and incremented with each release. See:
        // IE 8  - http://blogs.msdn.com/b/ie/archive/2009/01/09/the-internet-explorer-8-user-agent-string-updated-edition.aspx
        // IE 9  - http://blogs.msdn.com/b/ie/archive/2010/03/23/introducing-ie9-s-user-agent-string.aspx
        // IE 10 - http://msdn.microsoft.com/en-us/library/ie/hh869301(v=vs.85).aspx
        tridentVer = !isIE ? -1 : (/Trident\/([\d]+)/).exec(ua) !== null ? parseFloat( RegExp.$1 ) : null,
        ieVer      = !isIE ? -1 : !tridentVer ? 6 : tridentVer + 4, // IE version is tridentVer + 4

        // We can issue multiple fetch commands in a row to make more use of the network at an increased cost to CPU
        // and increased chance of saturated network. IE7 and below are most subject to saturation, so protect them with
        // fewer loaders. Note that although Android 2.2 and below have a 4 connection limit per device, it also supports
        // pipelining, so we can use the higher number of concurrent loaders. More loaders on mobile also reduces battery
        // usage by allowing the radio to shut down faster.
        // Setting allowedLoaders to 0 disables preloading entirely.
        // First check window.plCount, which allows these values to be overridden globally for weblab or other purposes.
        allowedLoaders = typeof window.plCount !== "undefined" ? window.plCount() : (isIE && ieVer < 8 ) ? 2 : 5,
        currentLoaders = 0,
        // preloadApiUsed exists to protect against declaring 'a-preload-api-used' more than once.
        preloadApiUsed = false,
        type_Link      = "LINK",
        type_Img       = "IMG",
        type_Obj       = "OBJECT",
        type_Script    = "SCRIPT",
        type_Iframe    = "IFRAME",
        handledImageExtensions = ["gif","jpeg","jpg","png"]; // List of extensions we treat as known images. Note that MSA
                                                             // currently serves webP images with the .jpg extension.

    // Sets whether to use a high pri or low pri asset at this time
    // Returns: true if an asset should be fetched, false otherwise.
    function setLoadState() {
        // If there are high pri ones left, use them.
        // Otherwise use low pri.
        if (hiPriUrls.length > 0) {
            plUrls = hiPriUrls;
        }
        else {
            plUrls = lowPriUrls;
            if (plUrls.length === 0 || !isLowPriEligibleYet) {
                return false;
            }
        }

        if (currentLoaders >= allowedLoaders) {
            return false;
        }

        currentLoaders++;

        return true;
    }

    // In order to reduce network load we don't want to load all files at once, so use
    // load and error handlers and timeouts to do sequential work.
    function loaderDone(loader, timer) {
        var destroyLoader = function(){
            if (loader) {
                var p = loader.parentElement;
                if (p) { p.removeChild(loader); }
                loader = null;
            }
        };

        if (timer) { clearTimeout(timer); }

        // Decrement currentLoaders, to a minimum of 0.
        // There are some edge cases where both onerror and onload can fire for the same object, and we
        // wouldn't want to decrement beyond zero.
        // Also, note that it's possible for this function to be called before load() has completed, in
        // the case of the asset already being cached. This is most easily seen in older IE in quirks mode
        // where the event can fire as soon as src is set.
        currentLoaders = currentLoaders < 1 ? 0 : currentLoaders - 1;

        // Clean up the old loader object. This reduces memory consumption, important when lots of preloading is done.
        // Gecko won't (ever) stop the spinner if you destroy the object during the page onload event.
        // So put in a timeout. There's no spinner with the iframe/prefetch link approach, so even Gecko could destroy
        // synchronously with it.
        if (isGecko) { ST(destroyLoader, 5); }
        else { destroyLoader(); }

        // In IE, we can't just call load() because IE will stack overflow with a stack only 13 levels deep if it
        // involves recursion and the window object. Definitely a problem through IE8, possibly fixed later.
        // (see http://cappuccino.org/discuss/2010/03/01/internet-explorer-global-variables-and-stack-overflows/)
        // This also triggers with event handlers on DOM elements - the onload of one img triggers the next one to load,
        // and if it's cached, it can trigger the next, etc. - resulting in a potentially deep stack.
        // setTimeout lets us avoid the deep stack.
        if (isIE){ ST(load, 0); }
        else { load(); }
    }

    // Returns the extension of the URL.
    // Technically, we should not rely on file extension to determine the type of content, since mime type is what's
    // supposed to govern that. However, in our usage scenarios, it's good enough.
    function getExtension(url){
        // Returns the "extension" of the current file or undefined.
        // Handles trailing querystring, fragment, or .gz.
        // Our patterns look like foo.extension[.gz][?bar][#baz]
        var extension,
            posDot,
            hash = url.indexOf("#"),
            end = url.indexOf("?");

        end = end > 0 ? end : (hash > 0 ? hash : url.length);
        posDot = url.lastIndexOf(".", end);

        if (posDot) {
            extension = url.substring(posDot + 1, end).toLowerCase();
        }

        return (extension === "gz") ? getExtension(url.substring(0, posDot)) : extension;
    }

    function checkIfImage(extension){
        var i = handledImageExtensions.length;
        while (i--){
            if (handledImageExtensions[i] === extension) { return true; }
        }
        return false;
    }

    function determineType(isImageUrl, extension, isHiPri){
        // Browser     Extension   LoaderType
        // =====================================
        // Gecko       all         OBJECT
        // IE10        js/css      LINK
        // IE9         js/css      SCRIPT
        // All other combinations  IMG
        // Experimental            IFRAME, where content is <link rel="prefetch"> tags; see comments below for browser limits.

        // REGARDING THE IFRAME TYPE:
        // type_Iframe is currently disabled, but support remains because it may give us a way forward for prefetching in
        // Firefox (gecko) due to recently added (late 2015) support for crossorigin anonymous on prefetch links:
        //   https://bugzilla.mozilla.org/show_bug.cgi?id=1172205
        //   https://bugzilla.mozilla.org/show_bug.cgi?id=1213443
        //   https://bugzilla.mozilla.org/show_bug.cgi?id=1214819
        // High-priority preloads seem incompatible with the iframe/prefetch link approach, since we lose control over how
        // quickly the actual request for the asset will be issued.
        // The current approach is limited to Firefox and non-Safari webkit, because IE ignores prefetch links in an iframe,
        // and Safari ignores prefetch links altogether (as of July 2015). Note that this approach is entirely experimental,
        // and we will need to watch it very closely in production to understand the full impact.
        //   https://msdn.microsoft.com/en-us/library/dn265039%28v=vs.85%29.aspx
        //   http://www.stevesouders.com/blog/2013/11/07/prebrowsing/

        var useType;

        if (isGecko) {
            // For now, Firefox (gecko) should not preload JS since our crossorigin anonymous headers prevent the preloads
            // from ever being usable. Leaving useType undefined causes this preload to be skipped.
            if (extension !== "js") {
                useType = type_Obj;
            }
        }
        else if (isIE) {
            // LOADER SELECTION LOGIC
            // IE has gone through major changes as they've improved their browser. The options are:
            // OBJECT - is expensive compared to other options and doesn't work in IE6.
            // IMG - works generally well in our scenarios through IE8. But in IE9, CSS and SCRIPTs fetched with IMG
            //       are more likely to not make it into cache. In IE10 this gets much worse. More detail here:
            //       http://blogs.msdn.com/b/ieinternals/archive/2012/05/05/problems-with-using-img-to-prefetch-script-or-css.aspx
            //          "When IE encounters an IMG tag, it creates an image object and assigns the download request to it. As
            //          data arrives from the image download, it's fed into the browser's image decoders. The decoders will reject
            //          data as malformed if you feed them plaintext, which seems reasonable, since they can't possibly make use of
            //          such data. When the decoders reject the data as 'Not possibly an image,' the image object will abort its
            //          processing. As a part of that abort, if the download has not yet completed, it too is aborted."
            //       In most of our cases prior to IE9, the image decoders don't kick in in time to abort the downloads,
            //       and the items are cached.
            // SCRIPT with invalid TYPE. Works great in IE9. But IE10 doesn't fire onerror appropriately for non-js files.
            //       And IE 8 and earlier also don't fire onload properly. So only use in IE9.
            // LINK with speech stylesheet. In IE 10, works well. Can't use in earlier versions because of the prior
            //       31 stylesheet limit in IE 9 and earlier:
            //       http://blogs.msdn.com/b/ieinternals/archive/2011/05/14/internet-explorer-stylesheet-rule-selector-import-sheet-limit-maximum.aspx
            //       Note that if IE 11+ support speech stylesheets we may need a new solution. They may at that time
            //       support rel=prefetch

            // Determine type of loader to use. By default use IMG. But override in specific cases.
            useType = type_Img;
            if (!isImageUrl)
            {
                if (ieVer >= 10) { useType=type_Link; }
                else if (ieVer === 9){ useType = type_Script; }
            }
        }
        else { // Chrome, Safari, other webkit, etc.
            useType = type_Img;

            // Safari notes:
            // As of 2015, IMG preloads seem to work well in Safari, and we are using them for all supported asset
            // types. In old versions of Safari, text assets fetched as images would sometimes be discarded. Maybe
            // that still happens occasionally, but it wasn't seen in development. (Old notes commented that it might
            // have been the same issue as the IE blog post "problems-with-using-img-to-prefetch-script-or-css".)
            // SCRIPT preloads in Safari were disastrous. CSS preloads as SCRIPT could break an asset entirely;
            // see https://tt.amazon.com/0012003920. JS preloads as SCRIPT with an invalid type would not download
            // at all. OBJECT preloads with display=none would not work, and without display=none there were major
            // memory costs. See elsewhere in this file for comments about old Safari from David Kilzer at Apple.
        }
        return useType;
    }

    function attachHandlers(loader, useType, isImageUrl, onLoaded){    // Handle loads, errors, and timeouts
        var timer;

        // In a few cases, onload and onerror won't fire, so we need a timeout.
        // In all current cases, this signals an error condition (like a 404/400/etc).
        //  * FF doesn't fire onerror on OBJECT on 404's, so need different approach
        //  * Chrome and Blink based Opera don't fire any event on IMG for non-image file types that 404.
        // If these things happen then it never returns the loader object to the pool and it can ultimately
        // kill the rest of the lookups. In the case of the errors they are unusual enough that this isn't
        // a horrible thing, but it's not as efficient as desired.
        if ( isGecko || ( isWebkit && !isImageUrl )){
            // Choosing a long timeout, which is helpful in China where we can see very long
            // DNS lookups and TCP connect times.
            timer = ST( function() {
                onLoaded();
                loaderDone(loader, timer);
            }, 2500 + Math.random()*100 );
        }

        // To make serial calls, we need to know when the loader is done. "Done" means that the file
        // either successfully loaded, or onerror fired. onerror firing can actually mean the file was
        // downloaded and cached successfully.
        // Browsers very differently handle these states.
        //  * All browsers fires onload for IMG elements when downloading files that are actually are images
        //    (png, jpg, gif, etc) that successfully load.
        //  * IE and Chrome fire onerror instead of onload in IMG for requests that fail but also
        //    for non-image file types that successfully load.
        //  * Safari calls onload even on 404's.
        loader.onerror = function() {
            onLoaded();
            loaderDone(loader, timer);
        };

        loader.onl    };
    }

    /**
    * load Function
    * This function detects whether to use hi or low pri list, and whether it's allowed to run currently.
    * It then triggers the loading
    */
    function load(){
        if (!setLoadState()) { return; }

        // Start this iteration. Get the URL and figure out what type of loader to use.
        var target      = plUrls.pop(),
            url         = target.url,
            extension   = getExtension(url),
            isImageUrl  = checkIfImage(extension),
            isHiPri     = plUrls===hiPriUrls,
            useType     = determineType(isImageUrl, extension, isHiPri),
            logCount    = 1,
            iframeHtml  = '',
            start       = Date.now(),
            loader;

        // If no appropriate type, exit this iteration.
        if (!useType) {
            target.reject({
                url: url,
                success: false,
                error: 'not supported type'
            });
            loaderDone();
            return;
        }

        function resolve(){
            var duration = Date.now() - start;
            target.resolve({
                url: url,
                success: true,
                duration: duration
            });
        }

        // Get the right loader
        loader = (useType===type_Img) ? new Image() : doc.createElement(useType);
        loader.style.display = "none";

        // Set properties in correct order.
        if (useType === type_Iframe) {
            // The iframe approach doesn't really fit the current code structure. Should we decide to use iframes
            // in preference to other preloads, a refactor is in order. For now, just reset some state.
            logCount = 0;

            // We will fill the iframe with HTML containing prefetch link tags. The browser is responsible for
            // scheduling these preloads during idle time, so we just drain plUrls all at once. There should no
            // longer be a need for load() to call itself recursively (the pre-existing behavior) but we leave it
            // for now. The recursive load() will just exit due to the now-empty plUrls.
            // Experimentation shows that Firefox 38 ignores prefetch links after the first 200. If we're preloading
            // more than 200, we should probably do some pruning. Or if the limit is per iframe, we could chunk the
            // list. More investigation required.
            while (url) {
                // Firefox (gecko) should not preload JS due to the crossorigin anonymous issues described elsewhere.
                if (!isGecko || getExtension(url) !== "js") {
                    iframeHtml += "<link rel='prefetch' href='" + url + "'/>";
                    logCount++;
                }
                url = plUrls.pop();
            }
        }
        else if (useType === type_Img){
            attachHandlers(loader, useType, isImageUrl, resolve); // Has to be set before the URL
            loader.src = url;
        }
        else if (useType === type_Obj){
            loader.data = url; // Should come first
            // Several browsers may change document height if the element is not set to display:none and cause scrolling.
            // Also can cause high CPU and memory usage. Summarizing from David Kilzer at Apple on Webkit -
            //     Unfortunately, when css resources are loaded with a visible OBJECT tag with width of zero and height
            //     of zero, it causes them to be laid out in a single column that's one character wide and webkit is
            //     forced to construct a render tree and layout all of the text. That results in as many lines of
            //     text as there are characters in the css file! this consumes a lot of memory in all browsers, but is
            //     especially noticeable on mobile browsers like safari on IOS on iPad. in fact, it can sometimes
            //     causes Safari on IOS to crash due to the extra memory use.
            attachHandlers(loader, useType, isImageUrl, resolve);
        }
        else if (useType === type_Script){
            // We don't want the browser to execute the downloaded content, so set to non-script.
            loader.type = "text/cache";
            attachHandlers(loader, useType, isImageUrl, resolve);
            loader.src = url;
        }
        else if (useType === type_Link){
            // Note - can't use "disabled" attribute, or events won't fire.
            // Use "speech" because they won't actually be processed by IE 10
            loader.rel = 'stylesheet';
            loader.media = 'speech';
            attachHandlers(loader, useType, isImageUrl, resolve);
            loader.href = url;
        }

        // Append into DOM - Except for IE IMG. IE does not need IMG tags inserted into the DOM -
        // it fetches as soon as you set SRC. So avoid it (it is slow).
        if (!(isIE && useType === type_Img)){
            try {
                docElem.appendChild(loader);
                if (iframeHtml) {
                    // TODO: support promise resolve for iframe. (iframe is disabled for now)
                    // Firefox and some other browsers don't work right when prefetch LINKs are instantiated directly in
                    // JavaScript. By writing them as HTML that passes through ordinary parsing, things work better.
                    var iDoc = loader.contentWindow.document;
                    iDoc.open();
                    iDoc.write(iframeHtml);
                    iDoc.close();
                    // Unlike other loader types, there's nothing to recover here except the count that lets us continue
                    // preloading; the browser manages the actual preloads. So, instead of attaching the full load/error
                    // handlers, we just schedule an asychronous recovery. Called this way, the iframe element will never
                    // be removed from the DOM. That's OK. The batching behavior means we shouldn't be adding many of them.
                    ST(loaderDone, 0);
                }
            }
            catch(e) {
                // In rare cases appendChild can fail, especially if PLNow is called before pageload in Chrome. Just move on.
                target.reject({
                    url: url,
                    success: false,
                    reason: 'failed to appendChild'
                });
                loaderDone();
                return;
            }
        }

        // Count preload fulfilled
        analytics.increment("preload_fulfilled", logCount);

        // We can issue multiple fetch commands simultaneously to make more use of the network at an increased cost to CPU
        // and increased chance of saturated network.
        if (currentLoaders < allowedLoaders) { load(); }
    }

    // insert an item into a list at a random position
    function randomInsert(list, item) {
        list.splice(Math.round( Math.random() * list.length), 0, item);
    }

    /**
     * Insert url, resolve and reject function into a list. When the assert is loaded or reject, call the resolve or reject function
     * @param list {*[]} list record all the target urls
     * @param url {String} the URL to be inserted
     * @returns {Promise}
     */
    function insertUrl(list, url){
        return new Promise(function(resolve, reject) {
            randomInsert(list, {
                url: url,
                resolve: resolve,
                reject: reject
            });
        });
    }

    // Process a list of Urls. Will recurse if the list contains other lists
    function processUrlList(urlList, target) {
        if (!isSupportedBrowser){
            return Promise.reject('not supported browser');
        }

        // Check for a single url being passed in. If it is, force it to an array
        if (typeof urlList === "string") {
            urlList = [urlList];
        }
        else if (typeof urlList !== "object" || urlList === null) { // Chrome treats null as an object
            return Promise.reject('not an URL or URL list');
        }

        var i, u, promises = [];
        for (i = 0; i < urlList.length; i++) {
            u = urlList[i];
            if (u && typeof u !== "string") {
                processUrlList(u, target);
            }
            else if (u && (u[0] !== " ")) {
                // Guard for empty url or a leading space. In Chrome/FF, empty urls result in requesting of the hosting page.
                // Empty urls have been the cause of many DDOS attacks against ourselves.
                //
                // Insert the item into a random location in the array. This spreads out in time the requests across HTTP and
                // HTTPS and different domains. Insert the item into a random location in the array. This spreads out in time
                // the requests across different domains, which increases the likelihood of connection reuse, and decreases
                // failures due to DNS/TCP timeouts. This was a significant problem in China.
                promises.push(insertUrl(target, u));

                // Count preload asks
                analytics.increment("preload_asks");
            }
        }

        if(promises.length === 0){
            return Promise.resolve();
        } else if(promises.length === 1) {
            return promises[0];
        } else {
            return Promise.all(promises);
        }
    }

    // Trigger default (low-priority) loading only after someone calls preload() and after page load fires.
    // Deferring until a-preload-api-used (i.e. someone calls preload()) because unnecessary click/beforeunload
    // handlers may hurt performance, especially on mobile.
    P.when('a-preload-api-used', 'afterLoad').execute('a-preload-low-prior    });

    /**
     * Get Current Load State
     * This method is for testing purposes only and no group should take
     * runtime dependencies on it.
     */

    function _getPLStat() {
      return {
        H: hiPriUrls.length,
        L: lowPriUrls.length,
        P: plUrls.length,
        CL: currentLoaders,
        AL: allowedLoaders
      };
    }

    /**
     * Add Preload URL
     * When calling with a lot of URLs, please call once using an array of URLS rather than many times with one each time.
     *
     * @param {Array} urlList
     */

    function preload(urlList) {
      if (!preloadApiUsed) {
        preloadApiUsed = true;
        P.declare('a-preload-api-used');
      }
      var promise = processUrlList(urlList, lowPriUrls);
      load();
      return promise;
    }

    /**
     * Preload files immediately. Don't wait for onload.
     *
     * @param {Array} urls
     */

    function preloadImmediately(urlList) {
      var promise = processUrlList(urlList, hiPriUrls);
      load();
      return promise;
    }

    return {
      pre    }
    };
});
/////////////////////////
// END FILE a_preload.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_request_animation_frame.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  window.requestAnimationFrame ployfill with an A.requestAnimationFrame interface.
 *  Code adapted from Paul Irish's github:  https://gist.github.com/paulirish/1579671
 *
 */

"use strict";

P.when("a-util").register("a-request-animation-frame", function (util) {
  var lastTime = 0;
  var vendors = ['ms', 'moz', 'webkit', 'o'];
  // If window.requestAnimationFrame isn't present, check to see if there's a prefixed version
  // of the API.
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
  }

  // If there's no prefixed version of the API either, fall back to using setTimeout
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback, element) {
      var currTime = util.now();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTi    },
        timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  }

  // We can't just return window.requestAnimationFrame here since the browser will throw an error if we
  // assign a native function to on of our objects and then call our object.  Therefore, we need to
  // wrap the function call.
  return {
    requestAnimationFrame: function (callback, element) {
      return window.requestAnimationFrame(callback, element);
    },
    cancelAnimationFrame: function (id) {
      window.cancelAnimationFrame(id);
    }
  };
});
/////////////////////////
// END FILE a_request_animation_frame.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_fonts.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Very simple polyfill for CSS Font Loading API [1]. This module will use
 * browser's built-in font loading API if available. The polyfilled version
 * can only load fonts - it does not pass FontFace array to the promise as
 * specified in the draft.
 *
 * The CSS Font Loading API is still in draft and so far only Chrome, Opera,
 * and Firefox support it.
 *
 * TODO:
 *   1. We should look back here when the API is finalised and modify the
 *      behaviour accordingly, though most of the features should
 *      have been stable.
 *   2. We should implement a polyfill for FontFace
 *   3. Implement rejects properly
 *
 * Current API:
 *   - a-fonts.load (polyfills document.fonts.load)
 *       Loads the supplied font strings (e.g. '1em Amazon Ember' or
 *       'italic lighter 1em Amazon Ember') and returns a promise.
 *       The polyfill part will not reject
 *   - a-fonts.check (polyfills document.fonts.check)
 *       Checks whether the font variant is available and returns true if so
 *   - a-fonts.ready (polyfills document.fonts.ready)
 *       Checks whether ALL fonts loaded with a-fonts.load is available and
 *       returns a promise. Never rejects
 *
 * This module does not replace the browser built-in font loading API if available.
 * It also makes uses of the Promise polyfill by jasjon@.
 *
 * Related: MDN CSS Font Loading API [2]
 *
 * [1] https://drafts.csswg.org/css-font-loading/
 * [2] https://developer.mozilla.org/en-US/docs/Web/API/CSS_Font_Loading_API
 */
P.when('jQuery', 'A', '3p-promise').register('a-fonts', function ($, A, Promise) {
  // CSS Font Loading API statuses
  var STATUS_UNLOADED = 'unloaded';
  var STATUS_LOADING = 'loading';
  var STATUS_LOADED = 'loaded';

  // Stack for monospace fonts for font width comparison
  var MONOSPACE_FONT_STACK = 'Consolas, "Courier New", Courier, monospace';
  var FONT_CHECK_INTERVAL = 50;

  var _fontSet = [];
  var _$body = $('body');

  /**
   * Attempts to load font string. Returns a promise.
   * The polyfill version will not reject. This will be look Into
   * soon.
   *
   * @param variant Font string to load. It should be in the format of
   *                "[style] [variant] [weight] [size] [family]". For
   *                example, "italic 1em Amazon Ember"
   * @return Promise. Polyfill version will not reject at this time.
   */
  var loadFont = function (variant) {
    return new Promise(function (fulfill, reject) {
      // Push new font variant set
      var newFont = {
        variant: variant,
        status: STATUS_UNLOADED
      };

      _fontSet.push(newFont);

      // Create an invisible DOM element to load the font
      newFont.$loader = $('<span>.</span>', { 'class': 'aok-hidden' })
          .css('font', newFont.variant)
          .appendTo(_$body);
          
      newFont.status = STATUS_LOADING;

      // Initialise a checker DOM. This is used for width comparison to
      // determine whether the font has been loaded.
      newFont.$checker = $('<span>.</span>', { 'class': 'aok-hidden' })
          .appendTo(_$body);

      // Periodically check the load status
      newFont.intervalId = window.setInterval(function () {
        newFont.$checker.css('font', newFont.variant + ', ' + MONOSPACE_FONT_STACK);
        
        var width = newFont.$checker.width(),
            height = newFont.$checker.height();

        newFont.$checker.css('fontFamily', MONOSPACE_FONT_STACK);

        if (newFont.$checker.width() !== width || newFont.$checker.height() !== height) {
          fulfill(newFont.variant);

          newFont.status = STATUS_LOADED;

          // Clean up
          newFont.$loader.remove();
          newFont.$checker.remove();
          clearInterval(newFont.intervalId);
        }
      }, FONT_CHECK_INTERVAL);
    });
  };

  /**
   * Check if the specified font string is available.
   *
   * @param variant Font string to load. It should be in the format of
   *                "[style] [variant] [weight] [size] [family]". For
   *                example, "italic 1em Amazon Ember"
   * @return True if available; false if otherwise.
   */
  var checkFont = function (variant) {
    A.each(_fontSet, function (font) {
      if (font.variant === variant) {
        return font.status === STATUS_LOADED;
      }
    });

    return false;
  };

  /**
   * Check if all fonts loaded with load() has been loaded.
   * Note that this is a property, not a function. This property
   * itself is a promise. It resolves when all fonts are loaded,
   * and will never reject.
   */
  var onFontsReady = (function () {
    return new Promise(function (fulfill, reject) {
      var readyIntervalId = window.setInterval(function () {
        var loadStatus = A.reduce(_fon    }, true);
        
        if (loadStatus) {
          fulfill();
          clearInterval(readyIntervalId);
        }
      }, FONT_CHECK_INTERVAL);
    });
  }());
  
  
  // Factory function for determining whether to use native or polyfills
  var polyfillFunctions = {
    load: loadFont,
    check: checkFont,
    ready: onFontsReady
  };
  
  var native = document.fon;
  }

  var polyfillReady = onFontsReady;
  if (native && native.ready) {
    // New CSS font loading API's `document.fonts.ready` is a Promise object,
    // but older Chrome implemented it as `.ready()` that returns a Promise object
    polyfillReady = native.ready.then ? native.ready : native.ready.apply(native);
  }
    
  return {
    load: getPolyfill('load', polyfillFunctions),
    check: getPolyfill('check', polyfillFunctions),
    ready: polyfillReady
  };
});
/////////////////////////
// END FILE a_fonts.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_form_controls_api.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Form Controls API
 */

'use strict';

P.when('A').register('a-form-controls-api', function (A) {
  var $ = A.$;

  /**
   *  The prefix for the form controls auto ID string
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var AUTO_ID_STRING = "a-form-controls-autoid-";

  /**
   *  Page-specific ID counter so we can assign unique IDs to all appropriate elements on the page in such a case that the implementer
   *  has not provided an ID for either the input or the label
   *
   *  @private
   *  @type {number}
   */
  var idCount = 0;

  /**
   *  Take a hypothetical element, confirm it's a jQuery object or a DOM node, and make sure we hand back a jQuery obj in the latter case
   *
   *  @private
   *  @param {object} element - Either a DOM element or a jQuery object containing a single DOM element
   *
   *  @return {object} - Returns the jQuery object representing the element passed in, or null if the element provided was not a DOM node
   */
  var _normalizeFunctionInput = function(element) {
    return (element && element.jquery) ? element : (element && element.nodeType === 1) ? $(element) : null;
  };

  /**
   *  Take a given element and properly search for its underlying form control
   *
   *  .first() is important for cases where similar elements turn up inside the label.
   *
   *  @private
   *  @param {object} $element - jQuery object representing a single form control element (radio/checkbox/touch-multi-select)
   *
   *  @return {object} - jQuery object for the underlying form control of the element
   */
  var _findInnerInput = function($element) {
    return $element.find('input').first();
  };

  /**
   *  Take a given element and properly search for its underlying form control
   *
   *  .first() is important for cases where similar elements turn up inside the label.
   *
   *  @private
   *  @param {object} $element - jQuery object representing a single icon element (radio/checkbox/touch-multi-select)
   *
   *  @return {object} - jQuery object for the underlying icon of the element
   */
  var _findInnerI;
  };

  /**
   *  Traverse upwards from a given element to find the most appropriate container to use when finding other elements that are related
   *
   *  @public
   *  @param {object} element - Either a DOM element or a jQuery object containing a single DOM element
   */
  var findFormElementContainer = function(element) {
    var $element = _normalizeFunctionInput(element);

    if ($element && $element.length === 1) {
      var $container = $element.closest('form');

      if ($container.length === 0) {
        $container = $element.closest('fieldset');
        if ($container.length === 0) {
          $container = $(document);
        }
      }

      return $container;
    }
  };

  /**
   *  Set the state of a single touch multiselect row.
   *
   *  @private
   *  @param {object} $element - jQuery object containing the touch multi select row
   *  @param {boolean} checkedState - State to set the checked attribute
   */
  var _setMultiSelectState = function($element, checkedState) {
    var $icon = _findInnerIcon($element);

    $icon
      .toggleClass('a-icon-touch-multi-select-active', checkedState)
      .toggleClass('a-icon-touch-multi-select', !checkedState);

    $element.attr('aria-checked', checkedState);
  };

  /**
   *  Set the state of a single checkbox/radio. Expects to be passed the <div> wrapping the label/input/i/text.
   *
   *  @private
   *  @param {object} element - Either a DOM element or a jQuery object containing a single DOM element
   *  @param {boolean} checked - State to set the checked attribute
   *  @param {boolean} disabled - State to set the disabled attribute
   */
  var _setInputState = function(element, checked, disabled) {
    var $element = _normalizeFunctionInput(element),
      $input, checkedState, disabledState;

    if (!$element || $element.length !== 1) {
      return false;
    }

    $input = _findInnerInput($element);

    // Check the original value for undefined for cases where we only want to change disabled state.
    if (checked !== undefined) {
      checkedState = !!checked;

      if ($element.hasClass('a-touch-multi-select')) {
        _setMultiSelectState($element, checkedState);
      }

      // Don't change the input or dispatch if it's already set correctly
      if ($input.prop('checked') !== checkedState) {
        $input.prop('checked', checkedState).trigger('change');
      }
    }

    // Check the original value for undefined for cases where we only want to change checked state.
    if (disabled !== undefined) {
      disabledState = !!disabled;

      // Don't change the input if it's already set correctly
      if ($input.prop('disabled') !== disabledState) {
        $input.prop('disabled', disabledState);
      }
    }
  };

  /**
   *  Convenience function to set the checkbox state to its opposite state.
   *
   *  @public
   *  @param {object} element - The element to toggle, otherwise attempt to use the context var
   */
  var toggleCheckboxState = function(element) {
    var $element = _normalizeFunctionInput(element),
      $input;

    if ($element && $element.length === 1) {
      $input = _findInnerInput($element);
      _setInputState($element, !$input[0].checked);
    }
  };

  /**
   *  Ensure a given elements visual appearance matches its underlying form element
   *
   *  @public
   *  @param {object} [element] - Optional, the element to normalize, otherwise attempt to use the context var
   */
  var normalizeElement = function(element) {
    /*jshint validthis:true */
    var $element = _normalizeFunctionInput(element);
    // if we didn't get passed an element directly, assume we're iterating, and test 'this' as the element
    $element = $element ? $element : _normalizeFunctionInput(this);

    if ($element && $element.length === 1) {
      var $input = _findInnerInput($element);
      var inputType = $input.attr('type');
      var isTouchMultiSelect = $element.hasClass('a-touch-multi-select');

      // If regular radio or checkbox, the label or the input inside may have an ID
      // If a touch-multi-select checkbox, the label's parent or the input may have an ID
      // Rule out element and input first, then if not touch multi, proceed, if is touch multi, check to see if the parent has an ID before proceeding
      if (!$element.attr('id') && !$input.attr('id') && (!isTouchMultiSelect || (isTouchMultiSelect && !$element.parent().attr('id')))) {
        var autoID = AUTO_ID_STRING + idCount;
        $element.attr('aria-labelledby', autoID).find('.a-checkbox-label, .a-radio-label, .a-touch-multi-select-item-label').attr('id', autoID);
        idCount++;
      }

      _setInputState($element, $input[0].checked, $input[0].disabled);
    }
  };

  /**
   *  For accessibility purposes, we need to associate legends to fieldsets so checkboxes and radio buttons announce
   *  their legend when they receive focus.
   *
   *  @public
   *  @param {string} selector - The selector for a given set of elements (they differ on desktop and mobile)
   */
  var normalizeFieldsets = function(selector) {
    // Get deduplicated list of fieldsets
    var $fieldsets = $(selector).closest('fieldset');

    $fieldsets.each(function(index, element) {
      var $fieldset = $(element);
      var $legend = $fieldset.find('legend').first();

      // If our fieldset has a legend, associate the two with aria roles and IDs.
      if ($legend.length) {
        var legendID = $legend.attr('id');

        if (!legendID) {
          legendID = AUTO_ID_STRING + idCount;
          $legend.attr('id', legendID);
          idCount++;
        }

        $fieldset.attr('aria-describedby', legendID);
      }
    });
  };

  return {
    findFormElementContainer: findFormElementContainer,
    toggleCheckboxState: toggleCheckboxState,
    setCheckboxState: _setInputState,
    setRadioState: _setInputState,
    normalizeElement: normalizeElement,
    normalizeFieldsets: normalizeFieldsets
  };
});
/////////////////////////
// END FILE a_form_controls_api.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_weblab.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Team Client-Side Weblabs
 */
'use strict';

/**
 *  Private API for querying AUI template weblab state, with optional client-side triggering.
 *
 *  IMPORTANT NOTICE:
 *  This API is solely for use with weblabs implemented by the AUI team and should not be used
 *  in any way by any other team.
 *
 *  WARNING:
 *  Because it relies on page state, a-weblab must be deferred until DOM ready (the 'ready' event).
 *  This means that all logic depending on a-weblab is also deferred. Design accordingly!
 */
P.when('jQuery', 'a-util', 'a-state', 'a-analytics', 'a-constants')
  .execute('prepare-a-weblab', function ($, util, state, analytics, constants) { // jshint ignore:line

    var WLAB_STATES_NAMESPACE = 'a-wlab-states';
    var LTREE_STATES_NAMESPACE = 'a-ltree-states';

    P.when(constants.constants.PAGESTATE_LOADED_MODULE_PREFIX + WLAB_STATES_NAMESPACE)
      .register('a-weblab', function (wlabValue) {
        // a-wlab-states is standard page state for AUI template weblabs
        // We only take the first weblab value which comes from AUI body component. All the following weblab pagestate
        // update will be ignored. So that there is no way to change weblab setting from client side.
        var aWlabStates = wlabValue || {};
        // a-ltree-states, if it exists, is a LinkTree/Nav hack to inject weblab state data
        var aLtreeStates;
        var toTrigger = {};
        var triggered = {};
        // Record every queried weblab before a-ltree-states is ready, so we know if a-ltree-states
        // changes any weblab value
        var wlabQueried = {};
        var phoneHomeTimeout;
        var DEFAULT_TREATMENT = 'C';

        P.when(constants.constants.PAGESTATE_LOADED_MODULE_PREFIX + LTREE_STATES_NAMESPACE).execute(function onLtreeUpdated (ltreeValue) {
            /**
             * Searching source code founds no one is using a-ltree-states. We still bind to it, and record an error if
             * a-ltree-states data cause any weblab status changing.
             */
            aLtreeStates = ltreeValue || {};
            util.each(util.keys(wlabQueried), function (wlabId) {
              if ((aLtreeStates[wlabId] || wlabQueried[wlabId]) && aLtreeStates[wlabId] !== wlabQueried[wlabId]) {
                P.log('a-weblab returned wrong value for ' + wlabId + '. It returned ' + wlabQueried[wlabId] + '. it is set as ' + aLtreeStates[wlabId] + ' at a-ltree-states.');
              }
            });
          }
        );

        /**
         *  Return a weblab treatment from page state data.
         *
         *  @private
         *  @param {string} weblabId
         *
         *  @return {string}
         */
        function getTreatment(weblabId) {
          if (!aLtreeStates) {
            wlabQueried[weblabId] = aWlabStates[weblabId];
          }
          return (aLtreeStates && aLtreeStates[weblabId]) || aWlabStates[weblabId];
        }

        /**
         *  Return a weblab treatment without recording a client-side trigger.
         *
         *  @public
         *  @param {string} weblabId
         *
         *  @return {string}
         */
      }

        /**
         *  Return a weblab treatment and also record a client-side trigger.
         *
         *  TODO
         *  This implementation is a stopgap until CSM supports weblab triggering:
         *    https://sim.amazon.com/issues/CSM-161
         *  Once that launches, our entire custom phoneHome mechanism should be
         *  killed with fire and fury.
         *
         *  @public
         *  @param {string} weblabId
         *
         *  @return {string}
         */
        function trigger(weblabId) {
          var treatment = getTreatment(weblabId);
          if (treatment && !toTrigger[weblabId] && !triggered[weblabId]) {
            toTrigger[weblabId] = treatment;
            clearTimeout(phoneHomeTimeout);
            phoneHomeTimeout = setTimeout(phoneHome, 5000);
          }
          return treatment || DEFAULT_TREATMENT;
        }

        /**
         *  Test a weblab for a specific treatment, and optionally record a client-side trigger.
         *
         *  @public
         *  @param {string} weblabId
         *  @param {string} testTreatment
         *  @param {boolean} doTrigger
         *
         *  @return {boolean}
         */
        function is(weblabId, testTreatment, doTrigger) {
          return (doTrigger ? trigger(weblabId) : noTrigger(weblabId)) === testTreatment;
        }

        /**
         *  Return true iff a weblab is actually active in the current realm.
         *
         *  @public
         *  @param {string} weblabId
         *
         *  @return {boolean}
         */
      }

        /**
         *  URI encode a string, and convert an undefined input to an empty string.
         *
         *  @private
         *  @param {string} param
         *
         *  @return {string}
         */
      }

        /**
         *  The base URL (relative to the current domain) for the trigger request.
         *
         *  TODO
         *  For hygiene and readability, phoneHomeUrl should be refactored into a path
         *  and a map of params, which can be serialized with $.param. When doing that,
         *  don't forget to:
         *  - pass undefined ue_id and ue_sid as empty strings
         *  - $.extend at appropriate steps, so invariant params remain invariant
         *  - deal with the nested array of weblabs sensibly in the server-side script
         *  - or, just kill this in favor of CSM's shared approach (see SIM link above)
         *
         *  @private
         *  @type {string}
         */
        var phoneHomeUrl = '/gp/aui/record.html?rid=' + encode(window.ue_id) + '&sid=' + encode(window.ue_sid) + '&wlab=';

        /**
         *  Convert pending triggers into an image URL that hits our app on RetailWebsite, and reset.
         *
         *  @private
         */
        function phoneHome() {
          var wlab = [];
          // Note that unless a weblab is active in the current realm, a-wlab-states should have
          // null as the treatment. In such a case, the weblab will never be queued in toTrigger.
          // This behavior should protect us from attempting to hit the phoneHomeUrl on domains
          // where our Gurupa endpoint does not exist (i.e., anything except retail).
          util.each(toTri    });
          if (wlab.length) {
            var url = phoneHomeUrl + encode(wlab.join(',')) + '&t=' + (new Date()).getTime() + '&type=';
            // Prefer the sendBeacon call (which returns true when it successfully queues),
            // but fall back to an image object.
            var nav = window.navigator;
            if (!!nav.sendBeacon && nav.sendBeacon(url + 'b')) {
              analytics.increment('wlabBcn');
            } else {
              (new Image()).src = url + 'i';
              analytics.increment('wlabImg');
            }
          }
          // reset for next phoneHome
          toTrigger = {};
          clearTimeout(phoneHomeTimeout);
        }

        // If pending triggers remain when the user leaves the page, try to send them.
        $(window).bind('unload', phoneHome);

        return {
          is: is,
          isActive: isActive,
          noTrigger: noTrigger,
          trigger: trigger
        };
      });
  });
/////////////////////////
// END FILE a_weblab.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_post_atf.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Defer to execute function after ATF or DOM is ready
 */
'use strict';

P.declare('prv:a-post-atf-catchdomready', true); // TODO: create P.block at MockPageJS to complete the test
P.when('a-util', 'a-defer', 'prv:a-post-atf-catchdomready')
  .register("prv:a-post-atf", function (util, defer, catchDomReady) {
    var fnQueue = [],
      postAtf = false;

    /**
     * postAtf.execute: defer executing a function after ATF or DOM is ready
     * @param fn {Function} the function to be deferred executed
     */
    function execute(fn) {
      if (postAtf) {
        defer.defer(fn);
      } else {
        fnQueue.push(fn);
      }
    }

    function flush() {
      if (!postAtf) {
        postAtf = true;
        util.each(fnQueue, function (fn) {
          defer.defer(fn);
        });
        fnQueue = [];
      }
    }    }

    P.when('af', 'cf').execute('flush_queued_functions_after_ATF', flush);

    P.when('a-domready').execute('flush_queued_functions_after_domre    });

    return {
      execute: execute
    };
  });
/////////////////////////
// END FILE a_post_atf.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_bit_array.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * AmazonUI Bit Array
 */

'use strict';

P.declare('prv:a-is-typedarray-supported', !!(window.ArrayBuffer && window.Uint8Array)); // IE 8 and Opera Mini don't
                                                                                         // support typed array
P.when('a-class', 'prv:a-is-typedarray-supported')
  .register('prv:a-bit-array', function (aClass, isTypedArraySupported) {
    /**
     * Helper function to unify bitPosition and byteOffset
     * @param fn {Function} the real function to use bitPosition and byteOffset to operate on BitArray
     * @returns {Function}
     */
    function bitFn(fn) {
      return function (bitPosition, byteOffset) {
        byteOffset |= 0;
        bitPosition |= 0;
        byteOffset += bitPosition / 8 >> 0;
        bitPosition %= 8;
        if (byteOffset < this.byteLength()) {
          return fn.call(this, bitPosition, byteOffset);
        }
      };
    }

    /**
     * BitArray class
     */
    var BitArray = aClass.createClass({
      /**
       * Constructor
       * @param bits {Array|Uint8Array} the BitArray buffer to hold the bits. Use TypedArray (Uint8Array) if possible,
       *   since it has better performance.
       */
          },
      /**
       * return the bits buffer length in byte
       * @returns {Number|number}
       */
      byteLength: function () {
        return this._bitsBuffer.length;
      },
      /**
       * Converts the BitArray to string. The string is **NOT** Base64 encoded. Only contains ASCII characters.
       * @returns {String}
       */
      toSt    },
      /**
       * Set byte value at giving position
       * @param value {Number}, should be less than 255, otherwise the behavior is undefined
       * @param byteOffset {Number}, should be less than BitArray's length in byte, otherwise does nothing
       */
      setByte: function (value, byteOffset) {
        byteOffset |= 0;
        if (byteOffset < this._bitsBuffer.length) {
          this._bitsBuffer[byteOffset] = value;
        }
      },
      /**
       * Get byte value at giving position
       * @param byteOffset {Number},
       * @returns {Number|Undefined}
       */
      getByte: function (byteOffset) {
        if (byteOffset < this.byteLength()) {
          return this._bitsBuffer[byteOffset];
        }
      },
      /**
       * Set the bit to 1 at giving position. The position can be set as combination of bitPosition and byteOffset as
       * byteOffset * 8 + bitPosition, as far as the combined position doesn't exceed the BitArray size.
       * @param bitPosition {Number}
       * @param byteOffset {Number}
       */
      set: bitFn(function (bitPosition, byteOffset) {
        var mask = 1 << bitPosition;
        this._bitsBuffer[byteOffset] = this._bitsBuffer[byteOffset] | mask;
      }),
      /**
       * Set the bit to 0 at giving position. The position can be set as combination of bitPosition and byteOffset as
       * byteOffset * 8 + bitPosition, as far as the combined position doesn't exceed the BitArray size.
       * @param bitPosition {Number}
       * @param byteOffset {Number}
       */
      unset: bitFn(function (bitPosition, byteOffset) {
        var mask = this._bitsBuffer[byteOffset] & (1 << bitPosition);
        this._bitsBuffer[byteOffset] = this._bitsBuffer[byteOffset] ^ mask;
      }),
      /**
       * Get the bit value (1 or 0) at giving position. The position can be set as combination of bitPosition and
       * byteOffset as byteOffset * 8 + bitPosition, as far as the combined position doesn't exceed the BitArray size.
       * @param bitPosition {Number}
       * @param byteOffset {Number}
       */
      get: bitFn(function (bitPosition, byteOffset) {
        var mask = 1 << bitPosition;
        return (this._bitsBuffer[byteOffset] & mask) ? 1 : 0;
      })
    });

    /**
     * BitArray factory function. Crete a new BitArray which size can cover the giving bit length, and initialize all
     * bits to 0.
     * @param bitLength {Number}
     */
    BitArray.create = function (bitLength) {
      var byteLength = (bitLength - 1) / 8 + 1 >> 0; // convert to integer
      return BitArray.createByteLength(byteLength);
    };

    /**
     * BitArray factory function. Crete a new BitArray which size can cover the giving byte length, and initialize all
     * bits to 0.
     * @param byteLength {Number}
     */
    BitArray.createByteLength = function (byteLength) {
      var bits;
      if (isTypedArraySupported) {
        bits = new Uint8Array(byteLength);
      } else {
        bits = new Array(byteLength);
        for (var i = byteLength - 1; i >= 0; i--) {
          bits[i] = 0;
        }
      }
      return new BitArray(bits);
    };

    /**
     * BitArray factory function. Create a new BitArray with copied value from the giving number array. Every number in
     * the array should be less than 255.
     * @param array {Number[]}
     */
    BitArray.fromArray = function (array) {
      var bits;
      if (isTypedArraySupported) {
        bits = new Uint8Array(array);
      } else {
        bits = [].slice.call(array);
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] >= 256) {
            bits[i] = bits[i] % 256;
          }
        }
      }
      return new BitArray(bits);
    };

    /**
     * BitArray factory function. Create a new BitArray from a string. The string is **NOT** Base64 encoded. It's used
     * at raw data.
     * @param str {String}
     */
    BitArray.fromString = function (str) {
      var strLen = str.length;
      var arr = new Array(strLen);
      for (var i = strLen - 1; i >= 0; i--) {
        // doesn't check Unicode here, since at inline CSS hint usage, the string is decoded from Base64 string, should
        // be no Unicode.
        // TODO: support Unicode string
        arr[i] = str.charCodeAt(i);
      }
      return BitArray.fromArray(arr);
    };

    return BitArray;
  });
/////////////////////////
// END FILE a_bit_array.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_cookie_writer.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * AmazonUI Cookie Writer
 *
 * This is a private module, only used inside AmazonUI. Before using the API, please first check:
 * https://w.amazon.com/index.php/AmazonCookiePolicy
 */

P.when('a-util').register('prv:a-cookie-writer', function (util) {
  // encode the string, escape backslash and double-quoter
  function encodeCookieString(str) {
    str = util.trim(str);
    if (str.indexOf('"') > -1 || str.indexOf('\\') > -1) {
      str = '"' + str.replace(/("|\\)/g, '\\$1') + '"';
    }
    return str;
  }

  /**
   * Set a single cookie. The cookie change will not appear to getter until a refresh is called.
   * @param name {string} cookie name
   * @param value {string} cookie value
   * @param options {Object} see: https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie#Syntax Possible option include:
   *          path {string}
   *          domain {string}
   *          maxAge {String|Number}
   *          expires {Date|String|Number} When Date format is used, it's the expire date; When String format is used,
   *              it should be a UTC time string; When Number is used, it's expire time in seconds from right now.
   */
  function set(name, value, options) {
    var cookieOption = [];
    var expiresString;

    value = encodeCookieString(value);
    options = options || {};
    if (options.path) {
      cookieOption.push(';path=' + options.path);
    }
    if (options.domain) {
      cookieOption.push(';domain=' + options.domain);
    }
    if (options.maxAge) {
      cookieOption.push(';max-age=' + options.maxAge);
    }
    if (options.expires) {
      // options.expires could be a Date Object, or a Number, or a string.
      // 1. assume it's a string
      // 2. if it's a Date object, covert it to string;
      // 3. if it's a number, it's the delta time in seconds from now, create Date object and convert it to string.
      expiresString = options.expires;
      // If expires has getTime function, it's taken as a Date object. toUTCString is also a needed function.
      if (options.expires.getTime && options.expires.toUTCString) {
        expiresString = options.expires.toUTCString();
      } else if (typeof options.expires === 'number') {
        // If expires is a number, it's expires delta from now.
        expiresString = new Date(Date.now() + options.expires * 1000).toUTCString();
      }
      // otherwise, expires is taken as a string.
      cookieOption.push(';expires=' + expiresString);
    }
    document.cookie = name + '=' + value + cookieOption.join('');
  }

  return set;
});

/////////////////////////
// END FILE a_cookie_writer.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_cookie_hint.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * AmazonUI Cookie Hint
 *
 * We created a Base64 encoded bloom filter at cookie. Use it track to track a set of resource caching status
 */

P.when('a-util', 'prv:a-cookie-writer', 'prv:a-bit-array', 'a-constants').register('a-cookie-hint', function (util, writeCookie, BitArray, constants) {
  if (!window.btoa || !window.atob) {
    return {
      get: constants.constants.NOOP
    };
  }

  // Bloom filter cookie format:
  // https://w.amazon.com/index.php/User:Jfrasca/BloomFilterCookieInlining#Cookie_Format
  //  +---------------------------------------------------------+
  //  | Header                                       | BitArray |
  //  +----------------------------------------------+          +
  //  | Version | CompressionAlgorithm | Create Date |          |
  //  +---------+----------------------+-------------+----------+
  //  | 2 bytes                                      | n bytes  |
  //  +----------------------------------------------+          +
  //  | 6 bits  | 2 bits               | 8 bits      |          |
  //  +---------+----------------------+-------------+----------+

  var HEADER_BYTE_SIZE = 2;
  var HEADER_SIZE = HEADER_BYTE_SIZE * 8; // 2 bytes
  var CURRENT_VERSION = 0; // bit offset: 0 - 5
  var COMPRESSION_ALGORITHM = 0; // bit offset: 6 - 7
  var VERSION_MASK = 0x3F;
  var DEFAULT_BIT_ARRAY_SIZE = 120; // 120 bits = 15 bytes = 20 Base64 encoded bytes
  var COOKIE_EXPIRES = 365 * 24 * 60 * 60; // 1 year;

  function dayOfYear() {
    var now = new Date();
    var start = new Date(now.getFullYear(), 0, 0);
    var diff = now - start;
    var oneDay = 1000 * 60 * 60 * 24;
    return Math.floor(diff / oneDay);
  }

  /**
   * Read the data from giving cookie
   * @param cookieName {String}
   * @returns {String?} data string read from Cookie
   */
  function readCookie(cookieName) {
    // We don't call cookies.refresh(), because at current design, the bloom filter cookie will be read only once
    // before all writing operation.
    return util.cookies.get(cookieName);
  }

  /**
   * Decode data and convert it to  a new BitArray
   * A cookie could be init/cleared at server side, or set up at client side
   * When server side init the cookie, it's set up as 0 value, at this status, client side has to set up the cookie
   * Otherwise, we can use the cookie content to create a BitArray.
   * @returns {BitArray?} A BitArray read from cookie if validate.
   */
  function dataToBloomFilter(data) {
    // A bloom filter cookie is not set up if it:
    // 1. data is '0'
    // 2. data is not Base64 encoded. (Base64 encoded string has minimum length of 4
    // 3. data is Base64 encoded 0.
    if (data.length < 4) {
      return;
    }
    try {
      var buffer = window.atob(data);
      if (buffer.length === 0 || (buffer.length === 1 && buffer.charCodeAt(0) === 0)) {
        return;
      }
      // TODO: decompress content according to compression algorithm at header
      return BitArray.fromString(buffer);
    } catch (e) {
      // if failed to decode the cookie value, do nothing, a new BloomFilter will be created
    }
    return;
  }

  /**
   * Check is the BloomFilter version is supported
   * @returns {boolean}
   */
  function isVersionSupported(bloomFilter) {
    // if cookie version is higher than current version, we don't support it.
    var version = bloomFilter.getByte(0) & VERSION_MASK;
    return version <= CURRENT_VERSION;
  }

  /**
   * Set up a brand new bloom filter cookie
   */
  function setupBloomFilter(bitArraySize, updateCookie) {
    var bloomFilter = BitArray.create(HEADER_SIZE + bitArraySize);
    var versionAlgorithmHeader = CURRENT_VERSION + (COMPRESSION_ALGORITHM << 6);
    var dayOfYearHeader = dayOfYear() / 2 >> 0;
    bloomFilter.setByte(versionAlgorithmHeader, 0);
    bloomFilter.setByte(dayOfYearHeader, 1);
    updateCookie(bloomFilter);
    return bloomFilter;
  }

  /**
   * Create a function to update cookie
   * @param cookieName {String} the name of the cookie
   * @returns {Function}
   */
  function cookieWriter(cookieName) {
    return function (bitArray) {
      writeCookie(cookieName, window.btoa(bitArray.toString()), {
        path: '/',
        expires: COOKIE_EXPIRES
      });
    };
  }

  var noop = {
       }
  };

  /**
   * Create a object to set bit at the CookieHint
   * @param bloomFilter {BitArray} the target BloomFilter
   * @param updateCookie {Function} the cookie updater
   * @returns {Function}
   */
  function cookieHintWriter(bloomFilter, updateCookie) {
    var bitArraySize = bloomFilter.byteLength() * 8 - HEADER_SIZE;
    return {
      set: util.rest(function (bitPositions) {
        util.each(bitPositions, function (bitPosition) {
          if (bitPosition >= bitArraySize) {
            return;
          }
          bloomFilter.set(bitPosition, HEADER_BYTE_SIZE);
        });

        updateCookie(bloomFilter);
        return this;
      })
    };
  }

  /**
   * Get CookieHint for the given cookie name
   * @param cookieName {String} the name for the bloom filter cookie
   * @param bitArraySize {Number} The bit array size in bit. It doesn't contain header size
   */
  function getCookieHint(cookieName, bitArraySize) {
    var bloomFilter;
    var updateCookie = cookieWriter(cookieName);
    // When there's no cookie and if we reach this point
    // we can just initialize the cookie. 
    // This is to handle the integration problem when we can't initialize the cookie from the server.
    // Edge cases:
    // - js disabled: we will never reach this point
    // - cookie disabled: returning noop or returning a cookie writer give the same result.
    // {@see https://code.amazon.com/packages/AmazonUIAssetInjectorJava/blobs/473640e71967c14fea1afcef7d237c814e4f5495/--/src/com/amazon/aui/assets/adapters/BloomFilterCookie.java#L70}
    // related SIM {@see https://sim.amazon.com/issues/AUI-11611}
    var data = readCookie(cookieName) || '0'; // giving '0' would trigger the setupBloomFilter() step

    bloomFilter = dataToBloomFilter(data) || setupBloomFilter(bitArraySize, updateCookie);
    if (!isVersionSupported(bloomFilter)) {
      return noop;
    }

    return cookieHintWriter(bloomFilter, updateCookie);
  }

  var cookieHints = {};

  /**
   * Cookie hint factory function. Create a new Cookie Hint, or get singleton instance.
   * @param cookieName {String} Cookie name
   * @param bitArraySize {Number} The bit array size in bit. It doesn't contain header size
   * @returns {CookieHint}
   */
  function get(cookieName, bitArraySize) {
    if (!cookieHints[cookieName]) {
      bitArraySize = bitArraySize || DEFAULT_BIT_ARRAY_SIZE;
      cookieHints[cookieName] = getCookieHint(cookieName, bitArraySize);
    }
    return cookieHints[cookieName];
  }

  return {
    get: get
  };
});
/////////////////////////
// END FILE a_cookie_hint.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_component_mixins.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Component Mixins
 *  Common methods for AUI components
 */

'use strict';

P.when('A').register('a-component-mixins', function (A) {

    var count = 0;

    var declarativeList = A.constants.declarativeEvents.split(' ');

    /**
     * Creates a unique identifier to be associated with a declarative action
     * @returns {string} the unique id
     *    }

    /**
     * Checks to make sure the A.declarative module supports all events in a list
     * @param searchKeys: The list of events to search for
     * @returns {boolean}: true if all events were found, false if any were not
     */
    function supportsAll (searchKeys) {
        for (var i = 0; i < searchKeys.length; i++) {
            if (A.indexOfArray(declarativeList, searchKeys[i]) < 0) {
                return false;
            }
        }
        return true;
    }

    return {

        /**
         * Show the component
         */
            },

        /**
         * Hide the component
         */
            },

        /**
         * Toggle the component's visibility
         * @return the toggled component
         */
        to    },

        /**
         * Returns the number of elements wrapped by the component
         * @return {number}
         */
            },

        /**
         * Return true if the component wraps no elements
         * @return {boolean}
         */
        isE    },

        /**
         * Creates a declarative action for the the event
         * @param events:  list of events
         * @param fn: the callback to execute when the event occurs
         */
        on: function (events, fn) {
            var fName = A.parseFunctionName(fn);
            if (!fName) {
                P.error.call({}, "Please name all asynchronous event callbacks");
            }
            var eventList = events ? events.split(' ') : undefined;
            if (!eventList) { return; }
            this.fnMap = this.fnMap || {};
            if (!supportsAll(eventList)) {
                P.error.call({}, 'That event is not supported!');
            }
            var context = this;

            A.each(eventList, function (event) {
                this.fnMap[event] = this.fnMap[event] || [];
                var actionID = this.fnMap[event][fn] = uuid();
                var guardedF    };
                A.declarative(actionID, event, guardedFunc);
                A.declarative.create(context._$element, actionID);
            }, context);
        },

        /**
         * Removes any declarative action matching the events or callback passed
         * @param events: a list of events to remove actions for
         * @param fn: specific callback to remove
         */
        off: function (events, fn) {
            var eventList = events ? events.split(' ') : undefined;
            if (!this.fnMap) {
                P.error.call({}, "There are no callbacks assigned to this component");
            }
            if (eventList && fn) {
                //Remove a specific callback
                A.each(eventList, function (event) {
                    try {
                        A.declarative.remove(this._$element, this.fnMap[event][fn]);
                        delete this.fnMap[event][fn];
                    } catch (e) {
                        P.error.call({}, "The component is not bound to a callback with name " + A.parseFunctionName(fn) || 'anonymous' +
                            " for event " + event);
                    }
                }, this);
            }
            else if (!fn && !eventList) {
                //Remove all
                A.declarative.remove(this._$element);
                delete this.fnMap;
            }
            else if (!fn && eventList) {
                //Remove all callbacks for a set of events
                A.each(eventList, function (event) {
                    for (var callback in this.fnMap[event]) {
                        if (this.fnMap[event].hasOwnProperty(callback)) {
                            this.off(event, callback);
                        }
                    }
                    delete this.fnMap[event];
                }, this);
            }
            else {
                //Can't remove a callback without knowing the event that triggers it
                P.error.call({}, "Please provide an event associated with the callback");
            }
        },

        /**
         * Attaches the component as a trigger for declarative actions corresponding to the specified event, then triggers the event on the component
         * @param signal: the event to trigger
         * @param extraArgs: any extra arguments to be passed to the event callback
         */
        tri    }
    };
});
/////////////////////////
// END FILE components/a_component_mixins.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_component.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Component Class/Factory
 *  Exposes functionality for creating AUI components from a common base.
 *  Handles mixing in methods from a-component-mixins
 */

'use strict';

P.when('A', 'a-component-mixins', 'a-analytics', 'prv:a-sampler')
  .register('a-component', function (A, mixins, analytics, sampler) {

    /**
     * Base component from which new components will inherit;
     * common properties can be initialized here.
     */
    var BaseComponent = A.createClass({
        init: function(selector, context) {
            if (A.contains(selector, '.a-')) {
                P.error("{API} Cannot create components using 'a-' selectors. Apply your own CSS class or ID to select this element.", 'API', 'component');
            }

            this._$element = A.$(selector, context);

            this._trackApi();
        },

        /**
         * Analytics to measure usage of JavaScript component APIs
         */
        _trackApi: function() {
            // Check for invalid/missing component names (undefined, empty string, etc)
            if (this._componentName && sampler("AUI API Analytics")) {
                analytics.increment("api:" + this._componentName);
            }
        }
    });

    /**
     * Create a new component type
     *
     * @param {object} options - an object containing the properties/methods the
            new component should have
     * @return {object}
     */
    function createComponent(options) {
        var toMixin = options.mixin,
            newComponent;

        if(toMixin) {
            delete options.mixin;
        }

        newComponent = BaseComponent.extend(options);

        if(toMixin) {
            A.mixin(newComponent.prototype, mixins, toMixin);
        }

        return newComponent;
    }

    /**
     * Public factory function
     */
    return {
        create: createComponent
    };
});
/////////////////////////
// END FILE components/a_component.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_alert.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Alert API
 */

'use strict';


/**
 *  Alert API allows users to create and manage alerts
 */
P.when('A', 'a-component').register('a-alert', function (A, component) {
    var $ = A.$;
    var TYPES = ['error', 'success', 'warning', 'info'];
    var INLINE_CLASS = 'a-alert-inline';
    var HEADING_CLASS = 'a-alert-heading';

    var normalClasses = A.map(T    }).join(' ');

    var inlineClasses = A.map(T    }).join(' ');

    var header = document.createElement('h4');
    header.className = HEADING_CLASS;
    var $HEADER = $(header);


    /**
     * Constructor for Alert
     *
     * @param {string} selector
     * @param {element or jQuery} context - A DOM Element, Document, or JQuery object to use as context
     */
    var Alert = component.create({
        _componentName: 'alert',
        init: function (selector, context) {
            this._super(selector, context);

            this._$element = this._$element.filter('.a-alert, .' + INLINE_CLASS);
            this._$heading = this._$element.find('.' + HEADING_CLASS);
            this._$content = this._$element.find('.a-alert-content');
        },
        mixin: ['show', 'hide', 'size', 'isEmpty'],

        /**
         * Get/set the heading of the alert
         *
         * @param {string} content - the plaintext heading for the alert
         * @return {string|object}
         */
        heading: function (content) {
            if(typeof content === 'undefined') {
                return this._$heading.text();
            } else {
                if(!this._$heading.length) {
                    this._$heading = $HEADER.clone()
                        .text(content)
                        .insertBefore(this._$content);
                } else {
                    this._$heading.text(content);
                }
            }
            return this;
        },

        /**
         * Remove the alert's heading
         */
        removeHea    },

        /**
         * Get/set the plaintext content of the alert
         *
         * @param {string} content - the text content for the alert
         * @return {string|object}
         */
        text: function (content) {
            if(typeof content === 'undefined') {
                return this._$content.text();
            } else {
                this._$content.text(content);
            }
            return this;
        },

        /**
         * Get/set the html content of the alert
         *
         * @param {string} content - the html content for the alert
         * @return {string|object}
         */
        html: function (content) {
            if(typeof content === 'undefined') {
                return this._$content.html();
            } else {
                this._$content.html(content);
            }
            return this;
        },

        /**
         * Set the alert_type of the alert
         *
         * @param {string} alertType
         */
        type: function (alertType) {
            if (A.indexOfArray(TYPES, alertType) === -1) {
                P.error('{API} Alert type must be one of [error, success, warning, info].', 'API', 'alert');
            }

            this._$element.each(function (index, el) {
                var $el = $(el),
                    prefix = 'a-alert-';

                if($el.hasClass(INLINE_CLASS)) {
                    prefix += 'inline-';
                    $el.removeClass(inlineClasses);
                } else {
                    $el.removeClass(normalClasses);
                }

                $el.addClass(prefix + alertType);
            });

            return this;
        }
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Alert(selector, context);
    };
});
/////////////////////////
// END FILE components/a_alert.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_checkbox.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Checkbox API
 */

'use strict';

/**
 *  Checkbox API allows users to manage the state of AUI checkboxes
 */
P.when('A', 'a-component', 'a-form-controls-api').register('a-checkbox', function (A, component, controls) {
    var $ = A.$,
        setState = controls.setCheckboxState;

    /**
     * Constructor for Checkbox
     *
     * @param {string} selector
     * @param {element or jQuery} context - A DOM Element, Document, or JQuery object to use as context
     */
    var Checkbox = component.create({
        _componentName: 'checkbox',
            },
        mixin: ['show', 'hide', 'size', 'isEmpty'],

        /**
         * Set the checked state of the checkbox
         *
         * @param {boolean} shouldCheck - optional, what checked state to toggle the checkbox into
         * @return {object}
         */
        check: function (shouldCheck) {
            shouldCheck = (shouldCheck === void 0) ? true : shouldCheck;
            this._$element    });
            return this;
        },

        /**
         * Uncheck the checkbox
         *
         * @return {object}
         */
        uncheck: function () {
            return this.check(false);
        },

        /**
         * Toggle each checkbox's checked state
         *
         * @return {object}
         */
        toggleChe    },

        /**
         * Returns true if all checkboxes are checked.
         *
         * @return {boolean}
         */
        isChecked: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                if(!this._$input[i].checked) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Returns true if all checkboxes are unchecked.
         *
         * @return {boolean}
         */
        isUnchecked: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                if(this._$input[i].checked) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Set the enabled state of the checkbox
         *
         * @param {boolean} shouldEnable - optional, what enabled state to toggle the checkbox into
         * @return {object}
         */
        enable: function (shouldEnable) {
            shouldEnable = (shouldEnable === void 0) ? true : shouldEnable;
            this._$element    });
            return this;
        },

        /**
         * Disable the checkbox
         *
         * @return {object}
         */
        disable: function () {
            return this.enable(false);
        },

        /**
         * Toggle each checkbox's disabled state
         *
         * @return {object}
         */
        toggleEnabled: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                setState(this._$element[i], void 0, !this._$input[i].disabled);
            }
            return this;
        },

        /**
         * Returns true if all checkboxes are enabled.
         *
         * @return {boolean}
         */
        isEnabled: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                if(this._$input[i].disabled) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Returns true if all checkboxes are disabled.
         *
         * @return {boolean}
         */
        isDisabled: function () {
            for(var i=0,l=this._$input.length;i<l;i++) {
                if(!this._$input[i].disabled) {
                    return false;
                }
            }
            return true;
        },

        /**
         * Toggle the checkbox visibility
         *
         * @param {boolean} shouldBeVisible - optional, should the element be visible?
         * @return {object}
         */
        toggle: function (shouldBeVisible) {
            if(typeof shouldBeVisible !== 'undefined') {
                shouldBeVisible = !!shouldBeVisible;
            }
            this._$element.each(function() {
                $(this).toggle(shouldBeVisible);
            });
            return this;
        }
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Checkbox(selector, context);
    };
});
/////////////////////////
// END FILE components/a_checkbox.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_meter.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Meter API
 */

'use strict';


/**
 *  Meter API allows users to update meter
 */
P.when('A', 'a-component').register('a-meter', function (A, component) {
    var METER_CLASS = '.a-meter, .a-meter-with-txt';
    var METER_BAR_CLASS = '.a-meter-bar';
    var METER_TEXT_CLASS = '.a-meter-progress-txt';
    var DISABLED_CLASS = 'a-inactive';
    /**
     * Constructor for Meter
     *
     * @param {string} selector
     * @param {element or jQuery} context - A DOM Element, Document, or JQuery object to use as context
     */
    var Meter = component.create({
        _componentName: 'meter',

        init: function (selector, context) {
            this._super(selector, context);

            this._$element = this._$element.filter(METER_CLASS);
            this._$bar = this._$element.find(METER_BAR_CLASS);
            this._$progressTxt = this._$element.find(METER_TEXT_CLASS);
        },

        mixin: ['show', 'hide', 'size', 'isEmpty'],

        /**
         * Get the percentage and text of meter
         *
         * @returns {{percent: *, txt: *}}
         */
           },

        /**
         * Enable the meter
         *
         * @returns {Meter}
         */
        enable: function () {
            this._$element.removeClass(DISABLED_CLASS);
            return this;
        },

        /**
         * Disable the meter
         *
         * @returns {Meter}
         */
        disable: function () {
            this._$element.addClass(DISABLED_CLASS);
            return this;
        },

        /**
         * Return whether the meter is enabled
         *
         * @return {boolean}
         */
        isEnabled: function () {
            return !this._$element.hasClass(DISABLED_CLASS);
        },

        /**
         * get/set the percent of meter
         *
         * @param {Number} [percent] - percentage to set
         * @returns {Meter or String}
         */
        percent: function (percent) {
            if (typeof percent === 'undefined') {
                percent = this._$bar.get(0).style.width;
                return parseInt(percent, 10);
            }

            if (!A.isFiniteNumber(percent)) {
                P.error('{API}  Meter percent should be a number between 0 and 100', 'a-meter', 'setProgress');
            }
            percent = Math.min(100, Math.max(0, percent));
            var percentStr = percent + '%';
            this._$bar.css({width: percentStr});
            this._$element.attr('aria-label', percentStr);
            return this;
        },

        /**
         * get/set the status text of meter
         *
         * @param {String} [txt] - text to be set
         * @returns {Meter or String}
         */
        text: function (txt) {
            if (typeof txt === 'undefined') {
                return this._$progressTxt.text();
            }
            this._$progressTxt.text(txt);
            return this;
        },

        /**
         * Set progress and text
         *
         * @param {Number} percent
         * @param {String} txt
         * @returns {Meter}
         */
        set: function (percent, txt) {
            this.percent(percent);
            if (txt) {
                this.text(txt);
            }
            return this;
        }
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Meter(selector, context);
    };
});
/////////////////////////
// END FILE components/a_meter.js
/////////////////////////
/////////////////////////
// BEGIN FILE components/a_spinner.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Spinner API
 */
P.when('a-component').register('a-spinner', function (component) {
    'use strict';

    /**
     * Constructor for Spinner
     *
     * @param {String} selector
     * @param {Element or jQuery} context - A DOM Element, Document, or JQuery to use as context
     */
    var Spinner = component.create({
        _componentName: 'spinner',
            },

        mixin: ['show', 'hide', 'isEmpty', 'size'],

        re    }

        // TODO add create function
        // something like the below, but ideally generated from the spinner.yada file
        // w?User:Freitas/SpinnerCreateAPI
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Spinner(selector, context);
    };
});
/////////////////////////
// END FILE components/a_spinner.js
/////////////////////////
/////////////////////////
// BEGIN FILE extras/a_ua.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Amazon UI User Agent Helpers
'use strict';

P.register('a-ua', function () {
  /**
   *  Determines whether a given an arbitrarily delimited multi-part version number is greater than another
   *  for versions that are patterned as positive real numbers, including 0, separated by string delimiters
   *  (or no delimiter, explicitly)
   *
   *  @param {string} firstVersion The first version number to compare
   *  @param {string} secondVersion The second version number to compare
   *  @param {string} [delimiter="."] The string used to split the version number into comparable parts
   *
   *  @return {int} Either -1, 0, or 1.
   *                -1: firstVersion is lower
   *                 0: versions are equal
   *                 1: firstVersion is higher
   */
  function compareVersions(firstVersion, secondVersion, delimiter) {
    var incompara    };
    
    // guards against "" delimiter
    delimiter = delimiter || ".";

    if (typeof firstVersion !== "string" || typeof secondVersion !== "string" || typeof delimiter !== "string" || firstVersion === "" || secondVersion === "") {
      // Checking empty string is necessary when using Number as Number("") evaluates to 0, "funfortunately."
      incomparable("Input values are not valid.");
    }

    var firstPieces = firstVersion.split(delimiter);
    var secondPieces = secondVersion.split(delimiter);
    var comparisonLength = Math.max(firstPieces.length, secondPieces.length);

    for (var i = 0; i < comparisonLength; i++) {
      // Use Number instead of parseInt for better handling of "8b" which parseInt
      // cannot handle properly and should not evaluate as equivalent to "8".
      var partFromFirst = (i < firstPieces.length) ? Number(firstPieces[i]) : 0;
      var partFromSecond = (i < secondPieces.length) ? Number(secondPieces[i]) : 0;

      if (isNaN(partFromFirst) || !isFinite(partFromFirst) || isNaN(partFromSecond) || !isFinite(partFromSecond)) {
        incomparable("Piece of one version number evaluates to NaN or +/- Infinity.");
      }

      if (partFromFirst < partFromSecond) {
        return -1;
      }
      if (partFromFirst > partFromSecond) {
        return 1;
      }
    }
    
    return 0;
  }
  
  return {
    compareVersions: compareVersions
  };
});
/////////////////////////
// END FILE extras/a_ua.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_template_errors.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/*
*    NOTE: Here we are waiting on afterLoad event to parse and throw errors. The reason for this is
*          to allow other  higher-priority customer-impacting tasks to finish.
*          And we do NOT want to overwhelm the browser with this task which is of lesser-
*          priority compared to other tasks.
*/
P.when('a-base', 'a-util', 'a-analytics', 'afterLoad').execute('a-template-errors', function(base, util, analytics) {
    var $ = base.$;
    var ERROR_CSS_SELECTOR = ".a-template-errors";
    var ERROR_DATA_KEY = "template-errors";
    var ERROR_DATA_SEARCH_KEY = "[data-" + ERROR_DATA_KEY + "]";
    var logLevel = "ERROR";

    /**
    * An object which keeps track of the count of the no. of times for which an error with a given attribution has been thrown on the page.
    * Example entry :: <"test_attr_validations:heading:non_blank_string_validation" : 10>
    */
    var attributionWiseErrorCount = {};

    /**
     * Parses the DOM for template errors logged from the server-side. For each error found calls parseErrAndUpdateCount to
     * parse and update attributionWiseErrorCount map.
    */
    function parseDOMForTemplateErrors(){
        $(ERROR_CSS_SELECTOR).each(function(){
            var $elemWithErrorClass = $(this);
            // NOTE: Ideally both the a-template-errors and the data-attributes should be attached on the same
            //       element. But for one or two templates I noticed that data-attributes were added in
            //       an element somewhere down the tree. So here we are trying to search for those scenarios as well.
            var templateErrors = $elemWithErrorClass.data(ERROR_DATA_KEY) || $elemWithErrorClass.find(ERROR_DATA_SEARCH_KEY).data(ERROR_DATA_KEY);
            if(templateErrors && templateErrors.length > 0){//NOTE: there is a bug currently in util.each and it fails if obj passed is undefined.
                util.each(templateErrors, function(error){
                    parseErrAndUpdateCount(error);
                });
            }
        });
    }

    /**
    * Parse template-error and combine errors which have same attribution and maintains a count.
    * @param {String} error : Error found in DOM. Looks like : "template_name:attr_name:<validation_type>_validation:attr_value:validation msg"
    */
    function parseErrAndUpdateCount(error){
        /*
        * From error that looks like : "template_name:attr_name:<validation_type>_validation:attr_value:validation msg",
        * extracts and the attribution which looks like : "template_name:attr_name:<validation_type>_validation".
        * NOTE: We are using "split" here instead of regex because using split is slightly faster. I created this perf-test
        *       to verify this : http://jsperf.com/js-split-vs-regex-match.
        */
        var attribution = error.split(":").slice(0, 3).join(":");

        // add an entry for attribution if not already present. Means this is the first error for that attribution.
        if(!attributionWiseErrorCount[attribution]){
            attributionWiseErrorCount[attribution] = 0;
        }
        attributionWiseErrorCount[attribution] += 1;
    }

    /**
    * Returns the error signature to be reported to RTLA.
    * NOTE: Instead of reporting the exact count  of errors for a given attribution to RTLA, we report them in bunch like if the
    * errorCount is 127, we would say the count is b/w 100 and 1000. This is because fatals.amazon.com tracks errors across
    * requests based on the long signature. Reporting the exact count would result in long signatures being different across pages.
    * However we also want to give some indication on how many errors are thrown. So here we have taken a mid-way path.
    *
    * @param {String} errorAttribution - looks like "template_name:attr_name:<validation_type>_validation"
    * @param {Number} errorCount - No. of times this error has been reported on the page.
    * @return {String} looks like "<attr_name> attribute failed <validation_type>_validation in <template_name>.
    *                               This error is thrown between <lowerBound> and <upperBound> number of times on the page."
    */
    function constructErrorMessageFromAttribution(errorAttribution, errorCount){
        var err = errorAttribution.split(":");
        // NOTE: 1) Here we are trying to figure out which range of a mulitple of 10 does the errorCount falls
        //       2) We are NOT using Math.log10 here as that is NOT supported in all browsers. Instead
        //          we are doing : Math.log(errorCount)/Math.log(10)
        var lowerBound = Math.pow(10, Math.floor(Math.log(errorCount)/Math.log(10)));
        var upperBound = lowerBound * 10;
        return (err[1] + " attribute failed " + err[2] + " in " + err[0] + " template. This error is thrown between " + lowerBound + " and " + upperBound + " number of times on the page.");
    }

    /**
    * Logs error for each error-attribution reported on the page.
    */
    function ueLogTemplateErrors(){
        util.each(attributionWiseErrorCount, function(errorCount, errorAttribution){
            var errorMessage = constructErrorMessageFromAttribution(errorAttribution, errorCount);
            analytics.logError(errorMessage, logLevel, errorAttribution);
        });
    }

    parseDOMForTemplateErrors();
    ueLogTemplateErrors();
});
/////////////////////////
// END FILE a_template_errors.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_log_trigger.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Logs two CSM counters representing the number and duration of
 * scheduled callbacks executed via P prior to the passed event.
 * This relies on the debug data format defined in AmazonUIPageJS
 * and is called automatically from P.trigger.
 */
P.when('a-analytics', 'prv:p-debug', 'ready').execute(function(analytics, debug) {
    P.declare('prv:a-logTrigger', function reportCallbackBlocking(event) {
        var threshold = debug[event] && debug[event].registered || 0;
        var count = 0;
        var duration = 0;
        for (var key in debug) {
            if (debug.hasOwnProperty(key)) {
                var datum = debug[key];
                if (datum.end && datum.end <= threshold) {
                    count++;
                    duration += datum.end - datum.start;
                }
            }
        }
        analytics.count("blocking-count:"+event, count);
        analytics.count("blocking-time:"+event, Math.round(duration));
    });
});
/////////////////////////
// END FILE a_log_trigger.js
/////////////////////////
/////////////////////////
// BEGIN FILE extras/a_unicode_rupee_test.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

P.when('jQuery', 'a-analytics', 'load').register('a-unicode-rupee-test', function ($, analytics) {

    var UNICODE_RUPEE  = '&#8377;';
    var UNICODE_NOCHAR = '&#65534;';

    var METRIC_SUPPORTED   = 'aui-supported-rupee';
    var METRIC_UNSUPPORTED = 'aui-unsupported-rupee';

    /* Test Setup */
    function _setup() {

        // _jqElement returns a jQuery object
        var container = $('<div/>');
        var nochar    = $('<span/>').html(UNICODE_NOCHAR);
        var rupee     = $('<span/>').html(UNICODE_RUPEE);

        container.append(nochar, rupee);
        container.appendTo(document.body);

        // Return a NATIVE DOM reference to these created elements.
        return {
            container: container,
            nochar: nochar,
            rupee: rupee
        };
    }

    /* Test Running */
    function test() {

        // jQuery objects returned from setup.
        var refs = _setup();

        var WIDTH_RUPEE  = refs.rupee.width();
        var WIDTH_NOCHAR = refs.nochar.width();

        /*
            Compare the Rupee width with the width of a purposefully
            undefined character. If they're the same, Rupee is unsupported
        */
        if( WIDTH_RUPEE === WIDTH_NOCHAR ) {
            analytics.increment(METRIC_UNSUPPORTED, 1);
        }
        else {
            analytics.increment(METRIC_SUPPORTED, 1);
        }

        // Teardown and remove the nodes, test complete.
        refs.container.remove();
    }

    // Run the test immediately, set finished to true. Return nothing
    test();

});

/////////////////////////
// END FILE extras/a_unicode_rupee_test.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_sampler.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Provides a function which takes an experiment name,
 * and returns a boolean if the experiment is active.
 *
 * Example:
 * P.when('a-sampler').execute(function(sampler) {
 *   if (sampler('AUI API Analytics')) {
 *     // will execute for 5% of page loads
 *   }
 * });
 *
 */

"use strict";

// TODO: This should be set in page template (and generated server-side).
P.register("prv:a-sampler-inclusion", function () {
  return {
    "AUI API Analytics": (Math.random() < 0.01)
  };
});

P.when("prv:a-sampler-inclusion")
  .register("prv:a-samp;
  });
/////////////////////////
// END FILE a_sampler.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_ember.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * See also: a-fonts module for the font loading mechanism.
 */
P.when('A', 'load').execute('a-ember', function (A) {
  // We block UC Browser for now, it's triggering too many script errors
  // Also, no need to do anything else if localStorage is not available
  if (!A.capabilities.isUCBrowser &&
        A.localStorage &&
        A.localStorage.getItem('a-font-class') !== 'a-ember') {
          
    P.when('a-fonts').execute('a-ember-loader', function (fonts) {
      fonts.load('1em Amazon Ember');
      fonts.load('bold 1em Amazon Ember');
      fonts.load('italic 1em Amazon Ember');
      fonts.load('italic bold 1em Amazon Ember');

      fonts.ready    });
    });
  }
});
/////////////////////////
// END FILE a_ember.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_pcv.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Helper module for getting Package Closure Version (PCV)
 * from `window.pcv` object.
 */
P.when('load').register('a-pcv', function () {
  var packageList = window.pcv || {};
  
  // Inject AmazonUI's PCV into HTML tag
  var HTML_ATTRIBUTE_KEY = 'data-aui-version';
  var auiVersion = packageList.AmazonUI;
  if (auiVersion) {
    document.documentElement.setAttribute(HTML_ATTRIBUTE_KEY, auiVersion);
  }
});
/////////////////////////
// END FILE a_pcv.js
/////////////////////////
/////////////////////////
// BEGIN FILE a_perf.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';
// When 'A' is ready, JS and CSS should have been loaded
// performance entries should have been populated.
P.when('A', 'a-analytics').register('prv:a-asset-transfer', function(A, analytics) {
    

    var RESOURCE_NAME_REGEX = /AUIClients\/(.*?(?=(?:#)|$))/,
        PERF_SUPPORTED = window && 
            window.performance &&
            window.performance.getEntries &&
            typeof window.performance.getEntries === 'function';

    /**
     * Extract the first substring encountered using a provided regex.
     * When default value is provided and no substring found, return the default value
     * otherwise return empty string.
     * @param regex the regex
     * @param source the string to extract the substring
     * @param defaultVal the default value.
     * Example: 
     *  extractByRegex(/foo([^\s]+)/, "this is a foobar string. How about foo bar?", "") => "bar"
     *  extractByRegex(/foo([^\s]+)/, "this is a foo bar string. How about foobar?", "") => "bar?"
     *  extractByRegex(/foo([^\s]+)/, "this is a foo bar string. How about foo bar?", "") => ""
     */
    function extractByRegex(regex, source, defaultVal) {
        var matches = regex.exec(source);
        return matches && matches.length >= 2 ? matches[1] : defaultVal || '';
    }

    function getResourceName(entry) {
        var resourceNameParts = [
            entry.initiatorType,
            extractByRegex(RESOURCE_NAME_REGEX, entry.name || '')
        ];
    
        return resourceNameParts.join(':');
    }

    function getAuiPerfEntries() {
        return A.filter(window.performance.getEntries({ entryType: 'resource' }), function(entry) {
            return (entry.initiatorType === 'link' || entry.initiatorType === 'script') && 
                entry.name && 
                entry.name.indexOf('AUIClients/AmazonUI') > 0; // this should cover AmazonUISkinSky
        });
    }

    return function() {
        if (!PERF_SUPPORTED) {
            return;
        }
        A.each(getAuiPerfEntries(), function(entry) {
            var resourceName = getResourceName(entry);
            // this is to log a count for aui:script|link:AmazonUI*:dataPoint
            // we are logging directly to CSM counters so that we don't need
            // to do additional onboarding beside whitelisting
            analytics.count(resourceName + ':startTime', entry.startTime || 0);  
            analytics.count(resourceName + ':responseEnd', entry.responseEnd || 0);
        });
    };
});

P.when('prv:a-asset-transfer').execute('a-asset-transfer-time', function(collectTransferTime) {
    // only 5% of the traffic will be logged.
    if (Math.random() < 0.05) {
        collectTransferTime();
    }
});
/////////////////////////
// END FILE a_perf.js
/////////////////////////
/////////////////////////
// BEGIN FILE touch/touchpress/a_touchpress.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Nothing to see here (no touchpress for desktop)
/////////////////////////
// END FILE touch/touchpress/a_touchpress.js
/////////////////////////
/////////////////////////
// BEGIN FILE touch/a_touch_recognize.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE touch/a_touch_recognize.js
/////////////////////////
/////////////////////////
// BEGIN FILE touch/a_touch.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE touch/a_touch.js
/////////////////////////
/////////////////////////
// BEGIN FILE touch/a_touch_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE touch/a_touch_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE touch/a_immersive_image.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE touch/a_immersive_image.js
/////////////////////////

// END ASSET AmazonUIBaseJS-3.1.1625.91
}));
////////////////////////////////////////////
/* ******** */

/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIButton", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIButton-3.1.1365.66
/////////////////////////
// BEGIN FILE button.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Button API
 */

'use strict';


/**
 *  Button API which allows users to select buttons and act on them.
 */

P.when('A', 'a-component').register('a-button', function (A, component) {

    var DISABLED_CLASS = 'a-button-disabled';
    var FOCUS_CLASS = 'a-button-focus';
    function eventHandler (event) {
        event.preventDefault();
    }



    /**
     * Constructor for Button Input
     *
     * @param {String} selector
     * @param {Element or jQuery} context - A DOM Element, Document, or JQuery to use as context
     */
    var Button = component.create({
        _componentName: 'button',
            },

        mixin: ['show', 'hide', 'toggle', 'isEmpty', 'size', 'on', 'off', 'trigger'],

        /**
         * Enable the button
         */
        enable: function () {
            this._$element.removeClass(DISABLED_CLASS);
            this._$coreFormElement.prop('disabled', false);
            this._$coreLinkElement.unbind('click', eventHandler);

            return this;
        },

        /**
         * Disable the button
         */
        disable: function () {
            this._$element.addClass(DISABLED_CLASS).removeClass(FOCUS_CLASS);
            this._$coreFormElement.prop('disabled', true);
            this._$coreLinkElement.click(eventHandler);

            return this;
        },

        /**
         * Return whether the button is enabled
         * @return {boolean}
         */
        isEnabled: function () {
            // We are assuming the core(Form/Link)Element piece of the button is in sync here.
            // If they are using our api the DISABLED_CLASS can be the source of truth.
            return !this._$element.hasClass(DISABLED_CLASS);
        },

        /**
         * Sets the button's status
         * @param newStatus - The new status value to set
         */
        setStatus: function (newStatus) {
            var $el = this._$element;
            var validStatuses = [null, "normal", "selected", "disabled", "error", "inactive"];
            var isStatusInvalid = A.indexOfArray(validStatuses, newStatus) < 0;
            var isInGroup = $el.attr('role') === 'radio';

            var removeOldSta    };
            var setAriaChecked = function (ind, currentAriaChecked) {
                return isInGroup ? newStatus === 'selected' : currentAriaChecked;
            };

            if (isStatusInvalid) {
                P.error(newStatus + " is not a valid status");
                return false;
            }

            A.each(validStatuses, removeOldStatus);

            this._$coreFormElement.prop('disabled', newStatus === 'disabled');
            $el.attr('aria-checked', setAriaChecked);

            if (newStatus !== null) {
                $el.addClass('a-button-' + newStatus);
            }
            return this;
        },

        /**
        * Return the button text
        * @return {string|object}
        */
        text: function (text) {
            if (this._$contentElement.length < 1 ) {
                return;
            }
            if (typeof text === 'undefined') {
                return this._$contentElement.text();
            } else {
                this._$contentElement.text(text);
            }
            return this;
        }
    });

    /**
     * Public factory function
     */
    return function (selector, context) {
        return new Button(selector, context);
    };
});
/////////////////////////
// END FILE button.js
/////////////////////////
/////////////////////////
// BEGIN FILE toggle_button.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Toggle Button API
 */

'use strict';


/**
 *  Button API which allows users to select buttons and act on them.
 */

P.when('A', 'a-component').register('a-toggle-button', function (A, component) {

  var DISABLED_CLASS = 'a-button-disabled';
  var UNAVAILABLE_CLASS = 'a-button-unavailable';
  var SELECTED_CLASS = 'a-button-selected';
  var FOCUS_CLASS = 'a-button-focus';
  var validStatusClasses = [SELECTED_CLASS, FOCUS_CLASS];

  /**
   * prevents default behaviour of link
   * @param  {Object} event - An event object passed into link click handler callback
  ;
  }

  /**
   * Remove valid status classes for toggle button
   * @param {Object} Button
  ;
  }

  /**
   * Checks whether button is empty or not
   *
   * @param {Object} Button
   * @param {boolean} returns true if button is empty
  ;
  }

  /**
   * Constructor for Button Input
   *
   * @param {String} selector
   * @param {Element or jQuery} context - A DOM Element, Document, or JQuery to use as context
   */
  var ToggleButton = component.create({
    _componentName: 'toggleButton',
        },

    /**
     * get name of the toggle button
     * @return {String} toggle button name
     */
        },

    /**
     * Enable the Toggle Button
     */
    enable: function () {
      this._$element.removeClass(DISABLED_CLASS);
      this._$coreFormElement.prop('disabled', false);
      // Links can not be disabled using disabled property.
      // To disable the link , default clickable behaviour is prevented when buttons are disabled.
      // For resuming the default clickable behaviour, unbind click event from link
      this._$coreLinkElement.unbind('click', preventDefault);
      return this;
    },

    /**
     * Disable the toggle button
     */
    disable: function () {
      removeValidStatusClass(this);
      this._$element.addClass(DISABLED_CLASS);
      this._$coreFormElement.prop('disabled', true);
      // Links can not be disabled using disabled property.
      // To disable the link , default clickable behaviour is prevented in click handler when buttons are disabled.
      this._$coreLinkElement.click(preventDefault);
      return this;
    },

    /**
     * Set available toggle button
     */
    setAvailable: function() {
      this._$element.removeClass(UNAVAILABLE_CLASS);
      return this;
    },

    /**
     * Set unavailable toggle button
     * @return {Object} Button object
     */
    setUnavailable: function() {
      this._$element.addClass(UNAVAILABLE_CLASS);
      return this;
    },

    /**
     * Checks whether the button is enabled
     * @return {boolean}
     */
    isEnabled: function () {
      return !isEmpty(this) && !this._$element.hasClass(DISABLED_CLASS);
    },

    /**
     * set toggle button as selected
     * @return {Object} button
     */
    setSelected: function() {
      if(!isEmpty(this) && this.isEnabled()) {
        this._$element.addClass(SELECTED_CLASS + ' ' + FOCUS_CLASS).attr("aria-checked", "true");
      }
      return this;
    },

    /**
     * set toggle button unselected
     * @return {Object} Button object
     */
    setUnsele    },

    /**
     * Checks whether the button is selected
     * @return {boolean}
     */
    isSelected: function() {
      return !isEmpty(this) && this._$element.hasClass(SELECTED_CLASS);
    },

    /**
     * Checks whether the button is available
     * @return {boolean}
     */
    isAvailable: function() {
      return !isEmpty(this) && !this._$element.hasClass(UNAVAILABLE_CLASS);
    }
  });

  /**
   * Public factory function
   */
  return function (selector, context) {
    return new ToggleButton(selector, context);
  };
});
/////////////////////////
// END FILE toggle_button.js
/////////////////////////
/////////////////////////
// BEGIN FILE toggle_button_group.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * AUI Toggle buttons API
 */

'use strict';

/**
 *  Toggle Buttons API which allows users to select button and act on them.
 */

 P.when('A', 'a-component', 'a-toggle-button').register('a-toggle-button-group', function(A, component, getToggleButton) {

  /**
   * Constructor for Toggle button group
   *
   * @param {String} selector
   * @param {Element or jQuery} context - A DOM Element, Document, or JQuery to use as context
   */
  var ToggleButtonGroup = component.create({

    _componentName: 'toggleButtonGroup',

    init: function(selector, context) {
      var buttonGroupData;
      this._super(selector, context);
      this._$toggleGroupElement = this._$element.filter('.a-button-group, .a-button-toggle-group').eq(0);
      buttonGroupData = this._$toggleGroupElement.data('a-button-group');
      this._$toggleGroupName = buttonGroupData ? buttonGroupData.name : undefined;
    },

    /**
     * get name of the toggle button group
     * @return {String} toggle button
     */
        },

    /**
     * Returns button object based on button name
     * @param  {String} buttonName
     * @return {Object} toggle button object created using buttonName
     */
    getToggleButtonBy    },

    /**
     * set selected Button
     * @param  {String} buttonSelector
     */
    setSelected: function(buttonSelector) {
      var toggleButton = this.getToggleButtonBySelector(buttonSelector);
      if(toggleButton.isEnabled()) {
        this.getSelected().setUnselected();
        toggleButton.setSelected();
      }
      return this;
    },

    /**
     * returns the selected toggle button object
     * @return {Object} toggle button
     */
    getSele    },

    /**
     * get Toggle button object using selector
     * @param  {string} selector
     * @return {Object} Toggle button object
     */
    getToggleButtonBySele    }
  });

  /**
   * Public factory function
   */
  r;
  };
});
/////////////////////////
// END FILE toggle_button_group.js
/////////////////////////

// END ASSET AmazonUIButton-3.1.1365.66
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIMeter", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIMeter-3.1.1258.91
/////////////////////////
// BEGIN FILE js/meters.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

// This is for issue AUI-3868
// TODO: it would be great to have unit tests for this, but dependence on A.onScreen makes that difficult
// TODO: look into adding a-popover-ajax into popover so we can better target the visibility code for ajax popover only
P.when("A", "ready").register("a-meters", function (A) {
  var $ = A.$;

  // This will be too slow without native classname support (IE8 and older).
  if(!!document.getElementsByClassName){

    var DOT_A_METER_BAR = '.a-meter-bar',
        A_METER_UNFILLED = 'a-meter-unfilled',
        DOT_A_METER_UNFILLED = '.' + A_METER_UNFILLED,
        DOT_A_MANUAL_ANIMATION = '.a-manual-animation';

    var changeUnfilledToFil    }

    var initializeHistogram = function (event) {
      $(DOT_A_METER_UNFILLED).each(function () {
        var $this = $(this);
        if(A.onScreen($this,0)){
          changeUnfilledToFilled($this);
        }
      });
    }

    var initializeHistogramPopover = function (event) {
      // only perform the following for non-ajax popovers to avoid race condition
      if(event.popover.currentDataStrategy !== "ajax") {
        var $meterBars = event.popover.$popover.find(DOT_A_METER_UNFILLED);
        if($meterBars.length) {
          changeUnfilledToFilled($meterBars);
        }
      }
    }

    var initializeHistogramPopoverAjax = function (event) {
      var $meterBars = event.popover.$popover.find(DOT_A_METER_BAR).not(DOT_A_MANUAL_ANIMATION);
      if($meterBars.length) {
        // Since meter doesn't exist in DOM for popovers that use Ajax, we have to add .a-meter-unfilled after a:popover:ajaxContentLoaded
        $meterBars.addClass(A_METER_UNFILLED);
        // The delay is here so that the browser doesn't try to optimize class removal so animation renders
        A.delay(function() {
          changeUnfilledToFilled($meterBars);
        }, 17);
      }
    }

    // For meters offscreen, add .a-meter-unfilled to remove meter value
    // Note that this class only impacts display in conjunction with .a-meter-animate
    $(DOT_A_METER_BAR).not(DOT_A_MANUAL_ANIMATION).each(function () {
      var $this = $(this);
      if(!A.onScreen($this,0)){
        $this.addClass(A_METER_UNFILLED);
      }
    });

    $('body').addClass('a-meter-animate');

    // Check if histogram is onscreen and should be animated upon resize, orientationchange, and scroll
    A.on("resize orientationchange scroll", initializeHistogram);

    // Check if histogram comes on screen after a:popover:afterShow
    A.on("a:popover:afterShow", initializeHistogramPopover);

    // Check if histogram comes on screen after a:popover:ajaxContentLoaded
    A.on("a:popover:ajaxContentLoaded", initializeHistogramPopoverAjax);
  }
});
/////////////////////////
// END FILE js/meters.js
/////////////////////////
// END ASSET AmazonUIMeter-3.1.1258.91
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIStandardComponent", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIStandardComponent-1.0.2089.91
/////////////////////////
// BEGIN FILE js/a_sc.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AUI Standard Component

"use strict";

P.when('A', 'prv:a-sc-component-factory').register('a-sc', function(A, ComponentFactory) {

    var rootFactory = new ComponentFactory();

    // Public touchpoint for the library. `spec` documentation is in a_sc_define.
    function define(spec) {
        // Safety check to ensure any child components specified are valid factory objects
        if(spec.components) {
            A.each(spec.components, function(childFactory) {
                if(!(childFactory instanceof ComponentFactory)) {
                    throw new Error('You must provide a component factory when specifying child components');
                }
            });
        }

        return rootFactory.redefine(spec);
    }

    return {
        define: define
    }
});
/////////////////////////
// END FILE js/a_sc.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_util.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AUI Standard Component Util

P.when('A').register('prv:a-sc-util', function (A) {

  var defineProperty = Object.defineProperty;

  // Check if userAgent supports defineProperty on non-DOM objects
  // see http://stackoverflow.com/questions/4819693/working-around-ie8s-broken-object-defineproperty-implementation
  var supportsFullDefinePropertySpec = (function () { 
    try { 
      defineProperty({}, 'x', {});
      return true;
    } catch (e) {
      return false; 
    } 
  }());

  // ie8 fallback only supports setting value on object property, will have no
  // effect on property's other descriptors (getter, setter, writable, etc),
  // once ie8 support is dropped, this fallback can be removed
  function definePropertyIE8Fallback(obj, prop, descriptor) {
    if ('value' in descriptor) {
      obj[prop] = descriptor.value;
    }
    return obj;
  }

  return {
    defineProperty: 
      supportsFullDefinePropertySpec ? 
        defineProperty : definePropertyIE8Fallback
  };
});
/////////////////////////
// END FILE js/a_sc_util.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AUI Standard Component

"use strict";

P.when('A', 'prv:a-sc-util').register('prv:a-sc-base', function(A, util) {
    var def = util.defineProperty;

    /**
     * Base class from which Components and Transition Proxies are derived.
     * Contains the IDs that are used to store and reference component
     * specifications, their constituent parts and relationships.
     *
     * @param {number} sid The ID of the component specification
     * @param {number} id The ID of the component instance
     * @param {number} pid The ID of the parent instance
     */
    var BaseComponentState = A.createClass({
        init: function(sid, id, pid) {
            def(this, '__sid', { value: sid });
            def(this, '__id', { value: id });
            def(this, '__pid', { value: pid });

            // True if a component has no parent component
            def(this, 'isRoot', { value: !pid, writable: false });
        },
        // Allows us to use objects derived from this base class as keys in registries
        // So instead of having to type __id all over the place, you can just use 'this'
        toSt    }
    });

    /**
     * Base class from which all Components are derived.
     * Extends BaseComponentState with instance transition state.
     *
     * @param {number} sid The ID of the component specification
     * @param {number} id The ID of the component instance
     * @param {number} pid The ID of the parent instance
     */
    var BaseComponent = BaseComponentState.extend({
        init: function(sid, id, pid) {
            this._super(sid, id, pid);

            // The index of the current state. By default, components are in
            // the 'uninitialized' state, or -1
            def(this, '__at', { value: -1, writable: true });

            // The index of the target state. This should be null when not
            // transitioning.
            def(this, '__to', { value: null, writable: true });

            // Used to indicate that a component is transitioning and external
            // calls to its lifecycle methods should be ignored.
            def(this, '__busy', { value: false, writable: true });
        }
    });

    return {
        ComponentState: BaseComponentState,
        Component: BaseComponent
    }
});
/////////////////////////
// END FILE js/a_sc_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_registry.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Standard Component Registry

'use strict';

P.when('prv:a-sc-datastore').register('prv:a-sc-registry', function(ds) {

    var specifications = {}, // Component specification objects
        constructors = {},   // Component constructors
        instances = {},      // Component instances
        datastores = {},     // Datastore instances
        hierarchy = {},      // Map of component IDs to their child components
        elements = {},       // Managed DOM element references
        handlers = {},       // Internal event handlers
        nextInstanceId = 0,
        nextSpecificationId = 0;

    // Convert map of child ids to list of instances
    function children(instance) {
        var map = hierarchy[instance],
            list = [],
            name;

        for(name in map) {
            if(map.hasOwnProperty(name)) {
                list.push(instances[map[name]]);
            }
        }

        return list;
    }

    return {
        specifications: specifications,
        constructors: constructors,
        instances: instances,
        datastores: datastores,
        hierarchy: hierarchy,
        elements: elements,
        handlers: handlers,
        children: children,
        getNextInstanceId: function() {
            return ++nextInstanceId;
        },
        getNextSpecificati    }
    }

});
/////////////////////////
// END FILE js/a_sc_registry.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_lifecycle.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Standard Component Lifecycle

'use strict';

P.when('A', 'prv:a-sc-util').register('prv:a-sc-lifecycle', function(A, util) {
    var def = util.defineProperty;

    // Return a default function for Lifecycle.implement if the caller does
    // not provide on    }

    // States define their name and the names of the methods used to
    // enter or leave them    }

    // Utility class method for creating a State
    State.cre    };

    // A lifecycle is just a list of state    }

    // Index of a state by its name
    Lifecycle.prototype.inde    };

    // Name of enter method for an index
    Lifecycle.prototype.enterForIndex = function(index) {
        return this.states[index].enter;
    };

    // Name of leave method for an index
    Lifecycle.prototype.leaveForIndex = function(index) {
        return this.states[index].leave;
    };

    // Get an array of method names based on current and target state
    Lifecycle.prototype.getTransitionArray = function(at, to) {
        var up = at < to,
            type = up ? 'enter' : 'leave',
            step = up ? 1 : -1,
            names;

        names = A.map(A.range(up ? at + 1: at, to + step, s    }, this);

        // up ? names.shift() : names.pop();

        return names;
    };

    // Takes a POJO with lifecycle methods and adds default NOOP/debug implementations for any missing methods
    Lifecycle.prototype.implement = function(methods, getDefault) {
        methods = methods || {};
        getDefault = (typeof getDefault === 'function') ? getDefault : _getDefaultFunction;

        return A.reduce(this.st    }, {});
    };

    // Utility class method for creating states and lifecycles using array of arrays
    // This is all we'll expose to the outside world
    Lifecycle.create = function(specs) {
        var states = A.map(s    });

        return new Lifecycle(states);
    };

    // Expose the lifecycle create helper
    return {
        create: Lifecycle.create
    }
});
/////////////////////////
// END FILE js/a_sc_lifecycle.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_lifecycle_instances.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Standard Component Lifecycle

'use strict';

P.when('prv:a-sc-lifecycle').register('prv:a-sc-lifecycle-instances', function(lc) {
    var standardLifecycle = lc.create([
        ["created", "create", "destroy"],
        ["loaded", "load", "unload"],
        ["rendered", "render", "remove"],
        ["visible", "show", "hide"]
    ]);

    return {
        standard: standardLifecycle
    }
});
/////////////////////////
// END FILE js/a_sc_lifecycle_instances.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_eventemitter.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Standard Component Event Emitter Mixin

'use strict';

P.when('A').register('prv:a-sc-event-emitter', function(A) {
    // Event names can be split on whitespace
    var splitter = /\s+/;

    var events = {

        // Register a handler for one or more event names
        on: function(names, handler, context) {
            names = splitter.test(names) ? names.split(splitter) : names;

            if(A.isArray(names)) {
                A.each(n    }, this);
            } else {
                (this.__events[names] || (this.__events[names] = [])).push({
                    handler: handler,
                    context: context || this
                });
            }
            return this;
        },

        // Remove handlers for one or more event names
        off: function(names, handler) {
            var handlers, keep;

            // Remove all handlers if no arguments are passed
            if(!names && !handler) {
                this.__events = {};
                return this;
            }

            names = splitter.test(names) ? names.split(splitter) : names;

            if(A.isArray(names)) {
                A.each(n    }, this);
                return this;
            }

            // If no handler is specified, remove all handlers for the event
            if(!handler) {
                delete this.__events[names];
                return this;
            }

            handlers = this.__events[names];
            this.__events[names] = keep = [];

            A.each(hand    }, this);

            // Remove the empty array for consistency
            if(!keep.length) {
                delete this.__events[names];
            }

            return this;
        },

        // Trigger a single event by name
        trigger: function(name) {
            var args, handlers;

            if(!this.__events || !name) {
                return this;
            }

            handlers = this.__events[name];
            if(!handlers) {
                return this;
            }

            args = [].slice.call(arguments, 1);

            A.each(hand    });

            return this;
        }

    };

    return {
            },
        m    }
    }
});
/////////////////////////
// END FILE js/a_sc_eventemitter.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_define.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AUI Standard Component Define

"use strict";

P.when('A', 'prv:a-sc-base', 'prv:a-sc-lifecycle-instances', '3p-promise', 'prv:a-sc-default-datastore', 'prv:a-sc-registry', 'prv:a-sc-component-proxies')
    .register('prv:a-sc-define', function(A, base, lc, Promise, DefaultDatastore, reg, proxies) {

    var standardLifecycle = lc.standard,
        specifications = reg.specifications,
        constructors = reg.constructors,
        instances = reg.instances,
        datastores = reg.datastores,
        hierarchy = reg.hierarchy,
        handlers = reg.handlers,
        componentPrototype, state, StandardComponent;

    function _getTransitionMethod(to, up) {
        return function() {
            var self = this,
                spec = specifications[this.__sid],
                prms = Promise.resolve(),
                at = this.__at,
                methodNames, next;

            // Disallow illogical transitions
            if(at === to || (up && at > to) || (!up && at < to)) {
                return prms;
            }

            // Get a list of method names we should call
            methodNames = standardLifecycle.getTransitionArray(at, to);

            // Queue them up in a promise chain
            while((next = methodNames.shift())) {
               }(next));
            }

            // Handle errors
            // TODO: flesh out the error handling https://sim.amazon.com/issues/AUI-8265
            return prms['catch'](function(err) {
                console.error(err);
            });
        }
    }

    componentPrototype = {
            }
    };

    // Implement lifecycle transitions on the prototype
    for(var i=0; i<standardLifecycle.states.length; i++) {
        state = standardLifecycle.states[i];

        // Transition up
        componentPrototype[state.enter] = _getTransitionMethod(i, true);

        // Transition down
        componentPrototype[state.leave] = _getTransitionMethod(i, false);
    }

    StandardComponent = base.Component.extend(componentPrototype);

    /**
     * Component factory. Takes an object that defines the default data,
     * composition, and runtime behavior
     *
     * @param {Object} spec - The component specification
     * @param {Object} spec.components - Child components
     * @param {Object} spec.data - Default component data
     * @param {Object} spec.events - Internal event handlers
     * @param {Object} spec.lifecycle - Lifecycle methods
     * @param {Object} spec.view - View methods
     */
    function defineComponent(spec, sid) {
        var lifecycle = spec.lifecycle = standardLifecycle.implement(spec.lifecycle || {}),
            view = spec.view = standardLifecycle.implement(spec.view || {}),
            children  = spec.components || {},
            data = spec.data || {},
            events = spec.events || {},
            event;

        // get a spec id if one wasn't provided
        sid = sid || reg.getNextSpecificationId();

        // Store a reference to the component spec
        specifications[sid] = spec;

        // Initialize event handler store for this spec
        handlers[sid] = {};

        // Store event handlers
        for(event in events) {
            if(events.hasOwnProperty(event)) {
                handlers[sid][event] = events[event];
            }
        }

        return StandardComponent.extend({
            init: function(idata, pid) {
                var id = reg.getNextInstanceId();

                this._super(sid, id, pid);

                // Combine instance data with spec data
                idata = A.extend({}, data, idata);

                // Store a reference to this instance and its constituents
                instances[id] = this;
                datastores[id] = new DefaultDatastore(idata);
                hierarchy[id] = {};

                // Initialize child components
                A.each(children, function(factory, name) {
                    var Constructor = constructors[factory],
                        newInstance = new Constructor(factory.defaultData, id);

                    // Store the child's ID in the registry
                    hierarchy[id][name] = newInstance.toString();
                });
            }
        });
    }

    return defineComponent;
});
/////////////////////////
// END FILE js/a_sc_define.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_datastore.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Standard Component Datastores

'use strict';

P.when('A', 'prv:a-sc-event-emitter', 'prv:a-sc-util').register('prv:a-sc-datastore', function(A, events, util) {
    var def = util.defineProperty,
        CHANGE_EVENT_PREFIX = 'change:';

    var BaseDatastore = A.createClass({
        init: function(data) {
            // More can be done to detect true POJOs, but for now this will do.
            if(data && typeof data !== 'object') {
                throw new Error('Datastores only accept plain JavaScript objects as input');
            }

            // Copy the initial data
            data = A.copy(data || {});

            // Attempt to avoid direct mutation of this property
            def(this, 'store', { value: data });
        },

           },

        set: function(key, value) {
            // Try and prevent misformed calls from tainting the internal store
            // AUI-7818 tracks an 'unset' method if we find it necessary to add it
            if(key === undefined || key === null || value === undefined) {
                return false;
            }

            this.store[key] = value;
            return true;
        }
    });

    // Base event-emitting data store
    // This is the minimum functionality to satisfy the needed interface
    var EventEmittingDatastore = BaseDatastore.extend(events.mixin({
            },
        set: function(key, value) {
            var oldValue = this.store[key];
            if(this._super(key, value) && !A.equals(oldValue, value)) {
                this.trigger(CHANGE_EVENT_PREFIX + key, oldValue, value);
                return true;
            }
            return false;
        }
    }));

    // Export the event-emitting constructor. We may export the BaseDatastore class in the future.
    return EventEmittingDatastore;
});
/////////////////////////
// END FILE js/a_sc_datastore.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_default_datastore.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Standard Component Default Datastore

'use strict';

P.when('A', 'prv:a-sc-datastore', 'prv:a-sc-registry', 'prv:a-sc-component-proxies', 'prv:a-sc-lifecycle-instances')
    .register('prv:a-sc-default-datastore', function(A, Datastore, reg, proxies, lc) {

    var splitter = /\s+/,
        instances = reg.instances,
        specifications = reg.specifications,
        standardLifecycle = lc.standard,
        CHANGE_EVENT_PREFIX = 'change:',
        CHANGE_EVENT_BATCH_DELAY = 100;


    // Batch change event triggers so we don't thrash the DOM if keys are set in rapid succession.
    var batch = (function() {
        var changes = {},
            timeouts = {};

        function trigger(instanceId, changeSet) {
            var instance = instances[instanceId],
                spec = specifications[instance.__sid],
                view = spec.view,
                method = standardLifecycle.enterForIndex(instance.__at);

            view[method].call(new proxies.View(instance), changeSet);
        }

        function add(instance, key, oldValue, newValue) {
            var timeout = timeouts[instance],
                changeSet = changes[instance];

            // get the real instance so we can get lifecycle data
            instance = instances[instance];

            // check for a pending batch operation, if one exists, clear it
            if(timeout) {
                clearTimeout(timeout);
            }

            // create or modify the changeset for a given instance
            if(!changeSet) {
                changes[instance] = changeSet = {};
            }

            changeSet[key] = {
                oldValue: oldValue,
                newValue: newValue
            };

            // delay the event trigger
            timeouts[instance] = setTi    }, CHANGE_EVENT_BATCH_DELAY);
        }

        return {
            add: add,
            trigger: trigger
        }
    }());

    // The default Datastore for components.
    var DefaultDatastore = Datastore.extend({
        init: function(data) {
            var out = {};

            // Try to prevent functions from being stored.
            for(var key in data) {
                if(data.hasOwnProperty(key) && typeof data[key] !== 'function') {
                    out[key] = data[key];
                }
            }

            this._super(out);
        },
        getProxy: function(instance, readOnly) {
            var self = this,
                proxy = {
                       }
                };

            if(readOnly !== true) {
                proxy.    };

                proxy.bind = function(keys, options) {
                    keys = keys.split(splitter);
                    options = options || {};

                    A.each(keys, function(key) {
                        self.on(CHANGE_EVENT_PREFIX + key, function(oldValue, newValue) {
                            var changeSet;
                            if(options.batch === false) {
                                changeSet = {};
                                changeSet[key] = { oldValue: oldValue, newValue: newValue };
                                batch.trigger(instance, changeSet);
                            } else {
                                batch.add(instance, key, oldValue, newValue);
                            }
                        });
                    });
                };

                proxy.unbind = function(keys) {
                    if(!keys) {
                        self.off();
                        return;
                    }

                    keys = keys.split(splitter);

                    A.each(    });
                };
            }

            return proxy;
        }
    });

    return DefaultDatastore;
});
/////////////////////////
// END FILE js/a_sc_default_datastore.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_component_collection.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Standard Component Collection

'use strict';

P.when('A', 'prv:a-sc-define')
    .register('prv:a-sc-component-collection', function(A, defineComponent) {
    var collections = {};

    // Collections are just a special component that keep an array of their child indices
    // This array is maintained by the ChildCollectionProxy
    function getComponentCollection(childFactory) {
        if(collections[childFactory]) {
            return collections[childFactory];
        }

        // For now this is extremeley simply and all lifecycle management is done through the proxy
        // However, it might be nice to offer the option of automatically advancing child components,
        // prefixing their names or otherwise providing bespoke IDs. Things like that would happen here.
        collections[childFactory] = defineComponent({
            data: {
                factory: childFactory,
                index: []
            }
        });

        return collections[childFactory];
    }

    return {
        get: getComponentCollection
    }
});
/////////////////////////
// END FILE js/a_sc_component_collection.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_component_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Standard Component Factory

'use strict';

P.when('A', 'prv:a-sc-registry', 'prv:a-sc-base', 'prv:a-sc-define', 'prv:a-sc-component-collection')
    .register('prv:a-sc-component-factory', function(A, reg, base, defineComponent, collection) {
    var specifications = reg.specifications,
        constructors = reg.constructors,
        nextFactoryId = 0;

    // Contains logic for manufacturing and extending Components and instances.
    var ComponentFactory = base.ComponentState.extend({
        init: function(sid, id, Constructor, defaultData) {
            this._super(sid, id || ++nextFactoryId);

            // save default data override. Don't care if people modify it, it's their data.
            this.defaultData = defaultData || {};

            // save a reference to the constructor
            if(Constructor) {
                constructors[this] = Constructor;
            }
        },
        // Build an instance
        getInst    },
        // Return a collection factory
        toCollection: function() {
            var Constructor = constructors[this];

            if(!Constructor) {
                throw new Error('You cannot create a collection of nothing');
            }

            return new ComponentFactory(null, null, collection.get(this), this.defaultData);
        },
        // Generate a new factory with new specification
        redefine: function(newSpec) {
            var keys = A.keys(newSpec),
                originalSpec, NewComponent, sid;

            // Don't allow cloning a Component without making changes
            if(!keys.length && this.__sid) {
                throw new Error('You must provide a new specification to the `redefine` method');
            }

            // If the only thing passed to this method is a new default data object,
            // short circuit and just return a new factory with new defaultData
            if(keys.length === 1 && keys[0] === 'data') {
                return new ComponentFactory(this.__sid, this.__id, null, newSpec.data);
            }

            // Otherwise extend the existing spec object with the new spec and get a new constructor.
            originalSpec = specifications[this.__sid] || {};

            newSpec = A.extend({}, originalSpec, newSpec);

            sid = reg.getNextSpecificationId();
            NewComponent = defineComponent(newSpec, sid);

            return new ComponentFactory(sid, null, NewComponent);
        }
    });

    return ComponentFactory;

});
/////////////////////////
// END FILE js/a_sc_component_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_component_proxies.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Standard Component Transition Proxies

'use strict';

P.when('A', 'prv:a-sc-registry', 'prv:a-sc-base', 'prv:a-sc-events', 'prv:a-sc-lifecycle-instances', '3p-promise')
    .register('prv:a-sc-component-proxies', function(A, reg, base, events, lc, Promise) {
    var instances = reg.instances,
        constructors = reg.constructors,
        datastores = reg.datastores,
        hierarchy = reg.hierarchy,
        elements = reg.elements,
        handlers = reg.handlers,
        standardLifecycle = lc.standard,
        splitter = /\s+/,
        slice = function(a, n) {
            return [].slice.call(a, n);
        };

    var VERY_LARGE_NUMBER = Math.pow(2, 32);

    var BaseProxy = base.ComponentState.extend({
        init: function(sid, id, pid) {
            // Optionally provide an instance as the sole parameter
            if(sid instanceof base.ComponentState) {
                this._super(sid.__sid, sid.__id, sid.__pid);
            } else {
                this._super(sid, id, pid);
            }
        }
    });

    // Provided as context to lifecycle methods
    var TransitionProxy = BaseProxy.extend({
            },
        // TODO: Flesh this out https://sim.amazon.com/issues/AUI-7701
        children: function(names) {
            var proxy = new ChildComponentProxy(this);

            return proxy.filter(names);
        },
        collec    },
        // Send an event up the hierarchy
        dispatch: function(name) {
            events.dispatch.call(this, name, slice(arguments, 1));
        },
        // Send an event down the hierarchy
        broadcast: function(name) {
            events.broadcast.call(this, name, slice(arguments, 1));
        }
    });

    // Provided as context to view methods
    var ViewProxy = BaseProxy.extend({
        init: function(sid, id, pid) {
            this._super(sid, id, pid);

            this.data = datastores[this].getProxy(this, true);
        },
        getEle    },
        setElement: function(el) {
            if(el instanceof HTMLElement) {
                elements[this.__id] = el;
            } else {
                throw new Error("You must provide an HTMLElement object to View.setElement");
            }
        },
        unsetEle    },
        // Send an event up the hierarchy
        dispatch: function(name) {
            events.viewDispatch.call(new TransitionProxy(this.__sid, this.__id, this.__pid), name, slice(arguments, 1));
        }
    });

    var childComponentProxyPrototype = {
        init: function(parent) {
            var self = this,
                methods;

            this._super(parent);

            // The currently selected subset of child components
            this.__cache = [];
        },
        // Filter the list of children this object proxies
        filter: function(names) {
            var children = this.__cache = [];

            if(!names || typeof names !== 'string') {
                // Return an array of all children
                children = A.map(A.values(hierarchy[this]), function(childId) {
                    return instances[childId];
                });
            } else {
                // Get a filtered array of children
                children = A.map(names.split(splitter), function(name) {
                    var childId = hierarchy[this][name] || null;
                    return childId ? instances[childId] : childId;
                }, this);

                children = A.filter(chil    });
            }

            this.__cache = children;

            return this;
        },
        add: function(name, factory, data) {
            var Constructor = constructors[factory],
                newInstance = new Constructor(data, this.__id);

            hierarchy[this][name] = newInstance.__id;
            this.__cache.push(newInstance);
            return this;
        },
        disown: function(name) {
            var id = hierarchy[this][name],
                instance;

            if(!id) {
                return this;
            }

            delete hierarchy[this][name];

            instance = instances[id];

            this.__cache = A.filter(this.__c    });

            return this;
        },
        le    }
    };

    // Lifecycle implementation for child component proxy prototype
    var childComponentProxyLifecycleMethods = standardLifecycle.implemen    });

    A.mixin(childComponentProxyPrototype, childComponentProxyLifecycleMethods);

    // Created when the 'children' method is invoked on a TransitionProxy. Maintains an internal cache
    // of selected children filtered from the call to 'children' on the transition proxy.
    var ChildComponentProxy = BaseProxy.extend(childComponentProxyPrototype);

    var ChildCollectionProxy = ChildComponentProxy.extend({
        init: function(parent, name) {
            var collectionId = hierarchy[parent][name],
                collection = instances[collectionId];

            if(!collection) {
                throw new Error('Child collection named ' + name + ' does not exist');
            }

            this._super(collection);

            // Fill the cache with all the children
            this.filter();
        },
        // Filter works by name, but we care about indexes, so override filter to always
        // fill the cache with all children by passing no argument to the super method
        fi    },
        // Override the add method because we already know the name and child factory
        // and we need to know the index
        add: function(data, i) {
            var ds, factory, index, Constructor, name, newInstance;

            // guard against calls using the original signature
            if(typeof data === 'string' || !A.isFiniteNumber(i)) {
                throw new Error("Argument error, usage: Collection.add(data:object, index:integer)");
            }

            ds = datastores[this];
            factory = ds.get('factory');
            index = ds.get('index');

            Constructor = constructors[factory];
            newInstance = new Constructor(data, this.__id);
            name = newInstance.toString();

            hierarchy[this][name] = newInstance.__id;
            this.__cache.push(newInstance);

            index.splice(i, 0, name);
            ds.set('index', index)

            return this;
        },
        ap    },
        pre    },
        // Shadows `add` but has a more intuitive name
        in    },
        // Get a proxy to a specific child in the collection
        get: function(i) {
            var ds = datastores[this],
                index = ds.get('index');

            if(i < 0 || i > index.length - 1) {
                throw new Error("Component index out of bounds");
            }

            return new ChildComponentProxy(this).filter(index[i]);
        },
        // Disown a child and remove it from the index
        disown: function(i) {
            var ds = datastores[this],
                index = ds.get('index'),
                removed;

            if(i < 0 || i > index.length - 1) {
                throw new Error("Component index out of bounds");
            }

            removed = index.splice(i, 1);
            return this._super(removed[0]);
        },
    });

    return {
        Transition: TransitionProxy,
        View: ViewProxy,
        ChildComponent: ChildComponentProxy,
        ChildCollection: ChildCollectionProxy
    }

});
/////////////////////////
// END FILE js/a_sc_component_proxies.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sc_internal_events.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Standard Component Transition Proxies

'use strict';

P.when('A', 'prv:a-sc-registry').register('prv:a-sc-events', function(A, reg) {
    var instances = reg.instances,
        handlers = reg.handlers,
        sl    };

        // Send an event up the hierarchy
        var dispatch = function dispatch(name, args) {
            var ProxyObject = this.constructor,
                proxy, handler, parent, prevent;

            if(this.isRoot) {
                return;
            }

            // Get the parent component
            parent = instances[this.__pid];
            // Get the event handler on the parent for this event
            handler = handlers[parent.__sid][name];
            // create a new transition proxy for the event
            proxy = new ProxyObject(parent.__sid, parent.__id, parent.__pid);

            if(handler) {
                prevent = (handler.apply(proxy, args) === false);
            }

            // If the handler returned false, don't propagate
            if(prevent) {
                return;
            }

            // Propagate the dispatch up the hierarchy
            dispatch.call(proxy, name, args);
        };

        var viewDispatch = function(name, args) {
            var host, handler, prevent;

            // Get the host component
            host = instances[this];
            // Get the event handler on the parent for this event
            handler = handlers[host.__sid][name];

            if(handler) {
                prevent = (handler.apply(this, args) === false);
            }

            // If the handler returned false, don't propagate
            if(prevent) {
                return;
            }

            // Propagate the dispatch up the hierarchy
            dispatch.call(this, name, args);
        };

        // Send an event down the hierarchy
        var broadcast = function broadcast(name, args) {
            var ProxyObject = this.constructor,
                children = reg.children(this),
                proxy, handler, prevent;

            // Short circuit if we have no child components
            if(!children.length) {
                return;
            }

            // Invoke the handler on each child
            A.each(children, function(child) {
                // get the handler for this child component spec
                handler = handlers[child.__sid][name];
                // create a new transition proxy for the event
                proxy = new ProxyObject(child.__sid, child.__id, child.__pid);

                if(handler) {
                    prevent = (handler.apply(proxy, args) === false);
                }

                // If the handler returned false, don't propagate
                if(prevent) {
                    return;
                }

                // Propagate the broadcast down the hierarchy
                broadcast.call(proxy, name, args);
            });
        };

    return {
        dispatch: dispatch,
        viewDispatch: viewDispatch,
        broadcast: broadcast
    }

});
/////////////////////////
// END FILE js/a_sc_internal_events.js
/////////////////////////

// END ASSET AmazonUIStandardComponent-1.0.2089.91
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUICard", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUICard-3.1.1436.91
/////////////////////////
// BEGIN FILE js/card_constants.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.register('prv:a-card-constats;
});
/////////////////////////
// END FILE js/card_constants.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/card.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Card
"use strict";

P.when('A', 'a-sc', 'prv:a-card-constants')
    .register('a-card-component', function (A, sc, consts) {

  function isInteractable(card) {
    return card.tagName.toLowerCase() === 'a' ||
           card.classList.contains('aok-card-allow-interaction');
  }

  function isExpanded(card) {
    return card.classList.contains('a-card-expanded');
  }

  function isHeader(card) {
    return card.classList.contains('a-card-header');
  }

  var INSIDE_INTERACTABLE = '0';
  var INSIDE_HEADER = '1';
  var INSIDE_BODY = '2';
  function closestContext(el, boundaryPredicate, targetPredicates) {
    while (!boundaryPredicate(el)) {
      for (var key in targetPredicates) {
        if (!targetPredicates.hasOwnProperty(key)) {
          continue;
        }

        if (targetPredicates[key](el)) {
          return key;
        }
      }
      el = el.parentNode;
    }
    return INSIDE_BODY;
  }

  function getContext(card, canvasTop) {
    var cardRect = card.getBoundingClientRect();
    var header = card.querySelector(consts.selectors.CARD_HEADER);
    var headerRect = header.getBoundingClientRect();
    // var canvasBottom = A.viewport().height;
    var context = {
      '_cardRect': cardRect,
      '_headerRect': headerRect,
      'isAboveCanvas': cardRect.bottom < canvasTop,
      'isBottomTouchCanvasTop': card.bottom === canvasTop,
      "isVisibleHeightLessThanPinnedHeader": cardRect.bottom - canvasTop < consts.CARD_PINNED_HEADER_SIZE,
      'isCutByCanvasTop': cardRect.top < canvasTop && canvasTop < cardRect.bottom,
      'isTopTouchingCanvasTop': cardRect.top === canvasTop,
      'isTopBelowCanvasTop': canvasTop < cardRect.top
      // 'isBottomAboveCanvasBottom': cardRect.bottom < canvasBottom,
      // 'isBottomTouchingCanvasBottom': cardRect.bottom === canvasBottom,
      // 'isCutByCanvasBottom': cardRect.top < canvasBottom && canvasBottom < cardRect.bottom,
      // 'isHeaderTouchingCanvasBottom': canvasBottom === cardRect.top,
      // 'isBelowCanvas': canvasBottom < cardRect.top
    };
    if (context.isVisibleHeightLessThanPinnedHeader) {
      context.visibleHeight = cardRect.bottom - canvasTop;
    }
    return context;
  }

  function toggleA11yLabel(cardHeaderEl, a11yLabel, expanded) {
    if (a11yLabel) {
      var a11yLabelId = a11yLabel.getAttribute('id');
      var ariaDescribedBy = expanded ? '' : a11yLabelId;
      cardHeaderEl.setAttribute('aria-describedby', ariaDescribedBy);
    }
  }

  function isTopLeavingCanvasTop(context) {
    return (context.isTopTouchingCanvasTop || context.isCutByCanvasTop);
  }
  function isTopEnteringCanvasTop(context) {
    return context.isTopTouchingCanvasTop || context.isTopBelowCanvasTop;
  }
  function isBottomEnteringCanvasTop(context) {
    return (context.isBottomTouchCanvasTop || context.isCutByCanvasTop);
;
  }

  function toggleClass(el, className, keep) {
    if (keep) {
      el.classList.add(className);
    } else {
      el.classList.remove(className);
    }
  }

  function triggerEvents(eventName, cardId) {
    A.trigger('a:card:' + eventName, { card: cardId });
    A.trigger('a:card:' + cardId + ':' + eventName);
  }

  // TODO should be implemented in Standard Compon;
  }

  var cardFactory = sc.define({
    data: {
      id: '',
      idx: '',
      selector: '',

      expandable: false,
      expanded: false,
      pinned: false,
      hasPeek: false,

      // canvas is (viewport - fixed page header)
      // top is relative to viewport
      canvasTop: 0,

      pinnedMode: -1,

      unpinnedHeaderHeight: 0,

      scrollDirection: 0
    },
    events: {
      // explicit toggle intent (click on header)
      'ui:toggle-card': function () {
        var expanded = !this.data.get('expanded');
        this.data.set('expanded', expanded);
        if (!expanded) {
          this.data.set('pinned', false);
        }
        return false;
      },
      // implicit expand intent (click on body)
      'ui:expand-card': function () {
        this.data.set('expanded', true);
        return false;
      },

      // TODO should be implemented in Standard Component
      'card:update-dom-data': function(domData) {
        for (var key in domData) {
          if (!domData.hasOwnProperty(key)) {
            continue;
          }
          this.data.set(key, domData[key]);
        }
      },

      'cardList:refresh-card': function(id, direction) {
        if (!shouldReceiveEvent(this.data.get('id'), id)) {
          return;
        }

        var card = this.data.get('cardEl');
        var context = getContext(card, this.data.get('canvasTop'));
        var predicate;

        // viewport
        // +-------------------------------+
        // |                               |
        // |                   +-+-+ +-+-+ |
        // |             +---+ | | | | ^ | |
        // |             |   | | v | | | | |                       (leaving)
        // +-+-+-+-+-+-+-------+-+-+-+-+-+-+ <- page header bottom
        // | | | | | ^ | +---+             |                       (entering)
        // | | v | | | |...................| <- pinned card header bottom
        // | +-+-+ +-+-+                   |
        // |                               |
        // | [1]   [2]   [5]   [3]   [4]   |
        // |                               |
        // +-------------------------------+
        //
        // direction === CARD_UP
        //   [2] w/o pinned header -> isTopLeavingCanvasTop     -> pin header
        //   [4] w/ pinned header  -> isBottomLeavingCanvasTop  -> unpin header
        // direction === CARD_DOWN
        //   [1] w/ pinned header  -> isTopEnteringCanvasTop    -> unpin header
        //   [3] w/o pinned header -> isBottomEnteringCanvasTop -> pin header
        // [5] isVisibleHeightLessThanPinnedHeader

        if (this.data.get('pinned')) {
          predicate = direction === consts.CARD_UP ? isBottomLeavingCanvasTop : isTopEnteringCanvasTop;
          if (predicate(context)) {
            // A.trigger('a:debug:card:' + card.id + ':unpin', {context: predicate.name});
            this.data.set('pinned', false);
          }
        } else {
          predicate = direction === consts.CARD_UP ? isTopLeavingCanvasTop : isBottomEnteringCanvasTop;
          if (predicate(context)) {
            // A.trigger('a:debug:card:' + card.id + ':pin', {context: predicate.name});
            this.data.set('pinned', true);
          }
        }

        if (this.data.get('pinned')) {
          var pinnedMode = context.isVisibleHeightLessThanPinnedHeader ?
              consts.PINNED_AS_RELATIVE : consts.PINNED_AS_FIXED;
          // A.trigger('a:debug:card:' + card.id + ':change-pinned-mode', {mode: pinnedMode});
          this.data.set('pinnedMode', pinnedMode);
        }
      },
      'cardList:update-canvas-top': function(canvasTop) {
        this.data.set('canvasTop', canvasTop);
      }
    },
    lifecycle: {
      render: function () {
        if (this.data.get('expandable')) {
          this.data.bind('expanded canvasTop');
          this.data.bind('pinned', {batch: false});
          this.data.bind('pinnedMode', {batch: false});
        }
      },
          }
    },
    view: {
      render: function () {
        var card = document.querySelector(this.data.get('selector')),
            header = card.querySelector(consts.selectors.CARD_HEADER),
            body = card.querySelector(consts.selectors.CARD_BODY),
            a11yLabel = card.querySelector(consts.selectors.CARD_A11Y_LABEL),
            isExpandable = this.data.get('expandable'),
            hasPeek = this.data.get('hasPeek'),
            self = this,
            shouldMaintainA11yLabel = hasPeek && a11yLabel;

        var domData = {
          'cardEl': card,
          'headerEl': header,
          'bodyEl': body,
          'a11yLabelEl': a11yLabel,
          'shouldMaintainA11yLabel': shouldMaintainA11yLabel
        };
        if (header) {
          var headerRect = header.getBoundingClientRect();
          domData['unpinnedHeaderHeight'] = headerRect.height;
        }
        this.dispatch('card:update-dom-data', domData);

        function clickHandler(event) {
          var card = event.currentTarget,
              node = event.target;

          // (target context: action)
          // inside header: toggle card
          // link or .aok-card-allow-interaction: follow it, don't toggle/expand card.
          // inside body: expand card

          // get target context
          var targetPredicates = {};
          targetPredicates[INSIDE_INTERACTABLE] = function (el) {
            return isInteractable(el);
          };
          targetPredicates[INSIDE_HEAD    };
          var targetContext = closestContext(    }, targetPredicates);

          // make an action
          if (targetContext === INSIDE_INTERACTABLE) {
            return;
          } else if (targetContext === INSIDE_HEADER) {
            self.dispatch('ui:toggle-card');
            return;
          } else { // INSIDE_BODY
            if (!self.data.get('expanded')) {
              self.dispatch('ui:expand-card');
            }
          }
        }

        if (isExpandable) {
          card.addEventListener('click', clickHandler);
        }

        // render initial state
        if (isExpanded(card)) {
          self.dispatch('ui:expand-card');
        }
        
        //a11y
        if (isExpandable) {
          var bodyId = this.data.get('id') + consts.CARD_BODY_ID_SUFFIX;
          body.setAttribute('id', bodyId);
          header.setAttribute('aria-controls', bodyId);
        }

        if (shouldMaintainA11yLabel) {
            var a11yLabelId = this.data.get('id') + consts.CARD_PEEK_DESCRIPTION_SUFFIX;
            a11yLabel.setAttribute('id', a11yLabelId);
            toggleA11yLabel(header, a11yLabel, this.data.get('expanded'));
        }

        this.setElement(card);
      },
      show: function (changes) {
        if (!changes) {
          return;
        }

        // dom
        var card = this.getElement();
        var cardRect = card.getBoundingClientRect();
        var header = this.data.get('headerEl');
        var body = this.data.get('bodyEl');
        var a11yLabel = this.data.get('a11yLabelEl');
        var unpinnedHeaderHeight = this.data.get('unpinnedHeaderHeight');

        // states
        var pinned = this.data.get('pinned');
        var expanded = this.data.get('expanded');
        var canvasTop = this.data.get('canvasTop');
        var pinnedMode = this.data.get('pinnedMode');
        var isDynamicCardHeight = this.data.get('isDynamicCardHeight');
        var hasPeek = this.data.get('hasPeek');

        // context
        var isPinning = changes.pinned && pinned;
        var isUnPinning = changes.pinned && !pinned;
        var hasExpandingChange = !!changes.expanded; // it's an object
        var isExpanding = hasExpandingChange && expanded;
        var isCollapsing = hasExpandingChange && !expanded;
        var isAboveCanvas = cardRect.bottom < canvasTop;
        var shouldMaintainA11yLabel = this.data.get('shouldMaintainA11yLabel');

        // Reflect the state change on card style ==============================
        toggleClass(card, 'aok-card-expanded', expanded);
        toggleClass(card, 'a-card-expanded', expanded);
        toggleClass(card, 'aok-card-collapsed', !expanded);
        toggleClass(card, 'a-card-collapsed', !expanded);
        toggleClass(card, 'a-card-pinned', pinned);
        toggleClass(card, 'a-card-pinned-fixed', pinned && (pinnedMode === consts.PINNED_AS_FIXED));
        toggleClass(card, 'a-card-pinned-relative', pinned && (pinnedMode === consts.PINNED_AS_RELATIVE));

        header.style.top = pinnedMode === consts.PINNED_AS_FIXED ? canvasTop + 'px': '';
        if (isDynamicCardHeight) {
          toggleClass(card, 'a-card-above-canvas', isAboveCanvas);
        } else {
          if (isPinning) {
            card.style.paddingTop = unpinnedHeaderHeight + 'px';
          } else if (isUnPinning) {
            card.style.paddingTop = 0;
          }
        }

        /* A.trigger('a:debug:card:' + card.id + ':view:show:states-change:before-class-change', {
          changes: changes,
          context: {
            isPinning: isPinning,
            isUnPinning: isUnPinning,
            hasExpandingChange: hasExpandingChange,
            isExpanding: isExpanding,
            isCollapsing: isCollapsing,
            isAboveCanvas: isAboveCanvas
          },
          card: card
        }); */

        // =====================================================================

        ////////////////////////////////////////////////////////////////////////
        //                        CARD STYLE CHANGED                          //
        ////////////////////////////////////////////////////////////////////////

        // latest dom states
        cardRect = card.getBoundingClientRect();
        var canvasBottom = A.viewport().height;

        // states

        // context
        var isCutByCanvasTop = cardRect.top < canvasTop;
        var isCutByCanvasBottom = canvasBottom < cardRect.bottom;

        // others
        var cardListScrollTopDelta = 0;

        /* A.trigger('a:debug:card:' + card.id + ':view:show:states-change:after-class-change', {
          changes: changes,
          context: {
            isCutByCanvasTop: isCutByCanvasTop,
            isCutByCanvasBottom: isCutByCanvasBottom
          },
          card: card
        }); */

        // Reflect the state change on card list events ========================

        if (isPinning) {
          this.dispatch('card:updated-pinned-index', this.data.get('idx'));
        }

        // When collapsing, the pinned card collapses into the card title,
        // which remains in place below the navigation bar.
        // If the card header is above the canvas, or scroll view, when expanded,
        // the view should scroll up slightly to align the top of the card
        // with the top of the scroll view.
        if (isCutByCanvasTop && (isExpanding || isCollapsing)) {
          var cutHeight = canvasTop - cardRect.top;
          cardListScrollTopDelta = consts.CARD_DOWN * cutHeight;
        } else if (isCutByCanvasBottom && isExpanding) {
          var maxRevealHeight = unpinnedHeaderHeight + 2 * consts.CARD_PEEK_SIZE;
          var cardHeight = cardRect.height;
          cardListScrollTopDelta = Math.min(cardHeight, maxRevealHeight);

          var inCanvasHeight = canvasBottom - cardRect.top;
          cardListScrollTopDelta = consts.CARD_UP * (cardListScrollTopDelta - inCanvasHeight);
        }

        // Always reset the card position for revealing complete header while
        // expanding/collapsing card
        if (cardListScrollTopDelta) {
          this.dispatch('card:scroll-card-list-up', cardListScrollTopDelta);
        }

        // Public events =======================================================

        if (hasExpandingChange) {
          triggerEvents(isExpanding ? 'expand' : 'collapse', this.data.get('id'));
          
          // a11y
          header.setAttribute('aria-expanded', expanded);
          body.setAttribute('aria-hidden', !expanded);
          if (shouldMaintainA11yLabel) {
            toggleA11yLabel(header, a11yLabel, isExpanding);
          }
        }

        // =====================================================================
      }
    }
  });

  return cardFactory;
});
/////////////////////////
// END FILE js/card.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/card_list.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI CardList
"use strict";

P.when('A', 'a-sc', 'a-card-component', 'prv:a-card-constants')
    .register('a-card-list', function (A, sc, cardFactory, consts) {

  function getOffsetTopToDocument(el) {
    var offset = 0;
    while (el) {
      if (!isNaN(el.offsetTop)) {
        offset += el.offsetTop;
      }
      el = el.offsetParent;
    }
    return offset;
  }
  function getCanvasTop(pageHeaderSelector) {
    var pageHeader = document.querySelector(pageHeaderSelector);
    var headerRect = pageHeader.getBoundingClientRect();
    return getOffsetTopToDocument(pageHeader) + headerRect.height;
  }

  function isExpandable(card) {
    return card.classList.contains('a-card-expandable');
  }
  function isExpanded(card) {
    return card.classList.contains('a-card-expanded');
;
  }

  var lastScrollTop = 0;
  function wrapDirection(handler) {
    return function (event) {
      var target = event.target;
      var direction = target.scrollTop > lastScrollTop ? consts.CARD_UP : consts.CARD_DOWN;
      handler(event, direction);
      lastScrollTop = target.scrollTop;
    }
  }

  var cardListFactory = sc.define({
    components: {
      cards: cardFactory.toCollection()
    },
    data: {
      headerSelector: 'header',
      selector: consts.selectors.CARD_LIST,
      cardSelector: consts.selectors.CARD,

      canvasTop: 0,
      cardListScrollTop: 0,
      cardListScrollTopDelta: 0,
      pinnedIndex: null,

      isDynamicCardHeight: true, // when header gets pinned/unpinned, card height might change

      cardStateCollection: []
    },
    events: {
      'ui:scroll-card-list': function(scrollTop) {
        this.data.set('cardListScrollTop', scrollTop);
      },
      'ui:update-canvas-    },

      'ui:refresh-c    },

      'card:updated-pinned-index': function (index) {
        this.data.set('pinnedIndex', index);
      },
      'card:scroll-card-list    },

      // TODO should be implemented in Standard Component
      'cardList:update-dom-data': function(domData) {
        for (var key in domData) {
          if (!domData.hasOwnProperty(key)) {
            continue;
          }
          this.data.set(key, domData[key]);
        }
      }
    },
    lifecycle: {
      render: function () {
        this.data.bind('cardListScrollTop', {batch: false});
        this.data.bind('cardListScrollTopDelta', {batch: false});

        // canvas is (viewport - page header)
        // top is relative to viewport
        var canvasTop = getCanvasTop(this.data.get('headerSelector'));
        this.data.set('canvasTop', canvasTop);
      },
          }
    },
    view: {
      render: function () {
        var cardList = document.querySelector(this.data.get('selector')),
            cards = Array.prototype.slice.call(cardList.querySelectorAll(this.data.get('cardSelector'))),
            canvasTop = this.data.get('canvasTop'),
            pageHeaderSelector = this.data.get('headerSelector'),
            self = this;

        var cardsStateCollection = [];
        A.each(cards, function (card, i) {
          card.id = card.id || ('a-card-' + i);
          cardsStateCollection.push({
            expandable: isExpandable(card),
            expanded: isExpanded(card),
            hasPeek: hasPeek(card),
            id: card.id,
            idx: i,
            selector: '#' + card.id
          });
        });
        this.dispatch('cardList:update-dom-data', {
          cardStateCollection: cardsStateCollection
        });

        function directionalScrollHandler(event, direction) {
          A.each(cards, function(card) {
            if (!isExpanded(card)) {
              return;
            }

            self.dispatch('ui:refresh-card', card.id, direction);
          });
        }

        var scrollHandler = wrapDirection(directionalScrollHandler);
        cardList.addEventListener('scroll', A.throttle(scrollHandler, 20));

        function orientationHandler() {
          A.animationFrameDelay(function () {
            var canvasTop = getCanvasTop(pageHeaderSelector);
            self.dispatch('ui:update-canvas-top', canvasTop);

            var pinnedIndex = self.data.get('pinnedIndex');
            if (!pinnedIndex) {
              return;
            }
            var pinnedCard = cards[pinnedIndex];
            var scrollTop = getOffsetTopToDocument(pinnedCard) - canvasTop;
            self.dispatch('ui:scroll-card-list', scrollTop);
            self.dispatch('ui:scroll-card-list', scrollTop + consts.CARD_UP);
          });
        }
        window.addEventListener('orientationchange', orientationHandler);

        this.setElement(cardList);
      },
      show: function (changes) {
        if (!changes) {
          return;
        }
        A.trigger('card-list:view:show:states-change', {changes: changes});

        var cardList = this.getElement();
        if (changes.cardListScrollTopDelta) {
          cardList.scrollTop += this.data.get('cardListScrollTopDelta');
        }
        if (changes.cardListScrollTop) {
          cardList.scrollTop = this.data.get('cardListScrollTop');
        }
      }
    }
  });

  return cardListFactory;
});
/////////////////////////
// END FILE js/card_list.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/index.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// AmazonUI Card Entry
"use strict";

P.when('A', 'a-card-list').register('a-c  }
});
/////////////////////////
// END FILE js/index.js
/////////////////////////

// END ASSET AmazonUICard-3.1.1436.91
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUICarousel", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUICarousel-3.1.1491.91
/////////////////////////
// BEGIN FILE js/carousel_constants.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Constants
 *
 */

"use strict";

P.declare("a-carousel-constants", {
  ANIMATING: "animating", // Transition strategy actually animating
  ANIMATION_SPEED: "animation_speed",
  AUTO_ADJUST_HEIGHT: "auto_adjust_height",
  CIRCULAR: "circular",
  CURRENT_PIXEL: "px",
  CURRENTLY_WRAPPING: "currentlyWrapping",
  DELAY_TIME: "delay_time",
  ELEMENT_CSS_CLASS: "elementCssClass", // Adds element CSS class to client side empty cards
  FETCHED_ITEMS: "fetchedItems",
  FIRST_VISIBLE_ITEM: "firstVisibleItem",
  HIDE_OFF_SCREEN: "hide_off_screen",
  INIT_EVENTS: 'a:pageUpdate beforeReady',
  LOADING: "loading", // Transition strategy replacing loading placeholder with actual cards
  MIN_GUTTER: "minimum_gutter_width",
  NAME: "name",
  NO_TRANSITION: "no_transition",
  PAGE_NUMBER: "pageNumber",
  PAGE_SIZE: "pageSize",
  PEEK_GRADIENT: "peek_gradient",
  PEEK_PERCENTAGE: "peek_percentage",
  PEEK_WIDTH: "peek_width",
  SET_SIZE: "set_size",
  SPRINGINESS: "springiness",
  STATIC_LOADER_CSS_CLASS: "staticLoaderCssClass", // Provides div with CSS class for client side empty cards (currently not compatible with empty server side cards)
  TOTAL_PAGES: "totalPages",
  TOUCH_EASING: "touch_easing",
  TRANSITION_STRATEGY: "transitionStrategy",
  WRAP_EASING: "wrap_easing"
});
/////////////////////////
// END FILE js/carousel_constants.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/carousel_utils.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.register("a-carousel-utils", function () {
  /**
   *  Convenience function for determining if something's a string
   *
   *  @public
   *  @param {Object} a
   *
   *  @returns {Boolean}
   ;
  }

  /**
   *  Convenience function to test if an object is an HTMLElement or a DocuemntFragment in a way
   *  that won't cause IE 6 to have a seizure.
   *
   *  @public
   *  @param {Object} a
   *
   *  @returns {Boolean}
   ;
  }

  /**
   *  There are several different acceptable formats for carousel card content to come back from the AJAX strategy.
   *  This abstracts fetching that data from the fetchedItems array elements.
   *
   *  @public
   *  @param {Object} item - The fetchedItems element to pull content from
   *
   *  @returns {String|Element|DocumentFragment}
   */

  function getElementFromItem(item) {
    // We are sanitizing input and if we get all whitespace and trim it, we trim down to ""
    // Type conversion in JS (!!"") results in false, which has us return null, which means
    // we dont insert anything and leave the previous slot as it was before in swap carousels.
    // Previous/desired behavior was to output an empty slot, so this if restores that.
    if (item === "") {
      return "<div></div>";
    }
    if (!item) {
      return null;
    }
    if (isString(item) || isElement(item)) {
      return item;
    }
    return getElementFromItem(item.content);
  }

  /**
   *  After we add the content to the DOM nodes, we don't need to keep that content in memory for this
   *  transition strategy.  So, set the content to the boolean true
   *
   *  @public
   *  @param {Obejct} item - The fetchedItems element to pull content from
   *
   *  @returns {Object}
   */

  function clearElementFromItem(item) {
    if (item) {
      if (isString(item) || isElement(item)) {
        item = true;
      } else {
        item.content = clearElementFromItem(item.content);
      }
    }
    return item;
  }

  /**
   *  Different actions need to be taken to add content to the DOM depending on the type of the content generated.
   *
   *  @public
   *  @param {object} $dom - The jQuery wrapped DOM node we'll be dumping content in to
   *  @param {string|HTMLElement|DocumentFragment} element  The content to be added
   */

  function addElementToDom($dom, element) {
    if (element) {
      if (isString(element)) {
        $dom.html(element);
      } else if (isElement(element)) {
        $dom.empty().append(element);
      }
      if (element !== true) {
        $dom.removeClass("a-carousel-card-empty");
      }
    }
  }


  return {
    addElementToDom: addElementToDom,
    clearElementFromItem: clearElementFromItem,
    getElementFromItem: getElementFromItem,
    isElement: isElement,
    isString: isString
  };
});
/////////////////////////
// END FILE js/carousel_utils.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/carousel_circular_utils.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

P.register('a-carousel-circular-utils', function () {
    /**
     *  Makes a rotation function. 1 for clockwise and -1 for counter-clockwise
     *
     *  @param {number} direction
     */
    function makeRotate(direciton) {
        var clockwise = direciton > 0;

        return function rotate($parent, $elements, quantity) {
            quantity = quantity || 1;
            var length = $elements.length;
            var rotations = quantity % length;

            var parentElement = $parent.get(0);
            var moveElement;

            for (var i = 0; i < rotations; i++) {
                // Move first element to the end
                if (clockwise) {
                    moveElement = $elements.get(i);
                    parentElement.appendChild(moveElement);

                // Move last element to the front
                } else {
                    moveElement = $elements.get(length - 1 - i);
                    parentElement.insertBefore(moveElement, parentElement.children[0]);
                }
            }
        };
    }

    /**
     * Makes an array rotation function. 1 for clockwise and -1 for counter-clockwise
     *
     * @param {number} direction
     */

    function makeRotateArray(direction) {
        var clockwise = direction > 0;

        return function rotateArray(arr, quantity) {
            quantity = quantity ? quantity % arr.length : 1;

            if (clockwise) {
                arr = arr.concat(arr.splice(0, quantity));
            } else {
                arr.unshift.apply(arr, arr.splice(arr.length - quantity, quantity));
            }

            return arr;
        };
    }

    /**
     *  Calculates relative index of first card after rotation of the card by a given offset
     *
     *  @param {number} offset - number of cards rotated. Positive value for clockwise and negative for counter clockwise rotation
     *  @param {number} idxOfFirstCard - relative index of first card in the carousel
     *  @param {number} setSize - number of cards in the carousel
     *
     */
    function firstCardIndexAfterRotate(offset, idxOfFirstCard, setSize) {
        var idx = (idxOfFirstCard + offset) % setSize;
        if (idx === 0) {
            idx = setSize;
        }
        else if (idx < 0) {
            idx = setSize + idx;
        }
        return idx;
    }

    /**
     *  Returns relative index of a card given with respect to the current state of carousel
     *
     *  @param {number} idx - index of the card of which relative index is needed
     *  @param {number} indexOfFirstCard - index of first card in the carousel
     *  @param {number} setSize - number of cards in the carousel
     *
     */
    function relativeIndexFromIndex(idx, idxOfFirstCard, setSize) {
        var relativeIdx = 1;
        if (idx > 0 && idx <= setSize) {
            if (idx > idxOfFirstCard) {
                relativeIdx = idx - idxOfFirstCard + 1;
            }
            else if (idx < idxOfFirstCard) {
                relativeIdx = setSize - idxOfFirstCard + idx + 1;
            }
            return relativeIdx;
        }
        P.error("idx should be between 1 and " + setSize, "a-carousel-circular-utils", "relativeIndexFromIndex");
    }

    return {
        rotateCW: makeRotate(1),
        rotateCCW: makeRotate(-1),
        rotateArrayCW: makeRotateArray(1),
        rotateArrayCCW: makeRotateArray(-1),
        firstCardIndexAfterRotate: firstCardIndexAfterRotate,
        relativeIndexFromIndex: relativeIndexFromIndex
    };
});
/////////////////////////
// END FILE js/carousel_circular_utils.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/carousel_measure.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Measurement Mixin
 */

"use strict";

/**
 *  A mixin which creates a set of functionality designed to allow a Carousel to measure itself.
 *  All measurement data is private, so use the get and measure functions.
 */
P.when("A", "jQuery").register("a-carousel-measure", function (A, $) {
  var undefined;

  /**
   *  Mixin which instantiate new private variables and adds measurement
   *  functionality to the carousel.
   *
   *  @param {Carousel} carousel
   */
  function asMeasurable(carousel) {
    /** @private */
    var dimensions = {
      carousel: {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      },
      viewport: {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      },
      items: [],
      getFirstCardWidth: function () {
        return this.items[0] === undefined || !A.isFiniteNumber(this.items[0].width) ? 160 : this.items[0].width;
      }
    };

    /**
     *  Measure all listed properties of a given DOM node and place them on the
     *  dimension object provided.  Keeps track of values which change, and returns
     *  those on a seperate object.
     *
     *  @private
     *  @param {Object} dimension - Place measurements here
     *  @param {HTMLElement} $dom - The DOM node to measure. Can be a jQuery wrapped DOM node
     *  @param {Array} properties - A list of properties to measure
     *
     *  @returns {Object} changes - A hash of properties which changed and their new value
     */
    function getChanges(dimension, $dom, properties) {
      var property, offset, tmp, changed;

      // Make sure we have a jQuery wrapped DOM node
      if (!$dom.jquery) {
        $dom = $($dom);
      }

      // We need to calculate the offset if the top or left is required
      A.each(properties, function (property) {
        if (property === "top" || property === "left") {
          offset = $dom.offset();
          return false;
        }
      });

      while ((property = properties.pop()) !== undefined) {
        tmp = dimension[property];
        if (property === "left" || property === "top") {
          dimension[property] = offset[property];
        } else if (property.indexOf("outer") > -1) {
          dimension[property] = $dom[property](true);
        } else {
          dimension[property] = $dom["outer" + property.charAt(0).toUpperCase() + property.substr(1)]();
        }

        if (dimension[property] !== tmp) {
          if (changed === undefined) {
            changed = {};
          }
          changed[property] = tmp;
        }
      }

      return changed;
    }

    /**
     *  Remeasures the carousel, keeps track of which dimensions changed, records the new measurements, then returns the changes.
     *
     *  @public
     *  @param {String} elements (Optional) - A space delimited list of the items you'd like to measure. Not passing this results in everything being measured.
     *  @returns {Object} changes - A hash of which dimensions changed and their associated new value
     */
    carousel.measure = function (elements) {
      var $carousel = this.dom.$carousel;
      var $viewport = this.dom.$viewport;
      var changes = {};

      if (elements) {
        elements = elements.split(" ");
      }

      if (!elements || A.indexOfArray(elements, "carousel") > -1) {
        changes.carousel = getChanges(dimensions.carousel, $carousel, ["top", "left", "height", "width", "outerHeight", "outerWidth"]);
      }

      if (!elements || A.indexOfArray(elements, "viewport") > -1) {
        changes.viewport = getChanges(dimensions.viewport, $viewport, ["height", "width", "outerHeight", "outerWidth"]);
      }

      if (!elements || A.indexOfArray(elements, "items") > -1) {
        dimensions.items = [];
        changes.items = {};

        $carousel.children("li").each(function (idx, item) {
          dimensions.items[idx] = {};
          var itemChanges = getChanges(dimensions.items[idx], item, ["top", "left", "height", "width", "outerHeight", "outerWidth"]);
          if (itemChanges !== undefined) {
            changes.items[idx] = itemChanges;
          }
        });
      }

      return changes;
    };

    /**
     *  Get the left offset of the card at the given index.
     *
     *  @public
     *  @param {Number} idx
     *
     *  @returns {Number}
     */
    carousel.getItemOffset = function (idx) {
      var items = dimensions.items;
      idx--;
      if (items && items.length) {
        if (idx < items.length) {
          var offset = 0;
          var firstItemWidth = items[0].outerWidth;

          for (var i = 0; i < idx; i++) {
            offset += items[i] ? items[i].outerWidth : firstItemWidth;
          }

          if (idx > 0 && this.getAttr("first_item_flush_left")) {
            offset += carousel.getAttr("currentGutter");
          }

          return offset;
        }
      } else {
        return 0;
      }
    };

    /**
     *  Dumb getter for private dimensions hash.  Does not re-measure the carousel.
     *
     *  @public
     *
     *  @returns {Object} dimensions - A copy of the current dimensions hash.
     */
    carousel.getDimensi    };

    /**
     *  Setter for dimension values.  If you change a dimension, know what the new value is, and want to update
     *  the private dimensions cache, use this.
     *
     *  @public
     *  @param {Object} newDimensions - A hash of dimension names and associated new values to cache.
     */
    carousel.updateDimensionsCa    };

    /**
     *  Get the cached width of the carousel viewport.
     *
     *  @public
     *
     *  @returns {Number|undefined}
     */
    carousel.getViewportWi    };
  }

  return asMeasurable;
});
/////////////////////////
// END FILE js/mixins/carousel_measure.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/carousel_attributes.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Attribute Management
 *
 */

"use strict";

/**
 *  A pseudo event system for attribute changes.  Allows pieces of the carousel to communicate without
 *  tight coupling.  A global event is triggered when attributes are changed, but locally defined callbacks
 *  will always fire first.
 */
P.when("A", "jQuery").register("a-carousel-attributes", function (A, $) {

  /**
   *  Allows the passed object to have private attributes which are managed through
   *  getters, setters, and change callbacks.
   *
   *  @param {Object} carousel - The object to which callbacks are bound.
   */
  var asAttributeManager = function (carousel, defaults) {
    /**
     *  Attribute hash.
     *
     *  @private
     *  @type {Object}
     */
    var attributes = {};

    /**
     *  A hash of named attributes to an array of event handlers.
     *
     *  @private
     *  @type {Object}
     */
    var handlers = {};

    /**
     *  When executing callbacks for an attribute, we don't want another call to setAttr
     *  to cause callbacks to fire again.  This keeps track of which attributes are
     *  frozen.
     *
     *  @private
     *  @type {Object}
     */
    var frozenAttrs = {};

    // Copy the defaults onto the private attributes hash
    A.extend(attributes, defaults);

    /**
     *  Register a callback function which executes when the named attribute changes.
     *
     *  @param {String} attributes - A space delimited string of attribute names to listen to
     *  @param {Function} fn - A callback function
     *
     *  @returns {Carousel} this
     */
    carousel.onChange = function (attributes, fn) {
      var names = attributes.split(" ");
      var i = names.length;
      var name;
      while (i--) {
        name = names[i];
        if (!handlers[name]) {
          handlers[name] = [];
        }
        if ($.isFunction(fn) && A.indexOfArray(handlers[name], fn) === -1) {
          handlers[name].push(fn);
        }
      }
      return this;
    };

    /**
     *  Get rid of a callback function so that it no longer executes when the named
     *  attribute changes.
     *
     *  @param {String} name - The name of the attribute the function was watching
     *  @param {Function} fn - The function which should no longer be executed
     *
     *  @returns {Carousel} this
     */
    carousel.unbind = function (name, fn) {
      if (handlers[name] && fn) {
        var i = A.indexOfArray(handlers[name], fn);
        if (i > -1) {
          handlers[name].splice(i, 1);
        }
      }
      return this;
    };

    /**
     *  Shortcut for binding a change handler which only executes once.
     *
     *  @public
     *  @param {String} attributes - A space delimited string of attribute names to listen to
     *  @param {Function} fn - A callback function
     *
     *  @returns {Carousel} this
     */
    carousel.o    };

    /**
     *  Set the value of the named attribute.  If the value has changed, change handlers
     *  registered with registerAttrChangeHandler will then fire a global A.trigger event
     *  is fired.
     *
     *  @param {String} name - The name of the attribute
     *  @param {Object}  value - The new value of the attribute
     *  @param {Boolean} silent - If set to true, events will not be fired. USE WITH CAUTION.
     *
     *  triggers a:carousel:[name]:change:[attribute_name]
     *
     *  @returns {Carousel} this
     */
    carousel.setAttr = function (name, value, silent) {
      var old = attributes[name];
      attributes[name] = value;
      if (!(silent || frozenAttrs[name] || A.equals(value, old))) {
        frozenAttrs[name] = true;
        var copyOfValue = A.copy(value);
        var copyOfOld = A.copy(old);
        if (handlers[name]) {
          var immutableHandlers = A.copy(handlers[name]);
          for (var i = 0, l = immutableHandlers.length; i < l; i++) {
            immutableHandlers[i](copyOfValue, copyOfOld, carousel, name);
          }
        }
        var eventData = {
          newValue: copyOfValue,
          oldValue: copyOfOld,
          carousel: carousel
        };
        A.trigger("a:carousel:change:" + name, eventData);
        if (attributes.name) {
          A.trigger("a:carousel:" + attributes.name + ":change:" + name, eventData);
        }
        frozenAttrs[name] = false;
      }
      return this;
    };

    /**
     *  A dumb getter for attributes.  Returns a copy of arrays and objects.
     *
     *  @returns {Object}  The value of the attribute or undefined if that attribute hasn't been set yet.
     */
    carousel.getA    };
  };

  return asAttributeManager;

});
/////////////////////////
// END FILE js/mixins/carousel_attributes.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/classes/carousel_class_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Base Carousel (abstract)
 */

"use strict";

/**
 *  Base Carousel class which all carousels are meant to inherit from.  Should not be instantiated directly since no event handlers are bound.
 */
P.when("A", "jQuery", "a-carousel-measure", "a-carousel-attributes", "a-carousel-strategies", "a-carousel-constants").register("a-carousel-base", function (A, $, asMeasurable, asAttributeManager, strategies, ATTR) {

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_MAINTAIN_STATE = "maintain_state";
  var ATTR_MAX_HEIGHT = "max_height";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_PAUSED = "transitionPaused";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_TOTAL_PAGES = "totalPages";
  var ATTR_IN_TAB = "isInTab";

  /**
   *  In certain cases, we need to switch between the UI to allow pagination and the UI for only one page of items.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function paginationButtonDisplay(carousel) {
    var singlePage = carousel.getAttr("set_size") <= carousel.getAttr("pageSize");
    var noTransition = carousel.getAttr(ATTR.NO_TRANSITION);
    if (carousel.getAttr(ATTR_TOTAL_PAGES) === 1 && carousel.getAttr(ATTR_PAGE_NUMBER) > 1) {
      carousel.gotoPage(1, {
        startover: true,
        animationDuration: 0
      });
    }
    carousel.dom.$container.find(".a-carousel-left, .a-carousel-right").css("visibility", singlePage || noTransition ? "hidden" : "visible");
  }

  /**
   *  This is the selector used to get the input element which stores the firstVisibleItem attribute.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var FIRST_VISIBLE_ITEM_SELECTOR = "input.a-carousel-firstvisibleitem";

  /**
   *  Make sure the provided set_size is numeric.
   *  {@see https://issues.amazon.com/issues/AUI-11263}
   */
  function asSetSize(value, defaultSize) {
    if (isNaN(value)) {
      // log a warning message
      P.log("`set_size` should be an integer: " + value, "WARN", "aui:carousel:base");
      return defaultSize;
    }
    // `set_size` should be an integer
    // {@link https://aui.amazon.com/development/interactive_components/carousel/quick_start_guide}
    return parseInt(value, 10);
  }

  /**
   *  This function is a one-time use function called by init so that init doesn't get too large
   *  and there aren't unneccessary variables hanging around in the scope chain for these callbacks.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function bindAttrChangeHandlers(carousel) {
    // Pagination functionality.  Update pageNumber and totalPages when the pageSize changes.
    carousel.onChange(ATTR_PAGE_SIZE, function (newPageSize, oldPageSize) {
      // When the page size changes due to resize or whatever, we need to check to see what page we're
      // on as it may change as well
      var currentIdx = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
      var newPageNumber = Math.ceil(currentIdx / newPageSize);
      if (newPageNumber === 1 && currentIdx > 1) {
        newPageNumber = 2;
      } else if (newPageNumber < 1) {
        newPageNumber = 1;
      }
      carousel.setAttr(ATTR_PAGE_NUMBER, newPageNumber);
      carousel.setAttr(ATTR_TOTAL_PAGES, Math.ceil(carousel.getAttr(ATTR_SET_SIZE) / newPageSize));

      // When the page size changes, we may need to fetch more items to ensure that the next/prev page
      // has been fetched
      var ajax = carousel.getAttr("ajax");
      if (newPageSize > oldPageSize) {
        if (ajax && ajax.prefetch_next_page) {
          carousel.strategies.ajax.wantNextPage(carousel);
        } else {
          carousel.strategies.ajax.wantCurrentPage(carousel);
        }
      }
    });

    // If the set size increases, the total number of pages may need to increase and the fetched items array will need to be altered
    carousel.onChange(ATTR_SET_SIZE, function (current, old) {
      // Set the new total number of pages
      var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
      var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);
      carousel.setAttr(ATTR_TOTAL_PAGES, Math.ceil(current / pageSize));

      // Alter the fetchedItems array to reflect the change in set size
      if (current < old) {
        fetchedItems.splice(current, Number.MAX_VALUE);
        carousel.setAttr(ATTR_FETCHED_ITEMS, fetchedItems);
      } else {
        if (carousel.strategies.ajax.wantCurrentPage) {
          carousel.strategies.ajax.wantCurrentPage(carousel);
        }
      }

    });

    // Keep track of the first visible item
    carousel.onChange(ATTR_FIRST_VISIBLE_    });

    // Reset some state variables on page change to prevent the carousel from getting stuck
    carousel.onChange(ATTR_PAGE_NUMBER, function (current) {
      if (current > 0 && current <= carousel.getAttr(ATTR_TOTAL_PAGES)) {
        carousel.setAttr("currentlyWrapping", false);
      }
    });
  }

  /**
   *  Base Carousel class which all carousels are meant to inherit from.  Should not be instantiated directly since no event handlers are bound.
   *
   *  @constructor
   *  @this {Carousel}
   *
   *  @param {HTMLElement} $dom  The optionally jQuery wrapped DOM node for the DIV conatining the carousel components
   *  @param {Object} strategies  A hash of strategies which will be used by this carousel
   *  @param {Object} options  A hash of options to configure the carousel
   *
   *  @returns {Carousel}
   */
  function Carousel($dom, strategies, options) {
    // No arg constructor is used for method inheritance
    // Ex:  CarouselDesktop.prototype = new Carousel();
    if (arguments.length === 0) {
      return;
    }

    // Alias the "this" variable for better minification
    var carousel = this;

    // Make sure we're dealing with a jQuery object, then cache the requisite dom nodes
    if (!$dom.jquery) {
      $dom = $($dom);
    }
    carousel.dom = {
      $container: $dom,
      $viewport: $dom.hasClass("a-carousel-viewport") ? $dom : $dom.find(".a-carousel-viewport"),
      $carousel: $dom.find(".a-carousel")
    };

    // Extend the default attributes with the options.  Don't care what they are.
    var defaults = {
      totalPages: 1000,
      pageNumber: 1,
      pageSize: 0,
      firstVisibleItem: 1,
      maintain_state: true,
      px: 0,
      auto_adjust_height: true,
      ajax: {}
    };
    A.extend(defaults, options);

    defaults.maintain_state = !!defaults.maintain_state;

    // BEGIN total set size detection

    // If a set of IDs (aka ASINs) is passed in as an option, use its size as the set size
    if (defaults.id_list) {
      if (!defaults.set_size) {
        defaults.set_size = defaults.id_list.length;
      }
    } else {
      defaults.id_list = [];
    }

    // If there's no set of ASINs, but they did put an aria-setsize on the carousel items, use that
    var $items = this.dom.$carousel.children("li");
    if (!defaults.set_size) {
      var setSize = parseInt($items.first().attr("aria-setsize"), 10);
      if (A.isFiniteNumber(setSize) && setSize > 0) {
        defaults.set_size = setSize;
      } else {
        defaults.set_size = $items.length;
      }
    } else {
      // https://issues.amazon.com/issues/AUI-11263
      // if we have an invalid value, take the $items.length as the default value
      // that is a good enough indication of how many carousel items
      defaults.set_size = asSetSize(defaults.set_size, $items.length);
    }

    // END total set size detection

    // Set up the fetchedItems array
    var fetchedItems = [];
    carousel.dom.$carousel.children("li")    });
    defaults.fetchedItems = fetchedItems;

    // Add measurement and attribute management functionality and bind the mixins
    asMeasurable(carousel);
    asAttributeManager(carousel, defaults);
    carousel.strategies = strategies;

    return carousel;
  }

  // Functionality for setting and initializing new strategies after the carousel has been created.
  A.each(strategies, function (ignored, type) {
    Carousel.prototype["set" + type.charAt(0).toUpperCase() + type.slice(1) + "Strategy"] = function (strategy) {
      this.strategies[name] = strategy;
      if (typeof strategy.init === "function") {
        strategy.init(this);
      }
    };
  });


  // Setup the rest of the public interface.  Usually just delegates to the appropriate strategy.
  var prototype = Carousel.prototype; // Aliased for compression
  prototype.gotoNextPage = function (options) {
    if (!this.getAttr(ATTR_PAUSED)) {
      this.strategies.transition.gotoNextPage(this, options);
      // accessibleSafe is only set to true by us when responding to a customer user interaction
      // this will stop autorotating carousels that call directly to the prototype to change pages
      // from stealing focus on every page shift
      if (options && options.accessibleSafe) {
        this.strategies.accessibility.nextPage(this, options.animationDuration, options.animationSpeed);
      }
    }
  };
  prototype.gotoPrevPage = function (options) {
    if (!this.getAttr(ATTR_PAUSED)) {
      this.strategies.transition.gotoPrevPage(this, options);
      if (options && options.accessibleSafe) {
        this.strategies.accessibility.prevPage(this, options.animationDuration, options.animationSpeed);
      }
    }
  };
  prototype.gotoPage = function (pageNumber, options) {
    if (!this.getAttr(ATTR_PAUSED)) {
      this.strategies.transition.gotoPage(this, pageNumber, options);
      if (options && options.accessibleSafe) {
        this.strategies.accessibility.gotoPage(this, options.animationDuration, options.animationSpeed);
      }
    }
  };
  prototype.gotoIndex = function (idx, options) {
    if (!this.getAttr(ATTR_PAUSED) || options && options.ignorePause) {
      this.strategies.transition.gotoIndex(this, idx, options);
    }
  };
  prototype.gotoPixel = function (px, options) {
    if (!this.getAttr(ATTR_PAUSED)) {
      this.strategies.transition.gotoPixel(this, px, options);
    }
  };
  prototype.resize = function () {
    if(!this.dom.$container.is(":visible")) {
      return;
    }
    var changes = this.measure("carousel viewport");
    this.strategies.display.resize(this, changes);
  };

  /**
   *  Temporarily prevent the goto functions from doing anything.  Restart goto functions by calling .resume().
   *
   *  @public
   */
  prototype.pause = function () {
    this.setAttr(ATTR_PAUSED, true);
  };

  /**
   *  Will resume allowing goto functions to do what they're supposed to do.
   *
   *  @public.
   */
  prototype.res;
  };

  /**
   *  Function which allows triggering events with consistent names and APIs for all carousels.
   *
   *  @public
   *  @param {string} eventName
   *  @param {object} data  (optional) A hash of data to pass to callbacks.  The carousel will automatically be added to this hash.
   *
   *  triggers a:carousel:[eventName]
   *  triggers a:carousel:[name]:[eventName]
   */
  prototype.triggerEvent = function (eventName, data) {
    var carousel = this;
    data = data || {};
    data.carousel = carousel;

    A.trigger("a:carousel:" + eventName, data);
    var name = carousel.getAttr("name");
    if (name) {
      A.trigger("a:carousel:" + name + ":" + eventName, data);
    }
  };

  /**
   *  Returns the HTML for the static loading image, which is usually empty.  Mobile Carousel has some HTML which gets output.
   *
   *  @public
   *
   *  @return {string}
   */

  prototype.getStaticLoader = function () {
    if (this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS)) {
      return '<div class="' + this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS) + '"></div>';
    }
    return "";
  };

  /**
   *  Return the HTML for an empty carousel card complete with standard loading HTML.
   *
   *  @public
   *  @param {number} index  The 1-based index of this particular card
   *  @param {number} setSize  The total number of cards in the carousel
   *
   *  @return {string}
   */

  prototype.getEmptyCard = function (index, setSize) {
    var elementCssClasses = 'a-carousel-card a-carousel-card-empty';
    if (this.getAttr(ATTR.ELEMENT_CSS_CLASS)) {
      elementCssClasses = elementCssClasses + ' ' + this.getAttr(ATTR.ELEMENT_CSS_CLASS);
    }
    return ['<li class="', elementCssClasses, '" role="listitem" aria-setsize="', setSize, '" aria-posinset="', index, '">', this.getStaticLoader(), '</li>'].join('');
  };


  /**
   *  Setup swipe and pan gesture support.
   *
   *  @public
   */
  prototype.initTouchHandling = function() {
    var carousel = this;
    var $viewport = carousel.dom.$viewport;

    // If the user can swipe, let 'em
    if (A.capabilities.touch || A.capabilities.pointerPrefix) {
      P.when("a-touch").execute(function (touch) {
        $viewport.addClass("a-gesture a-gesture-horizontal").bind("pan-horizontal swipe-horizontal", function () {
          return false;
        });
        A.on("a:swipe-horizontal:" + $viewport[0].id, function (touch) {
          if (!carousel.getAttr("transitionPaused") && carousel.strategies.transition.onSwipe) {
            carousel.strategies.transition.onSwipe(carousel, touch);
          }
        });
        if (!carousel.getAttr("disable_panning")) {
          A.on("a:pan-horizontal:" + $viewport[0].id, function (touch) {
            if (!carousel.getAttr("transitionPaused") && carousel.strategies.transition.onPan) {
              carousel.strategies.transition.onPan(carousel, touch);
            }
          });
        }
      });
    }

    // IE dispatches clicks even if we've panned or swiped. My guess is that the browser checks a delta on movement within the element
    // and since we're moving the element along with the finger, the down and up occur in the same place on a given element?
    // Whether my guess is right or not, on each pointerdown, look for swipes/pans, if one happens, aggressively murder the next click event.
    // This does not manifest on a free scroll carousel.
    // "ssiec" = Stop Stray Internet Explorer Click
    if (A.capabilities.isIE10 || A.capabilities.isIE11Plus) {
      var stopStrayIEClick = function (event) {
        event.stopPropagation();
        event.preventDefault();
        document.body.removeEventListener("click", stopStrayIEClick, true);
      };

      $viewport.bind(A.action.start, function (event) {
        $viewport.bind("swipe-horizontal.a-ssiec pan-horizontal.a-ssiec", function (event) {
          $viewport.unbind(".a-ssiec");
          // Was occasionally killing a valid click. Clicks are only errantly triggered if we get a pointerup here
          // and if we do get a pointerup, it appears that it triggers a click *every* time in my testing
          $viewport.bind(A.action.end + ".a-ssiec", function (event) {
            $viewport.unbind(".a-ssiec");
            if (document.body) {
              document.body.addEventListener("click", stopStrayIEClick, true);
            }
          });
        });
      });
    }
  };

  /**
   *  Seperate initialization function for binding event handlers and whatever else is needed.
   *  Meant to be called when the carousel is almost visible on the screen.  Should be extended
   *  in inheriting classes.
   *
   *  @this {Carousel}
   *
   *  @returns {Boolean} Whether or not initialization actually took place.  Will be delayed if the set size isn't known
   */
  prototype.init = function () {
    var carousel = this;
    var strategies = carousel.strategies;

    // If the carousel viewport DOM node doesn't have an ID, give it one so that we can listen to some extra events
    var viewport = carousel.dom.$viewport[0];
    if (viewport && !viewport.id) {
      viewport.id = "anonCarousel" + carousel.__id;
    }

    // Kill all the non-li nodes in the carousel list to prevent extra whitespace from screwing up the carousel
    // card display.  They need to stack right next to each other.
    var carouselNode = carousel.dom.$carousel[0];
    var children = carouselNode.childNodes;
    var i = children.length;
    while (i--) {
      if (!(children[i].tagName && children[i].tagName.toLowerCase() === "li")) {
        carouselNode.removeChild(children[i]);
      }
    }

    A.each(carousel.strategies, function (strategy) {
      if (strategy.initAttrs) {
        A.each(strategy.initAttrs, function (value, name) {
          var initValue = value;
          if (typeof value === 'function') {
            initValue = value(carousel.getAttr(name));
          }
          carousel.setAttr(name, initValue);
        });
      }
    });

    if (carousel.getAttr(ATTR_SET_SIZE) < 1) {
      strategies.ajax.init(carousel);
      return false;
    }

    // Run init for all the strategies
    carousel.measure();
    A.each(carousel.strate    });

    // Get the total number of pages
    var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
    var set_size = carousel.getAttr(ATTR_SET_SIZE);
    var totalPages = Math.ceil(set_size / pageSize);
    carousel.setAttr(ATTR_TOTAL_PAGES, totalPages);

    bindAttrChangeHandlers(carousel);

    carousel.setAttr(ATTR_IN_TAB, carousel.dom.$container.closest('.a-tab-content').length > 0, true);

    // Make sure you tweet your initialization
    carousel.triggerEvent("init");

    // If any code needs to be run after all other initialization code, take care of it now
    A.each(carousel.strate    });

    carousel.triggerEvent("afterInit");

    // If the carousel should start on a different page, go there now
    var firstVisibleItem = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    if (firstVisibleItem === 1 && carousel.getAttr(ATTR_MAINTAIN_STATE)) {
      // If the user has navigated back to this page, see if we need to start on a different page
      firstVisibleItem = parseInt(carousel.dom.$container.find(FIRST_VISIBLE_ITEM_SELECTOR).val(), 10);
      if (!(A.isFiniteNumber(firstVisibleItem) && firstVisibleItem > 0 && firstVisibleItem <= set_size)) {
        firstVisibleItem = 1;
      }
    }

    if (firstVisibleItem > 1) {
      var initialDuration = 700;
      var duration = initialDuration;
      var pagesToMove = Math.ceil(firstVisibleItem / carousel.getAttr(ATTR_PAGE_SIZE));
      for (var j = 2; j < pagesToMove; j++) {
        duration = duration + (initialDuration / j);
      }

      //var duration = distance / A.viewport().width * 1000 * 0.7 * ((firstVisibleItem - 1) * 0.6);
      carousel.gotoIndex(firstVisibleItem, {
        animationDuration: duration,
        easingFunction: "ease"
      });
    }

    // If there is only one page worth of cards, hide the pagination buttons
    paginationButtonDisplay(this);
    carousel.onChange("pageSize set_size", function () {
      paginationButtonDisplay(carousel);
    });

    // Fix the positions of the pagination buttons
    var $buttons = carousel.dom.$container.find(".a-carousel-button");
    if ($buttons.length) {
      var top = $buttons.eq(0).position().top + "px";
      $buttons.css("top", top);
    }

    /**
     * IE 9+ and IE < 9 handle double clicks differently.  IE 8 will only trigger one click event before triggering
     * the double click event.  IE 9+ will trigger two.  So, in order to allow the user to spam the next and prev
     * page buttons, I need to bind to both click and dblclick.  If two click events are fired before dblclick,
     * don't fire the handler on dblclick.  This boolean state var is used to do that.  When the event handler
     * fires, check this var, set it to true if it's false, then set it back to false after a short delay.
     *
     *  @private
     *  @type {boolean}
     */
    var clickHandled = false;
    var restartCarousel = function(event) {
      event.preventDefault();
      var options = {
        startover: true,
        accessibleSafe: (event.type === "keydown") ? true : false
      };
      if (carousel.getAttr(ATTR_PAGE_NUMBER) > 5) {
        options.animationDuration = 1250;
      } else {
        options.animationSpeed = carousel.getDimensions().viewport.width * 5;
      }
      carousel.gotoPage(1, options);
    }

    // Bind event handlers
    carousel.dom.$container.delegate(".a-carousel-goto-nextpage", "click dblclick", function (event) {
      if (!clickHandled) {
        clickHandled = true;

        event.preventDefault();
        carousel.gotoNextPage();

        A.delay(function () {
          clickHandled = false;
        }, 5);
      }
    }).delegate(".a-carousel-goto-prevpage", "click dblclick", function (event) {
      if (!clickHandled) {
        clickHandled = true;

        event.preventDefault();
        carousel.gotoPrevPage();

        A.delay(function () {
          clickHandled = false;
        }, 5);
      }

    }).delegate(".a-carousel-goto-nextpage", "keydown", function (event) {
      if (event.which === A.constants.keycodes.ENTER || event.which === A.constants.keycodes.SPACE) {
        event.preventDefault();
        carousel.gotoNextPage({accessibleSafe: true});
      }
    }).delegate(".a-carousel-goto-prevpage", "keydown", function (event) {
      if (event.which === A.constants.keycodes.ENTER || event.which === A.constants.keycodes.SPACE) {
        event.preventDefault();
        carousel.gotoPrevPage({accessibleSafe: true});
      }
    }).delegate(".a-carousel-restart", "keydown", function(event) {
      if (event.which === A.constants.keycodes.ENTER || event.which === A.constants.keycodes.SPACE) {
        restartCarousel(event);
      }
    }).delegate(".a-carousel-restart", "click", restartCarousel);

    // Get the total number of pages and update that on the UI
    carousel.dom.$container.find(".a-carousel-page-max").html(this.getAttr(ATTR_TOTAL_PAGES));
    return true;

  };

  return Carousel;
});
/////////////////////////
// END FILE js/classes/carousel_class_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/classes/carousel_class_mobile.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AUI Carousel Default Mobile Class
 *
 */

"use strict";

/**
 *  A sub-class of Carousel which has mobile specific event handlers for user interaction and DOM updates.
 */
P.when("A", "jQuery", "a-carousel-base", "a-carousel-constants").register("a-carousel-mobile", function (A, $, Carousel, ATTR) {
  var undefined;

  /**
   *  The static loading needs to have its height specificed in pixels.  We determine that here.
   *
   *  @private
   *  @param {Carousel} carousel
   *
   *  @returns {Number} height
   */
  function determineStaticLoaderHeight(carousel) {
    var height = carousel.getAttr("loaderHeight");
    if (height) {
      return height;
    } else {
      height = carousel.getAttr("maxHeight");
      if (height) {
        height *= 0.9;
        height = Math.min(height, 90);
        height = Math.max(height, 120);
      } else {
        height = 90;
      }
      carousel.setAttr("loaderHeight", height);
    }
    return height;
  }

  /**
   *  The mobile specific Carousel class.  This has additional event handlers and attribute change callbacks
   *  to update the mobile UI.
   *
   *  @constructor
   *  @augments Carousel
   *  @this {CarouselMobile}
   *
   *  @param {HTMLElement} $dom  The optionally jQuery wrapped DOM node for the DIV conatining the carousel components
   *  @param {Object} strategies  A hash of strategies which will be used by this carousel
   *  @param {Object} options  A hash of options to configure the carousel
   *
   *  @returns {CarouselMobile}
   */
  function CarouselMobile($dom, strategies, options) {
    // No arg constructor is used for method inheritance
    // Ex:  AwesomeCarousel.prototype = new CarouselMobile();
    Carousel.call(this, $dom, strategies, options);
    if (arguments.length === 0) {
      return;
    }

    var carousel = this;

    // Set mobil specific defaults
    if (carousel.getAttr("circular") === undefined) {
      carousel.setAttr("circular", false);
    }
    if (carousel.getAttr("show_partial_next") === undefined) {
      carousel.setAttr("show_partial_next", true);
    }
    if (carousel.getAttr("hide_off_screen") === undefined) {
      carousel.setAttr("hide_off_screen", false);
    }
    if (carousel.getAttr("springiness") === undefined) {
      carousel.setAttr("springiness", 0.8);
    }
    if (carousel.getAttr("touch_easing") === undefined) {
      carousel.setAttr("touch_easing", "cubic-bezier(0.215, 0.610, 0.355, 1.000)");
    }

    /**
     *  Creates mobile specific event handlers.
     *
     *  @this {CarouselMobile}
     *  @returns {Boolean} Whether or not initialization actually took place.  Will be delayed if the set size isn't known
     */
    carousel.init = function () {
      var carousel = this;
      if (Carousel.prototype.init.call(carousel)) {
        if (!this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS)) {
          // Determine the height of any existing static loaders
          carousel.dom.$carousel.children("li").children(".a-loading-static").css("height", determineStaticLoaderHeight(carousel) + "px");
        }

        if (!carousel.getAttr(ATTR.NO_TRANSITION)) {
          carousel.initTouchHandling();
        }
        return true;
      } else {
        return false;
      }
    };

    return this;
  }

  // Inherit from the base paginated carousel and reset the constructor
  CarouselMobile.prototype = new Carousel();
  CarouselMobile.prototype.constructor = CarouselMobile;

  /**
   *  Returns the HTML for the static loading image.  The height of the static loader is dependent on the height of the
   *  carousel right after initialization with a minimum and maximum bound on that height.
   *
   *  @this {CarouselMobile}
   *  @public
   *
   *  @returns {String}
   */
  CarouselMobile.prototype.getStaticLoader = function () {
    if (this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS)) {
      return '<div class="' + this.getAttr(ATTR.STATIC_LOADER_CSS_CLASS) + '"></div>';
    }
    var height = determineStaticLoaderHeight(this);
    return '<div class="a-loading-static" style="height:' + height + 'px"><div class="a-loading-static-inner"></div></div>';
  };

  return CarouselMobile;
});
/////////////////////////
// END FILE js/classes/carousel_class_mobile.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/classes/carousel_class_desktop.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Default class for the Desktop Carousel
 *
 */

"use strict";

/**
 *  A sub-class of Carousel which has desktop specific event handlers for user interaction and DOM updates.
 */
P.when("A", "jQuery", "a-carousel-base", "a-carousel-constants").register("a-carousel-desktop", function (A, $, Carousel, ATTR) {
  var undefined;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_TOTAL_PAGES = "totalPages";
  var ATTR_PAGE_NUMBER = "pageNumber";

    /**
   *  In certain cases, we need to switch between the UI to allow pagination and the UI for only one page of items.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function paginationButtonDisplay(carousel) {
    var singlePage = carousel.getAttr("set_size") <= carousel.getAttr("pageSize");
    var noTransition = carousel.getAttr(ATTR.NO_TRANSITION);
    carousel.dom.$container.find(".a-carousel-pagination").css("visibility", singlePage || noTransition ? "hidden" : "visible");
  }

  /**
   *  The desktop specific Carousel class.  This has additional event handlers and attribute change callbacks
   *  to update the desktop UI.
   *
   *  @constructor
   *  @augments Carousel
   *  @this {CarouselDesktop}
   */
  function CarouselDesktop($dom, strategies, options) {
    // No arg constructor is used for method inheritance
    // Ex:  AwesomeCarousel.prototype = new CarouselDesktop();
    Carousel.call(this, $dom, strategies, options);
    if (arguments.length === 0) {
      return;
    }

    // Alias "this" to provide better minification
    var carousel = this;

    // Set desktop specific defaults
    if (carousel.getAttr("circular") === undefined) {
      this.setAttr("circular", true);
    }
    if (carousel.getAttr("hide_off_screen") === undefined) {
      this.setAttr("hide_off_screen", true);
    }

    // Make sure the total number of pages is kept up to date
    carousel.onChange(ATTR_TOTAL_PAGES, function (totalPages) {
      carousel.dom.$container.find(".a-carousel-page-max").html(totalPages);
      if (totalPages < carousel.getAttr(ATTR_PAGE_NUMBER)) {
        carousel.gotoPage(totalPages);
      }
    });

    // The "start over" link needs to be hidden on the first page and shown everywhere else
    carousel.onChange(ATTR_PAGE_NUMBER, function (newValue, oldValue) {
      var $container = carousel.dom.$container;
      var $restart = $container.find(".a-carousel-restart-container");
      if (newValue > 1) {
        $restart.show();
      } else {
        $restart.hide();
      }
      $container.find(".a-carousel-page-current").html(newValue);
    });

    /**
     *  Creates desktop specific event handlers.
     *
     *  @this {CarouselDesktop}
     *  @returns {Boolean} Whether or not initialization actually took place.  Will be delayed if the set size isn't known
     */
    carousel.init = function () {
      // Alias "this" to provide better minification
      var carousel = this;

      if (Carousel.prototype.init.call(carousel)) {
        // If there is only one page worth of cards, hide the pagination buttons
        paginationButtonDisplay(this);
        carousel.onChange("pageSize set_size", function () {
          paginationButtonDisplay(carousel);
        });

        // Hide the "start over" link
        if (carousel.getAttr(ATTR_PAGE_NUMBER) < 2) {
          carousel.dom.$container.find(".a-carousel-restart-container").hide();
        }

        if (!carousel.getAttr(ATTR.NO_TRANSITION)) {
          carousel.initTouchHandling();
        }
        return true;
      } else {
        return false;
      }
    };

    return carousel;
  }

  // Inherit from the base paginated carousel and reset the constructor
  CarouselDesktop.prototype = new Carousel();
  CarouselDesktop.prototype.constructor = CarouselDesktop;

  return CarouselDesktop;
});
/////////////////////////
// END FILE js/classes/carousel_class_desktop.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/classes/carousel_classes.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Class Aggregator
 */

"use strict";

P.when("A", "a-carousel-desktop", "a-carousel-mobile").register("a-carousel-clas };
});
/////////////////////////
// END FILE js/classes/carousel_classes.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_stretchygoodness.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel "Stretchy Goodness" Display Strategy
 *
 */

"use strict";

/**
 *  A display strategy wherein the margin between elements is adjusted to ensure that cards are equally spaced inside the viewport.
 */
P.when("A", "jQuery", "p-detect", "a-carousel-constants").register("a-carousel-stretchygoodness", function (A, $, detect, ATTR) {
  var undefined;

  /**
   *  The default minimum space between elements in the carousel
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_MIN_GUTTER = 15;

  /**
   *  The default animation duration for adjusting carousel height
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_HEIGHT_ANIMATION_SPEED = 200;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_ANIMATING = "animating";
  var ATTR_CURRENT_GUTTER = "currentGutter";
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_FIRST_ITEM_FLUSH_LEFT = "first_item_flush_left";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_HEIGHT_ANIMATION_SPEED = "height_animation_speed";
  var ATTR_HIDE_OFFSCREEN = "hide_off_screen";
  var ATTR_MAX_HEIGHT = "maxHeight";
  var ATTR_MIN_GUTTER = "minimum_gutter_width";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_SHOW_PARTIAL = "show_partial_next";
  var ATTR_SINGLE_PAGE_ALIGN = "single_page_align";
  var ATTR_TOTAL_PAGES = "totalPages";

  /**
   *  Determines the maximum number of items which can fit in the viewport given the item width,
   *  the minimum possible gutter, and the total set size.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} viewportWidth  The width of the visible area of the carousel container
   *  @param {Number} itemWidth  How wide is each element
   *
   *  @returns {Number} pageSize
   */
  function determinePageSize(carousel, viewportWidth, itemWidth, flushLeft) {
    if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
      viewportWidth -= itemWidth / 10;
    }
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);
    var pageSize = 0;
    var first = true;
    while (viewportWidth > 0) {
      pageSize++;
      if (flushLeft && first) {
        viewportWidth -= itemWidth;
      } else {
        viewportWidth -= (itemWidth + minGutter);
      }
      first = false;
    }
    if (viewportWidth < 0) {
      pageSize--;
    }

    return A.isFiniteNumber(pageSize) && pageSize > 0 ? pageSize : 1;
  }

  /**
   *  Calculate the new gutter width.  Relatively simple calculation, but it needs quite a bit of
   *  information about the state/dimensions of the carousel.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} viewportWidth
   *  @param {Number} itemWidth
   *  @param {Number} pageSize
   *  @param {Number} minGutter
   *  @param {Number} setSize
   *  @param {boolean} flushLeft
   *
   *  @returns {Number}  The new minimum gutter for the carousel
   */
  function determineGutterWidth(carousel, viewportWidth, itemWidth, pageSize, minGutter, setSize, flushLeft) {
    if (carousel.getAttr(ATTR_SINGLE_PAGE_ALIGN) === "stretch" && pageSize > setSize) {
      pageSize = setSize;
    }
    // Calculate the new gutter based on the new page size
    var whiteSpace = viewportWidth - (itemWidth * pageSize);
    if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
      var remainder = whiteSpace - (minGutter * (pageSize + 1));
      if (flushLeft) {
        remainder += minGutter;
      }
      var percentWidthAvailable = remainder / itemWidth;
      whiteSpace -= itemWidth * (percentWidthAvailable > 0.5 ? 0.5 : percentWidthAvailable);
    } else if (flushLeft) {
      whiteSpace += minGutter;
    }
    var newGutter = Math.ceil(whiteSpace / (pageSize + 1));
    if (!A.isFiniteNumber(newGutter) || newGutter < minGutter) {
      newGutter = minGutter;
    }
    return newGutter;
  }

  /**
   *  The height of the carousel is determined by the tallest element which has ever appeared
   *  in the viewport of the carousel.  This function will find that max height and apply it
   *  to the proper div
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function adjustHeight(carousel) {
    if (carousel.getAttr("auto_adjust_height")) {
      if (carousel.getAttr(ATTR_ANIMATING)) {
        carousel.once(ATTR_ANIMA    });
      } else {
        // Get the existing maxHeight
        var maxHeight = carousel.getAttr(ATTR_MAX_HEIGHT);
        var dimensions = carousel.getDimensions();
        if (!maxHeight || !A.isFiniteNumber(maxHeight)) {
          maxHeight = 1;
        }

        // Determine if any visible element is taller than the viewport
        var newMaxHeight = maxHeight;
        var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
        var current = pageSize * (carousel.getAttr(ATTR_PAGE_NUMBER) - 1);
        var limit = current + pageSize - 1;
        var itemDimensions = dimensions.items;
        var numItems = itemDimensions.length;
        var item;
        if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
          limit++;
        }
        for (; current <= limit && current < numItems; current++) {
          item = itemDimensions[current];
          if (item && item.outerHeight > newMaxHeight) {
            newMaxHeight = itemDimensions[current].outerHeight || itemDimensions[current].height;
          }
        }

        // Apply the new height, if necessary
        if (newMaxHeight > maxHeight) {
          var newDimensions = {
            viewport: {
              height: newMaxHeight,
              outerHeight: newMaxHeight
            }
          };
          carousel.updateDimensionsCache(newDimensions);
          carousel.setAttr(ATTR_MAX_HEIGHT, newMaxHeight);
          if (maxHeight === 1) {
            carousel.dom.$viewport.height(newMaxHeight);
          } else {
            A.animate(carousel.dom.$viewport, {
              height: newMaxHeight
            }, carousel.getAttr(ATTR_HEIGHT_ANIMATION_SPEED), "linear");
          }
        }
      }
    } else {
      carousel.dom.$viewport.css("height", "");
    }
  }

  /**
   *  During init, we need to make some DOM changes to ensure that the display and transition strategies can do what needs doin
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function initDom(carousel) {
    // Set the height to ensure all elements are properly displayed
    if (!carousel.getAttr(ATTR.NO_TRANSITION)) {
      adjustHeight(carousel);
    }
    var dimensions = carousel.getDimensions();
    var height = dimensions.viewport.height;
    carousel.dom.$container
      .find(".a-carousel-left, .a-carousel-right, .a-carousel-viewport")
      .css("height", Math.max(dimensions.viewport.height, dimensions.items[0] ? dimensions.items[0].height : 0) + "px");
  }

  /**
   *  This function is a one-time use function called by init so that init doesn't get too large
   *  and there aren't unneccessary variables hanging around in the scope chain for these callbacks.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function bindAttrChangeHandlers(carousel) {
    // Before we animate, we need to adjust visibility and carousel height
    carousel.onChange(ATTR_PAGE_NUMBER, function () {
      if (carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
        carousel.dom.$carousel.children("li").css("visibility", "");
      }
    });

    // See if a new item added to the page forces a taller carousel
    carousel.onChange(ATTR_PAGE_SIZE, function (current, old) {
      // Make sure the viewport is the right height
      if (current > old) {
        adjustHeight(carousel);
      }
    });

    carousel.onChange("loading", function (current) {
      if (!current) {
        adjustHeight(carousel);
      }
    });

    // Adjust the height to fit the new elements on the page
    carousel.onChange(ATTR_FIRST_VISIBLE_ITEM, function () {
      adjustHeight(carousel);
    });

    // Process hiding off screen elements if appropriate
    carousel.onChange(ATTR_ANIMATING, function (current) {
      if (!current && carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
        var c = carousel;
        var first = c.getAttr(ATTR_FIRST_VISIBLE_ITEM) - 1;
        var last = first + c.getAttr(ATTR_PAGE_SIZE) - 1;
        if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
          last++;
        }
        c.dom.$carousel.children("li").each(function (idx, item) {
          var visible = idx >= first && idx <= last;
          $(item).css("visibility", visible ? "" : "hidden");
        });
      }
    });

    // A couple of attributes just need a repaint on change
    carousel.onChange(ATTR_SINGLE_PAGE_ALIGN + " " + ATTR_MIN_GUTTER, function () {
      repaint(carousel);
    });

    carousel.onChange(ATTR_MIN_GUTTER, function () {
      repaint(carousel);
    });
  }

  /**
   *  Calculate and apply a new gutter width.  Alter pageSize if necessary.
   *
   *  @public
   *  @param {Carousel} carousel
   *
   *  triggers a:carousel:[name]:repaint
   */
  function repaint(carousel) {
    var dimensions = carousel.getDimensions();
    var viewportWidth = dimensions.viewport.width;
    var itemWidth = dimensions.getFirstCardWidth();
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);
    var flushLeft = carousel.getAttr(ATTR_FIRST_ITEM_FLUSH_LEFT);

    // Calculate the page size and the new gutter width
    var pageSize = determinePageSize(carousel, viewportWidth, itemWidth, flushLeft);
    var newGutter = determineGutterWidth(carousel, viewportWidth, itemWidth, pageSize, minGutter, setSize, flushLeft);
    // Update carousel attributes
    carousel.setAttr(ATTR_CURRENT_GUTTER, newGutter);
    carousel.setAttr(ATTR_PAGE_SIZE, pageSize);

    // Calculate the new carousel width and ensure current set values are accurate based on potential page size changes
    var $carousel = carousel.dom.$carousel;
    var $items = $carousel.children("li");
    var numItems = $items.length;
    var totalPages = carousel.getAttr(ATTR_TOTAL_PAGES);
    var currentPage = carousel.getAttr(ATTR_PAGE_NUMBER);
    var firstVisible = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    var expectedFirstVisible = (currentPage - 1) * pageSize + 1;
    
    // Determine if we're on a page number that may no longer exist as a result of resize/device rotation and move to the highest page
    if (currentPage > totalPages) {
      firstVisible = (totalPages - 1) * pageSize + 1;
      carousel.setAttr(ATTR_PAGE_NUMBER, totalPages);
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisible);
    } else if (firstVisible !== expectedFirstVisible) {
    // Or determine if, after rotating, our previous first item is part of a different page now than we were on previously. If it is,
    // make sure to shift the carousel to an index divisble by the new page size *that still contains the item that was the first
    // visible item in the previous orientation*
      var newPage = Math.ceil(firstVisible / pageSize);
      firstVisible = (newPage - 1) * pageSize + 1;
      carousel.setAttr(ATTR_PAGE_NUMBER, newPage);
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisible);
    }

    // Apply the new gutter width
    var first = firstVisible - 1;
    var last = first + pageSize - 1;
    if (carousel.getAttr(ATTR_SHOW_PARTIAL)) {
      last++;
    }
    var hideOffScreen = carousel.getAttr(ATTR_HIDE_OFFSCREEN);
    var margin = newGutter + "px";
    var itemWidthAttr = itemWidth + "px";
    var visible;
    $items.each(function (idx, item) {
      visible = !hideOffScreen || (idx >= first && idx <= last);
      item.style.marginLeft = flushLeft && idx === 0 ? 0 : margin;
      item.style.visibility = visible ? "" : "hidden";
      item.style.width = itemWidthAttr;
    });

    // Apply the carousel width as well as the single page alignment, if necessary
    var itemOuterWidth, firstItemOuterWidth, carouselWidth;
    if (carousel.getAttr(ATTR_FIRST_ITEM_FLUSH_LEFT)) {
      firstItemOuterWidth = $items.first().outerWidth(true);
      if ($items.length > 1) {
        itemOuterWidth = $items.eq(1).outerWidth(true);
      }
      carouselWidth = (numItems - 1) * itemOuterWidth + firstItemOuterWidth;
    } else {
      firstItemOuterWidth = itemOuterWidth = $items.first().outerWidth(true);
      carouselWidth = numItems * itemOuterWidth;
    }
    if (pageSize >= setSize) {
      carouselWidth = viewportWidth;
      var alignment = carousel.getAttr(ATTR_SINGLE_PAGE_ALIGN);
      $carousel.toggleClass("a-text-right", alignment === "right");
      $carousel.toggleClass("a-text-center", alignment === "center");
      if (alignment === "center") {
        $items.first().css("margin-left", 0);
      }
    } else {
      $carousel.removeClass("a-text-right a-text-center");
    }

    carouselWidth = pageSize >= setSize ? viewportWidth : carouselWidth;
    $carousel.css("width", carouselWidth + "px");

    // Prepare and make updates to the measurements cache
    var updates = {
      carousel: {
        width: carouselWidth,
        outerWidth: $carousel.outerWidth()
      },
      items: []
    };
    for (var i = 0; i < numItems; i++) {
      updates.items.push({
        width: itemWidth,
        outerWidth: i === 0 ? firstItemOuterWidth : itemOuterWidth
      });
    }
    carousel.updateDimensionsCache(updates);

    // Make sure the item which was the first visible item in the viewport is still the first visible item
    carousel.gotoIndex(firstVisible, {
      animationDuration: 0,
      ignorePause: true
    });

    // Trigger a global event if able
    carousel.triggerEvent("repaint");
  }

  /**
   *  If the page has resized and the width of the viewport has changed, we need to repaint.
   *
   *  @param {Carousel} carousel
   *  @param {Object} changes - A hash of changed dimensions and their associated new value
   */
  function resize(carousel, changes) {
    if (changes.viewport && changes.viewport.width !== undefined) {
      repaint(carousel);
    }
  }

  /**
   *  When the carousel inits, we need to determine the minimum gutter, initial pageSize, and which items where fetched.
   *  Then we repaint to apply the right gutter sizes.
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function init(carousel) {
    // Set the min gutter if the user didn't pass one in.
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    if (!A.isFiniteNumber(minGutter)) {
      minGutter = DEFAULT_MIN_GUTTER;
      carousel.setAttr(ATTR_MIN_GUTTER, minGutter);
    }
    carousel.setAttr(ATTR_CURRENT_GUTTER, minGutter);

    // Make sure the height animation speed's legit
    var heightAnimationSpeed = carousel.getAttr(ATTR_HEIGHT_ANIMATION_SPEED);
    if (!A.isFiniteNumber(heightAnimationSpeed)) {
      carousel.setAttr(ATTR_HEIGHT_ANIMATION_SPEED, DEFAULT_HEIGHT_ANIMATION_SPEED);
    }

    // Cast to a boolean
    carousel.setAttr(ATTR_FIRST_ITEM_FLUSH_LEFT, !!carousel.getAttr(ATTR_FIRST_ITEM_FLUSH_LEFT));

    // See if we need to show part of the next element
    carousel.setAttr(ATTR_SHOW_PARTIAL, !!carousel.getAttr(ATTR_SHOW_PARTIAL));

    // Repaint to get the right gutter applied and adjust the height to match page 1 content
    repaint(carousel);
    initDom(carousel);

    // If the user has navigated back to this page, see if we need to start on a different page
    var firstVisibleItem = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    if (firstVisibleItem > 1) {
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisibleItem);
      var newPage = Math.ceil(firstVisibleItem / carousel.getAttr(ATTR_PAGE_SIZE));
      carousel.gotoPage(newPage);
    }

    // Bind all the attr change handlers we need.
    bindAttrChangeHandlers(carousel);
  }

  return {
    repaint: repaint,
    init: init,
    resize: resize
  };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_stretchygoodness.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_swap.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when("A", "jQuery", "p-detect", "a-carousel-utils").register("a-carousel-display-swap", function (A, $, detect, util) {
  var undefined;

  /**
   *  The default minimum space between elements in the carousel
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_MIN_GUTTER = 15;

  /**
   *  The default animation duration for adjusting carousel height
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_HEIGHT_ANIMATION_SPEED = 200;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I dont' misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_ANIMATING = "animating";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_MIN_GUTTER = "minimum_gutter_width";
  var ATTR_CURRENT_GUTTER = "currentGutter";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_HEIGHT_ANIMATION_SPEED = "height_animation_speed";
  var ATTR_MAX_HEIGHT = "maxHeight";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_TOTAL_PAGES = "totalPages";
  var ATTR_LOADING = "loading";
  var ATTR_SINGLE_PAGE_ALIGN = "single_page_align";

  /**
   *  The CSS class placed on empty carousel cards
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var EMPTY_CARD_CLASS = "a-carousel-card-empty";

  /**
   *  Determines the maximum number of items which can fit in the viewport given the item width,
   *  the minimum possible gutter, and the total set size.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} viewportWidth - The width of the visible area of the carousel container
   *  @param {Number} itemWidth - How wide is each element
   *
   *  @returns {Number} pageSize
   */

  function determinePageSize(carousel, viewportWidth, itemWidth) {
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);
    var pageSize = Math.max(Math.floor(viewportWidth / (itemWidth + minGutter)), 1);

    return A.isFiniteNumber(pageSize) ? pageSize : 1;
  }

  /**
   *  The height of the carousel is determined by the tallest element which has ever appeared
   *  in the viewport of the carousel.  This function will find that max height and apply it
   *  to the proper div
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function adjustHeight(carousel) {
    if (carousel.getAttr("auto_adjust_height")) {
      // Get the existing maxHeight
      var maxHeight = carousel.getAttr(ATTR_MAX_HEIGHT);
      if (!maxHeight || !A.isFiniteNumber(maxHeight)) {
        maxHeight = 1;
      }

      // Determine if any visible element is taller than the viewport
      var newMaxHeight = maxHeight;
      carousel.dom.$carousel.children("li").not("." + EMPTY_CARD_CLASS)    });

      if (newMaxHeight > maxHeight) {
        carousel.setAttr(ATTR_MAX_HEIGHT, newMaxHeight);
        if (detect.capabilities.transition) {
          if (maxHeight === 1) {
            carousel.dom.$viewport.height(newMaxHeight);
          } else {
            A.animate(carousel.dom.$viewport, {
              height: newMaxHeight
            }, carousel.getAttr(ATTR_HEIGHT_ANIMATION_SPEED), "linear");
          }
        } else {
          carousel.dom.$viewport.height(newMaxHeight);
        }

        var newDimensions = {
          viewport: {
            height: newMaxHeight,
            outerHeight: newMaxHeight
          }
        };
        carousel.updateDimensionsCache(newDimensions);
      }
    } else {
      carousel.dom.$viewport.css("height", "");
    }
  }

  /**
   *  Create an empty card using the attributes for this carousel
   *
   *  @private
   *  @param {Number} setSize - The total number of items in the carousel
   *  @param {Number} position - The 1-based position of the carousel item in the list
   *  @param {Number} width - The width of a card in pixels
   *  @param {Number} gutter - The amount of space between each card in pixels
   *  @param {Carousel} carousel
   *
   *  @returns {String}
   */

  function generateBlankItem(setSize, idx, width, gutter, carousel) {
    return ['<li class="a-carousel-card ', EMPTY_CARD_CLASS, '" role="listitem" aria-setsize="', setSize, '" aria-posinset="', idx, '" style="width:', width, 'px; margin-left:', gutter, 'px;">', carousel.getStaticLoader()].join("");
  }

  /**
   *  It the number of items in the list is greater than the page size, remove those extra items.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} pageSize
   */

  function removeExtraItems(carousel, pageSize) {
    var list = carousel.dom.$carousel[0];
    var items = carousel.dom.$carousel.children("li").get();
    var item;
    while (items.length > pageSize) {
      item = items.pop();
      list.removeChild(item);
    }
  }

  /**
   *  During init, we may need to make DOM changes
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function initDom(carousel) {
    // Set the height to ensure all elements are properly displayed
    var dimensions = carousel.getDimensions();
    var height = dimensions.viewport.height;
    carousel.dom.$container.find(".a-carousel-left, .a-carousel-right, .a-carousel-viewport").css("height", Math.max(dimensions.viewport.height, dimensions.items[0] ? dimensions.items[0].height : 0) + "px");
  }

  /**
   *  This function is a one-time use function called by init so that init doesn't get too large
   *  and there aren't unneccessary variables hanging around in the scope chain for these callbacks.
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function bindAttrChangeHandlers(carousel) {
    // After animation, we may need to adjust page size. Check that the animating attribute has
    // been set to false and then call the function that determines whether new items have been
    // brought into the DOM and are taller than the existing max height
    carousel.onChange(ATTR_ANIMATING, function (current) {
      if (!current) {
        adjustHeight(carousel);
      }
    });

    // Ensure that when new items are fetched, the height of the DOM is tall enough as above
    carousel.onChange(ATTR_LOADING, function (current) {
      if (!current) {
        adjustHeight(carousel);
      }
    });

    // See if a new item added to the page forces a taller carousel
    carousel.onChange(ATTR_PAGE_SIZE, function (current, old) {
      if (current > old) {
        if (old === 0) {
          removeExtraItems(carousel);
        }
        var setSize = carousel.getAttr(ATTR_SET_SIZE);
        var itemWidth = carousel.getDimensions().getFirstCardWidth();
        var currentGutter = carousel.getAttr(ATTR_CURRENT_GUTTER);
        var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);
        var firstVisibleIndex = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM) - 1;
        var $items = carousel.dom.$carousel.children("li");
        var fragment = document.createDocumentFragment();
        var $item, idx;
        if ($.isArray(fetchedItems)) {
          for (var i = $items.length; i < current; i++) {
            idx = i + firstVisibleIndex;
            $item = $(generateBlankItem(setSize, idx + 1, itemWidth, currentGutter, carousel));
            if (fetchedItems[idx]) {
              util.addElementToDom($item, util.getElementFromItem(fetchedItems[idx]));
            }
            if (idx >= setSize) {
              $item.removeClass(EMPTY_CARD_CLASS);
            }
            fragment.appendChild($item[0]);
          }
          carousel.dom.$carousel.append(fragment);
        }
        adjustHeight(carousel);
      } else if (current < old) {
        removeExtraItems(carousel);
      }
    });

    // If the set size increases,
    carousel.onChange(ATTR_SET_SIZE, function (current, old) {
      var page = carousel.getAttr(ATTR_PAGE_NUMBER);
      var lastPage = carousel.getAttr(ATTR_TOTAL_PAGES);
      var $items = carousel.dom.$carousel.children("li");
      if (page === lastPage) {
        if (current > old) {
          if ($items.length) {
            carousel.dom.$carousel.children("li").each(function (idx, item) {
              if (!A.trim(item.innerHTML)) {
                item.className += " " + EMPTY_CARD_CLASS;
                item.innerHTML = carousel.getStaticLoader();
              }
            });
          }
          if (old === 0) {
            repaint(carousel);
          }
        }
      }
    });

    // A couple of attributes just need a repaint on change
    carousel.onChange(ATTR_SINGLE_PAGE_ALIGN + " " + ATTR_MIN_GUTTER, function () {
      repaint(carousel);
    });

    carousel.onChange(ATTR_MIN_GUTTER, function () {
      repaint(carousel);
    });
  }

  /**
   *  Calculate the new gutter width.  Relatively simple calculation, but it needs quite a bit of
   *  information about the state/dimensions of the carousel.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {Number} viewportWidth
   *  @param {Number} itemWidth
   *  @param {Number} pageSize
   *  @param {Number} minGutter
   *  @param {Number} setSize
   *
   *  @returns {Number}  The new minimum gutter for the carousel
   */
  function determineGutterWidth(carousel, viewportWidth, itemWidth, pageSize, minGutter, setSize) {
    if (carousel.getAttr(ATTR_SINGLE_PAGE_ALIGN) === "stretch" && pageSize > setSize) {
      pageSize = setSize;
    }
    // Calculate the new gutter based on the new page size
    var whiteSpace = viewportWidth - (itemWidth * pageSize);
    var newGutter = Math.ceil(whiteSpace / (pageSize + 1));
    if (!A.isFiniteNumber(newGutter)) {
      newGutter = minGutter;
    }
    return newGutter;
  }

  /**
   *  Calculate and apply a new gutter width.  Alter pageSize if necessary.
   *
   *  @public
   *  @param {Carousel} carousel
   *
   *  triggers a:carousel:[name]:repaint
   */
  function repaint(carousel) {
    var dimensions = carousel.getDimensions();
    var viewportWidth = dimensions.viewport.width;
    var itemWidth = dimensions.getFirstCardWidth();
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);

    // Calculate the page size and the new gutter width
    var pageSize = determinePageSize(carousel, viewportWidth, itemWidth);
    var newGutter = determineGutterWidth(carousel, viewportWidth, itemWidth, pageSize, minGutter, setSize);

    // Update carousel attributes
    carousel.setAttr(ATTR_CURRENT_GUTTER, newGutter);
    carousel.setAttr(ATTR_PAGE_SIZE, pageSize);

    // Calculate the new carousel width
    var $carousel = carousel.dom.$carousel;
    var $items = $carousel.children("li");
    var numItems = $items.length;
    var itemOuterWidth = itemWidth + newGutter;
    var carouselWidth = numItems * itemOuterWidth;

    // Apply the new gutter and carousel width
    removeExtraItems(carousel, Math.min(pageSize, setSize));
    $items.css("margin-left", newGutter + "px");

    // Apply the carousel width as well as the single page alignment, if necessary
    if (pageSize >= setSize) {
      carouselWidth = viewportWidth;
      var alignment = carousel.getAttr(ATTR_SINGLE_PAGE_ALIGN);
      $carousel.toggleClass("a-text-right", alignment === "right");
      $carousel.toggleClass("a-text-center", alignment === "center");
      if (alignment === "center") {
        $items.first().css("margin-left", 0);
      }
    } else {
      $carousel.removeClass("a-text-right a-text-center");
    }

    // Prepare and make updates to the measurements cache
    var updates = {
      carousel: {
        width: carouselWidth,
        outerWidth: $carousel.outerWidth()
      },
      items: []
    };
    while (numItems--) {
      updates.items.push({
        outerWidth: itemOuterWidth
      });
    }
    carousel.updateDimensionsCache(updates);

    // Trigger a global event if able
    carousel.triggerEvent("repaint");
  }

  /**
   *  When the carousel inits, we need to determine the minimum gutter, initial pageSize, and which items where fetched.
   *  We then repaint to apply the right gutter sizes.
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function init(carousel) {
    // Set the min gutter if the user didn't pass one in.
    var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
    if (!minGutter) {
      minGutter = DEFAULT_MIN_GUTTER;
      carousel.setAttr(ATTR_MIN_GUTTER, minGutter);
    }
    carousel.setAttr(ATTR_CURRENT_GUTTER, minGutter);

    // Make sure the height animation speed's legit
    var heightAnimationSpeed = carousel.getAttr(ATTR_HEIGHT_ANIMATION_SPEED);
    if (!A.isFiniteNumber(heightAnimationSpeed)) {
      carousel.setAttr(ATTR_HEIGHT_ANIMATION_SPEED, DEFAULT_HEIGHT_ANIMATION_SPEED);
    }

    // Bind all the attr change handlers we need.
    bindAttrChangeHandlers(carousel);

    // Repaint to get the right gutter applied and adjust the height to match page 1 content
    repaint(carousel);
    initDom(carousel);

    // If the user has navigated back to this page, see if we need to start on a different page
    var firstVisibleItem = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    if (firstVisibleItem > 1) {
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisibleItem);
      var newPage = Math.ceil(firstVisibleItem / carousel.getAttr(ATTR_PAGE_SIZE));
      carousel.gotoPage(newPage);
    }
  }

  /**
   *  If the page has resized and the width of the viewport has changed, we need to repaint.
   *
   *  @public
   *  @param {Carousel} carousel
   *  @param {Object} changes - A hash of changed dimensions and their associated new value
   */
  function resize(carousel, changes) {
    if (changes.viewport && changes.viewport.width !== undefined) {
      repaint(carousel);
    }
  }

  return {
    repaint: repaint,
    init: init,
    resize: resize
  };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_swap.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_single.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Single Item Per Page Display Strategy
 *
 */

"use strict";

P.when("A", "jQuery").register("a-carousel-display-single", function (A, $) {
  var undefined;

  /**
   *  The default minimum space between elements in the carousel
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_MIN_GUTTER = 14;

  /**
   *  The default animation duration for adjusting carousel height
   *
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_HEIGHT_ANIMATION_SPEED = 200;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_ANIMATING = "animating";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_FIXED_HEIGHT = "fixed_height";
  var ATTR_HIDE_OFFSCREEN = "hide_off_screen";
  var ATTR_MIN_GUTTER = "minimum_gutter_width";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_SHOW_PARTIAL = "show_partial_next";

  /**
   *  The height of the carousel is determined by the tallest element which has ever appeared
   *  in the viewport of the carousel.  This function will find that max height and apply it
   *  to the proper div
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function adjustHeight(carousel) {
    if (carousel.getAttr("auto_adjust_height")) {
      if (carousel.getAttr(ATTR_ANIMATING)) {
        carousel.once(ATTR_ANIMATING, function () {
          adjustHeight(carousel);
        });
      } else {
        carousel.dom.$viewport.css("height", "auto");
        A.    }, 0);
      }
    } else {
      carousel.dom.$viewport.css("height", "");
    }
  }
  
  function hideOffscreenCards(carousel, resetOnscreenCards) {
    var $cards = carousel.dom.$carousel.children("li");
    var visibleItemIndex = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM) - 1; // This is stored 1-based instead of 0-based
    var numberOfCards = carousel.getAttr(ATTR_SHOW_PARTIAL) ? 2 : 1;
    var $expectedVisibleCards = $cards.slice(visibleItemIndex, visibleItemIndex + numberOfCards);
    $cards.not($expectedVisibleCards).css("visibility", "hidden");
    if (resetOnscreenCards) {
      $expectedVisibleCards.css("visibility", "");
    }
  }

  /**
   *  During init, we need to make some DOM changes to ensure that the display and transition strategies can do what needs doin
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function initDom(carousel) {
    var fixedHeight = carousel.getAttr(ATTR_FIXED_HEIGHT);
    if (A.isFiniteNumber(fixedHeight)) {
      carousel.dom.$viewport.height(fixedHeight);
    } else {
      carousel.setAttr(ATTR_FIXED_HEIGHT, false);
    }
    carousel.dom.$carousel.children("li").css("visibility", "visible");
  }

  /**
   *  This function is a one-time use function called by init so that init doesn't get too large
   *  and there aren't unneccessary variables hanging around in the scope chain for these callbacks.
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function bindAttrChangeHandlers(carousel) {
    if (!carousel.getAttr(ATTR_FIXED_HEIGHT)) {
      carousel.dom.$viewport.delegate("img", "load", function () {
        adjustHeight(carousel);
      });

      carousel.onChange("load    });

      // Before animating, make everybody visible again
      carousel.onChange(ATTR_PAGE_NUMBER, function () {
        if (carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
          carousel.dom.$carousel.children("li").css("visibility", "");
        }
      });
      
      // After animating, make cards other than the current one hidden
      carousel.onChange(ATTR_ANIMATING, function(current) {
        if (!current && carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
          hideOffscreenCards(carousel);
        }
      });

      carousel.onChange(ATTR_MIN_GUTTER, function () {
        repaint(carousel);
      });
    }
  }

  /**
   *  Calculate and apply a new item width.
   *
   *  @public
   *  @param {Carousel} carousel
   *
   *  triggers a:carousel:[name]:repaint
   */
  function repaint(carousel) {
    var dimensions = carousel.getDimensions();
    var width = dimensions.viewport.width;
    var showPartial = carousel.getAttr(ATTR_SHOW_PARTIAL);
    var gutter = carousel.getAttr(ATTR_MIN_GUTTER);
    var setSize = carousel.getAttr(ATTR_SET_SIZE);
    var $cards = carousel.dom.$carousel.children("li");

    // Calculate and apply the new item width
    width -= gutter * 2;
    if (showPartial) {
      width -= gutter + dimensions.viewport.width / 3;
    }
    $cards.css({
      width: width + "px",
      margin: "0 " + gutter + "px"
    });

    // Update the carousel width
    var outerWidth = width + gutter * 2;
    var carouselWidth = outerWidth * setSize;
    carousel.dom.$carousel.width(carouselWidth);

    // Update the dimensions cache
    var updates = {
      carousel: {
        width: carouselWidth
      },
      items: []
    };
    while (setSize--) {
      updates.items[setSize] = {
        width: width,
        outerWidth: outerWidth
      };
    }
    carousel.updateDimensionsCache(updates);
    
    // hide elements other than the single being displayed if we ought to
    if (carousel.getAttr(ATTR_HIDE_OFFSCREEN)) {
      hideOffscreenCards(carousel, true);
    }

    // Make sure the item which was the first visible item in the viewport is still the first visible item
    carousel.gotoIndex(carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM), {
      animationDuration: 0,
      ignorePause: true
    });

    carousel.triggerEvent("repaint");
  }

  return {
    repaint: repaint,
    /**
     *  When the carousel inits, we need to determine the initial values for attributes like the gutter,
     *  whether to show a partial of the next, etc.  Then we need to alter the DOM to ensure display specific
     *  CSS takes effect and the proper height is set.  Then we need to bind attribute change handlers and
     *  call repaint to set the proper width.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    init: function (carousel) {
      // Set attribute defaults
      var minGutter = carousel.getAttr(ATTR_MIN_GUTTER);
      carousel.setAttr(ATTR_MIN_GUTTER, A.isFiniteNumber(minGutter) ? minGutter : DEFAULT_MIN_GUTTER);
      carousel.setAttr(ATTR_SHOW_PARTIAL, !!carousel.getAttr(ATTR_SHOW_PARTIAL));
      carousel.setAttr("pageSize", 1);

      // Set up the DOM and bind attribute change handlers
      carousel.setAttr("pageSize", 1);
      initDom(carousel);
      bindAttrChangeHandlers(carousel);
      this.repaint(carousel);
      adjustHeight(carousel);
    },
    /**
     *  If the page has resized and the width of the viewport has changed, we need to repaint.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} changes - A hash of changed dimensions and their associated new value
     */
    resize: function (carousel, changes) {
      if (changes.viewport && changes.viewport.width !== undefined) {
        this.repaint(carousel);
        if (!carousel.getAttr(ATTR_FIXED_HEIGHT)) {
          adjustHeight(carousel);
        }
      }
    }
  };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_single.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_peekcircular.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Single Item Per Page Display Strategy
 *
 */

'use strict';

P.when('A', 'jQuery', 'a-carousel-constants').register('a-carousel-display-peekcircular', function (A, $, ATTR) {

    function defaultFiniteNumber (defaultValue) {
        return function (initValue) {
            return A.isFiniteNumber(initValue) ? initValue : defaultValue;
        };
    }

    var DEFAULT_MIN_GUTTER = 14,
        DEFAULT_PEEK_PERCENTAGE = 10;

    var initAttrs = {};
    initAttrs[ATTR.PAGE_SIZE] = 1;
    initAttrs[ATTR.MIN_GUTTER] = defaultFiniteNumber(DEFAULT_MIN_GUTTER);
    initAttrs[ATTR.PEEK_PERCENTAGE] = defaultFiniteNumber(DEFAULT_PEEK_PERCENTAGE);

    return {
        initAttrs: initAttrs,

        /**
         *  Establish defaults for required attributes, make cards visible, and repaint.
         *
         *  @public
         *  @param {Carousel} carousel
         */
            },

        /**
         *  Calculate and apply a new item and peek width.
         *
         *  @public
         *  @param {Carousel} carousel
         *
         *  triggers a:carousel:[name]:repaint
         */
        repaint: function (carousel) {
            var gutter = carousel.getAttr(ATTR.MIN_GUTTER),
                setSize = carousel.getAttr(ATTR.SET_SIZE),
                peekPercentage = carousel.getAttr(ATTR.PEEK_PERCENTAGE),
                viewportWidth = carousel.getDimensions().viewport.width,
                $carousel = carousel.dom.$carousel,
                $cards = $carousel.children('li');

            var peekWidth = (peekPercentage / 100) * viewportWidth,
                cardWidth = viewportWidth - (peekWidth * 2) - gutter,
                outerWidth = cardWidth + (gutter * 2),
                carouselWidth = outerWidth * setSize;

            // Update DOM
            $carousel.width(carouselWidth);
            $cards.css({
                width: cardWidth + 'px',
                'margin-left': gutter + 'px',
                'margin-right': gutter + 'px',
            });

            // Update cache
            carousel.updateDimensionsCache({
                carousel: {
                    width: carouselWidth
                },
                items: A.map(A.range(setS    }),
            });

            // Update Attrs and do so loudly (silent = false)
            carousel.setAttr(ATTR.PEEK_WIDTH, peekWidth, false);

            carousel.triggerEvent('repaint');
        },

        /**
         *  If the viewport width changes, repaint.
         *
         *  @public
         *  @param {Carousel} carousel
         *
         *  triggers a:carousel:[name]:repaint
         */
        resize: function (carousel, changes) {
            if (changes.viewport && changes.viewport.width !== undefined) {
                this.repaint(carousel);
            }
        }
    };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_peekcircular.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/display/carousel_strategies_display_variablewidth.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel "Variable Width" Display Strategy
 *
 *  This is currently minimal strategy to support mobile variable width carousel.
 *
 */

"use strict";

P.when("A").register("a-carousel-display-variablewi };
});
/////////////////////////
// END FILE js/strategies/display/carousel_strategies_display_variablewidth.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies_display.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Display Strategies
 *
 */

"use strict";

/**
 *  Officially supported set of display strategies provided for carousels.
 */
P.when("a-carousel-stretchygoodness", "a-carousel-display-swap", "a-carousel-display-single", "a-carousel-display-peekcircular", "a-carousel-display-variablewidth").register("a-carousel-strategies-disp };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies_display.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/transition/carousel_strategies_transition_swap.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when("A", "jQuery", "a-carousel-utils").register("a-carousel-transition-swap", function (A, $, util) {
  /**
   *  When switching, this is the default delay between card swaps
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var DEFAULT_DELAY_TIME = 30;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I dont' misspell things.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var ATTR_ANIMATING = "animating";
  var ATTR_CIRCULAR = "circular";
  var ATTR_DELAY_TIME = "delay_time";
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_FIRST_VISIBLE_ITEM = "firstVisibleItem";
  var ATTR_LOADING = "loading";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_PRELOADED_IMAGES = "preloadedImages";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_TIMER_ID = 'responsiveTimerId';
  var ATTR_TOTAL_PAGES = "totalPages";

  var EMPTY_CARD_CLASS = 'a-carousel-card-empty';

  /**
   *  When the AJAX strategy loads in new items preload the images for off-screen cells.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {array} fetchedItems
   */
  function preloadNewItemsOnChange(carousel, fetchedItems) {
    var preloadedImages = carousel.getAttr(ATTR_PRELOADED_IMAGES);
    if (! preloadedImages) {
      preloadedImages = [];
    }

    var imageUrls = [];
    for (var i = fetchedItems.length - 1; i >= 0; i--) {
      if (fetchedItems[i] && !preloadedImages[i]) {
        var element = util.getElementFromItem(fetchedItems[i]);
        if (element) {
          $('img', element)    });
        }
        preloadedImages[i] = true;
      }
    }

    A.preload(imageUrls);
    carousel.setAttr(ATTR_PRELOADED_IMAGES, preloadedImages);
  }


  /**
   * Get the sign -1, 0, 1, or NaN
   *
   * @param {number} x A number
   */

  function sign(x) {
    return typeof x === 'number' ? x ? x < 0 ? -1 : 1 : isNaN(x) ? NaN : 0 : NaN;
  }

  /**
   *  When the AJAX strategy loads in new items which need to be shown immediately, this function makes sure
   *  they're added to the DOM correctly.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {array} fetchedItems
   */

  function showNewFetchedItems(carousel, fetchedItems) {
    var pageNumber = carousel.getAttr(ATTR_PAGE_NUMBER);
    var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
    var firstVisibleItem = carousel.getAttr(ATTR_FIRST_VISIBLE_ITEM);
    var delayIncrement = carousel.getAttr("delay_time");
    var delay = 0;
    var $items = carousel.dom.$carousel.children("li");
    var $emptyItems = $items.filter("." + EMPTY_CARD_CLASS);
    
    if ($emptyItems.length) {
      carousel.setAttr(ATTR_LOADING, true);
    }
    
    $emptyItems.each(function (idx, item) {
      var $item = $(item);
      var fetchedItemIdx = $items.index(item) + firstVisibleItem - 1;
      var fetchedItem = fetchedItems[fetchedItemIdx];
      if (fetchedItem) {
        A.delay(function () {
          util.addElementToDom($item, util.getElementFromItem(fetchedItem));
          if (idx === $emptyItems.length - 1) {
            carousel.setAttr(ATTR_LOADING, false);
          }
        }, delay + delayIncrement);
      }
    });
  }

  /**
   *  Make the carousel move to a different page
   *
   *  @param {Carousel} carousel
   *  @param {number} page  The page number to slide to (1 based)
   *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
   */

  function gotoPage(carousel, page, options) {
    options = options || {};
    var currentPage = carousel.getAttr(ATTR_PAGE_NUMBER);
    if (page !== currentPage) {
      var setSize = carousel.getAttr(ATTR_SET_SIZE); // one-based total number of items
      var maxPage = carousel.getAttr(ATTR_TOTAL_PAGES);
      var circular = carousel.getAttr(ATTR_CIRCULAR);

      var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
      var delayTime = options.delayTime || carousel.getAttr(ATTR_DELAY_TIME);
      var direction = sign(options.direction) || NaN;
      var displayStrategy = carousel.strategies.display;


      if (!circular && page < 1) {
        page = 1;
      } else if (!circular && page > maxPage) {
        page = maxPage;
      } else if (circular && page < 1) {
        page = maxPage;
      } else if (circular && page > maxPage) {
        page = 1;
      }

      // We need to get the pre-load directionality
      if (!direction) {
        direction = currentPage < page ? 1 : -1;
      }

      // When starting over, replace as fast as possible
      if (options.startover) {
        delayTime = 1;
        direction = 1;
      }

      // Start the swapping animation
      var firstVisibleIndex = pageSize * (page - 1);
      var currentCellIndex = direction === 1 ? 0 : (pageSize - 1);
      
      // Updating various necessary stats at the beginning of the transition
      // There was a race condition of sorts between receiving new cards via AJAX and populating the carousel
      // wherein if the first visible item was set at the end of the transition and new data came in during a
      // transition, we could put the wrong page's cards into a given page.
      //
      // Page number was being set before the animation began, but first visible item was being set at the end
      // of the animation and the AJAX handler: showNewFetchedItems above was using the first visible item to
      // determine which items to drop into the page.
      carousel.setAttr(ATTR_PAGE_NUMBER, page);
      carousel.setAttr(ATTR_FIRST_VISIBLE_ITEM, firstVisibleIndex + 1);
      carousel.setAttr(ATTR_ANIMATING, true);
      
      var timerId = A.interval(function () {
        var setIndex = firstVisibleIndex + currentCellIndex;

        // Animation complete
        if (timerId !== carousel.getAttr(ATTR_TIMER_ID)) {
          clearInterval(timerId);
        } else if ((direction === -1 && currentCellIndex < 0) || (direction === 1 && currentCellIndex >= pageSize)) {
          carousel.setAttr(ATTR_TIMER_ID, undefined);
          carousel.setAttr(ATTR_ANIMATING, false);
        } else {
          // Display ASIN / Update Cell
          var $cell = carousel.dom.$carousel.children('li').eq(currentCellIndex);

          var currentItem = carousel.getAttr(ATTR_FETCHED_ITEMS)[setIndex];
          if (currentItem) {
            util.addElementToDom($cell, util.getElementFromItem(currentItem));
          } else if (setIndex < setSize) {
            $cell.html(carousel.getStaticLoader()).addClass(EMPTY_CARD_CLASS);
          } else {
            $cell.empty().removeClass(EMPTY_CARD_CLASS);
          }

          // Move to the next cell
          currentCellIndex = currentCellIndex + direction;
        }
      }, delayTime);

      carousel.setAttr(ATTR_TIMER_ID, timerId);
    }
  }

  /**
   *  Find the page for a given index and navigate to it
   *
   *  @param {Carousel} carousel
   *  @param {number} idx  The index number of the item (1 based)
   *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
   */

  function gotoIndex(carousel, idx, options) {
    options = options || {};

    var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
    var pageNumber = Math.ceil(idx / pageSize);

    gotoPage(carousel, pageNumber, options);
  }

  /**
   *  Tell the carousel to show the next page
   *
   *  @param {Carousel} carousel
   *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
   */

  function gotoNextPage(carousel, options) {
    options = options || {};
    var pageNumber = carousel.getAttr(ATTR_PAGE_NUMBER);

    // Mark our direction as moving backward
    options.direction = -1;

    gotoPage(carousel, ++pageNumber, options);
  }

  /**
   *  Tell the carousel to show the previous page
   *
   *  @param {Carousel} carousel
   *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
   */

  function gotoPrevPage(carousel, options) {
    options = options || {};
    var pageNumber = carousel.getAttr(ATTR_PAGE_NUMBER);

    // Mark our direction as moving forward
    options.direction = 1;

    gotoPage(carousel, --pageNumber, options);
  }

  /**
   *  Initializes the strategy.  Basically just ensures the animation speed is set.
   *
   *  @param {Carousel} carousel
   */

  function init(carousel) {
    // AUI Convention: passed arguments with underscores are public
    var delayTime = carousel.getAttr(ATTR_DELAY_TIME);
    if (!A.isFiniteNumber(delayTime)) {
      carousel.setAttr(ATTR_DELAY_TIME, DEFAULT_DELAY_TIME);
    }

    // Clean-up old timers
    carousel.onChange(ATTR_TIMER_ID, function (newTimerId, oldTimerId) {
      if (oldTimerId !== newTimerId) {
        clearInterval(oldTimerId);
      }
    });

    carousel.onChange(ATTR_FETCHED_I    });

    preloadNewItemsOnChange(carousel, carousel.getAttr(ATTR_FETCHED_ITEMS));
  }

  return {
    init: init,
    gotoIndex: gotoIndex,
    gotoNextPage: gotoNextPage,
    gotoPrevPage: gotoPrevPage,
    gotoPage: gotoPage
  };
});
/////////////////////////
// END FILE js/strategies/transition/carousel_strategies_transition_swap.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/transition/carousel_strategies_transition_slide.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Carousel Transition Strategies
 *
 */

"use strict";

/**
 *  A set of default transition strategies which define behavior when the user navigates through the carousel.
 */
P.when("A", "jQuery", "a-carousel-utils", "a-carousel-constants").register("a-carousel-transition-slide", function (A, $, util, ATTR) {
  var undefined;

  /**
   *  When sliding, this is the default transition speed in pixels/second
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var DEFAULT_ANIMATION_SPEED = A.capabilities.touch ? 2000 : 3000;

  /**
   *  The default easing function for normal pagination
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var DEFAULT_EASING = "ease-out";

  /**
   *  This will put enough empty cards in the list to accomodate the total set_size.
   *
   *  @private
   *  @param {Carousel} carousel
   */

  function addEmptyCards(carousel) {
    var numItems = carousel.dom.$carousel.children("li").length;
    var firstIndex = numItems + 1;
    var setSize = carousel.getAttr(ATTR.SET_SIZE);
    var cardsNeeded = setSize - numItems;

    if (cardsNeeded > 0) {
      var lastIndex = firstIndex + cardsNeeded - 1;
      var emptyItems = [];

      for (var i = firstIndex; i <= lastIndex; i++) {
        emptyItems.push(carousel.getEmptyCard(i, setSize));
      }
      carousel.dom.$carousel.append(emptyItems.join(""));

      carousel.setAttr(ATTR.LOADING, true);
      var fetchedItems = carousel.getAttr(ATTR.FETCHED_ITEMS);
      var $items = carousel.dom.$carousel.children("li");
      var $item, item;

      for (i = numItems; i < setSize; i++) {
        item = fetchedItems[i];
        // Dump the fetched HTML into the DOM
        if (item) {
          var element = util.getElementFromItem(item);
          $item = $items.eq(i);
          util.addElementToDom($item, element);

          // Remove the HTML string from memory since we don't need to hang onto it
          fetchedItems[i] = util.clearElementFromItem(item);
        }
      }

      if (carousel.strategies.display.repaint) {
        carousel.strategies.display.repaint(carousel);
      }

      // Put the new fetchedItems struct back in memory and update the dimensions cache with the item's dimensions
      carousel.setAttr(ATTR.FETCHED_ITEMS, fetchedItems, true);
      carousel.setAttr(ATTR.LOADING, false);
    }
  }


  /**
   *  When the fetchedItems object changes, this function will add any new items which were fetched to
   *  the carousel.
   *
   *  @private
   *  @param {Carousel} carousel
   *  @param {array} newFetchedItems
   *  @param {array} oldFetchedItems
   */

  function handleItemChanges(carousel, newFetchedItems, oldFetchedItems) {
    var animating = carousel.getAttr(ATTR.ANIMATING);

    if (animating) {
      carousel.once(ATTR.ANIMATING, function () {
        handleItemChanges(carousel, newFetchedItems, oldFetchedItems);
      });
    } else {
      var dimensions = carousel.getDimensions();
      var itemDimensions = dimensions.items;

      if (!oldFetchedItems || newFetchedItems.length >= oldFetchedItems.length) {
        carousel.setAttr(ATTR.LOADING, true);
        var $items = carousel.dom.$carousel.children("li");
        var i = newFetchedItems.length;
        var $item, item;

        while (i--) {
          item = newFetchedItems[i];
          // Dump the fetched HTML into the DOM...
          // When we change the fetched items array internally (end of this function), we trigger reprocessing of some items
          // We want to bail from rechecking those instead of doing it twice and occasionally triggering a TypeError
          // based on logic that never expected to run over items a second time - caused by A.copy becoming a deep copy
          // So also test if item === true or item.content === true.
          if (item && !A.equals(item, oldFetchedItems[i]) && !((item === true) || (item.content === true))) {
            var element = util.getElementFromItem(item);
            $item = $items.eq(i);
            if ($item.length) {
              util.addElementToDom($item, element);
              itemDimensions[i] = {
                width: $item.outerWidth(),
                outerWidth: $item.outerWidth(true),
                height: $item.outerHeight(),
                outerHeight: $item.outerHeight(true)
              };

              // Remove the HTML string from memory since we don't need to hang onto it
              newFetchedItems[i] = util.clearElementFromItem(item);
            }
          }
        }
      }

      // Put the new fetchedItems struct back in memory and update the dimensions cache with the item's dimensions
      carousel.setAttr(ATTR.FETCHED_ITEMS, newFetchedItems);
      carousel.updateDimensionsCache({
        items: itemDimensions
      });
      carousel.setAttr(ATTR.LOADING, false);
    }
  }

  return {
    /**
     *  After the entire carousel has slid off the page, wrap around and display the first page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wrapToFirst: function (carousel) {
      var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
      var itemWidth = carousel.getDimensions().getFirstCardWidth();
      var strategy = this;

      // Move the carousel to the other side of the viewport
      var px = pageSize * itemWidth * -1;
      carousel.gotoPixel(px, {
        animationDuration: 0,
        callback: function () {
          carousel.setAttr(ATTR.CURRENTLY_WRAPPING, false);
          strategy.gotoPage(carousel, 1);
        }
      });
    },
    /**
     *  After the entire carousel has slid off the page, wrap around and display the last page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wrapToLast: function (carousel) {
      var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
      var totalPages = carousel.getAttr(ATTR.TOTAL_PAGES);
      var strategy = this;

      // Move the carousel to the other side of the viewport
      var px = carousel.getDimensions().carousel.width;
      carousel.gotoPixel(px, {
        animationDuration: 0,
        callback: function () {
          carousel.setAttr(ATTR.CURRENTLY_WRAPPING, false);
          strategy.gotoPage(carousel, totalPages);
        }
      });
    },
    /**
     *  Make the carousel slide to a specific page.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {number} page  The page number to slide to (1 based)
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoPage: function (carousel, page, options) {
      options = options || {};
      if ((options.animationDuration === undefined || options.animationDuration > 0) && !options.silent) {
        carousel.setAttr(ATTR.ANIMATING, true);
      }

      var maxPage = carousel.getAttr(ATTR.TOTAL_PAGES);
      if (page > 0 && page <= maxPage) {
        carousel.setAttr(ATTR.PAGE_NUMBER, page);
      }

      var circular = carousel.getAttr(ATTR.CIRCULAR);
      if (!circular && page < 1) {
        page = 1;
        options.animationDuration = Math.pow(carousel.getAttr(ATTR.ANIMATION_SPEED) * carousel.getAttr(ATTR.SPRINGINESS));
      } else if (!circular && page > maxPage) {
        page = maxPage;
        options.animationDuration = Math.pow(carousel.getAttr(ATTR.ANIMATION_SPEED), carousel.getAttr(ATTR.SPRINGINESS));
      }
      this.gotoIndex(carousel, (carousel.getAttr(ATTR.PAGE_SIZE) * (page - 1)) + 1, options);
    },
    /**
     *  Make the carousel slide so that a particular item is the left-most visible item in the carousel.
     *  Calling an index outside of the set of available items will cause the carousel to wrap, if not
     *  disabled.  It'll do nothing otherwise.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {number} idx  The index number of the item (1 based)
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoIndex: function (carousel, idx, options) {
      options = options || {};

      if ((options.animationDuration === undefined || options.animationDuration > 0) && !options.silent) {
        carousel.setAttr(ATTR.ANIMATING, true);
      }

      var allowWrap = carousel.getAttr(ATTR.CIRCULAR) && !carousel.getAttr(ATTR.CURRENTLY_WRAPPING);
      var callback = options.callback;
      var strategy = this;
      var pixel = false;
      var viewportWidth = carousel.getViewportWidth();
      var newPage = Math.ceil(idx / carousel.getAttr(ATTR.PAGE_SIZE));
      var wrapCallback;
      if (newPage !== carousel.getAttr(ATTR.PAGE_NUMBER) && newPage > 0 && newPage <= carousel.getAttr(ATTR.TOTAL_PAGES)) {
        carousel.setAttr(ATTR.PAGE_NUMBER, newPage);
      }

      carousel.setAttr(ATTR.FIRST_VISIBLE_ITEM, idx);

      if (idx < 1) {
        if (allowWrap) {
          pixel = viewportWidth * -1;
          wrapCallback = function () {
            if (callback) {
              callback();
            }
            strategy.wrapToLast(carousel);
          };
        }
      } else if (idx > carousel.getAttr(ATTR.SET_SIZE)) {
        if (allowWrap) {
          pixel = carousel.getAttr(ATTR.CURRENT_PIXEL) + viewportWidth;

          // Set new options specific to the wrapping use-case
          wrapCallback = function () {
            if (callback) {
              callback();
            }
            strategy.wrapToFirst(carousel);
          };
        }
      } else {
        pixel = carousel.getItemOffset(idx);
      }

      // We're going to be wrapping around from last to first, or first to last, so set common params
      if (wrapCallback) {
        carousel.setAttr(ATTR.CURRENTLY_WRAPPING, true);
        options.callback = wrapCallback;
        options.easingFunction = options.easingFunction || carousel.getAttr(ATTR.WRAP_EASING);
        options.animationSpeed = (A.isFiniteNumber(options.animationSpeed) ? options.animationSpeed : carousel.getAttr(ATTR.ANIMATION_SPEED)) * 1.3;
      } else {
        options.callback = callback;
      }

      // Goto a pixel value if we need to
      if (pixel !== false) {
        this.gotoPixel(carousel, pixel, options);
      }
    },
    /**
     *  Tell the carousel to slide to a specific offset position
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {number} px  The pixel to slide to
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoPixel: function (carousel, px, options) {
      var currentPx = carousel.getAttr(ATTR.CURRENT_PIXEL);
      if (px !== currentPx) {
        options = options || {};
        var easingFunction = options.easingFunction || DEFAULT_EASING;
        var callback = options.callback;
        var viewportWidth = carousel.getViewportWidth();
        var animationDuration, afterAnimate;

        if (options.animationDuration !== undefined) {
          animationDuration = options.animationDuration;
        } else {
          var pxPerSecond = A.isFiniteNumber(options.animationSpeed) ? options.animationSpeed : carousel.getAttr(ATTR.ANIMATION_SPEED);
          var distance = Math.abs(px - currentPx);
          animationDuration = pxPerSecond === 0 ? 0 : Math.floor(distance / pxPerSecond * 1000);
        }

        if (animationDuration > 0 && !options.silent) {
          carousel.setAttr(ATTR.ANIMATING, true);
        }

        if (A.isFiniteNumber(px)) {

          if (animationDuration > 0) {
            afterAnimate = function () {
              if (callback) {
                callback();
              }
              if (!carousel.getAttr(ATTR.CURRENTLY_WRAPPING)) {
                carousel.setAttr(ATTR.ANIMATING, A.isAnimated(carousel.dom.$carousel), options.silent);
              }
            };
          } else {
            afterAnimate = callback;
          }

          carousel.setAttr(ATTR.CURRENT_PIXEL, px);
          A.animate(carousel.dom.$carousel, {
            "left": px * -1
          }, animationDuration, easingFunction, afterAnimate);
        } else {
          P.error("Target pixel is not a finite number", "a-carousel-transition-slide", "gotoPixel");
        }
      }
    },
    /**
     *  Tell the carousel to slide to the next page
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoNext    },
    /**
     *  Tell the carousel to slide to the previous page
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} options  A hash of options which can do a one-time override of animation parameters (optional)
     */
    gotoPrev    },
    /**
     *  Slide to the correct page with a custom velocity based on the movement of the user's finger
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} touch  Touch event data generated by the gesture detection library
     */
    onSwipe: function (carousel, touch) {
      if (!carousel.getAttr(ATTR.CURRENTLY_WRAPPING)) {
        var firstVisibleItem = carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM);
        var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
        var currentPage = carousel.getAttr(ATTR.PAGE_NUMBER);
        var goingRight = touch.velocityX < 0;
        var newIdx = firstVisibleItem;
        if (goingRight && currentPage < carousel.getAttr(ATTR.TOTAL_PAGES)) {
          newIdx = firstVisibleItem + pageSize;
        } else if (!goingRight && currentPage > 1) {
          newIdx = firstVisibleItem - pageSize;
        }

        // The animation speed should be based on the speed of the user's finger.  However, some sane boundaries
        // (min/max) need to be put into place in order to prevent the thing from slowing to a crawl or firing off
        // into infinity like a rocket.  Those upper and lower bounds are really just pulled out of my ass, so if
        // they need changing, feel free.
        var currentPx = carousel.getAttr(ATTR.CURRENT_PIXEL);
        var itemOffset = carousel.getItemOffset(newIdx);
        var dx = goingRight ? currentPx - itemOffset : currentPx + itemOffset;
        var duration = Math.abs(dx * 1000 / touch.velocityX);
        duration = Math.max(duration, 300);
        duration = Math.min(duration, A.viewport().width * 1.2);

        var options = {
          animationDuration: duration,
          easingFunction: carousel.getAttr(ATTR.TOUCH_EASING)
        };

        if (newIdx === firstVisibleItem && !carousel.getAttr("circular")) {
          options.animationSpeed = A.viewport().width * 0.95;
          delete options.animationDuration;
          carousel.gotoIndex(newIdx, options);
        } else if (goingRight) {
          carousel.gotoNextPage(options);
        } else {
          carousel.gotoPrevPage(options);
        }
      }
    },
    /**
     *  Allow the user to pan to a specific pixel based on the movement of the user's finger.
     *  When the user lifts their finger, if they haven't swiped, this will return the user
     *  to the closest page.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {object} touch  Touch event data generated by the gesture detection library.
     */
    onPan: function (carousel, touch) {
      if (!carousel.getAttr(ATTR.CURRENTLY_WRAPPING)) {
        carousel.setAttr(ATTR.ANIMATING, true);
        var offset = carousel.getItemOffset(carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
        var px = offset - touch.touchDeltaX;
        var circular = carousel.getAttr(ATTR.CIRCULAR);
        var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);
        var totalPages = carousel.getAttr(ATTR.TOTAL_PAGES);

        if (touch.ended) {
          var options = {
            easingFunction: carousel.getAttr(ATTR.TOUCH_EASING),
            animationSpeed: A.viewport().width * 0.95
          };

          options.silent = true;
          var delta = touch.touchDeltaX;

          var underThreshold = Math.abs(delta) < carousel.getViewportWidth() * 0.4;
          var pastEdge = (delta < 0 && totalPages === pageNumber) || (delta > 0 && pageNumber === 1);
          if (!circular && pastEdge || underThreshold) {
            carousel.gotoPage(pageNumber, options);
          } else if (delta < 0) {
            carousel.gotoNextPage(options);
          } else {
            carousel.gotoPrevPage(options);
          }
        } else {
          if (!circular) {
            var springiness = carousel.getAttr(ATTR.SPRINGINESS);
            if ((px < 0 && touch.touchDeltaX > 0) || (pageNumber === totalPages && touch.touchDeltaX < 0)) {
              var diff = Math.pow(Math.abs(touch.touchDeltaX), springiness);
              if (px <= 0) {
                px = diff * -1;
              } else {
                px = offset + diff;
              }
            }
          }

          carousel.gotoPixel(px, {
            easingFunction: carousel.getAttr(ATTR.TOUCH_EASING),
            animationDuration: 0,
            silent: true
          });
        }
      }
    },
    /**
     *  Initializes the strategy.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    init: function (carousel) {
      var animationSpeed = carousel.getAttr(ATTR.ANIMATION_SPEED);
      if (!A.isFiniteNumber(animationSpeed)) {
        carousel.setAttr(ATTR.ANIMATION_SPEED, DEFAULT_ANIMATION_SPEED);
      }
      if (carousel.getAttr(ATTR.WRAP_EASING) === undefined) {
        carousel.setAttr(ATTR.WRAP_EASING, "linear");
      }

      // If the set size is greater than the number of preloaded cards, we need to create some empty ones.
      addEmptyCards(carousel);

      carousel.onChange(ATTR.FETCHED_I    });

      carousel.onChange(ATTR.SET_SIZE, function (current, old) {
        if (current > old) {
          addEmptyCards(carousel);
        }
      });
    }
  };
});
/////////////////////////
// END FILE js/strategies/transition/carousel_strategies_transition_slide.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/transition/carousel_strategies_transition_slidecircular.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Carousel Transition Strategy slide circular
 *
 */

'use strict';

P.when('A', 'a-carousel-utils', 'a-carousel-circular-utils', 'a-carousel-constants').register(
    'a-carousel-transition-slidecircular', function (A, util, circularUtil, ATTR) {

        var SLIDE_DIRECTION = {
            CLOCKWISE: 1,
            COUNTER_CLOCKWISE: -1
        };
        var EDGE_SPRING_MULTIPLIER = 0.4;
        var MIN_SWIPE_DISTANCE = 0.4;

        /**
         * Index of first card in the carousel
         * @private
         * @constant
         * @type {string}
         */
        var TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX = 'transitionSlideCircularFirstCardIndex';

        /**
         *  This will put enough empty cards in the list to accomodate the total set_size.
         *
         *  @private
         *  @param {Carousel} carousel
         */
        function addEmptyCards(carousel) {
            var cardsPresent = carousel.dom.$carousel.children('li').length;
            var setSize = carousel.getAttr(ATTR.SET_SIZE);
            var cardsNeeded = setSize - cardsPresent;
            var $card = getCard(carousel, cardsPresent);

            if (cardsNeeded > 0) {
                var firstIndex = cardsPresent + 1;
                var lastIndex = firstIndex + cardsNeeded;

                var emptyItems = A.map(A.range(firstIndex, lastIn    });
                $card.after(emptyItems.join(''));

                carousel.measure('items');
            }
        }

        /**
         * Moves the cards (in the DOM) such that there are enough cards on to the left and the right of the current
         * visible card to allow for swiping in either direction
         *
         * @private
         * @param {Carousel} carousel
         * @param {TransitionStrategy} strategy - current transition strategy
         */

        function arrangeCards(carousel, strategy) {
            var setSize = carousel.getAttr(ATTR.SET_SIZE);
            // transition will act like slideHorizontal strategy when 2 or less cards
            if (isCircularCarousel(carousel)) {
                var firstCardIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
                var desiredFirstCardIdx = Math.round(carousel.getAttr(ATTR.SET_SIZE) / 2);
                var cardsToMove = calculateCardsToMove(desiredFirstCardIdx, firstCardIdx, setSize);
                if (cardsToMove.quantity !== 0) {
                    rotateCards(carousel, cardsToMove.direction, cardsToMove.quantity);
                    if (cardsToMove.direction === SLIDE_DIRECTION.CLOCKWISE) {
                        firstCardIdx -= cardsToMove.quantity;
                    }
                    else {
                        firstCardIdx += cardsToMove.quantity;
                    }
                    strategy.gotoPixel(carousel, getItemOffset(carousel, firstCardIdx), {animationDuration: 0}); // snap back to original card in viewport
                }
            }
        }

        /**
         * Calculates the number of cards that need to be moved, and the direction of rotation, to move from
         * currentIdx to destinationIdx
         *
         * @private
         * @param currentIdx
         * @param destinationIdx
         * @param setSize
         */
        function calculateCardsToMove(currentIdx, destinationIdx, setSize) {
            var result = {};
            var clockwise;
            var counterClockwise;
            if (currentIdx === destinationIdx) {
                clockwise = counterClockwise = 0;
            }
            else if (currentIdx > destinationIdx) {
                counterClockwise = currentIdx - destinationIdx;
                clockwise = setSize - counterClockwise;
            }
            else {
                clockwise = destinationIdx - currentIdx;
                counterClockwise = setSize - clockwise;
            }
            result.direction = (clockwise <= counterClockwise) ? SLIDE_DIRECTION.CLOCKWISE : SLIDE_DIRECTION.COUNTER_CLOCKWISE;
            result.quantity = Math.min(clockwise, counterClockwise);
            return result;
        }

        /**
         * Gets the card associated with the index from DOM
         *
         * @private
         * @param {Carousel} carousel
         * @param {number} idx - index of the card to be returned
         */
      }

        /**
         * Helper method to get the offset taking peek width into account
         *
         * @private
         * @param {Carousel} carousel
         * @param {Number} idx
         */
        function getItemOffset(carousel, idx) {
            var peekWidth = Math.floor(carousel.getAttr(ATTR.PEEK_WIDTH) || 0);
            var offset = carousel.getItemOffset(idx);
            return (offset - peekWidth);
        }

        /**
         * There are two different types of card indices. The cards often get moved around within the parent carousel
         * container which is called a rotation clockwise or counter-clockwise creating a difference between what is
         * present in the DOM and how the carousel manages each card.
         *
         * @private
         * @param {Carousel} carousel
         * @param {Number} idx - the index as determined by the original order of the cards in, or ajaxed into, the markup.
         * @return {Number} - the current position of the card in the carousel container
         */
        function getRelativeIndex(carousel, idx) {
            idx = idx || 1;
            var idxOfFirstCard = carousel.getAttr(TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX);
            var setSize = carousel.getAttr(ATTR.SET_SIZE);
            return circularUtil.relativeIndexFromIndex(idx, idxOfFirstCard, setSize);
        }

        /**
         *  When the fetchedItems object changes, this function will add any new items which were fetched to
         *  the carousel.
         *
         *  @private
         *  @param {Carousel} carousel
         *  @param {array} newFetchedItems
         *  @param {array} oldFetchedItems
         */
        function handleItemChanges(carousel, newFetchedItems, oldFetchedItems) {
            if (carousel.getAttr(ATTR.ANIMATING)) {
                carousel.once(ATTR.ANIMA    });
            } else {
                var itemDimensions = carousel.getDimensions().items;
                var itemsToProcess = Math.min(newFetchedItems.length, carousel.getAttr(ATTR.SET_SIZE));

                if (!oldFetchedItems || newFetchedItems.length >= oldFetchedItems.length) {
                    carousel.setAttr(ATTR.LOADING, true);

                    A.each(A.range(itemsToProcess), function (idx) {
                        var ajaxIdx = idx; // ajax uses 0-based index
                        var crslIdx = ajaxIdx + 1; // carousel uses 1-based index

                        var item = newFetchedItems[ajaxIdx];
                        var $item = getCard(carousel, crslIdx);

                        // If the item is indeed new, update the DOM and demensionsCache
                        var itemNotProcessed = item && !((item === true) || (item.content === true));
                        if (item && !A.equals(item, oldFetchedItems[ajaxIdx]) && $item.length && itemNotProcessed) {
                            var relativeItemIdx = getRelativeIndex(carousel, crslIdx);

                            itemDimensions[relativeItemIdx] = {
                                width: $item.outerWidth(),
                                outerWidth: $item.outerWidth(true),
                                height: $item.outerHeight(),
                                outerHeight: $item.outerHeight(true)
                            };
                            util.addElementToDom($item, util.getElementFromItem(item));
                            newFetchedItems[ajaxIdx] = util.clearElementFromItem(item);
                        }
                    });
                    carousel.setAttr(ATTR.LOADING, false);
                }

                carousel.setAttr(ATTR.FETCHED_ITEMS, newFetchedItems);
                carousel.updateDimensionsCache({
                    items: itemDimensions
                });
            }
        }


        function isCircularCarousel(carousel) {
            return (carousel.getAttr(ATTR.SET_SIZE) > 2);
        }

        function getEdge(carousel) {
            var edge = {
                reached: false,
                left: false,
                right: false
            };
            if (!isCircularCarousel(carousel)) {
                var currentPage = carousel.getAttr(ATTR.PAGE_NUMBER);
                var setSize = carousel.getAttr(ATTR.SET_SIZE);
                if (currentPage === 1) {
                    edge.reached = true;
                    edge.left = true;
                }
                if (currentPage === setSize) {
                    edge.reached = true;
                    edge.right = true;
                }
            }
            return edge;
        }

        function gotoDirection(carousel, direction, options) {
            var edge = getEdge(carousel);
            var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);

            if (edge.reached && edge[direction]) {
                carousel.gotoPage(pageNumber);
                return;
            }
            var gotoNextOrPrevPage = (direction === 'right') ? carousel.gotoNextPage : carousel.gotoPrevPage
            gotoNextOrPrevPage.call(carousel, options);
        }

        /**
         * Rotate the carousel in specified direction
         *
         * @private
         * @param {Carousel} carousel
         * @param {SLIDE_DIRECTION} direction
         * @param {Number} quantity
         */
        function rotateCards(carousel, direction, quantity) {
            var firstCardIdx = carousel.getAttr(TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX) || 1;
            var setSize = carousel.getAttr(ATTR.SET_SIZE);
            var $cards = carousel.dom.$carousel.children('li');
            var $carousel = carousel.dom.$carousel;
            if (direction === SLIDE_DIRECTION.CLOCKWISE) {
                circularUtil.rotateCW($carousel, $cards, quantity);
                firstCardIdx = circularUtil.firstCardIndexAfterRotate(quantity, firstCardIdx, setSize);
            } else {
                circularUtil.rotateCCW(carousel.dom.$carousel, carousel.dom.$carousel.children('li'), quantity);
                firstCardIdx = circularUtil.firstCardIndexAfterRotate((-1 * quantity), firstCardIdx, setSize);
            }
            carousel.setAttr(TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX, firstCardIdx);
            updateDimension(carousel, quantity, direction);
        }


        /**
         * Slides the carousel clockwise/counter-clockwise by quantity. Carousel shows the card that's in the middle,
         * for peek to work the carousel shoul have card in both left or right hand side of the viewport. This involves
         * 1. Move the necessary number of cards to the direction of slide
         * 2. Make sure that the same card that was visible in the viewport before rotating (reposition)
         * 3. Animate the cards
         *
         * @private
         * @param carousel
         * @param direction
         * @param strategy
         * @param quantity
         * @param options
         */
        function slide(carousel, direction, strategy, quantity, options) {
            var originalCallback = options.callback;
            var currentVisibleCardIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
            var deltaPx = carousel.getAttr(ATTR.CURRENT_PIXEL) - getItemOffset(carousel, currentVisibleCardIdx);

            function rotate(next) {
                // move desired number of cards
                rotateCards(carousel, direction, quantity);
                next();
            }

            function reposition(next) {
                // reposition the viewport to ensure card that was visible before rotation is still visible
                var cardIndex = (direction === SLIDE_DIRECTION.CLOCKWISE) ?
                    (currentVisibleCardIdx - quantity) : (currentVisibleCardIdx + quantity);

                strategy.gotoPixel(carousel, getItemOffset(carousel, cardIndex) + deltaPx,
                    {animationDuration: 0, callback: next});
            }

            function animate(next) {
                // slide animation
                options.callback = next;
                strategy.gotoPixel(carousel, getItemOffset(carousel, currentVisibleCardIdx), options);
            }

            function rearrange(next) {
                // balancing carousel such that equal number of cards are present in either side of viewport
                arrangeCards(carousel, strategy);
                next();
            }

            function triggerCallback(next) {
                if (originalCallback) {
                    originalCallback();
                }
                next();
            }

            A.sequence(rotate, reposition, animate, rearrange, triggerCallback)();

        }

        /**
         * updates dimensions to reflect rotation of cards
         *
         * @private
         * @param {Carousel} carousel
         * @param {number} quantity
         * @param {number} direction - clockwise or counter clockwise
         */

        function updateDimension(carousel, quantity, direction) {
            quantity = quantity || 1;
            direction = direction || SLIDE_DIRECTION.CLOCKWISE;
            var dimensionItems = carousel.getDimensions().items;

            if (direction === SLIDE_DIRECTION.CLOCKWISE) {
                dimensionItems = circularUtil.rotateArrayCW(dimensionItems, quantity);
            }
            else {
                dimensionItems = circularUtil.rotateArrayCCW(dimensionItems, quantity);
            }
            carousel.updateDimensionsCache({
                items: dimensionItems
            });
        }


      }


        var DEFAULT_ANIMATION_SPEED = A.capabilities.touch ? 2000 : 3000; // in pixel/second
        var DEFAULT_EASING = 'ease-out';

        var initAttrs = {};
        initAttrs[ATTR.HIDE_OFF_SCREEN] = false;
        initAttrs[ATTR.ANIMATION_SPEED] = defaultFiniteNumber(DEFAULT_ANIMATION_SPEED);
        initAttrs[TRANSITION_SLIDE_CIRCULAR_FIRST_CARD_IDX] = 1;

        return {
            initAttrs: initAttrs,

            /**
             *  Add empty card, updates ajaxed in content and bind attr handlers
             *
             *  @public
             *  @param carousel
             */
            init: function (carousel) {
                addEmptyCards(carousel);

                carousel.onChange(ATTR.FETCHED_I    });

                carousel.onChange(ATTR.SET_SIZE, function (current, old) {
                    if (current > old) {
                        addEmptyCards(carousel);
                    }
                });
                carousel.onChange(ATTR.PEEK_WIDTH, function (current, old) {
                    if (current !== old) {
                        var idx = carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM);
                        carousel.gotoIndex(idx);
                    }
                })
            },

            /**
             *  Balances the card carousl such that equal number of cards are present on either side of viewport
             *
             *  @public
             *  @param carousel
             */
            after    },
            gotoPage: function (carousel, page, options) {
                options = options || {};
                var maxPage = carousel.getAttr(ATTR.TOTAL_PAGES);
                if (page > 0 && page <= maxPage) {
                    carousel.setAttr(ATTR.PAGE_NUMBER, page);
                    this.gotoIndex(carousel, (carousel.getAttr(ATTR.PAGE_SIZE) * (page - 1)) + 1, options);
                }
            },
            gotoIndex: function (carousel, idx, options) {
                var setSize = carousel.getAttr(ATTR.SET_SIZE);
                var relativeIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
                var desiredRelativeIdx = getRelativeIndex(carousel, idx);
                if (relativeIdx === desiredRelativeIdx) {
                    this.gotoPixel(carousel, getItemOffset(carousel, relativeIdx), options);
                    return;
                }

                if (isCircularCarousel(carousel)) {
                    var cardsToMove = calculateCardsToMove(relativeIdx, desiredRelativeIdx, setSize);
                    // in case of of start over, the animation should be snappy
                    if (options.startover) {
                        if (cardsToMove.quantity > 5) {
                            options.animationDuration = 1250;
                        } else {
                            delete options.animationDuration;
                            options.animationSpeed = carousel.getDimensions().viewport.width * 5;
                        }
                    }
                    slide(carousel, cardsToMove.direction, this, cardsToMove.quantity, options);
                } else {
                    this.gotoPixel(carousel, getItemOffset(carousel, idx), options);
                }
                carousel.setAttr(ATTR.FIRST_VISIBLE_ITEM, idx);
            },
            gotoPixel: function (carousel, desiredPx, options) {
                var currentPx = carousel.getAttr(ATTR.CURRENT_PIXEL);
                if (desiredPx === currentPx) {
                    return;
                }

                if (!A.isFiniteNumber(desiredPx)) {
                    P.error('Target pixel is not a finite number', 'a-carousel-transition-slide-circular', 'gotoPixel');
                }

                options = options || {};
                var easingFunction = options.easingFunction || DEFAULT_EASING;
                var afterAnimate = options.callback;
                var animationDuration;

                if (options.animationDuration !== undefined) {
                    animationDuration = options.animationDuration;
                } else {
                    var pxPerSecond = A.isFiniteNumber(options.animationSpeed) ?
                        options.animationSpeed : carousel.getAttr(ATTR.ANIMATION_SPEED);
                    var distance = Math.abs(desiredPx - currentPx);
                    animationDuration = pxPerSecond === 0 ? 0 :
                        Math.floor(distance / pxPerSecond * 1000);
                }

                if (animationDuration > 0) {
                    !options.silent && carousel.setAttr(ATTR.ANIMATING, true);
                    afterAnimate = function () {
                        if (options.callback) {
                            options.callback();
                        }
                        carousel.setAttr(ATTR.ANIMATING, A.isAnimated(carousel.dom.$carousel), options.silent);
                    };
                }

                carousel.setAttr(ATTR.CURRENT_PIXEL, desiredPx);
                A.animate(carousel.dom.$carousel, {
                    left: desiredPx * -1
                }, animationDuration, easingFunction, afterAnimate);
            },
            gotoNext    },
            gotoPrevPage: function (carousel, options) {
                var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);
                pageNumber = (pageNumber === 1) ? carousel.getAttr(ATTR.TOTAL_PAGES) : (pageNumber - 1);
                this.gotoPage(carousel, pageNumber, options);
            },
            /**
             *  Delegates swipe events to gotoNextPage/PrevPage based on thresholds
             *  @param carousel
             *  @param touch
             */
            onSwipe: function (carousel, touch) {
                var currentPx = carousel.getAttr(ATTR.CURRENT_PIXEL);
                var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
                var firstCardIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));

                // Calculate Duration
                var goingRight = touch.velocityX < 0;
                var newIdx = goingRight ? firstCardIdx + pageSize : firstCardIdx - pageSize;
                var itemOffset = getItemOffset(carousel, newIdx);
                var dx = goingRight ? currentPx - itemOffset : currentPx + itemOffset;
                var duration = Math.abs(dx * 1000 / touch.velocityX);

                var maxDuration = 300,
                    minDuration = A.viewport().width * 1.2;

                var direction = (touch.touchDeltaX < 0) ? 'right' : 'left';
                gotoDirection(carousel, direction, {
                    animationDuration: Math.min(Math.max(duration, maxDuration), minDuration),
                    easingFunction: carousel.getAttr(ATTR.TOUCH_EASING)
                });

            },
            /**
             *  Allow the user to pan to a specific pixel based on the movement of the user's finger.
             *  When the user lifts their finger, if they haven't swiped, this will return the user
             *  to the closest page.
             *
             *  @public
             *  @param {Carousel} carousel
             *  @param {object} touch  Touch event data generated by the gesture detection library.
             */
            onPan: function (carousel, touch) {
                carousel.setAttr(ATTR.ANIMATING, true);
                var pageNumber = carousel.getAttr(ATTR.PAGE_NUMBER);
                var firstCardIdx = getRelativeIndex(carousel, carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM));
                var offset = getItemOffset(carousel, firstCardIdx);
                var px;
                if (getEdge(carousel).reached) {
                    px = offset - touch.touchDeltaX * EDGE_SPRING_MULTIPLIER;
                } else {
                    px = offset - touch.touchDeltaX;
                }

                if (touch.ended) {
                    var options = {
                        easingFunction: carousel.getAttr(ATTR.TOUCH_EASING),
                        animationSpeed: A.viewport().width * 0.95,
                        silent: true
                    };

                    var isSwipe = Math.abs(touch.touchDeltaX) >= carousel.getViewportWidth() * MIN_SWIPE_DISTANCE;
                    if (isSwipe) {
                        var direction = (touch.touchDeltaX < 0) ? 'right' : 'left';
                        gotoDirection(carousel, direction, options);
                    } else {
                        carousel.gotoPage(pageNumber, options);
                    }
                } else {
                    carousel.gotoPixel(px, {
                        easingFunction: carousel.getAttr(ATTR.TOUCH_EASING),
                        animationDuration: 0,
                        silent: true
                    });
                }
            }
        };
    });
/////////////////////////
// END FILE js/strategies/transition/carousel_strategies_transition_slidecircular.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/transition/carousel_strategies_transition_freescroll.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Carousel Transition Strategies
 *
 *  This is currently minimal strategy to support mobile variable width carousel.
 *
 */

'use strict';

P.when('A', 'a-carousel-utils', 'a-carousel-constants').register('a-carousel-transition-freescroll', function (A, util, ATTR) {

  /**
   *  Constants for attribute names.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_NEXT_REQUEST_SIZE = 'next_request_size';
  var ATTR_LOADING_THRESHOLD_PIXELS = 'loading_threshold_pixels';
  var ATTR_AJAX_LOCK = "ajaxLock";

  // Import CarouselInteractions
  /* Importing js/strategies/transition/_carousel_strategies_transition_freescroll_interactions.js */
/**
 * CarouselInteractions factory method returns instance for provided carousel.
 * @private
 */
function carouselInteractions(carousel) {
  if (!carouselInteractionsInstances[carousel.__id]) {
    carouselInteractionsInstances[carousel.__id] = new CarouselInteractions(carousel);
  }
  return carouselInteractionsInstances[carousel.__id];
}

// tracks CarouselInteractions instances by carousel id
var carouselInteractionsInstances = {};

/**
 * CarouselInteractions encapsulates carousel API and DOM interactions for freescroll transtion strategy.
 * @private
 */
var CarouselInteractions = function(carousel) {
  this.carousel = carousel;
}
A.extend(CarouselInteractions.prototype, {
  setAttr: function(name, value) {
    return this.carousel.setAttr(name, value);
  },
  getAttr: function(name) {
    return this.carousel.getAttr(name);
  },
  onCh;
  },
  getItems: function() {
    return this.carousel.dom.$carousel.children('li');
  },
  countI;
  },
  showI;
  },
  getEmpty;
  },
  getEmptyC;
  },
  hasEmpty;
  },
  getFirstEmptyDetails: function() {
    var $empty = this.getEmptyCards();
    if ($empty.length > 0) {
      var $card = $empty.first();
      return {
        index: $card.index(),
        left: $card.position().left
      };
    } else {
      return {
        index: -1,
        left: -1
      };
    }
  },
  appendI;
  },
  has;
  },
  insertFetched;
  },
  attachScrollList;
  },
  detachScrollList;
  },
  measureW;
  },
  want;
  },
  thro;
  }
});
/* Done importing js/strategies/transition/_carousel_strategies_transition_freescroll_interactions.js */


  /**
   *  Prepare fetched items attribute based on preloaded items.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function prepareFetchedItems(carousel) {
      var numItems = carousel.countItems();
      var fetchedItems = [];

      for (var i = 0; i < numItems; i++) {
          fetchedItems.push(true);
      }
      carousel.setAttr(ATTR.FETCHED_ITEMS, fetchedItems);
  }

  /**
   *  This will put enough empty cards in the list to accomodate the total set_size.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function addEmptyCards(carousel) {
    var numItems = carousel.countItems();
    var setSize = carousel.getAttr(ATTR.SET_SIZE);
    var emptyItems = [];
    var cardIndex;

    if (setSize > numItems) {
      for (var i = 0; i < (setSize - numItems); i++) {
        cardIndex = numItems + i + 1; // one based index, offset by existing cards
        emptyItems.push(carousel.getEmptyCard(cardIndex, setSize));
      }
      carousel.appendItems(emptyItems);
    }
  }

  /**
   *  When the fetchedItems object changes, this function will add any new items which were fetched to
   *  the carousel.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   *  @param {array} newFetchedItems
   *  @param {array} oldFetchedItems
   */

  function handleItemChanges(carousel, newFetchedItems, oldFetchedItems) {
    if (!oldFetchedItems || newFetchedItems.length >= oldFetchedItems.length) {
      var items = carousel.getItems();
      var i = newFetchedItems.length;
      var fetched;
      while (i--) {
        fetched = newFetchedItems[i];
        // Dump the fetched HTML into the DOM...
        // Uses skip reprocessing pattern from slide transition handleItemChanges function
        if (fetched && !A.equals(fetched, oldFetchedItems[i]) && !((fetched === true) || (fetched.content === true))) {
          if (carousel.hasItem(items, i)) {
            newFetchedItems[i] = carousel.insertFetchedItem(fetched, items, i);
          }
        }
      }
    }
    // Put the new fetchedItems struct back in memory
    carousel.setAttr(ATTR.FETCHED_ITEMS, newFetchedItems);
  }

  /**
   * Add scroll listener to carousel if empty cards present. Throttles scroll events.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function addScrollListener(carousel) {
    // Add handler when empty cards present.
    if (carousel.hasEmptyCard()) {
      carousel.attachScrollLis    });
    }
  }

  /**
   * Check if scroll listener still necessary for carousel, if not remove.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function checkScrollListener(carousel) {
    // Remove handler when empty cards not present.
    if (!carousel.hasEmptyCard()) {
      carousel.detachScrollListener();
    }
  }

  /**
   * Determines when to request next items.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   */
  function detectEmptyCardsLoadingThreshold(carousel) {
      var loadingThresholdPixels = carousel.getAttr(ATTR_LOADING_THRESHOLD_PIXELS);
      var carouselWidth = carousel.measureWidth();
      var emptyCard = carousel.getFirstEmptyDetails();

      // check if first empty card is in view
      if (emptyCard.index !== -1 && emptyCard.left < carouselWidth + loadingThresholdPixels) {
        next(carousel, emptyCard.index);
      } else {
        // continue to check loading threshold for momentum scrolling
        if (carousel.previousCardLeft && carousel.previousCardLeft !== emptyCard.left) {
          carousel.throttle('detect', detectEmptyCardsLoadingThreshold);
        }
        carousel.previousCardLeft = emptyCard.left;
      }
  }

  /**
   * Inform ajax strategy of want for additional items.
   *
   *  @private
   *  @param {CarouselInteractions} carousel
   *  @param {int} index
  ;
  }

  var initAttrs = {};
  initAttrs[ATTR_AJAX_LOCK] = true;
  initAttrs[ATTR.NO_TRANSITION] = true;
  initAttrs[ATTR.HIDE_OFF_SCREEN] = false;
  initAttrs[ATTR.AUTO_ADJUST_HEIGHT] = false;
  initAttrs[ATTR_NEXT_REQUEST_SIZE] = 10;
  initAttrs[ATTR_LOADING_THRESHOLD_PIXELS] = 400;

  return {
    gotoIndex: A.constants.NOOP,
    gotoNextpage: A.constants.NOOP,
    gotoPrevPage: A.constants.NOOP,
    gotoPage: A.constants.NOOP,
    initAttrs: initAttrs,
    init: function (rawCarousel) {
      var carousel = carouselInteractions(rawCarousel);
      carousel.showItems();

      prepareFetchedItems(carousel);
      addEmptyCards(carousel);
      addScrollListener(carousel);

      carousel.onChange(ATTR.FETCHED_ITEMS, function (current, old) {
        detectEmptyCardsLoadingThreshold(carousel);
        handleItemChanges(carousel, current, old);
        checkScrollListener(carousel);
      });

      // orientation change may require loading cards
      A.on.resize(function() {
        detectEmptyCardsLoadingThreshold(carousel);
      });
    },
    afterInit : function(rawCarousel) {
      var carousel = carouselInteractions(rawCarousel);
      A.delay(function() {
        carousel.setAttr(ATTR_AJAX_LOCK, false);
        detectEmptyCardsLoadingThreshold(carousel);
      });
    },
    // visible for testing
    prepareFetchedItems: prepareFetchedItems,
    addEmptyCards: addEmptyCards,
    handleItemChanges: handleItemChanges,
    detectEmptyCardsLoadingThreshold: detectEmptyCardsLoadingThreshold,
    ATTR: {
      NEXT_REQUEST_SIZE: ATTR_NEXT_REQUEST_SIZE,
      LOADING_THRESHOLD_PIXELS: ATTR_LOADING_THRESHOLD_PIXELS
    }
  };
});
/////////////////////////
// END FILE js/strategies/transition/carousel_strategies_transition_freescroll.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies_transition.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Carousel Transition Strategies
 *
 */

"use strict";

/**
 *  A set of default transition strategies which define behavior when the user navigates through the carousel.
 */
P.when("A", "jQuery", "a-carousel-transition-slide", "a-carousel-transition-swap", "a-carousel-transition-freescroll", "a-carousel-transition-slidecircular", "a-carousel-constants").register("a-carousel-strategies-transition", function (A, $, slide, swap, freeScroll, slideCircular, ATTR) {

  var initAttrs = {};
  initAttrs[ATTR.NO_TRANSITION] = true;
  initAttrs[ATTR.HIDE_OFF_SCREEN] = false;
  initAttrs[ATTR.AUTO_ADJUST_HEIGHT] = false;

  return {
    slideHorizontal: slide,
    swap: swap,
    freeScroll: freeScroll,
    slideCircular: slideCircular,
    none: {
      gotoIndex: A.constants.NOOP,
      gotoNextPage: A.constants.NOOP,
      gotoPrevPage: A.constants.NOOP,
      gotoPage: A.constants.NOOP,
      initAttrs: initAttrs,
          }
    },
    "default": "slideHorizontal"
  };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies_transition.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/ajax/carousel_strategies_ajax_standard.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel AJAX Strategies
 *
 */

"use strict";

/**
 *  Generate the default AJAX strategy for use in a Carousel.  This strategy involves queued fetching based on AJAX
 *  endpoint and optional prefetching the next page for the user
 */
P.when("A").register("a-carousel-ajax-standard", function (A) {
  var undefined;

  /**
   *  @private
   *  @constant
   *  @type {Number}
   */
  var DEFAULT_FETCH_DELAY = 500;

  /**
   *  Constants for attribute names.  Aids in compression and ensures I don't misspell things.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var ATTR_FETCHED_ITEMS = "fetchedItems";
  var ATTR_PAGE_NUMBER = "pageNumber";
  var ATTR_PAGE_SIZE = "pageSize";
  var ATTR_AJAX_HASH = "ajax";
  var ATTR_SHOW_PARTIAL_NEXT = "show_partial_next";
  var ATTR_REQUEST_TIMER = "requestTimer";
  var ATTR_SET_SIZE = "set_size";
  var ATTR_AJAX_LOCK = "ajaxLock";

  /**
   * Blurb including a link to a wiki page that details AJAX response formatting.
   *  @private
   *  @constant
   *  @type {String}
   */
  var AJAX_WIKI_LINK = " - see http://tiny/c1mr5h0u for details.";

  /**
   *  Fires an AJAX request to fetch more items in the Carousel
   *
   *  @private
   *  @param {Carousel} carousel - The carousel which will be receiving the fetched items
   *  @param {String} url - The AJAX endpoint to hit
   *  @param {Object} params - HTTP request parameters to send
   */

  function sendRequest(carousel, url, params) {
    var success = function (data) {
      data = _getValidatedData(data, url);

      if(data === null) {
        P.error("Invalid JSON returned to carousel from " + url + AJAX_WIKI_LINK, "a-carousel-ajax-standard", "sendRequest");
        return;
      }

      // If the carousel needed a set_size, we need need to get it from the returned data
      if (params.needSetSize) {
        if (!data || !data.length) {
          P.error("Carousel requires a set_size and none was returned by the fallback AJAX request at: " + url, "a-carousel-ajax-standard", "sendRequest");
        }
        var setSize = data[0].setSize ? data[0].setSize : data.length;
        carousel.setAttr(ATTR_SET_SIZE, setSize);
      }

      // Get the current set of fetchedItems and add the returned data to the array
      var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);
      var item;

      while ((item = data.pop()) !== undefined) {
        // Check if the item is not somehow null and then act on it based on one of the two accepted patterns for AJAX response
        // [{"content":"blahblahblah"}, ...] or
        // ["blahblahblah", ...]
        if (item) {
          if (item.content || item.content === "") {
            item.content = A.trim(item.content);
          } else {
            item = A.trim(item);
          }
        }

        fetchedItems[params.offset + data.length] = item;
      }

      // If the carousel didn't have a set_size, it didn't initialize.  Do that now.
      if (params.needSetSize) {
        carousel.init();
      }

      carousel.setAttr(ATTR_FETCHED_ITEMS, fetchedItems);

      // Allow the want functions to trigger AJAX calls again
      carousel.setAttr(ATTR_AJAX_LOCK, false);
      if (params.needSetSize && carousel.getAttr(ATTR_PAGE_SIZE) >= fetchedItems.length) {
        carousel.strategies.ajax.wantCurrentPage(carousel);
      }

      // Useful event for metrics
      carousel.triggerEvent("ajaxSuccess", {
        url: url,
        params: params
      });
    };

    // Useful event for metrics
    carousel.triggerEvent("beforeAjax", {
      url: url,
      params: params
    });

    A.get(url, {
      cache: false,
      success: success,
      params: params
    });
  }

  /**
   *  If another fetch is requested before the queued request is fired, we need to clear out
   *  that queued request.
   *
   *  @private
   *  @param {Carousel} carousel - The carousel to check
   */

  function clearRequestQueue(carousel) {
    var timer = carousel.getAttr(ATTR_REQUEST_TIMER);
    if (timer) {
      clearTimeout(timer);
      carousel.setAttr(ATTR_REQUEST_TIMER, null);
    }
  }

  /**
   *  Validate that AJAX response is properly formatted; return the array
   *  of carousel items if it is or null if it is invalid JSON.
   *
   *  @private
   *  @param {object} data - the JSON data returned from the AJAX call
   *  @param {string} url - the URL of the AJAX call
   */
  function _getValidatedData(data, url) {
    // We support array because this is how we used to tell teams to construct the code
    // Now, we expect users to return a JSON object that looks like:
    // { data: [/* card data goes here */] }
    if(A.isArray(data)) {
      // NOTE: turning off warning for now due to false alarms (tt/0058346174).  Turn back on in
      // 3.15.9 or 3.15.10 after SIMS has updated their carousels to use the new format.
      //P.log("Invalid carousel AJAX format from " + url + AJAX_WIKI_LINK, "WARN", "a-carousel-ajax-standard");
      return data;
    }

    if(data === undefined || data === null || A.objectIsEmpty(data) || !data.hasOwnProperty('data') || !A.isArray(data.data)) {
      return null;
    }

    return data.data;
  }

  return {
    /**
     *  AJAX requests should have a slight delay in case the user spams the next or prev buttons.
     *  Queue up a request with a given delay.
     *
     *  @public
     *  @param {Carousel} carousel - The carousel which will be receiving the fetched items
     *  @param {String} url - The AJAX endpoint to hit
     *  @param {Object} params - HTTP request parameters to send
     */
    getItems: function (carousel, url, params) {
      var ajax = carousel.getAttr(ATTR_AJAX_HASH);
      carousel.setAttr(ATTR_REQUEST_TIMER, A.delay(sendRequest, ajax.fetch_delay, carousel, url, params));
    },
    /**
     *  Convenience method which calls want on the current and next page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wantNextPage: function (carousel) {
      clearRequestQueue(carousel);
      var ajax = carousel.getAttr(ATTR_AJAX_HASH);
      if (ajax.prefetch_next_page) {
        var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
        var size = pageSize * 2;
        if (carousel.getAttr(ATTR_SHOW_PARTIAL_NEXT)) {
          size++;
        }
        this.want(carousel, (carousel.getAttr(ATTR_PAGE_NUMBER) - 1) * pageSize, size);
      } else {
        this.wantCurrentPage(carousel);
      }

    },
    /**
     *  Convenience method which calls want on the current and previous page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wantPrevPage: function (carousel) {
      clearRequestQueue(carousel);
      var ajax = carousel.getAttr(ATTR_AJAX_HASH);
      if (ajax.prefetch_next_page) {
        var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
        var size = pageSize * 2;
        if (carousel.getAttr(ATTR_SHOW_PARTIAL_NEXT)) {
          size++;
        }
        this.want(carousel, (carousel.getAttr(ATTR_PAGE_NUMBER) - 2) * pageSize, size);
      } else {
        this.wantCurrentPage(carousel);
      }
    },
    /**
     *  Convenience method which calls want on the current page
     *
     *  @public
     *  @param {Carousel} carousel
     */
    wantCurrentPage: function (carousel) {
      clearRequestQueue(carousel);
      var pageSize = carousel.getAttr(ATTR_PAGE_SIZE);
      var size = carousel.getAttr(ATTR_SHOW_PARTIAL_NEXT) ? pageSize + 1 : pageSize;
      this.want(carousel, (carousel.getAttr(ATTR_PAGE_NUMBER) - 1) * pageSize, size);
    },
    /**
     *  Expresses a desire for a set of indexes.  Will queue up a fetch for indexes which haven't been fetched.
     *
     *  @public
     *  @param {Carousel} carousel
     *  @param {Number} startIdx - The index of the first item in the set which is desired
     *  @param {Number} size - The number of items desired.
     */
    want: function (carousel, startIdx, size) {
      if (!carousel.getAttr(ATTR_AJAX_LOCK)) {
        clearRequestQueue(carousel);
        var ajax = carousel.getAttr(ATTR_AJAX_HASH);
        var setSize = carousel.getAttr(ATTR_SET_SIZE);
        if (ajax.url) {
          var fetchedItems = carousel.getAttr(ATTR_FETCHED_ITEMS);
          var ids = ajax.id_list;
          if (!ids) {
            ids = [];
          }
          var current = startIdx > -1 ? startIdx : 0;
          var end = startIdx + size - 1;
          var params = ajax.params || {};
          var idsToFetch = [];
          var itemsToFetch = [];
          var id;
          if (setSize === 0) {
            if (ids.length) {
              setSize = ids;
            }
            params.needSetSize = "true";
            carousel.setAttr(ATTR_AJAX_LOCK, true);
          }
          if (size === -1 && setSize) {
            end = setSize;
          }
          while (current <= end && current < setSize) {
            if (!fetchedItems[current]) {
              id = ids[current];
              if (id) {
                idsToFetch.push(id);
              }
              itemsToFetch.push(current);
              fetchedItems[current] = false;
            }
            current++;
          }
          carousel.setAttr(ATTR_FETCHED_ITEMS, fetchedItems, {
            silent: true
          });

          params.count = itemsToFetch.length;
          params.offset = itemsToFetch[0] || 0;
          if (idsToFetch.length > 0) {
            params[ajax.id_param_name] = idsToFetch.join(",");
          }
          if (itemsToFetch.length > 0 || params.needSetSize) {
            this.getItems(carousel, ajax.url, params);
          }
        }
      }
    },
    /**
     *  Sets up the default for the AJAX queue fetch delay.
     *  Fetches missing items for the current page and optionally fetches the next page.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    init: function (carousel) {
      // Set some defaults
      var ajax = carousel.getAttr(ATTR_AJAX_HASH);
      if (!A.isFiniteNumber(ajax.fetch_delay)) {
        ajax.fetch_delay = DEFAULT_FETCH_DELAY;
      }
      ajax.id_param_name = ajax.id_param_name || "ids";
      ajax.prefetch_next_page = ajax.prefetch_next_page === undefined ? true : !!ajax.prefetch_next_page;

      carousel.setAttr(ATTR_AJAX_HASH, ajax);

      if (!carousel.getAttr(ATTR_SET_SIZE)) {
        this.want(carousel, 0, -1);
      }
    },
    /**
     *  Ensure that all fetching is done after all change handlers have been bound.
     *
     *  @public
     *  @param {Carousel} carousel
     */
    afterInit: function (carousel) {
      // Make sure we have enough items to fill the current page
      carousel.strategies.ajax.wantCurrentPage(carousel);

      // When the page number changes, we might have to get more items
      carousel.onChange(ATTR_PAGE_NUMBER, function (current, old) {
        if (current > old) {
          carousel.strategies.ajax.wantNextPage(carousel);
        } else {
          carousel.strategies.ajax.wantPrevPage(carousel);
        }
      });
    }
  };
});
/////////////////////////
// END FILE js/strategies/ajax/carousel_strategies_ajax_standard.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies_ajax.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel AJAX Strategies
 *
 */

"use strict";

/**
 *  Officially supported set of ajax strategies provided for carousels.
 */
P.when("A", "a-carousel-ajax-standard").register("a-carousel-strategies-a };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies_ajax.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/accessibility/carousel_strategies_accessibility_standard_desktop.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Accessibility Standard Desktop Strategy
 *
 */

"use strict";

/**
 *  Generate the default accessibility strategy for use in a Carousel on desktops.
 */
P.when("A", "a-carousel-constants").register("a-carousel-accessibility-standard-desktop", function (A, ATTR) {
  var $ = A.$;

  /**
   *  The CSS class placed on empty carousel cards
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var LOADING_SPINNER_CARD_CLASS = "a-carousel-card-empty";

  /**
   *  Combined child selector to get a list of all "real" cards (returns in DOM order)
   *
   *  Different carousel display strategies have different behaviors for what ends up inside the carousel's <ol>
   *  This selector will ensure that we get <li.a-carousel-card>s that are, at the moment the selector is run, either
   *  actual cards with content or cards that are loading and waiting for new content.
   *
   *  The swap carousel has a concept of a third type of card which is a card that is neither loading nor containing
   *  any content and is just a placeholder so that the swap animation looks correct when moving to another page. This
   *  selector avoids those cards.
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var REAL_CARDS_SELECTOR = "li:not(:empty), li." + LOADING_SPINNER_CARD_CLASS;

  /**
   *  The CSS class for the carousel's next page button
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var NEXT_PAGE_BUTTON_CLASS = "a-carousel-goto-nextpage";

  /**
   *  The CSS class for the carousel's previous page button
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var PREV_PAGE_BUTTON_CLASS = "a-carousel-goto-prevpage";


  // ----------------------- PRIVATE FUNCTIONS ----------------------- //


  /**
   *  Return the first descendent element from the passed in element that can become activeElement via tab
   *
   *  @private
   *  @param {jQuery Object} $elem
   *
   *  @return {jQuery Object} single jQuery object representing the element or empty
  ;
  }

  /**
   *  Return a list of cards that are visible and aren't filler cards from the swap strategy
   *
   *  @private
   *  @param {Carousel} carousel
   *
   *  @return {jQuery Object} list of visible items
   */
  function _getVisibleCards(carousel) {
    var $carousel = carousel.dom.$carousel;
    var $cards = $carousel.children("li");
    var pageSize = carousel.getAttr(ATTR.PAGE_SIZE);
    var firstVisibleZeroIndex = carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM) - 1; // ATTR.FIRST_VISIBLE_ITEM starts at 1, not 0

    // The if/else if/final here do not necessarily map to a specific implementation of display/transition strategy
    // While the following explanations discuss which built-in strategy they target, by not specifically mentioning
    // strategies by name, when possible, we can cover similar use cases from custom strategies if they conform enough.

    // For a transition strategy of none, we want to return all cards as they are all visible and available all the time
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return $cards;
    // This else if will run for:
    // - Swap:             Always, Swap always has the same number of cards in the <ol> as pageSize
    // - Single:           When $cards.length = 1, essentially that the carousel only contains one card
    // - Stretchygoodness: When the carousel contains fewer total cards than can be displayed on one page
    } else if ($cards.length <= pageSize) {
      return $carousel.children(REAL_CARDS_SELECTOR);
    }
    // This case covers Single and Stretchygoodness for all cases other than mentioned above
    return $cards.slice(firstVisibleZeroIndex, firstVisibleZeroIndex + pageSize);
  }

  /**
   *  Handle waiting for the carousel to stop animating and move the focus to the first
   *  or last card on the current page
   *
   *  @private
   *  @param {boolean} toFirst
   */
  function _moveFocusAfterPagination(carousel, toFirst, duration, speed) {
    var actualFocusMove = function() {
      var $cards = _getVisibleCards(carousel);
      var $focusTarget = toFirst ? $cards.first() : $cards.last();

      // From the first card, find the first child that is selectable, if any, and focus it.
      _getFirstTabbableDescendant($focusTarget).focus();

      A.delay(function() {
        _updateLivePaginationText(carousel);
      }, carousel.getAttr(ATTR.PAGE_SIZE) * carousel.getAttr(ATTR.DELAY_TIME) + 50);
      // e.g.: 7x30 + 50 (7 items per page, 30ms default delay time, 50 because we may have triggered 7x A.delays()
      // and they may not execute perfectly in the calculated timeframe)
      // This value cannot be stored as a simple constant as these attributes can change over the life of the carousel
    }

    // If the duration or speed are 0 (instantaneous movement), the carousel does not toggle the ANIMATING attribute
    // However it defers using A.delay before calling any callbacks to ensure animation has had time to commit the change
    // visually to the DOM. Delay here as well.
    if (duration === 0 || speed === 0) {
      A.delay(actualFocusMove, 0);
    } else {
      // In the base class, the transition strategy is called first, which sets ATTR.ANIMATING to true, check once for false
      carousel.once(ATTR.ANIMA    });
    }
  }

  /**
   *  If we know what size the set is, set it to all the elements and setup position
   *  If not, at least set position
   *
   *  This function primarily exists to keep downstream users of the carousel from needing to configure
   *  these values on their preloaded content in Mason (they should, but they might not). Given that
   *  various things may have changed from the past, we need to normalize any pre-rendered content to
   *  be sure it fits the new accessibility model the carousel is following.
   *
   *  In the case of a changing set size (future functionality, the carousel doesn't support this now),
   *  this function will be invoked again as the safest possible approach for normalizing the resulting cards
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updateAriaInfo(carousel) {
    var $cards = carousel.dom.$carousel.children("li");
    var transitionStrategy = carousel.getAttr(ATTR.TRANSITION_STRATEGY);
    var setSize = carousel.getAttr(ATTR.SET_SIZE);
    var cardProps = (setSize) ? {"aria-setsize": setSize} : {};

    if (transitionStrategy === "swap") {
      var firstItemNumber = carousel.getAttr(ATTR.FIRST_VISIBLE_ITEM);

      $cards.each(function(idx) {
        var $this = $(this);
        // If this card is higher than the set size, we're dealing with empty cards that we want to skip
        // otherwise we'd end up with posinset numbers greater than the set size.
        if (firstItemNumber + idx > setSize) {
          // When we move to jQuery 1.7, consolidate to a single call
          $this.removeAttr("aria-setsize");
          $this.removeAttr("aria-posinset");
        } else {
          cardProps["aria-posinset"] = firstItemNumber + idx;
          $this.attr(cardProps);
        }
      });
    } else {
      $cards    });
    }
  }

  /**
   *  In order to get screen readers to announce the current page, we place this text inside of an aria-live polite
   *  flagged container. At various times it is appropriate to update this information and announce it aloud. Do that.
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updateLivePaginationText(carousel) {
    var $outerCarouselContainer = carousel.dom.$container;
    $outerCarouselContainer.find(".a-carousel-accessibility-page-info").html($outerCarouselContainer.find(".a-carousel-page-count").text());
  }

  /**
   *  For carousels where cards are present but off screen (that aren't using transition strategy none)
   *  handle toggling aria-hidden behavior so that screen readers don't start reading things that are off screen.
   *  Not all carousels will have the hide offscreen parameter set, but in order to normalize for screen readers,
   *  we need to hide anyway so that tabbing doesn't leave the visible set yet end up on pagination buttons after...
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updateOffscreenVisibility(carousel) {
    var transitionStrategy = carousel.getAttr(ATTR.TRANSITION_STRATEGY);
    // No transition strategy means we need the cards to all be visible to screen readers all at once
    // They should still be read as separate entities, but we don't want to hide ones that aren't visible
    // because they are just overflow: scrolled out of view
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return;
    }

    var $cards = carousel.dom.$carousel.children("li");
    var $visibleCards = _getVisibleCards(carousel);
    var $nonVisibleCards = $cards.not($visibleCards);
    
    $visibleCards.attr("aria-hidden", false);
    $nonVisibleCards.attr("aria-hidden", true);
  }

  /**
   *  Check for circular/non-circular and enable/disable the right buttons at the right times
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updatePaginationButtonStatus(carousel, currentPage) {
    if (!carousel.getAttr(ATTR.CIRCULAR)) {
      var $container = carousel.dom.$container;
      $container.find("." + PREV_PAGE_BUTTON_CLASS).attr("aria-disabled", (currentPage === 1) ? "true" : "false");
      $container.find("." + NEXT_PAGE_BUTTON_CLASS).attr("aria-disabled", (currentPage === carousel.getAttr(ATTR.TOTAL_PAGES)) ? "true" : "false");
    }
  }

  /**
   *  Shared functionality between accessibility strategies
   *  Signature(s):
   *  - _setCarouselBusy
   */

  /* Importing js/strategies/accessibility/_carousel_strategies_accessibility_standard_shared.js */
/**
 *  AmazonUI Carousel Accessibility Standard Shared Functions
 *
 */

/**
 *  setCarouselBusy: Update the aria-busy attribute for the carousel container
 *
 *  @private
 *  @param {Carousel} carousel
 *  @param {boolean} busy
 */
function _setCarouselBusy(carousel, busy) {
  carousel.dom.$carousel.attr("aria-busy", (!!busy).toString());
}
/* Done importing js/strategies/accessibility/_carousel_strategies_accessibility_standard_shared.js */



  // ----------------------- PUBLIC FUNCTIONS ----------------------- //


  /**
   *  Initializes the strategy.  Sets up appropriate change handlers
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function init(carousel) {
    var carouselName = carousel.getAttr(ATTR.NAME);
    var $carouselContainer = carousel.dom.$container;

    _updateAriaInfo(carousel);
    _updateOffscreenVisibility(carousel);
    _updatePaginationButtonStatus(carousel, 1);

    // If the carousel has a name, listen only to named repaints, otherwise listen to all so we don't miss one
    A.on("a:carousel" + (carouselName ? (":" + name) : "") + ":repaint", function() {
      _updateOffscreenVisibility(carousel);
    });

    // If the carousel's overall size changes we need to process the items again
    carousel.onChange(ATTR.SET_SIZE, function(current, old) {
      _updateAriaInfo(carousel);
    });

    // SWAP: Loading is set to true when data has actually been returned only
    // SLIDE: Loading is set to true when adding new empty cards during init / set size change
    // as well as when new items become available to replace the placeholder cards
    carousel.onChange(ATTR.LOADING, function(current) {
      // Ensure busy state remains when animating or loading and removes only when both are finished
      if (!carousel.getAttr(ATTR.ANIMATING)) {
        _setCarouselBusy(carousel, current);
      }
      // we do not need to call ariaInfoUpdate here as the proper settings are applied via the prototype's
      // getEmptyCard function and we use that to generate proper markup when injecting new cards to the list
    });

    // All elements that aren't visible after animate should be aria-hidden.
    // Animate is set to true during the swap and slide *actual animations* whether or not individual
    // cards have been loaded in
    carousel.onChange(ATTR.ANIMATING, function(current) {
      // Ensure busy state remains when animating or loading and removes only when both are finished
      if (!carousel.getAttr(ATTR.LOADING)) {
        _setCarouselBusy(carousel, current);
      }

      if (!current) {
        // If we have more items than will fit on a single page, reprocess the aria-hidden states
        // Also, if using the swap strategy, update the carousel items aria-related parameters
        if (carousel.getAttr(ATTR.SET_SIZE) > carousel.getAttr(ATTR.PAGE_SIZE)) {
          var transitionStrategy = carousel.getAttr(ATTR.TRANSITION_STRATEGY);

          _updateOffscreenVisibility(carousel);

          // Try not to preclude this from working elsewhere. We want to update for swap, but variations
          // on swap that others create should also update here, just not slide (and it's not destructive
          // if we do act on variations of slide, just some JS overhead).
          if (transitionStrategy !== "slide") {
            _updateAriaInfo(carousel);
          }
        }
      }
    });

    // Disable the pagination buttons on non-circular carousels when appropriate
    carousel.onChange(ATTR.PAGE_NUMBER, function(current) {
      _updatePaginationButtonStatus(carousel, current);
    });
  }

  /**
   *  Handles calls from the base class to paginate to a specific page
   *  Move to the first element. This should be invoked by the reset link and other calls to move to a
   *  specific page programmatically via the Carousel object prototype
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function gotoPage(carousel, duration, speed) {
    // The call to the transition strategy will have been a noop, so for safety, we need to do nothing
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return;
    }
    _moveFocusAfterPagination(carousel, true, duration, speed);
  }

  /**
   *  Handles calls from the base class to paginate to the next page
   *  This is so we have a proper direction so we know which way the carousel is moving as you can't tell
   *  by just using page numbers in a two page long carousel
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function nextPage(carousel, duration, speed) {
    // The call to the transition strategy will have been a noop, so for safety, we need to do nothing
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return;
    }
    _moveFocusAfterPagination(carousel, true, duration, speed);
  }

  /**
   *  Handles calls from the base class to paginate to the previous page
   *  This is so we have a proper direction so we know which way the carousel is moving as you can't tell
   *  by just using page numbers in a two page long carousel
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function prevPage(carousel, duration, speed) {
    // The call to the transition strategy will have been a noop, so for safety, we need to do nothing
    if (carousel.getAttr(ATTR.NO_TRANSITION)) {
      return;
    }
    _moveFocusAfterPagination(carousel, false, duration, speed);
  }

  /**
   *  Handles any accessibility needs post-initalization
   *
   *  @public
   *  @param {Carousel} carousel
  ;
  }

  return {
    init: init,
    afterInit: afterInit,
    gotoPage: gotoPage,
    nextPage: nextPage,
    prevPage: prevPage
  }
});
/////////////////////////
// END FILE js/strategies/accessibility/carousel_strategies_accessibility_standard_desktop.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/accessibility/carousel_strategies_accessibility_standard_mobile.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Accessibility Standard Mobile Strategy
 *
 */

"use strict";

/**
 *  Generate the default accessibility strategy for use in a Carousel on mobile and tablet devices.
 */
P.when("A", "a-carousel-constants").register("a-carousel-accessibility-standard-mobile", function (A, ATTR) {
  var $ = A.$;
  var NOOP = A.constants.NOOP;


  // ----------------------- PRIVATE FUNCTIONS ----------------------- //


  /**
   *  The carousel cannot be swiped with assistive technologies enabled, and concerns from the accessibility team
   *  about unmanageably long carousels suggest that we should not attempt to aid in the creation of extremely long
   *  carousels as that is difficult for our accessibility-device-using customers to navigate.
   *
   *  Take all currently empty cards and mark them hidden.
   *  Then properly set the posinset and set-size values for the remaining cards.
   *  If an intial AJAX call is made, this function will be called again to reprocess for the cards we receive that one time
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function _updateAriaInfo(carousel) {
    var $carousel = carousel.dom.$carousel;
    var $emptyCards = $carousel.children(".a-carousel-card-empty");
    var $nonEmptyCards = $carousel.children("li").not($emptyCards);
    var setSize = $nonEmptyCards.length;
    var cardProps = (setSize) ? {"aria-setsize": setSize} : {};
    
    $emptyCards.attr("aria-hidden", "true")
               .removeAttr("aria-setsize")
               .removeAttr("aria-posinset");
    $nonEmptyCards    });
  }

  /**
   *  Shared functionality between accessibility strategies
   *  Signature(s):
   *  - _setCarouselBusy
   */

  /* Importing js/strategies/accessibility/_carousel_strategies_accessibility_standard_shared.js */
/**
 *  AmazonUI Carousel Accessibility Standard Shared Functions
 *
 */

/**
 *  setCarouselBusy: Update the aria-busy attribute for the carousel container
 *
 *  @private
 *  @param {Carousel} carousel
 *  @param {boolean} busy
 */
function _setCarouselBusy(carousel, busy) {
  carousel.dom.$carousel.attr("aria-busy", (!!busy).toString());
}
/* Done importing js/strategies/accessibility/_carousel_strategies_accessibility_standard_shared.js */



  // ----------------------- PUBLIC FUNCTIONS ----------------------- //


  /**
   *  Initializes the strategy.  Essentially ensures that aria posinset and aria setsize are always accurate
   *
   *  @public
   *  @param {Carousel} carousel
   */
  function init(carousel) {
    _updateAriaInfo(carousel);

    // If the carousel's overall size changes we need to process the items again
    carousel.onChange(ATTR.SET_SIZE, function() {
      _updateAriaInfo(carousel);
    });

    // Because we cannot swipe with screen readers active, we will never be animating, but we may be loading
    // so manage the busy state of the carousel in that case.
    carousel.onChange(ATTR.LOADING, function(current) {
      _setCarouselBusy(carousel, current);
      // The transition strategies manage adding newly acquired data into the DOM...
      // When loading is complete, reprocess our limited set of visible-to-aria elements
      if (!current) {
        _updateAriaInfo(carousel);
      }
    });
  }

  // Take no action on goto/next/prev because those actions are visual in nature. If pagination does occur
  // which kicks off AJAX, we will update and include those results in the available content for screen readers
  // to tab over when the carousel is discovered.
  return {
    init: init,
    gotoPage: NOOP,
    nextPage: NOOP,
    prevPage: NOOP
  }
});
/////////////////////////
// END FILE js/strategies/accessibility/carousel_strategies_accessibility_standard_mobile.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies_accessibility.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Accessibility Strategies
 *
 */

"use strict";

/**
 *  Officially supported set of accessibility strategies provided for carousels.
 */
P.when("A", "a-carousel-accessibility-standard-desktop", "a-carousel-accessibility-standard-mobile").register("a-carousel-strategies-accessibil };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies_accessibility.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/strategies/carousel_strategies.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Strategies Aggregator
 */

"use strict";

P.when("a-carousel-strategies-display", "a-carousel-strategies-transition", "a-carousel-strategies-ajax", "a-carousel-strategies-accessibility").register("a-carousel-strateg };
});
/////////////////////////
// END FILE js/strategies/carousel_strategies.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/carousel_framework.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Carousel Framework
 */

"use strict";

/**
 *  Contains a framework for managing carousels on the page.  If you need to include strategies or classes which are not included in the aui,
 *  this framework will allow you to register those extra modules.  Most carousel creation and initialization should happen automatically.  If you
 *  add a carousel to the page via AJAX but the a:pageUpdate event isn't getting fired, you will need to manually run the createAll method.
 */
P.when("A", "jQuery", "a-timing-analytics", "a-carousel-classes", "a-carousel-strategies", "a-carousel-constants")
    .register("a-carousel-framework", function (A, $, timingAnalytics, carouselClasses, strategies, constants) {
  var undefined;

  /**
   *  The name of the DOM node's data attribute which contains the carousel
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var CAROUSEL_DATA_ATTRIBUTE = "a-carousel";

  /**
   *  The class name for the DOM node which contains a carousel and has the requisite data attributes
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var CAROUSEL_CONTAINER_CLASS = "a-carousel-container";

  /**
   *  The class name for a carousel which has been created and initialized
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var CAROUSEL_INITIALIZED_CLASS = "a-carousel-initialized";

  /**
   *  The class name for a carousel which needs to be created
   *
   *  @private
   *  @constant
   *  @type {String}
   */
  var CAROUSEL_STATIC_CLASS = "a-carousel-static";

  /**
   *  A list of all carousels which have been created and initialized
   *
   *  @private
   *  @type {Array}
   */
  var initializedCarousels = [];

  /**
   *  A list of all carousels which have been created but have not been initialized
   *
   *  @private
   *  @type {Array}
   */
  var uninitializedCarousels = [];

  /**
   *  Keep track of whether DOM ready has fired yet
   *
   *  @private
   *  @type {Boolean}
   */
  var pageInitialized = false;

  /**
   *  A map of carousel names to their corresponding carousel.
   *
   *  @private
   *  @type {Object}
   */
  var namedCarousels = {};

  /**
   *  Keep a reference to the document here for ease of use.
   *
   *  @private
   *  @type {Object}
   */
  var $document = $(document);

  /**
   *  People can register init handlers for named carousels in the same way that they can register handlers for DOM
   *  ready.  This is a name -> callback hash which should execute whenever a carousel with that name initializes
   */
  var initHandlers = {};

  /**
   *  Auto-incrementing unique ID applied to each carousel.
   *
   *  @private
   *  @type {Number}
   */
  var id = 0;


  /************************* BEGIN PRIVATE METHODS *************************/

  /**
   *  Create a new carousel for the given DOM node with the modules and parameters listed.
   *
   *  @private
   *  @param {HTMLElement} $carouselContainer - The DOM node for the carousel
   *  @param {Carousel} CarouselClass - The constructor function for the carousel class
   *  @param {Object} carouselStrategies - A hash of strategy name to actual strategy Object
   *  @param {Object} options - A hash of options to pass to the carousel
   */
  function createCarousel($carouselContainer, CarouselClass, carouselStrategies, options) {
    // Create the carousel object
    var carousel;
    carousel = new CarouselClass($carouselContainer, carouselStrategies, options);
    carousel.__id = ++id;

    $carouselContainer.data(CAROUSEL_DATA_ATTRIBUTE, carousel);
    $carouselContainer.removeClass(CAROUSEL_STATIC_CLASS);

    // List the carousel as needing initialization or just initialize it if it's ready
    if (carouselContainerReady($carouselContainer)) {
      A.delay(initializeCarousel, 10, carousel);
    } else {
      uninitializedCarousels.push(carousel);
    }

    if (options.name) {
      namedCarousels[options.name] = carousel;
    }

    return carousel;
  }

  /**
   *  Initialize an individual carousel
   *
   *  @private
   *  @param {Carousel} carousel
   */
  function initializeCarousel(carousel) {
    carousel.init();
    initializedCarousels.push(carousel);
    carousel.__initialized = true;
    carousel.dom.$container.addClass(CAROUSEL_INITIALIZED_CLASS);
    var name = carousel.getAttr("name");
    if (name && initHandlers[name]) {
      A.each(initHandlers[name], function (callback) {
        callback(carousel);
      });
    }
  }

  /**
   *  Given a strategy type and options hash, get the correct strategy off of the hash.
   *
   *  @private
   *  @param {String} type - The strategy type to fetch (display, transition, or ajax)
   *  @param {Object} options - The options hash placed on the carousel DOM node
   *
   *  @return {Object} strategy
   */
  function getStrategy(type, options) {
    var strategyName = options[type + "Strategy"];

    if (!strategyName) {
      strategyName = strategies[type]["default"];
    }

    return strategies[type][strategyName];
  }

  /**
   *  Search through an array of carousels, find any which have DOM nodes which aren't on
   *  the page any more, and remove them from the array.
   *
   *  @private
   *  @param {Array} arr - An array of carousel Objects
   */
  function findDeadCarousels(arr) {
    var i = arr.length;
    var carousel, name;
    while (i--) {
      carousel = arr[i];
      if (!(carousel.dom.$container.length && $document.find(carousel.dom.$container).length)) {
        name = carousel.getAttr("name");
        if (name) {
          delete namedCarousels[name];
        }
        arr.splice(i, 1);
      }
    }
  }

  /**
   *  Look for carousels whos DOM nodes have been removed from the page and delete the Objects.
   *
   *  @private
  ;
  }

  /**
   *  Pull all possible attributes for carousel creation off of a DOM node.  If required attributes
   *  are missing, then this will return undefined.
   *
   *  @private
   *  @param {HTMLElement} $dom
   *
   *  @return {undefined|Object} Either an Object containing all the attributes found or undefined if required attributes were missing
   */
  function getAttributesFromDom($dom) {
    var attrs = {};
    var options = $dom.data("a-carousel-options") || {};

    options.displayStrategy = $dom.data("a-display-strategy");
    options.transitionStrategy = $dom.data("a-transition-strategy");
    options.ajaxStrategy = $dom.data("a-ajax-strategy");
    options.accessibilityStrategy = $dom.data("a-accessibility-strategy");
    options.carouselClass = $dom.data("a-class");

    var displayStrategy = getStrategy("display", options);
    var transitionStrategy = getStrategy("transition", options);
    var ajaxStrategy = getStrategy("ajax", options);
    var accessibilityStrategy = getStrategy("accessibility", options);

    var className = options.carouselClass;
    if (!className) {
      className = carouselClasses["default"];
    }

    var CarouselClass = carouselClasses[className];

    if (CarouselClass === undefined || displayStrategy === undefined || transitionStrategy === undefined || ajaxStrategy === undefined || accessibilityStrategy === undefined) {
      return;
    }

    var carouselStrategies = {
      display: displayStrategy,
      transition: transitionStrategy,
      ajax: ajaxStrategy,
      accessibility: accessibilityStrategy
    };

    return {
      carouselClass: CarouselClass,
      strategies: carouselStrategies,
      opts: options
    };
  }

  /**
   *  Determine if carousel container is ready for initialization. To be ready, a Carousel must be on screen with all
   *  child nodes rendered from server.
   *
   *  @private
   *  @param {HTMLElement} $carouselContainer - The DOM node for the carousel (actually a jQuery object, but this param
   *  definition is consistent with carousel framework.)
   *
   *  @return {boolean} Whether carousel represented by container is ready to proceed with initialization.
   */
  function carouselContainerReady($carouselContainer) {
    var carouselSupportsBeginEndDetection = $carouselContainer.hasClass('a-begin');
    if (carouselSupportsBeginEndDetection && $carouselContainer.children('.a-end').length === 0) {
      return false;
    }
    return A.onScreen($carouselContainer);
  }

  /************************* END PRIVATE METHODS *************************/



  /************************* BEGIN PUBLIC INTERFACE *************************/

  /**
   *  Scan to DOM to find carousels which haven't been created yet, then create them if possible.
   *
   *  @public
   */
  function createAllCarousels() {
    var $carousels = $("." + CAROUSEL_STATIC_CLASS);

    $carousels.each(function () {
      var $this = $(this);
      var attrs = getAttributesFromDom($this);
      if (attrs) {
        createCarousel($this, attrs.carouselClass, attrs.strategies, attrs.opts);
      }
    });
  }

  /**
   *  Scan the list of uninitialized carousels and initialize them if they're almost visible on the screen
   *  Simultaneously remove them from the uninitialized carousels list so we don't iterate over them again.
   *
   *  @public
   */
  function initializeAllCarousels() {
    var i = uninitializedCarousels.length;
    // We are decrementing from the end of the list which allows us to modify the list while iterating over it.
    while (i--) {
      var carousel = uninitializedCarousels[i];
      if (carouselContainerReady(carousel.dom.$container)) {
        uninitializedCarousels.splice(i, 1);
        initializeCarousel(carousel);
      }
    }
  }

  /**
   *  Wires up Carousel to be able to handle new strategies and allow for custom functionality on Carousels.
   *  If the page is already initialized, Carousel.initializeAll will be called for you; you should never
   *  have to call that method yourself.
   *
   *  @public
   *  @param {String} type - The strategy type being registered (display, transition, etc)
   *  @param {String} name - The unique name of this strategy
   *  @param {Object} strategy - The actual strategy Object
   *
   */
  function registerStrategy(type, name, strategy) {
    if (!strategies[type]) {
      strategies.type = {};
    }

    if (strategies[type][name]) {
      P.error("Attempted to register a " + type + " strategy which already exists: " + name, "a-carousel-framework", "registerStrategy");
    }

    strategies[type][name] = strategy;

    if (pageInitialized) {
      createAllCarousels();
    }
  }

  /**
   * If the  default Carousel class can not meet your needs by simply changing a strategy, you can register
   *  a new class here.
   *
   *  @public
   *  @param {String} name - The carouselClassName which is passed into the carouselOptions parameter
   *  @param {Function} constructor - The constructor function used for the carousel
   */
  function registerCarouselClass(name, constructor) {
    if (carouselClasses[name]) {
      P.error("Attempted to register a carousel class which already exists: " + name, "a-carousel-framework", "registerCarouselClass");
    }

    if (!$.isFunction(constructor)) {
      P.error("Attempted to register carousel class " + name + " without a constructor function.", "a-carousel-framework", "registerCarouselClass");
    }

    carouselClasses[name] = constructor;

    if (pageInitialized) {
      createAllCarousels();
    }
  }

  /**
   * Convenience function. Returns the carousel Object from any DOM element inside the carousel.
   *
   *  @public
   *  @param {HTMLElement} $dom - Node representing an element inside the carousel, or the carousel node itself.
   *
   *  @return {Carousel} A Carousel Object or undefined
   */
  function getCarousel($dom) {
    if (!$dom.jquery) {
      $dom = $($dom);
    }
    var carousel = $dom.closest("." + CAROUSEL_CONTAINER_CLASS).data(CAROUSEL_DATA_ATTRIBUTE);
    if (!carousel) {
      var attrs = getAttributesFromDom($dom);
      if (attrs) {
        carousel = createCarousel($dom, attrs.carouselClass, attrs.strategies, attrs.opts);
      }
    }
    return carousel;
  }

  /**
   *  Convenience function.  Returns the carousel Object with the given Object or undefined.
   *
   *  @public
   *  @param {HTMLElement} $dom - Node representing an element inside the carousel, or the carousel node itself.
   *
   *  @return {Carousel|undefined} A Carousel object or undefined
   */
  function getCarouselByName(name) {
    return namedCarousels[name];
  }

  /**
   *  Get rid of all references to the carousel at the specific DOM node and get rid of the associated DOM elements
   *
   *  @public
   *  @param {HTMLElement} $dom - The DOM node representing the carousel container or one of its decentendents, optionally wrapped in a jQuery call
   */
  function killCarousel($dom) {
    if (!$dom.jquery) {
      $dom = $($dom);
    }

    if ($dom.length) {
      var $container = $dom.closest("." + CAROUSEL_CONTAINER_CLASS);
      if ($container.length) {
        var carousel = $container.data(CAROUSEL_DATA_ATTRIBUTE);
        if (carousel) {
          var i = A.indexOfArray(initializedCarousels, carousel);
          if (i > -1) {
            if (initializedCarousels[i].name) {
              delete namedCarousels[initializedCarousels[i].name];
            }
            initializedCarousels.splice(i, 1);
          } else {
            i = A.indexOfArray(uninitializedCarousels, carousel);
            if (i > -1) {
              if (uninitializedCarousels[i].name) {
                delete namedCarousels[uninitializedCarousels[i].name];
              }
              uninitializedCarousels.splice(i, 1);
            }
          }
        }
        $container.remove();
      }
    }
  }

  /**
   *  Return all the carousels that we know about
   *
   *  @public
   *
   *  @return {Array}
  ;
  }

  /**
   *  This allows people to register an onInit handler for carousels which behaves similarly to the
   *  DOM ready handler.  If initialziation hasn't happened yet, wait till it does.  If it has happened,
   *  then execute immediately.  Unlike DOM ready, since carousels can be reloaded via AJAX, we don't
   *  destructively iterate of the callback array, and we add to the array regardless.  This way, if the RHF
   *  carousel has one of these handlers and gets AJAX'd in on top of itself, the callback still fire.
   */
  function onInit(name, callback) {
    if (name) {
      if (!initHandlers[name]) {
        initHandlers[name] = [];
      }
      if ($.isFunction(callback)) {
        initHandlers[name].push(callback);
        var carousel = getCarouselByName(name);
        if (carousel && carousel.__initialized) {
          callback(carousel);
        }
      }
    }
  }

  /************************* END PUBLIC INTERFACE *************************/


  /******* Bind to the requisite DOM events for the framework to function *******/

  // Trigger resize events on each carousel when the window has the potential to resize
  A.on("resize orientationchange", function (viewport, changed) {
    removeDeadCarousels();
    if (changed.height || changed.width) {
      A.delay(function () {
        A.each(initializedCarousels, function (carousel) {
          carousel.resize();
        });
      }, A.capabilities.mobile || A.capabilities.tablet ? 100 : 0);
    }
  });

  // If the orientation changed while the secondary view was open, carousels could be in a very odd state, so
  // we need to call the resize handler to ensure that the carousel will be the correct size after the secondary view
  // is gone.
  A.on("a:popover:afterSlide;
  });

  // If a carousel's name changes, we'll want to keep track of that so that the
  // getCarouselsByName() API actually works.
  A.on("a:carousel:change:name", function (data) {
    if (data.newValue) {
      namedCarousels[data.newValue] = data.carousel;
    }
    if (data.oldValue) {
      delete namedCarousels[data.oldValue];
    }
  });

  // Create carousels on key DOM events
  A.on(constants.INIT_EV;
  });

  // Ensure dead carousels don't stay in memory when someone uses our pageUpdate API
  A.on("a:pageUpdate", removeDeadCarousels);

  // Check to see if carousels need to be initialized on certain DOM events
  A.on("scroll", function () {
    initializeAllCarousels();
    createAllCarousels(); // createAllCarousels initializes new carousels also
  });

  // When the user switches tabs, see if there's a carousel which needs to be initialized or resized
  A.declarative("a-tabs", "click", function (event) {
    A.delay(function() {
      initializeAllCarousels();
      A.each(initializedCarou    });
    }, 50);
  });

  // If there's a carousel inside of a popover, see if it needs to be initialized.
  A.on("a:popover:afterShow", function () {
    A.delay(initializeAllCarousels, 50);
  });

  // When the AJAX request for a popover completes, see if the new HTML has a carousel in it
  A.on("a:popover:ajaxContentLoa;
  });

  // Record when DOM ready has fired
  A.on.ready(function () {
    pageInitialized = true;
  });

  // Create the framework Object which will be returned and make immutable, if possible
  var carouselFramework = {
    getCarousel: getCarousel,
    getCarouselByName: getCarouselByName,
    createAll: function () {
      // If the user has replaced a carousel via AJAX (RHF does this), we'll need to check for dead
      // carousels before creating new ones.
      removeDeadCarousels();
      createAllCarousels();
    },
    initializ    },
    kill: killCarousel,
    registerStrategy: registerStrategy,
    registerCarouselClass: registerCarouselClass,
    getAllCarousels: getAll,
    onInit: onInit
  };

  if (Object.freeze !== undefined) {
    Object.freeze(carouselFramework);
  }

  return carouselFramework;
});
/////////////////////////
// END FILE js/carousel_framework.js
/////////////////////////

// END ASSET AmazonUICarousel-3.1.1491.91
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIComponents", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIComponents-3.1.1512.92
/////////////////////////
// BEGIN FILE js/controls_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Form Controls Handlers
 */

'use strict';

P.when('A', 'a-form-controls-api').register('a-form-controls-handlers', function (A, controlsAPI) {
    var $ = A.$,
        BOX_INPUT_FOCUS_CLASS = 'a-form-focus',
        HOVER_DISABLE_CLASS = 'a-hover-disable',
        RESET_EVENT = 'reset.a-form-controls-reset';

    /**
     * (mobile only)
     * When "box input" (aka multi-select, input and textarea) gets focused,
     * we set focus class on ALL "AUI wrapping ancestors" (see TOUCH_SELECT_INPUT
     * in controls_touch.js). It's possible one "box input" has multiple
     * "AUI wrapping ancestors", for example, in the "input group" use case :
     *    input_group > n * ( input_group_row > text_input ).
     * The redundant nested style will be removed by default.
     *
     * @public
     */
    var handleBoxInputMobileFocus = function() {
        $(this).addClass(BOX_INPUT_FOCUS_CLASS);
    };

    /**
     * Same as handleBoxInputMobileFocus, except this is a class remover.
     *
     * @public
     */
    var handleBoxInputMobileBlur = function() {
        $(this).removeClass(BOX_INPUT_FOCUS_CLASS);
    };

    /**
     *  Removes the hover disable class used to override the hover state on checkboxes after they have been clicked
     *
     *  @private
     */
    var _hoverDisableHandler = function() {
        /*jshint validthis:true */
        $(this).removeClass(HOVER_DISABLE_CLASS);
    };

    /**
     *  When you uncheck a checkbox, the hover state becomes active, which may make it appear that the checkbox is still checked
     *  on low contrast displays. This handler will suppress the hover effect until the cursor leaves the label.
     *
     *  @public
     */
    var handleCheckboxClick = function() {
        /*jshint validthis:true */
        if (!A.capabilities.mobile && !A.capabilities.tablet) {
            $(this)
                .addClass(HOVER_DISABLE_CLASS)
                .one('mouseleave', _hoverDisableHandler);
        }
    };

    /**
     *  Some browsers need this canceling behavior in order to keep the page from moving when the space bar is pressed
     *
     *  @param {object} event - The event corresponding to the keypress
     */
    var accessibilityKeyPress = function(event) {
        if (event.keyCode === A.constants.keycodes.SPACE) {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    /**
     *  Browsers handle form resetting in various ways. Unfortunately, the reset button simply blanks out the checked attr
     *  on form elements without necessarily dispatching change events we could potentially listen to (Chrome is a culprit).
     *
     *  We capture the reset event on any given form tag and then re-normalize the visual icons for all elements that we
     *  care about in that form.
     *
     *  @param {object} form - The DOM element of the form
     *  @param {string} selector - The selectors for our image-enhanced elements (changes based on device type)
     */
    var formRe    };

    /* The reset event does not bubble up to the document in Safari: https://jsbin.amazon.com:443/tuqakusax/1/
     * Therefore we cannot listen for this event delegated off of the document... :(
     *
     * Remove existing bindings first on pageUpdate then add new bindings to catch new additions to the page
     * and don't keep track of specific elements in case they've been removed somewhere in between as it is
     * beyond our scope to track the various ways elements may be removed from the DOM.
     */
    var normalizeFormControls = function() {
        $('form')
            .unbind(RESET_EVENT)
            .bind(RESET_E    });
    };

    /**
     *  Update the UI for the touch multi select component when it is clicked
     *
     *  @private
     *  @param {object} event The event which triggered the change
     */
    var touchMultiSelectHandler = function(event) {
        controlsAPI.toggleCheckboxState(event.currentTarget);
    };

    return {
        handleBoxInputMobileFocus: handleBoxInputMobileFocus,
        handleBoxInputMobileBlur: handleBoxInputMobileBlur,
        accessibilityKeyPress: accessibilityKeyPress,
        formReset: formReset,
        handleCheckboxClick: handleCheckboxClick,
        normalizeFormControls: normalizeFormControls,
        touchMultiSelectHandler: touchMultiSelectHandler
    };
});
/////////////////////////
// END FILE js/controls_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/controls.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Form Controls
 */

'use strict';

P.when('A', 'a-form-controls-handlers', 'ready').register('a-form-controls', function (A, controlsHandlers) {
    var $ = A.$,
        CHECKS = '.a-checkbox-fancy';

    $(document)
        .delegate(CHECKS, 'click', controlsHandlers.handleCheckboxClick)
        .delegate(CHECKS + ', .a-radio-fancy', 'keypress', controlsHandlers.accessibilityKeyPress);

    /*
    On DOM ready, we want to double check to make sure that the state of the UI matches the state of the underlying form
    controls. The browser may autocomplete or change the value provided by the server to match what the user had on the
    previous page view.
    */
    A.on('a:pageUpdate beforeReady', controlsHandlers.normalizeFormControls);
});
/////////////////////////
// END FILE js/controls.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/buttons.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Toggle Button JS
 */

"use strict";

/**
 *  Set up default behavior for toggle button groups.
 */
P.when("A").register("a-buttons", function (A) {

  /**
   * Button groups have default functionality wherein clicking one button in a group
   * gives it the selected state and removes the selected state from other buttons.
   *
   * trigger "a:button-group:[button-group-name]:toggle"
   * trigger "a:button-group:[button-group-name]:[button-name]:toggle"
   */

  var $ = A.$;
  var idCount = 0;

  function handleToggleButtons(event) {

    // Make sure we clicked on a button
    var $button = event.$target.closest(".a-button:not(.a-button-disabled)");
    if ($button.length) {
      var $buttons = event.$declarativeParent.find(".a-button");
      var buttonGroupName = event.data && event.data.name ? event.data.name : false;
      // html button type could be button/submit/reset
      // button could wrap around span, etc.. therefore $target could be a span
      // using closest() api to look for the exact button name.
      // {@see https://sim.amazon.com/issues/AUI-12009}
      var buttonName = event.$target.closest('input[type=submit], button').attr("name");

      $buttons.removeClass("a-button-selected").attr("aria-checked", "false");
      $button.addClass("a-button-selected").attr("aria-checked", "true");

      // Broadcast events if we can
      if (!(buttonName || buttonGroupName)) {
        return;
      }

      var button = {
        $button: $button,
        buttonName: buttonName,
        buttonGroupName: buttonGroupName
      };

      if (buttonGroupName) {
        A.trigger("a:button-group:" + buttonGroupName + ":toggle", {
          selectedButton: button
        });

        if (buttonName) {
          A.trigger("a:button-group:" + buttonGroupName + ":" + buttonName + ":toggle", {
            selectedButton: button
          });
        }
      }
    }
  }

  // Bind the declarative event
  A.declarative("a-button-group", ["click"], handleToggleButtons);

  //This is being done just for accesibility reasons, we want the screen reader to
  //read the text in the innermost span and this mapping can only be done with ad ID
  //this is taken care of in MarkupTemplates if ID is provided, if not we need to
  //assign a manual ID.
  A.on("a:pageUpdate beforeReady", function () {
    var $buttons = $(".a-button:not([id])");
    var $toggles = $(".a-button-group,.a-button-toggle-group");

    // Add auto IDs to buttons that does not have a default ID
    $buttons.each(function () {
      var $button = $(this);
      var $buttonText = $button.find(".a-button-text");
      var $buttonInput = $button.find(".a-button-input"); // It is okay for $buttonInput to be []
      var id = "a-autoid-" + idCount++;
      var innerId;
      var originalId;

      // Add ID to buttons anyways to avoid re-accessing later
      $button.attr("id", id);

      // Only add aria labels if the text anchor DOM exists
      if ($buttonText.length) {
        originalId = $buttonText.attr('id');
        innerId = originalId ? originalId : id + "-announce";
        $buttonInput.attr("aria-labelledby", innerId);
        $buttonText.attr("id", innerId);
      }
    });

    // Add aria-posinset and aria-setsize to toggle buttons in toggle button group for better screen reader accessibility
    $toggles.each(function () {
      var $toggle = $(this);
      var $toggleButtons = $toggle.find(".a-button[role='radio']");
      var buttonCount = $toggleButtons.length;
      var count = 1;
      $toggleButtons    });
    })
  });

  // When the focusable element of a button gets focus, it usually doesn't affect the visual style of the button.
  // Add a class to the outer node to ensure that it looks legit.
  // Internet Explorer doesn't dispatch focusout when a scroll takes over. Listen for cancel as well.
  $(document).delegate(".a-button-input, .a-button-text", "focusin", function () {
    var $button = $(this).closest(".a-button");
    if (!$button.hasClass("a-button-disabled")) {
      $button.addClass("a-button-focus");
    }
  }).delegate(".a-button-input, .a-button-text", "focusout " + A.action.ca;
  });
});
/////////////////////////
// END FILE js/buttons.js
/////////////////////////

// END ASSET AmazonUIComponents-3.1.1512.92
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUITabs", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUITabs-3.1.1290.91
/////////////////////////
// BEGIN FILE js/tabs.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//AmazonUI Tabs

'use strict';

P.when('A').register('a-tabs', function(A){
  var $ = A.$;

  function handleTabSelection(event){
    var $tab = event.$target.closest('li'),
        tabSetName = event.data.name,
        tabName = $tab.data('a-tab-name'),
        $tabContents = $tab.closest('.a-tab-container').find('.a-box-tab');

    if (!tabName){
      return;
    }

    //Toggle active state
    $('li.a-active', $tab.closest('.a-tabs')).removeClass('a-active');
    $tab.closest('li').addClass('a-active');

    $tabContents.addClass('a-hidden');
    $tabContents.filter('[data-a-name="' + tabName + '"]').removeClass('a-hidden');

    //Broadcast events
    var tab = {
      $tab : $tab,
      tabName : tabName,
      tabSetName : tabSetName
    }

    A.trigger('a:tabs:' + tabSetName + ':select', {
      selectedTab : tab
    });

    A.trigger('a:tabs:' + tabSetName + ':' + tabName + ':select', {
      selectedTab : tab
    });

    event.$event.preventDefault();
  }

  A.declarative('a-tabs', ['click'], handleTabSelection);
});
/////////////////////////
// END FILE js/tabs.js
/////////////////////////
// END ASSET AmazonUITabs-3.1.1290.91
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIAccordion", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIAccordion-3.1.1304.91
/////////////////////////
// BEGIN FILE js/accordion.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Accordion Event Handler
 */

'use strict';

P.when('A').register('a-accordion-a11y', function(A) {
  var $ = A.$;
  var $focusHolder;

  // Some screen readers won't announce aria changes on the focused element.
  // A explicit re-focusing could fix it. We need this for JAWS with IE.
  function refreshFocus($target, delay) {
    delay = delay || 600; // milli seconds

    // Create a persistent focusHolder (if none exists) so that we
    // can momentarily move focus in and out of this element.
    if (!$focusHolder) {
      $focusHolder = $('<b />', {
        "class": "a-accordion-a11y",
        tabIndex: -1,
        style: 'position: absolute'
      }).appendTo('body');
    }

    // Focus in on the focusHolder. We will only display the focusHolder
    // when momentarily needed, otherwise it will be display: none.
    // We need it close to target so that window scroll position doesn't jump.
    $focusHolder
      .css({display: 'block'})
      .offset($target.offset());
    A.delay(function() {
      $focusHolder.focus();
    }, 50);


    // Focus out of the focusHolder after short delay (JAWS will now read aria)
    A.    }, delay);
  }
  return {
    refreshFocus: refreshFocus
  };
});

/**
 *  Bind event handlers which allows the accordion to function.
 */

P.when('A', 'a-accordion-a11y').register('a-accordion', function (A, a11y) {
  /**
   *  The name of the function we're using the show accordion content.
   *
   *  @private
   *  @type {string}
   */
  var showFunction = "slideDown";

  /**
   *  The name of the function we're using the hide accordion content.
   *
   *  @private
   *  @type {string}
   */
  var hideFunction = "slideUp";

  /**
   *  The amount of time the accordion show/hide animation should take.
   *
   *  @private
   *  @type {number}
   */
  var duration = 300;

  if (A.capabilities.mobile || A.capabilities.tablet) {
    showFunction = "show";
    hideFunction = "hide";
    duration = 0;
  }

  /**
   *  String constants to aid in minification.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var ACTIVE_ROW_CLASS = "a-accordion-active";
  var ICON_SELECTOR = ".a-icon.a-accordion-radio";

  var shouldRefreshFocus = !A.capabilities.touch && A.capabilities.isFirefox;

  /**
   * Event handler for accordions which will show/hide the relevant divs,
   * update icons, and update ARIA attributes.
   *
   * @private
   * @param {object} event
   *
   * triggers a:accordion:select
   * triggers a:accordion:<accordionName>:select
   * triggers a:accordion:<accordionName>:<rowName>:select
   */

  function handleAccordionSelection(event) {
    var $container = event.$target.closest(".a-accordion");
    var $row = event.$target.closest('.a-box');
    var $otherRows = $container.find('.a-box').not($row);
    var $trigger = $row.find('.a-accordion-row');
    var accordionName = $container.data('a-accordion-name');
    var rowName = $row.data('a-accordion-row-name');
    var collapseAll = $container.hasClass("a-accordion-collapse");

    var $rowA11y = event.$target.closest('.a-accordion-row-a11y');
    var $otherRowsA11y = $container.find('.a-accordion-row-a11y').not($rowA11y);

    if (rowName) {
      // Toggle if needed
      var $inner = $row.find('.a-accordion-inner');
      var hasToggled = true;
      if (!$row.hasClass(ACTIVE_ROW_CLASS)) {
        // Toggle active state
        $otherRows.find(".a-accordion-inner")[hideFunction]({
          duration: duration,
          complete: function () {
            $otherRows.removeClass(ACTIVE_ROW_CLASS);
          }
        });
        $inner[showFunction]({
          duration: duration,
          complete: function () {
            // Toggle radio button
            $row.addClass(ACTIVE_ROW_CLASS);
            $otherRows.find(ICON_SELECTOR).removeClass('a-icon-radio-active').addClass('a-icon-radio-inactive');
            $row.find(ICON_SELECTOR).removeClass('a-icon-radio-inactive').addClass('a-icon-radio-active');
          }
        });

        // accessibility
        $otherRowsA11y.attr('aria-checked', 'false').attr("aria-expanded", "false");
        $rowA11y.attr('aria-checked', 'true').attr("aria-expanded", "true");

      } else if (collapseAll) {
        $inner[hideFunction]({
          duration: duration,
          complete: function () {
            $row.removeClass("a-accordion-active");
            $row.find(ICON_SELECTOR).removeClass('a-icon-radio-active').addClass('a-icon-radio-inactive');

            // accessibility
            $rowA11y.attr('aria-checked', 'false').attr("aria-expanded", "false");
          }
        });
      } else {
        hasToggled = false;
      }

      if (hasToggled && shouldRefreshFocus) {
        a11y.refreshFocus($trigger); // $trigger is focusable; $row is not
      }

      // Only broadcast events if something happened.
      if (hasToggled) {
        var accordionRow = {
          $row: $row,
          rowName: rowName,
          accordionName: accordionName
        };

        A.trigger("a:accordion:select", {
          selectedRow: accordionRow
        });

        A.trigger('a:accordion:' + accordionName + ':select', {
          selectedRow: accordionRow
        });

        A.trigger('a:accordion:' + accordionName + ':' + rowName + ':select', {
          selectedRow: accordionRow
        });
      }
    }

    event.$event.preventDefault();
  }

  A.declarative('a-accordion', ['click'], handleAccordionSelection);
});

/* Importing js/accordion_accessibility.js */
/**
 *  AmazonUI Accordion Accessibility
 */
/* Done importing js/accordion_accessibility.js */

/////////////////////////
// END FILE js/accordion.js
/////////////////////////
// END ASSET AmazonUIAccordion-3.1.1304.91
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIExpander", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIExpander-3.1.1287.91
/////////////////////////
// BEGIN FILE js/expander.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  AmazonUI Expander
 */

"use strict";

/**
 *  JS for the toggle expander component.
 */
P.when("A", "jQuery").register("a-expander", function (A, $) {
  var undefined;

  /**
   *  Class names for the various states/types of icons.
   *
   *  @private
   *  @type {object}
   *  @constant
   */
  var classNames = {
    inline: {
      expand: "a-icon-expand",
      collapse: "a-icon-collapse"
    },
    section: {
      expand: "a-icon-section-expand",
      collapse: "a-icon-section-collapse"
    },
    extender: {
      expand: "a-icon-extender-expand",
      collapse: "a-icon-extender-collapse"
    }
  };

  var elementClasses = {
    container: "a-expander-container",
    content: "a-expander-content",
    header: "a-expander-header",
    fadeDiv: "a-expander-content-fade"
  }

  /**
   *  Regular expressions used in the removal of classes from icons.  Generated from classNames.
   *
   *  @private
   *  @type {object}
   *  @constant
   */
  var classRegex = {};
  A.each(classN;
  });

  /**
   *  A toggle function that supports a fixed collapsed height as well as
   *  showing/hiding the expander content.
   *
   *  @private
   *  @param {jQuery element} $element
   *  @param {function} callback
   */
  function expanderToggle($element, callback) {
    var $expanderContainer = $element.closest('.' + elementClasses.container);
    var collapsedHeight = $expanderContainer.data('a-expander-collapsed-height');
    var isExpanded = $element.attr("aria-expanded") === "true";

    //Toggle aria attributes / classes
    $element.toggleClass(elementClasses.content + '-expanded');

    //Support a fixed collapsed height
    if (collapsedHeight) {
      $expanderContainer.css('height', isExpanded ? collapsedHeight : 'auto');
      $element.attr("aria-expanded", isExpanded ? "false" : "true");
      callback();
    } else {
      $element.togg    });
    }
  }

  /**
   *  Show/hide toggle expander content and update the icon and text for the header
   *
   *  @param {object} event
   */
  function toggleExpanderContent(event) {
    var $container = event.$target.closest('.' + elementClasses.container);
    var $subContainers = $container.find('.' + elementClasses.container);
    var expanderName = $container.data('a-expander-name');
    var $header;
    if (event.$currentTarget.hasClass(elementClasses.header)) {
      $header = event.$currentTarget;
    } else {
      $header = $container.find('.' + elementClasses.header).not($subContainers.find('.' + elementClasses.header));
    }
    var $content = $container.find('.' + elementClasses.content).not($subContainers.find('.' + elementClasses.content));

    // Show/hide content
    expanderToggle($content, function () {
      var icon = $header.find(".a-icon")[0],
        prompt = null,
        $fadeDiv = $header.children('.' + elementClasses.fadeDiv),
        expanderAction;

      if ($content.attr("aria-expanded") === "false") { // Switch to the content hidden class names ('expand')
        if (icon) {
          icon.className = icon.className.replace(classRegex.inline.collapse, classNames.inline.expand)
            .replace(classRegex.section.collapse, classNames.section.expand)
            .replace(classRegex.extender.collapse, classNames.extender.expand);
        }
        if (event.data && event.data["expand_prompt"]) {
          prompt = event.data["expand_prompt"];
        }

        $fadeDiv.show();

        expanderAction = "collapse";
      } else { // Switch to the content visible class names ('collapse')
        if (icon) {
          icon.className = icon.className.replace(classRegex.inline.expand, classNames.inline.collapse)
            .replace(classRegex.section.expand, classNames.section.collapse)
            .replace(classRegex.extender.expand, classNames.extender.collapse);
        }
        if (event.data && event.data["collapse_prompt"]) {
          prompt = event.data["collapse_prompt"];
        }

        $fadeDiv.hide();


        expanderAction = "expand";
      }

      // Swap out text, if required
      if (prompt && prompt !== "") {
        $header.find(".a-expander-prompt").not($subContainers.find(".a-expander-prompt")).html(prompt);
      }

      // Publish events
      var expander = {
        $expander: $container,
        expanderName: expanderName
      };

      A.trigger('a:expander:toggle', {
        expander: expander
      });

      A.trigger('a:expander:toggle:' + expanderAction, {
        expander: expander
      });

      if (expanderName) {
        A.trigger('a:expander:' + expanderName + ':toggle', {
          expander: expander
        });
        A.trigger('a:expander:' + expanderName + ':toggle:' + expanderAction, {
          expander: expander
        });
      }
    });
  }



  // Bind to the correct events
  A.declarative("a-expander-toggle", "click", toggleExpanderContent);

  // If the height of the content is too short, hide the expander.
  function initializeExpanders() {
    $('.a-expander-partial-collapse-container').each(function () {
      // Check to see if our expander should be fully gone when gone or only partially
      var $container = $(this);
      var $content = $container.children('.' + elementClasses.content);
      var collapsedHeight = $container.data('a-expander-collapsed-height');
      var $expanderHeader = $container.children('.' + elementClasses.header);

      if ($content.height() <= collapsedHeight) {
        $expanderHeader.css({
          'opacity': '0',
          'display': 'none'
        });
      } else {
        $expanderHeader.css({
          'opacity': '1',
          'display': 'block'
        });
        // Make enough space at the bottom of the content div to show the heading. Note
        // that this is done using JS to allow for different heights of headers.
        $content.css('padding-bottom', $expanderHeader.height());

        // If the expander isn't expanded, remove the max-height that we set on it before
        // and add a height property, so that when we toggle it we only have to deal with
        // height and not max-height (which doesn't work in old IE).
        if ($content.attr("aria-expanded") !== "true") {
          $container.css({
            "height": collapsedHeight,
            "max-height": "none"
          });
        }
      }
    });
  }

  // Make sure we initialze at all the right times, over and over again.
  A.on("load ready resize orientationchange a:popover:afterShow a:popover:ajaxContentLoaded", initializeExpanders);

  // Make "initializeExpanders" a public API so that people can call it manually if they
  // ajax in an expander
  return {
    initializeExpanders: initializeExpanders
  };
});
/////////////////////////
// END FILE js/expander.js
/////////////////////////
// END ASSET AmazonUIExpander-3.1.1287.91
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUISwitch", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUISwitch-3.1.1309.92
/////////////////////////
// BEGIN FILE js/switch.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* AUI Switch Component API
  Author: @tuanvo & @jordanw

  API for switch Component. This component depends on "a-switch-framework" for
  certain functions affecting the -switch-, in addition to some constant values defined in
  "a-switch-framework". "a-switch-framework" handles the interaction logic aswell.

  Functions defined here are accesible from client code.
*/

  "use strict";

P.when("a-switch-framework", "jQuery").register("a-switch", function(switchFramework, $) {

  // Globals Defined in "a-switch-framework"
  var SWITCH_STATE = switchFramework.SWITCH_STATE;
  var SWITCH_CONTAINER_CLASS = switchFramework.SWITCH_CONTAINER_CLASS;
  var SWITCH_CLASS = switchFramework.SWITCH_CLASS;

  /**
   * Allows client to retrieve a -switch- object, with API functions to interact with
   * a particular switch. Namely, this object references $switch associated with the $dom
   * parameter. The $switch's switchState data attribute will be initialized if an API call occurs,
   * and that -switch- has not been initialized yet.
   *
   * @param $dom Must not be null
   *   Note: if $dom is an jQuery array, only the first element will be processed and checked for $switch
   * @returns switchComponent [object]
   *   has API functions affecting a $switch associated with $dom
   *   null returned for invalid $dom as described in @param, or if $dom is empty
   */
  function getSwitch($dom) {

    /******** Begin "Constructor" ********/

    // cast to jQuery
    if (!$dom.jquery) {
      $dom = $($dom);
    }

    // empty object
    if ($dom.length === 0) {
      return null;
    }

    // Only retrieves switch for first element, where $dom is a jQuery array
    $dom = $dom.eq(0);

    var $switchContainer = $dom.closest("." + SWITCH_CONTAINER_CLASS);

    // no matched elements
    if ($switchContainer.length === 0) {
      return null;
    }

    // $switch which API functions reference
    var $switch = $switchContainer.find("." + SWITCH_CLASS);
    switchFramework.ensureInitialized($switch);

    /******** API Functions ********/

    /**
     * Mutator
     * toggles the -switch- if possible
     *
     * @returns success [boolean]
     *   true if -switch- was successfully toggled
     *   false otherwise (dragging / disabled)
     */
    function toggle() {
      return isOn(!$switch.data(SWITCH_STATE).isOn);
    }

    /**
     * getter: isOn()
     *   @returns isOn [boolean]
     *     current -on/off- state of the -switch-
     *
     * setter: isOn(isOn)
     *   @param isOn [boolean]
     *     -on/off- state to set -switch- to
     *   @returns success [boolean]
     *     true if -switch- was successfully switched ON
     *     false otherwise (dragging / disabled)
     */
    function isOn(isOn) {
      var switchState = $switch.data(SWITCH_STATE);

      /* Getter */
      if (isOn === undefined) {
        return switchState.isOn
      }

      /* Setter */

      // cannot set state
      if (!switchState.isEnabled || isDragging($switch)) {
        return false;
      }

      switchFramework.setOnState($switch, isOn);

      return true;
    }

    /**
     * getter: enabled()
     *   @returns isEnabled [boolean]
     *     current -enabled- state of the -switch-
     *
     * setter: enabled(isEnabled)
     *   @param isEnabled [boolean]
     *     -enabled- state to set -switch- to
     *   @returns changedState [boolean]
     *     true if the -enabled- state different from the original
     *     false if the switch is already in the desired -enabled-
     */
    function enabled(isEnabled) {
      var switchState = $switch.data(SWITCH_STATE);

      /* Getter */
      if (isEnabled === undefined) {
        return switchState.isEnabled;
      }

      /* Setter */

      // Check if the desired -enabled- state is same as prior -enabled- state
      if (switchState.isEnabled === isEnabled) {
        return false;
      }

      // State is different
      switchFramework.setEnabled($switch, isEnabled);

      return true;
    }

    /**
     * getter: label()
     *   @return label [string]
     *     -label- associated with the -switch-
     *
     *
     * setter: label(value)
     *   sets -label- of -switch- to the desired text
     *
     *   @param label [string]
     *     desired label text
     */
    function label(value) {
      var $label =  $switch.data(SWITCH_STATE).label,
        textNode = $label[0].childNodes[0];

      /* Getter */
      if(value === undefined) {
        return $label.text();
      }

      // If it's not a text node, short circuit
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
      if(textNode.nodeType !== 3) {
        return;
      }

      /* Setter */
      textNode.textContent = value;
    }

    /**
     * Getter
     *    @returns isDragging [boolean]
     *      whether or not the -switch- is currently being dragged
     *    }

    // API Functions Targetting referencing this $switch
    return {
      toggle: toggle,
      isOn: isOn,
      enabled: enabled,
      isDragging: isDragging,
      label: label
    }
  }

  // Public function to retrieve -switch- object
  return {
    getSwitch: getSwitch
  };

});
/////////////////////////
// END FILE js/switch.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/switch_framework.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* AUI Switch Component Framework
  Author: @tuanvo & @jordanw

  This switch component is the UI equivalent of a light switch in the "real world".
  It has two states on/off. The user can click the switch to toggle on/off, in addition
  to be able to drag the switch and it will snap to the closest edge.

  This component handlers user interaction, and the switch implementation.
  The switch API, depends on this and is in a seperate module "a-switch". Clients shouldn't need to
  access functions from this component.

  The switch has an -enabled- state, which is not to be confused with -on/off-. This locks the switch from being turned -on/off-
  or dragged, both by the API and user interaction. Still, the -enabled- state can be toggled via the API. Currently,
  the -enabled- state couples both user interaction and API interaction together. It's possible that
  we want to lock the user, but not client code via the API, which will necessitate two seperate locks; this is a possible
  feature to add.

  ***** For Implementors *****
  User Interaction Handlers
    initSwitch()
    dragSwitch()
    clearSwitch()

  Mobile/Desktop Interface
    These abstract out desktop/mobile implementation.
    The code calls these functions agnostically, where the appropriate implementation
    will already be associated to these interfaces.

      bindInteraction()
      unbindInteraction()
      getCurrentX()

    This is not to say all implementation details about desktop/mobile are abstracted in the entirety of the code.
    There are parts with remnants that check for certain mobile/desktop values, and are not part of these
    functions, e.g. initially binding initSwitch based on mobile or desktop.

    Events Namespaced
      Events are namespaced (defined by the var SWITCH_EVENT_NAMESPACE), such that we won't interfere with client code.
      Still, the client code can interfere with us... they have great power, so they also have the great responsibility
      of namespacing their events aswell.

    Convention of Comments
      I write "-thing-" in the comments to talk about the thing in the abstract,
      not a particular object or variable. E.g. -switch state-.

  ****** Frequently Used Variable Names *****
  $switch [jQuery] (see Dom Structure)
  $container [jQuery] (see Dom Structure)
  $control [jQuery] (see Dom Structure)
  switchState [object] data attribute of $switch

  Look inside initializeSwitchData() for info on variables inside switchState

  ****** Assumptions *****
  ON/OFF --> Left/Right
    Currently, ON/OFF are coupled with ON being the right side of the switch, and OFF being the left side of the switch.
    This is an assumption pervasive in the code. While it's possible to define left/right as a function of ON/OFF, and
    have the code access this mapping, we still don't want client code to set this themselves. We want AUI to be consistent across
    devices/pages, and it would be confusing to end users if the switch had inconsistent convention.
    What if a nation was inconsistent in whether cars should drive on the left or right side of the road?
  -switch state- Data attribute not encapsulated
    State data of each -switch- element stored in a data attribute, under the key: (var SWITCH_STATE). This is part of the dom,
    and client code access if they wanted to. Ofcourse, they'd have to try to do it on purpose.
  Dom structure
    The code has an assumed dom structure. Meaning, client doesn't alter this.
    Dom traversal in the code reflects this given structure:

      <div class="a-switch-row"> <!-- container -->
        <span class="a-switch-label">Default Label</span> <!-- Label -->
        <input type="checkbox"> <!-- checkbox -->
        <div class="a-switch a-declarative" data-action="a-switch"> <!-- switch -->
          <a class="a-switch-control" style="-webkit-transform: translateX(-1px) translateZ(0px);"></a> <!-- switch control -->
        </div>
      </div>

  ON/OFF
    class "a-active" applied to the -container- for on, class is absent for off (default).
    This is applied on -container- not the -switch-, because we want to stylize the -label- aswell.
  Enabled/Disabled
    class "a-disabled" applied to the -container- for -disabled-, class is absent for -enabled- (default)
    This is applied on -container- not the -switch-, because we want to stylize the -label- aswell.
  Left vs right offset
    Chosen to be left, for CSS3 Translate. The css left property applied if no css3 translate, otherwise
    translateX() used.
*/

"use strict";

P.when("A", "jQuery").register("a-switch-framework", function (A, $) {

  var undefined;

  /**
   *  If the user clicks on the switch or the state is changed via an API, this is the duration
   *  of the animation.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var ANIMATION_TIME = 300;

  /**
   *  If the user clicks on the switch or the state is changed via an API, this is the easing function
   *  of the animation.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var ANIMATION_EASING = "ease-out";

  /**
   *  Various strings who are used repeatedly.  They've been made constants in order to improve
   *  the compression of this file and to prevent us from misspelling these things...
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var SWITCH_EVENT_NAMESPACE = "a-switch-component";
  var SWITCH_CONTROL_CLASS = "a-switch-control";
  var SWITCH_LABEL_CLASS = "a-switch-label";

  /**
   *  The name of the data attribute which contains the state of a swtich for a particular DOM node
   *
   *  @public
   *  @constant
   *  @type {string}
   */
  var SWITCH_STATE = "a-switch-state";

  /**
   *  The class name for <div> which contains the "fancy" UI portion of the switch.  This includes the
   *  moving block and the color changing background.  It also defines the draggable area of the switch
   *  block.
   *
   *  @public
   *  @constant
   *  @type {string}
   */
  var SWITCH_CLASS = "a-switch";

  /**
   *  The class name for the <div> which contains ALL components of a switch, including the label and
   *  checkbox.
   *
   *  @public
   *  @constant
   *  @type {string}
   */
  var SWITCH_CONTAINER_CLASS = "a-switch-row";

  /********************************** EVENT HANDLERS **********************************/

  // Event Handlers for User Interaction
  var handlers = {
    mobile: {
      bind: function ($switch) {
        $switch.bind("touchmove." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, dragSwitch);
        $switch.bind("touchend." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, clearSwitch);
        $switch.bind("touchcancel." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, clearSwitch);

        // Some mobile browsers occasionally fire mouseup
        $switch.bind("mouseup." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, clearSwitch);
      },
      unbind: function ($switch) {
        $switch.unbind("touchmove." + SWITCH_EVENT_NAMESPACE);
        $switch.unbind("touchend." + SWITCH_EVENT_NAMESPACE);
        $switch.unbind("touchcancel." + SWITCH_EVENT_NAMESPACE);
        $switch.unbind("mouseup." + SWITCH_EVENT_NAMESPACE);
      },
      getX: function ($event) {
        var touch = $event.originalEvent.touches[0] || $event.originalEvent.changedTouches[0];
        return touch.pageX;
      }
    },
    desktop: {
      bind: function ($switch) {
        // bind to body because we want interaction to continue even when
        //   we move mouse out of switch,
        $("body").bind("mousemove." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, dragSwitch);
        $("body").bind("mouseup." + SWITCH_EVENT_NAMESPACE, {
          $switch: $switch
        }, clearSwitch);
      },
      unbind: function ($switch) {
        $("body").unbind("mousemove." + SWITCH_EVENT_NAMESPACE, dragSwitch);
        $("body").unbind("mouseup." + SWITCH_EVENT_NAMESPACE, clearSwitch);
      },
      getX: function ($event) {
        return $event.pageX;
      }
    }
  };

  /**
   *  User Interaction Handler
   *    Initialize -switch- for dragging/toggling
   *
   *  @private
   *  @param {jQuery.event} $event
   */
  function initSwitch(event) {
    var $event = event.$event; // jQuery event obj, as opposed to AUI declarative event obj
    $event.preventDefault();

    // mouse/desktop interaction, but not left mousedown
    if (!A.capabilities.touch && $event.which !== 1) {
      return;
    }

    var $switch = event.$declarativeParent;

    // (re)initialize switchState
    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);
    switchState.dragCount = 0;
    switchState.clicked = true;  // TODO: remove after 3.15.6 - for backward compatibility

    // redundant with statement in clearSwitch, but Chrome on Android is dumb and doesn't fire end events
    switchState.isDragging = false;

    // Interaction allowed only for -enabled switches-
    if (switchState.isEnabled) {
      switchState.initialX = getCurrentX($event);

      bindInteraction($switch);
    }
  }

  /**
   *  User Interaction Handler
   *    moves -switch control- with user dragging
   *
   *  @private
   *  @param {jQuery.event} $event
   */
  function dragSwitch($event) {
    /* Some browser/os combinations allow dragging/dropping of browser content into OS inteface*/
    $event.preventDefault();

    var $switch = $event.data.$switch;
    var switchState = $switch.data(SWITCH_STATE);
    var $control = switchState.control;

    // -switch- could be moving to an edge, with nonzero (see global var ANIMATION_TIME) animation time
    if (A.isAnimated($control)) {
      return;
    }

    // compute updated leftOffset
    var currentX = getCurrentX($event);
    var leftOffset = computeLeftOffset(currentX, switchState);

    // position hasn't changed
    if (leftOffset === switchState.leftOffset) {
      return;
    }

    // Update Position
    A.animate($control, {
      left: leftOffset
    }, 0);
    switchState.leftOffset = leftOffset;

    switchState.isDragging = true;
    switchState.dragCount++;
  }

  /**
   *  User Interaction Handler
   *    rests the -switch control- at an edge
   *
   *  @private
   *  @param {jQuery.event} $event
   */
  function clearSwitch($event) {
    $event.preventDefault();

    // desktop interaction, and not being cleared with left mouseout
    if (!A.capabilities.touch && $event.which !== 1) {
      return;
    }

    var $switch = $event.data.$switch;
    var switchState = $switch.data(SWITCH_STATE);

    // Decides to snap or toggle, then update -on/off- state of -switch state-
    setOnState($switch, shouldToggle($switch, switchState));

    switchState.isDragging = false;

    unbindInteraction($switch);
  }

  /********************************** END EVENT HANDLERS **********************************/

  /********************************** PRIVATE HELPER FUNCTIONS **********************************/

  // Default switch slider boundaries.
  var bounds = {
    left: -1,
    right: -1
  };

  // If a skin is present, override base vars with skin vars
  P.when('prv:skin-vars').execute(function(vars) {
    bounds = vars.toggle.bounds;
  });

  /**
   * Helper
   *    Initializes the -switch state- data attribute
   *
   *  @private
   *  @param {HTMLElement} $switch
   */
  function initializeSwitchData($switch) {
    // cache dom relationships
    var $container = $switch.closest("." + SWITCH_CONTAINER_CLASS);
    var $control = $switch.children("." + SWITCH_CONTROL_CLASS);
    var $label = $container.find("." + SWITCH_LABEL_CLASS);  // TODO: change back after 3.15.6 - $switch.closest
    var $input = $label.siblings("input"); // TODO: change back after 3.15.6  - $label.prev

    var name = $input.attr("name");

    var isOn = $container.hasClass("a-active");
    var isEnabled = !$container.hasClass("a-disabled");

    var leftBoundary = bounds.left;
    var rightBoundary =  (($switch.width() - $control.width()) + bounds.right);
    var midPoint = (rightBoundary / 2);
    var leftOffset = isOn ? rightBoundary : leftBoundary; // initial position
    var maxLeftOffset = bounds.maxLeftOffset; // can be set by skin vars (or undefined in beacon)

    $switch.data(SWITCH_STATE, {
      input: $input, // [jQuery dom]
      container: $container, // [jQuery dom]
      control: $control, // [jQuery dom]
      label: $label, // [jQuery dom]
      isDragging: false, // [boolean]
      rightBoundary: rightBoundary, // [int], pixels or rems
      leftBoundary: leftBoundary, // [int], pixels or rems
      midPoint: midPoint, // [int], pixels or rems
      initialX: null, // [int] mouse/touch coordinate at initSwitch call
      leftOffset: leftOffset, // [int] position of switch control from left edge
      maxLeftOffset: maxLeftOffset, // [int or undefined] if defined, control will not move beyond
      isOn: isOn, // [boolean]
      isEnabled: isEnabled, // [boolean]
      name: name, // [string] name of input element
      dragCount: 0, // [int] threshold marker for snap / toggle
      clicked: false // [boolean] TODO: remove after 3.15.6
    });
  }

  /**
   * Helper
   *    snaps to closest side (associated with on/off), if -switch- has been dragged.
   *    toggles between on/off otherwise.
   *
   *  @private
   *  @param {HTMLElement} $switch
   *  @param {object} switchState
   *  @returns {boolean} isOn
   */
  function shouldToggle($switch, switchState) {
    // (switchState.dragCount > 1) defines a threshold for if user meant to toggle, but drags 1px
    // this also address MS surface bug, that fires ATLEAST one mousemove, even if you havn't moved
    var snap = switchState.isDragging && (switchState.dragCount > 1);

    return snap ? (switchState.leftOffset > switchState.midPoint) : !switchState.isOn;
  }

  /**
   * Helper
   *    Syncs -control- with -switch state-
   *
   *  @private
   *  @param {HTMLElement} $switch
   *  @param {object} switchState
   */
  function updateControl($switch, switchState) {
    var $control = switchState.control;
    var maxLeftOffset = switchState.maxLeftOffset;

    // Moves -control- to edge based on updated -switch state-
    var leftOffset = switchState.isOn ? switchState.rightBoundary : switchState.leftBoundary;
    leftOffset = (maxLeftOffset && leftOffset > maxLeftOffset) ? maxLeftOffset : leftOffset;

    A.animate($control, {
      left: leftOffset
    }, ANIMATION_TIME, ANIMATION_EASING);

    switchState.leftOffset = leftOffset;
  }

  /**
   *  Helper
   *    Syncs -switch container- and -switch label- with -switch state-
   *
   *  @private
   *  @param {HTMLElement} $switch
   *  @param {object} switchState
   */
  function updateContainer($switch, switchState) {
    var $container = switchState.container;

    switchState.isOn ? $container.addClass("a-active") : $container.removeClass("a-active");
  }

  /**
   *  Helper
   *    Syncs -checkbox- with value in -switch state-
   *
   *  @private
   *  @param {HTMLElement} $switch
   *  @param {object} switchState
   */
  function updateCheckbox($switch, switchState) {
    var $checkbox = switchState.input;

    switchState.isOn ? $checkbox.attr("checked", "checked") : $checkbox.removeAttr("checked");
  }

  /**
   *  Helper
   *    Fires -switch- events, with the given action
   *      'a:switch:[switchName]:action' // specify the particular -switch-
   *      'a:switch:action' // generic for all toggle -switches-
   *    ( where switchName is the name of the input element associated with the -switch-)
   *
   *  @private
   *  @param {object} switchState
   *  @param {string} action - The name of the action, e.g. ('on', 'off', 'flipped')
   *  @param {boolean} [previousState] - The previous state of the control.  Can be undefined...
   */
  function triggerSwitchEvent(switchState, action, previousState) {
    var callbackData = {
      switchState: switchState,
      previousState: previousState
    };
    A.trigger("a:switch:" + action, callbackData);
    if (switchState.name) {
      A.trigger("a:switch:" + switchState.name + ":" + action, callbackData);
    }
  }

  /**
   *  Helper
   *    Computes new leftOffset value
   *    (does not affect -switch state-, e.g. mutate switchState.leftOffset)
   *
   *  @private
   *  @param {number} currentX - The current mouse position
   *  @param {object} switchState
   *
   *  @returns {number} leftOffset
   */
  function computeLeftOffset(currentX, switchState) {
    // Difference in mouse position
    var leftOffset = currentX - switchState.initialX;

    // accounts for initial side being "right"
    if (switchState.isOn) {
      leftOffset += switchState.rightBoundary;
    }

    // bounds -switch control- inside -switch container-
    leftOffset = checkDragBoundary(leftOffset,
      switchState.leftBoundary,
      switchState.rightBoundary
    );

    return leftOffset;
  }

  /**
   *  Helper
   *    Computes leftOffset bounded by upper/lower bounds, associated with left/right edges respectively
   *    (prevents -switch control- from being dragged outside the -switch-)
   *
   *  @private
   *  @param {number} leftOffset
   *  @param {number} lowerBound - Left edge of the switch UI
   *  @param {number} upperBound - Right edge of the switch UI
   *
   *  @returns {number} boundedLeftOffset
  ;
  }

  /********************************** END PRIVATE HELPER FUNCTIONS **********************************/

  /********************************** PUBLIC APIS **********************************/

  /**
   *  Helper
   *    initialize -switch- if it isn't already initialized
   *
   *  @public
   *  @param {HTMLElement} $switch
   */
  function ensureInitialized($switch) {
    if (!$switch.data(SWITCH_STATE)) {
      initializeSwitchData($switch);
    }
  }

  /**
   * Helper
   *    Sets -on/off- state of the -switch-, updating components (-control-, -container-, -checkbox-) aswell
   *
   *  @public
   *  @param {HTMLElement} $switch
   *  @param {boolean} isOn - State to set the switch to
   */
  function setOnState($switch, isOn) {
    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);
    var prevState = switchState.isOn;

    var flipped = (isOn !== switchState.isOn); // -switch- changed states

    switchState.isOn = isOn;

    // Syncs components of the -switch- with the -switch state-
    updateControl($switch, switchState);
    updateContainer($switch, switchState);
    updateCheckbox($switch, switchState);

    // Trigger Events
    if (flipped) {
      triggerSwitchEvent(switchState, "flip", prevState);
    }
    if (isOn) {
      triggerSwitchEvent(switchState, "on", prevState);
    } else {
      triggerSwitchEvent(switchState, "off", prevState);
    }
  }

  /**
   * Helper
   *    Sets -enabled- state of the -switch-
   *
   *  @public
   *  @param {HTMLElement} $switch
   *  @param {boolean} isEnabled
   */
  function setEnabled($switch, isEnabled) {
    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);
    var $container = switchState.container;

    isEnabled ? $container.removeClass("a-disabled") : $container.addClass("a-disabled");

    switchState.isEnabled = isEnabled;
  }

  /********************************** END PUBLIC APIS **********************************/

  /********************************** MOBILE/DESKTOP ABSTRACTION **********************************/


  /*
   * These helper functions are interfaces that abstract out touch/mouse implementation.
   * This allows the invoker to be agnostic about touch/mouse.
   */

  /**
   *  Interface (details about touch/mouse implementation left out)
   *  bind user interaction event (drag/clear) handlers for the -switch-.
   *
   *  @private
   *  @param $switch [jQuery]
   */
  var bindInteraction = null;

  /**
   *  Interface (details about touch/mouse implementation left out)
   *  unbind user interaction event (drag/clear) handlers for the -switch-.
   *
   *  @private
   *  @param {HTMLElement} $switch
   */
  var unbindInteraction = null;

  /**
   *  Interface (details about touch/mouse implementation left out)
   *
   *  @private
   *  @param {jQuery.event} $event
   *  @returns {number} currentX - Current mouse or touch x-coordinate
   */
  var getCurrentX = null;

  // Instantiates the appropriate implementation
  if (A.capabilities.touch) {
    bindInteraction = handlers.mobile.bind;
    unbindInteraction = handlers.mobile.unbind;
    getCurrentX = handlers.mobile.getX;
  } else {
    bindInteraction = handlers.desktop.bind;
    unbindInteraction = handlers.desktop.unbind;
    getCurrentX = handlers.desktop.getX;
  }

  /********************************** END MOBILE/DESKTOP ABSTRACTION **********************************/

  /********************************** INITIALIZE SWITCH INTERACTION **********************************/

  var initEvent = A.capabilities.touch ? "touchstart" : "mousedown";
  A.declarative("a-switch", initEvent, initSwitch);

  /* Changing of -input- toggles the -switch-. */
  A.declarative("a-switch-input", "change", function (event) {
    var $event = event.$event;
    $event.preventDefault();

    var $input = event.$target;
    var $container = $input.closest("." + SWITCH_CONTAINER_CLASS); // TODO: change back after 3.15.6 - $label = $input.next
    var $switch = $container.find("." + SWITCH_CLASS); // TODO: change back after 3.15.6 - $label.children

    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);

    setOnState($switch, !switchState.isOn);

  });

  /* TODO: remove after 3.15.6 - Clicking of -label- toggles the -switch-. */
  A.declarative("a-switch-label", "click", function (event) {
    var $event = event.$event;
    $event.preventDefault();

    var $label = event.$target;
    var $container = $label.closest("." + SWITCH_CONTAINER_CLASS);
    var $switch = $container.find("." + SWITCH_CLASS);

    ensureInitialized($switch);
    var switchState = $switch.data(SWITCH_STATE);

    // If we are using the templates from 3.15.6
    if (switchState.clicked) {
      switchState.clicked = false;
      return;
    }

    if(switchState.isEnabled){
      setOnState($switch, !switchState.isOn);
    }

  });

  // Normalize visible switch state with underlying checkbox
  P.when('ready').execute('a-switch-normalization', function() {
    
    $('.a-switch-input').each(function() {
      var $input = $(this),
        $switch = $input.next().children('.' + SWITCH_CLASS);
      setOnState($switch, $input.prop('checked'));
    });
  });

  /********************************** END INITIALIZE SWITCH INTERACTION **********************************/

  /********************************** EXPOSE SWITCH FRAMEWORK **********************************/

  return {
    ensureInitialized: ensureInitialized,
    setOnState: setOnState,
    setEnabled: setEnabled,
    SWITCH_STATE: SWITCH_STATE,
    SWITCH_CONTAINER_CLASS: SWITCH_CONTAINER_CLASS,
    SWITCH_CLASS: SWITCH_CLASS
  };

});
/////////////////////////
// END FILE js/switch_framework.js
/////////////////////////

// END ASSET AmazonUISwitch-3.1.1309.92
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIProgressBar", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIProgressBar-3.1.1258.91
/////////////////////////
// BEGIN FILE js/progress.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
P.when("A", "ready").register("a-progress", function(A) {

  var $ = A.$;

  // Class name constants that interface with javascript.
  var PROGRESS_CLASS = ".a-js-progress-bar",
      TOOLTIP_CLASS  = ".a-js-progress-tooltip",
      ARROW_CLASS    = ".a-js-tooltip-arrow",

      // Tooltip animation classes
      REVEALED_CLASS = "a-progress-tooltip-revealed",
      HIDDEN_CLASS   = "a-progress-tooltip-hidden",

      // Hardcoded width because .width() doesn't grab border-width.
      TOOLTIP_ARROW_WIDTH = 18,
      TOOLTIP_ARROW_DISPLAY_THRESHOLD = (TOOLTIP_ARROW_WIDTH / 2) + 3;

  /*
    init - The function most pertinent to the event listeners, it runs
    every single time there's a resize or scroll, and a single
    time to accomodate the "ready" event.
  */
  function init(component) {

    var components = component ? $(component) : $(PROGRESS_CLASS);


    components.each(function() {
      var progress = $(this);

      if(A.onScreen(progress, 0)) {
        update(progress);
        reveal(progress.find(TOOLTIP_CLASS));
      }

    });
  }

  /*
    update - a driver function that updates a single progress component
    component: a DOM node representing the root of the component
  */
  function update(component) {
    var state = {};

    // Grab the current state of this component.
    // Unary plus (+) casts a string into an integer.
    state.percentage = +(component.attr('data-progress-percentage'));
    state.complement = -(state.percentage - 100);
    state.bounds     = component.width();
    state.remainder  = state.bounds * (state.complement / 100);
    state.tooltip    = component.find(TOOLTIP_CLASS); // $

    _update_tooltip(state);
  }

  /*
    reveal - it just... it adds a class that has animation props.
 )
  }

  /*
    _update_tooltip - A helper function that is responsible for modifying a tooltip
                      based on state.

    state: An object that contains three properties relating to the state
           of the parent tooltip

          percentage: the percentage of meter that's filled
          complement: the percentage of meter that's empty
          bounds    : the 'bounds' that the tooltip must stay in.
                      typically the width of the progress component
          remainder : the width of the part of the meter that's empty'
          tooltip   : the tooltip that belongs to this progress component
  */
  function _update_tooltip(state) {
    var tooltip   = state.tooltip,
        tipwidth  = tooltip.width(),
        arrow     = tooltip.find(ARROW_CLASS),
        at        = state.percentage + (state.complement / 2),
        position  = state.bounds * (at/100) - (tipwidth / 2),
        fullwidth = tipwidth + position,
        bounded   = (fullwidth < state.bounds);


    if(!bounded) {
      position -= (fullwidth - state.bounds);
    }

    _align(tooltip, position, 0);
    _update_arrow({
      tooltip   : tooltip,
      remainder : state.remainder,
      bounded   : bounded
    });
  }

  /*
    _update_arrow - A helper function that aligns a tooltip arrow to its parent

    state: An object that contains three properties relating to the state
           of the parent tooltip

           tooltip: the parent tooltip
           remainder: the remaining dead space in the meter
           bounded: whether or not the tooltip went past the meter in width
  */
  function _update_arrow(state) {
    var tooltip  = state.tooltip,
        tipwidth = tooltip.width(),
        arrow    = state.tooltip.find(ARROW_CLASS);

    // Reset state
    arrow.removeClass('aok-hidden');

    // if the tooltip was out of bounds,
    if(!state.bounded) {
      _align(arrow, tipwidth, -TOOLTIP_ARROW_WIDTH * 1.5);
    }
    else {
      _align(arrow, tipwidth / 2, -TOOLTIP_ARROW_WIDTH / 2)
    }

    // if the tooltip arrow is greater than 'half the arrow width plus three'
    if(state.remainder < TOOLTIP_ARROW_DISPLAY_THRESHOLD) {
      arrow.addClass('aok-hidden')
    }

  }

  /*
    _align - A help function that aligns a child element horizontally to its parent

    child:  a DOM reference to the child element
    to:     a number within the bounds of the parent to align to
    offset: a number to add or subtract to the final alignment location

  */
  function _align(child, to, offset) {
      $(child).css('left', to + offset);
  }

  // Initialize
  init();
  A.on("resize scr;
  });

  // Returning API so progress bars can be reinitialized at runtime
  return {
    init: init
  }

});
/////////////////////////
// END FILE js/progress.js
/////////////////////////
// END ASSET AmazonUIProgressBar-3.1.1258.91
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIPopoverJS", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIPopoverJS-3.1.1463.95
/////////////////////////
// BEGIN FILE js/base/popover_base_apis.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  @deprecated
 *  Popover API class
 *
 */

'use strict';

P.when('A', 'a-popover-base-factory').register('a-popover-base-apis', function (A, factory) {
  var undefined,
    $ = A.$,
    LOCK_SYSTEM = 1;

  /**
   *  @deprecated
   *  Please use popover.get(id).show()
   *
   *  Show a popover customized with an options hash.  Popovers are created if
   *  necessary (first user interaction, DOM changes, etc), and the state of
   *  other popovers is changed if necessary.
   *
   *  @public
   *  @param {object} options  A hash of customizations to the popover
   *
   *  @return {object} popover
   */

  function show(options) {
    var $trigger = options.$trigger ? options.$trigger : options; //now $trigger is moved away from options in popover/modal etc class,
    //this is for backward compatibility
    //if option.$trigger is not set, will treat the first argument as id
    var popover = factory.get($trigger);
    if (popover) {
      return popover.show.apply(popover, arguments);
    }
  }

  /**
   *  @deprecated
   *  Please use popover.get(id).hide();
   *
   *  Hide the popover with the given ID
   *
   *  @public
   *  @param {string|number|object} id
   *
   *  @return {object} popover
   */

  function hide(id) {
    var popover = factory.get(id);
    if (popover) {
      // Unlock the popover as it is explicitly called to be hidden
      popover.unlock(LOCK_SYSTEM);
      return popover.hide.apply(popover, arguments);
    }
  }

  /**
   *  @deprecated
   *  Please use popover.get(id);
   *
   *  Get a popover by passing its ID, name, or the $trigger element
   *
   *  @public
   *  @param {string|number|object} id  The popover ID, name, or $trigger
   *
   *  @return {object}  Popover instance
   */

  function get(id) {
    return factory.get(id);
  }

  /**
   *  @deprecated
   *  Please use popover.remove(id);
   *
   *  Remove the popover DOM elements with the associated ID/name/$trigger
   *
   *  @public
   *  @param {string|number|object} id  The popover ID, name, or $trigger
   */

  function remove(id) {
    return factory.remove(id);
  }

  /**
   * APIs in popover_base are not meant to be public; it should only be consumed by leave classes
   * such as popover/modal/tooltip
   *
   * Keeping the show/hide/get/remove method just to keep back compatibility
   *
   * Now popover will auto refresh upon updates, making the remove() method unnecessary
   */
  return {
    show: show, // deprecated, please use popover.get(id).show();
    hide: hide, // deprecated, please use popover.get(id).hide();
    get: get, // deprecated, please use popover.get(id);
    remove: remove // deprecated, please use popover.remove(id);
  }
});
/////////////////////////
// END FILE js/base/popover_base_apis.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/base/popover_base_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Base factory for popovers.
 *
 */

'use strict';

/**
 *  All the CRUD functionality for a default popover is in this module.
 */
P.when('A', 'a-popover-util', 'a-popover-objectclass', 'a-popover-data').register('a-popover-base-factory', function (A, util, objectclass, data) {
  var $ = A.$;

  /**
   *  The name of the data attribute which contains the popover's ID.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var POPOVER_ID_DATA_ATTR = "a-popover-id";

  /**
   *  The class defined as a declarative element
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var DECLARATIVE_CLASS = "a-declarative";

  /**
   *  Popover lock level
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LOCK_SYSTEM = 1;

  /**
   *  This will contain the ID of the next popover which will be created and is incremented after each create.
   *
   *  @private
   *  @type {number}
   */
  var popoverId = 1;

  /**
   *  A name -> popover hash useful when reusing named popover DOM nodes.
   *
   *  @private
   *  @type {object}
   */
  var named = {};

  /**
   *  An ID -> object hash containing all popovers which currently exist on the page.
   *
   *  @private
   *  @type {object}
   */
  var existing = {};

  /**
   *  The "fake" DOM node which acts as the trigger and popover of the root popover
   *
   *  @private
   *  @type {DOM Node}
   */
  var ROOT_POPOVER_NODE = $("<div id='a-popover-root' style='z-index:-1;position:absolute;' />").appendTo('body');

  /**
   *  The ID of the root popopver.  Constant used for self-documenting some code.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var ROOT_POPOVER_ID = -1;

  /**
   *  The fake parent popover of all popovers who wouldn't otherwise have a parent.
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var ROOT_POPOVER;

  /**
   * Insert a popover that current exist in the page
   *
   * @private
   * @param {object} popover  popover instance
   ;
  }

  /**
   *  Get an existing popover by ID
   *
   *  @private
   *  @param {number} id
   *
   *  @return {object} popover
   */
  function _getPopoverById(id) {
    return existing[id] ? existing[id] : null;
  }

  /**
   * Setter for named array
   *
   * @private
   * @param {object} popover  Popover instance to set
   */
  function _setNamedPopover(popover) {
    if (popover.name) {
      named[popover.name] = popover;
    }
  }

  /**
   * Getter for named array
   *
   * @private
   * @param {string} name  Name of the popover to fetch
   *
   * @return {object}  popover instance
  ;
  }

  /**
   * Create popover instance
   *
   * @param {object} attribute              Hash of attributes for popover
   * @param {object} typeSpecificFunctions  Display-related functions that are specific to the popover type
   *
   * @return {object}  popover instance
  ;
  }

  /**
   * Create a new popover with the given customization options.
   *
   * @private
   * @param {object} trigger                DOM of the trigger
   * @param {object} attribute              Hash of attributes for popover
   * @param {object} typeSpecificFunctions  Display-related functions that are specific to the popover type
   *
   * @return {object} popover
   */
  function _doCreate(trigger, attributes, typeSpecificFunctions) {
    /*jshint validthis:true */
    var $trigger = $(trigger),
      type = attributes.type,
      $triggerWrapper = null,
      popover = null;

    // Require type to continue
    if (!type) {
      return null;
    }

    // Throw a ueLogError when the popoverLabel attribute isn't avaliable. This
    // behaviour is behind a weblab to control the number of errors logged to
    // RTLA
    if($.inArray(type, ["modal", "secondary-view", "popover"]) !== -1 && !attributes.popoverLabel) {
      if(window.ueLogError &&
         document.getElementsByTagName('body')[0].className.indexOf('a-aui_accessibility_49860-t1') !== -1) {
        var errorMessage = {
          message: '[popoverLabel attribute is required for all AUI popovers, modals and secondary views for ' +
                    'accessibility reasons. Please see http://tiny/g8mxo1mk/auiamazdevepopo for more details]'
        };
        var additionalInfo = {
            logLevel: "ERROR"
        };
        window.ueLogError(errorMessage, additionalInfo);
      }
    }

    // Gotta have a trigger
    if (!$trigger || !$trigger.length) {
      return null;
    }

    // Create a new popover
    var attributes = A.extend({
      id: popoverId++,
      $trigger: $trigger,
      $triggerWrapper: $triggerWrapper
    }, attributes),
      typeSpecificFunctionsCopy = A.copy(typeSpecificFunctions),
      popover = _createInstance(attributes, typeSpecificFunctionsCopy);

    // Add and register popover
    _addExisting(popover);
    _setNamedPopover(popover);
    $trigger.data(POPOVER_ID_DATA_ATTR, popover.id);

    // Put this popover in the correct place in the popover tree.
    var $parent = popover.$trigger.closest(".a-popover");
    var parentPopover;
    if (!popover.attrs("immersive") && $parent.length) {
      parentPopover = _getPopoverById($parent.data(POPOVER_ID_DATA_ATTR)) || getRoot();
    } else {
      parentPopover = getRoot();
    }
    popover.parent = parentPopover;
    parentPopover.children.push(popover);

    return popover;
  }

  /**
   *  Get a popover by passing its ID, name, or the $trigger element
   *
   *  @public
   *  @param {string|number|object|popover} id  The popover ID, name, or $trigger
   *  @param {string} type  Popover type
   *
   *  @return {object|null}  popover instance
   */

  function _doGet(id, type) {
    var popover = null;

    // If id is number, get by checking existing indexes
    if (typeof id === 'number') {
      popover = _getPopoverById(id);
    }
    // If 'id' is a name, then get by name
    // else get by ID
    else if (typeof id === 'string') {
      popover = _getNamedPopover(id);
      if (!popover) {
        popover = _getPopoverById(id);
      }
    }
    // We also allow people to pass in the $trigger and get the popover,
    // so pull the ID off of the $trigger
    else if (typeof id === 'object') {
      if (id.$popover) {
        // The input itself is a popover object
        popover = id;
      } else {
        // If all of the above failed, there are three possibilites:
        // 1. id is $trigger
        // 2. id is a $popover
        // 3. the user might have created declarative action from create() method
        // and do not know the declarative action is actually inside the original DOM.
        var $id = $(id),
          pid = $id.data(POPOVER_ID_DATA_ATTR);
        if (!pid) {
          var $trigger = $id.find("." + DECLARATIVE_CLASS).eq(0),
            pid = $trigger.length ? $trigger.data(POPOVER_ID_DATA_ATTR) : null;
        }
        popover = _getPopoverById(pid);

        // For the case of people triggering different popover with the same name,
        // we give them the popover if the name is the same
        if (!popover) {
          var action = $id.data("action"),
            actionParams = action ? $id.data(action) : null;
          if (actionParams && actionParams.name) {
            //allow popover reuse if the type is the same and the data strategy allows it
            popover = _getNamedPopover(actionParams.name);
            if (popover && (!type || popover.type === type)) {
              var currentDataStrategyName = popover.attrs("currentDataStrategy");
              var currentDataStrategy =  currentDataStrategyName ? data.getStrategyByName(currentDataStrategyName) : data.guessStrategyByAttrs(popover.attrs());

              if (currentDataStrategy && currentDataStrategy.reusePopover){
                //since there is a possibility that different triggers are sharing the same name
                //we change $trigger and a-popover-id here just to make sure
                if (popover.$trigger[0] !== $id[0]) {
                  popover.$trigger.data(POPOVER_ID_DATA_ATTR, null);
                  popover.$trigger = $id;
                }
              } else {
                popover = null;
              }
            } else {
              popover = null;
            }
          }
        }
      }
    }
    return popover;
  }

  /**
   *  Destroy a popover with the given ID as well as its associated DOM nodes
   *
   *  @public
   *  @param {object} popover  popover instance
   *
   *  @return {boolean}  if operation succeed
   */

  function _doRemove(popover) {
    var id = popover.id;

    if (popover && id > ROOT_POPOVER_ID) {
      var idx = A.indexOfArray(popover.parent.children, popover),
        $container = popover.$container,
        $trigger = popover.$trigger,
        $triggerWrapper = popover.$triggerWrapper;

      popover.parent.children.splice(idx, 1);

      popover.unlock().hide(); // Hide popover and its children
      popover.update({
        content: ""
      });

      // Remove content if popover has been shown before
      if ($container) {
        popover.$container.remove();
      }

      // Unsetting id from $trigger
      $trigger.data(POPOVER_ID_DATA_ATTR, "");

      // Remove object
      if (popover.name) {
        delete named[popover.name];
      }
      delete existing[id];
      popover = null;

      return true;
    } else {
      return false;
    }
  }

  /**
   *  Get the root popover node
   *
   *  @public
   *
   *  @return {object} ROOT_POPOVER
   */

  function getRoot() {
    //lazy initization
    if (!ROOT_POPOVER) {
      ROOT_POPOVER = _createInstance({
        id: ROOT_POPOVER_ID,
        $popover: ROOT_POPOVER_NODE,
        $trigger: ROOT_POPOVER_NODE,
        immersive: true
      }, {
        isActive: function () {
          return true;
        },
        hideMe    },
        showMethod: A.constants.NOOP
      });
    }
    return ROOT_POPOVER;
  }

  /**
   *  Get a popover by passing its ID, name, or the $trigger element
   *  Will return null if obtained instance's type does not match with API popover type
   *
   *  @public
   *  @param {string|number|object|popover} id  The popover ID, name, or $trigger
   *  @param {string} type                      Popover type
   *
   *  @return {object|undefined}  The popover or undefined
   */

  function get(id, type) {
    /*jshint validthis:true */
    var type = type ? type : (this ? this.type : null),
      popover = _doGet(id, type);

    // Sanity check, see if the popover is of the same type as requested if the request is popover type factory
    if (popover && type && popover.type !== type) {
      return null;
    } else {
      return popover;
    }
  }

  /**
   * Create a new popover with the given customization options.
   * Will return null if the $trigger's declaration action does not match with API popover type
   *
   * @private
   * @param {object} trigger  DOM of the trigger
   * @param {object} options  Hash of options
   *                 {object} attribute     Hash of attributes for popover
   *                 {object} typeSpecificFunctions  Display-related functions that are specific to the popover type
   *                 {object} actionCheck   Whether to check if action type matches
   *
   * @return {object} popover
   */
  function create(trigger, options) {
    var $trigger = $(trigger),
      attributes = options.attributes || {},
      typeSpecificFunctions = options.typeSpecificFunctions || options.variant || {}, // options.variant is for back-compat from previous name
      actionCheck = options.actionCheck || false,
      id = $trigger.data('a-popover-id'),
      type = attributes.type,
      popover = null;

    // If the user is passing in a DOM without declarative action, create one for them
    if (type && (!$trigger.hasClass(DECLARATIVE_CLASS) || !$trigger.data("action") || $trigger.data("action").indexOf(type) === -1)) {
      $trigger = A.declarative.create($trigger, "a-" + type);
      trigger = $trigger[0];
    }

    // Action type matching check
    if (actionCheck && $trigger.data("action") && $trigger.data("action").indexOf(type) === -1) {
      return null;
    }

    // If there is $trigger, see if there is already a valid instance created
    if (type && $trigger) {
      popover = _doGet($trigger);
    }

    // Return a popover
    if (!popover) {
      return _doCreate(trigger, attributes, typeSpecificFunctions);
    } else if (popover.type !== type) {
      return null;
    } else {
      return popover;
    }
  }

  /**
   *  Destroy a popover with the given ID as well as its associated DOM nodes.
   *  Will not remove if the id does not match with API popover type.
   *  Will also remove the associated declarative actions if the second parameter is truthy.
   *
   *  @public
   *  @param {number} id  The popover's ID
   *  @param {string} action  (optional) If you would like to remove a declarative action from the DOM node, pass the action name here
   *
   *  @return {boolean}  if operation succeed
   */

  function remove(id, action) {
    /*jshint validthis:true */
    var popover = this.get(id),
      isSuccess = false;

    // Remove popover is a valid popover is found
    if (popover) {
      isSuccess = _doRemove(popover);
      if (action) {
        A.declarative.remove(popover.$trigger[0], "a-" + action);
      }
    }

    return isSuccess;
  }

  return {
    getRoot: getRoot,
    get: get,
    create: create,
    remove: remove
  };
});
/////////////////////////
// END FILE js/base/popover_base_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/base/popover_base_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Common delegates AUI Popover framework
 *
 */

'use strict';

P.when('A', 'a-popover-util', 'a-popover-base-factory').register('a-popover-base-handlers', function (A, util, factory) {
  var undefined,
    $ = A.$;

  /**
   *  Popover lock level
   *
   *  @private
   *  @constant
   *  @type {integer}
   */

  var LOCK_SYSTEM = 1;

  var START_ANCHOR_CLASSNAME = "a-popover-start";
  var END_ANCHOR_CLASSNAME   = "a-popover-end";

  /**
   *  When clicking anywhere in the DOM, we may need to close open popovers.  Search through
   *  the popover tree and close all popovers which didn't get clicked.
   *  Click for mice in Old-IE and Win 7 IE10/11, A.action.start for IE10/11 in Win 8 / devices
   */
  $(document).bind('click ' + A.action.start, function (event) {
    var $target = $(event.target);
    var oe = event.originalEvent;

    /*
     * Ignore click events that originate from a touch-based input, but not a mouse-based click. Sometimes (~1 in 20ish taps) event timing
     * results in mouseenter (tooltip opens), pointerdown, close check (pointerdown), mouseleave, close check (click, tooltip closes)
     * and not mouseenter (tooltip opens), pointerdown, close check (pointerdown), close check (click), mouseleave (tooltip stays open)
     */
    if (oe && oe.pointerType && oe.pointerType === A.pointerType.touch && oe.type === "click") {
      return;
    }

    /*
     * Lightbox/Modal scroller clicking logic will be handled at popover_light.js.  Do nothing here.
     * There's also a possibility that some android browsers will trigger a touchstart event on a mythical
     * <html> node whos pointer doesn't match document.documentElement during or shortly after scrolling.
     * If that happens, bail out quickly to prevent some seriously fubar behavior.
     */
    if ($target.hasClass("a-modal-scroller") || $target[0].id === "a-popover-lgtbox" || $target[0].nodeName.toLowerCase() === "html") {
      return;
    }

    // Function used to search the popover tree to see if the event occurred withing the confines of a popovper
    var condition = function (popover) {
      return util.eventOccursWithin(event, popover);
    };

    A.each(factory.getRoot().children, function (child) {
      if (child.isVisible() || child.isContentLoaded()) {
        var clickedChild = util.search(child, condition);
        if (clickedChild) {
          clickedChild.hideChildren();
        } else if (child.attrs("lightboxOptions") === null && !child.attrs("immersive")) {
          // If the popover is a lightbox-backed popover, it is not possible to click on any portion
          //   of the document to close the popover itself.  In the case of such happens, such as the ipad
          //   case in SC-1426, we check that first before closing a popover
          //
          // Same theory, if a popover is immersive (secondary view), dont close it as it might be needed later for the back operation
          child.unlock(LOCK_SYSTEM).hide();
        }
      }
    });
  });

  /**
   *  Get the closest popover instance when a popover content Jquery object is passed in
   */

  function _getPopoverByDescendantElement ($target) {
    var id;

    // Search for the closest element with a popover id
    while ($target.length) {
      id = $target.data('a-popover-id');
      if (id) {
        break;
      }
      $target = $target.parent();
    }

    return factory.get(id);
  }

  /**
   *  Many popovers have a close button.  Keep that behavior in a centralized place.
   */
  // Adding touchstart as well in case people are getting non-touch asset in touch devices
  A.declarative('a-popover-close', ['click', A.action.start], function (event) {
    var popover = _getPopoverByDescendantElement(event.$target);

    if (popover) {
      // Explicit user action overrides this lock which only prevents accidental closing of a popover
      popover.unlock().hide();
      util.trigger('dismiss', popover);
    }
    event.$event.preventDefault();

  });

  var startFocusout = null;
  var startFocusin = null;
  var throttleMSecs = 100;

  /**
  * Trap the focus inside the popover
  *
  * We used to rely on keydown events to trap the focus inside the popover,
  * however this doesn't work on mobile devices, because they don't dispatch
  * keydown events. There is no way to listen to any touch event and anticipate
  * a focus change. So now, we are listening to the focusout event and check where the
  * next focus is going to land, if its going to land on "a-popover-start" outward,
  * we forcefully move the focus to the last tabbable element in the popover content.
  * If it lands on "a-popover-start" when popover opens, we do nothing.
  */
  A.declarative("a-popover-a11y", "focusout", function loopFocusToBegin(event) {
    var popover = _getPopoverByDescendantElement(event.$target);
    if (!popover || !event.$target.length || !popover.$firstTabbable.length) { return; }

    var isFirstTabbable = event.$target[0] === popover.$firstTabbable[0];
    if(!isFirstTabbable) { return; }

    // One focus out unexpectedly trigger two events
    if (startFocusout && (A.now() - startFocusout) < throttleMSecs) {
      return;
    }
    startFocusout = A.now();

    A.delay(function () {
      if ($(document.activeElement).hasClass(START_ANCHOR_CLASSNAME)) {
        popover.$lastTabbable.focus();
      }
    }, 0);
  });

  /**
  * Trap the focus inside the popover
  *
  * If the focus lands on "a-popover-end", we move the focus to the first tabbable
  * element. In this case, we don't check the tabbing/swiping direction since
  * there's only one possible direction: from last tabbable element to "a-popover-end".
  */
  A.declarative("a-popover-a11y", "focusin", function loopFocusToEnd(event) {
    var popover = _getPopoverByDescendantElement(event.$target);
    if (!popover || !event.$target.length) { return; }

    var isLastTabbable = event.$target.hasClass(END_ANCHOR_CLASSNAME);
    if (!isLastTabbable) { return; }

    // One focus in unexpectedly trigger two events
    if (startFocusin && (A.now() - startFocusin) < throttleMSecs) {
      return;
    }
    startFocusin = A.now();

    A.delay(function () {
      popover.$firstTabbable.focus();
    }, 0);
  });

    /**
  * Close the popover by pressing escape
  */
  A.declarative("a-popover-a11y", "keydown", function (event) {
    var e = event.$event;
    var keyCode = e.keyCode;
      //close the popover by pressing escape
      if (keyCode === A.constants.keycodes.ESCAPE) {
        var popover = _getPopoverByDescendantElement(event.$target);
        // Prevent the default escape key behavior, which cancels existing network request
        e.preventDefault();
        if(popover) {
          popover.hide();
        }
      }
  });

  /**
   *  Ensure all popovers are properly when the window's size changes.
   */

  A.on("resize z;
  });

  // Implementing workaround for AUI-5568
  if (A.capabilities.isSafari && A.capabilities.ios) {
    A.on("a:popover:refresh",function(data){
      var popover = data.popover;

      if (popover.$popover){
        popover.$popover.undelegate('input[type="date"]','blur')
          .delegate('input[type="date"]','    });
      }
    });
  }

});
/////////////////////////
// END FILE js/base/popover_base_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/base/popover_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Popover base class
 *
 */

'use strict';

P.when('A', 'a-popover-base-apis', 'a-popover-base-handlers').register('a-popover-bis;
});
/////////////////////////
// END FILE js/base/popover_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/base/popover_objectclass.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Object class for popovers, needs to be created/constructed to work
 *
 */

'use strict';

P.when('A', 'a-popover-util', 'a-popover-data', 'a-popover-position', 'a-popover-lightbox', 'a-popover-animate')
  .register('a-popover-objectclass', function (A, util, data, position, lightbox, animation) {
  var undefined;
  var $ = A.$;

  /*****************************************
  PRIVATE CONSTANTS USED THROUGHOUT THE FILE
  ******************************************/

  /**
   *  The entire nav bar has its own z-index.  We need to be above that.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var NAV_ZINDEX = 299;

  /**
   *  Lock levels
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var LOCK_SYSTEM = 1,
    LOCK_USER = 10,
    LOCK_UNLOCK = -1;

  /**
   *  Status codes
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var STATUS_ACTIVE = 1,
    STATUS_VISIBLE = 2,
    STATUS_CONTENT_LOADING = 3,
    STATUS_CONTENT_LOADED = 4,
    STATUS_INACTIVE = -1,
    STATUS_UNLOADED = -2;

  /**
   *  The ID of the root popopver.  Constant used for self-documenting some code.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var ROOT_POPOVER_ID = -1;

  /**
   *  The name of the data attribute which contains the popover's ID.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var POPOVER_ID_DATA_ATTR = "a-popover-id";

  /**
   *  The name of the custom position in popover_position
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var CUSTOM_POSITION_KEY = "customPosition";

  /**
   *  List of attribute names change that does not require skin refresh
   *  Make it an object to save inArray() iterations
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var NO_SKIN_REFRESH_NAMES = {
    "name": true,
    "url": true,
    "content": true,
    "width": true,
    "height": true,
    "max-width": true,
    "max-height": true,
    "min-width": true,
    "min-height": true
  };

  /**
   *  For IE specific workarounds
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_IE_MOBILE = A.capabilities.mobile && A.capabilities.isIE10Plus;

 /**
  *  Whether the browser is IE < 9
  *
  *  @private
  *  @constant
  *  @type {boolean}
  */
 var IS_LT_IE9 = $("html").hasClass("a-lt-ie9");

 /**
  *  Selector to get all the tabbable elements
  *
  *  @private
  *  @constant
  *  @type {String}
  */
 var TABBABLE_SELECTOR = "a, button, input, select, textarea, [tabindex]:not([tabindex='-1'])"

 /**
  *  An event that should be triggered when the popover is actually visible to
  *  the customers after animation(if any)
  *
  *  @private
  *  @constant
  *  @type {String}
  */
 var POPOVER_VISIBLE_EVENT = "visible";

 /**
  *  An event that should be triggered when the popover is completely invisible to
  *  the customers after animation(if any)
  *
  *  @private
  *  @constant
  *  @type {String}
  */
 var POPOVER_INVISIBLE_EVENT = "invisible";

  /******************************************************************************
  PRIVATE HELPER FUNCTIONS USED INSIDE CONSTRUCTORS BUT NOT DEPENDENT ON INSTANCE
  ******************************************************************************/


  /**
   *  The default show animation for popovers.  Can be called from methods
   *  which override the showMethod method
   *
   *  @private
   *  @param {function} triggerVisibilityChange The function that triggers the visibility event
   */
  var _baseShowMethod = function (triggerVisibilityChange) {
    /*jshint validthis:true */
    var popover = this;

    // Manipulating a-popover-hidden as a workaround for carousel-in-popover, remove then SC-1499 is resolved
    popover.$popover.css({
      "visibility": "visible"
    }).removeClass("a-popover-hidden");

    // Focus on the popover when it is shown:
    // - only if the focusWhenShown option is set to true
    // - unless ajax is used to load content. Then, wait for the ajax response. See a-popover-ajax-strategy
    if (popover.attrs("focusWhenShown") && (popover.attrs("currentDataStrategy") !== "ajax")) {
      popover.focus();
    }

    // Need to trigger visibility events even for cases
    // when no animation is invloved, and the popover
    // becomes immediately visible.
    triggerVisibilityChange.call(popover);
  }

  /**
   *  The default hide animation for popovers.  Can be called from methods
   *  which override the hideMethod method
   *
   *  @private
   *  @param {function} triggerVisibilityChange The function that triggers the visibility event
   */

  var _baseHideMethod = function (triggerVisibilityChange) {
    /*jshint validthis:true */
    var popover = this;
    var triggerVisibilityChange = arguments[0];

    popover.$popover.hide().find(".a-lgtbox-vertical-scroll").removeClass("a-lgtbox-vertical-scroll");

    // Need to trigger visibility events even for cases
    // when no animation is invloved, and the popover
    // hides immediately
    triggerVisibilityChange.call(popover);
  }

  /**
   *  Get the html look-and-feel of the popover as string
   *
   *  @private
   *  @return {object}  jquery wrapped DOM of the content parent
   */
  var _skin = function () {
    var popover = this,
      typeSpecificFunctions = popover.typeSpecificFunctions;
    return typeSpecificFunctions.skin !== undefined ? typeSpecificFunctions.skin(popover) : "";
  };

  /*******************
  CONSTRUCTOR FUNCTION
  ********************/

  /**
   * Constructor used to create a new popover
   *
   * @constructor
   * @this {Carousel}
   *
   * @public
   * @param {object} attributes             Instance specific attributes used in configuring the look and behavior of the popover
   * @param {object} typeSpecificFunctions  Instance specific functions used to determine the behavior of the popover during show, hide, content loading, etc.
   *
   * @return {PopoverClass}
   */
  function PopoverClass(attributes, typeSpecificFunctions) {

    /**
     *  This is a soft lock which prevents hiding this popover.  It is ignored in several instances, mostly in
     *  the popover_base module.  However, it can be useful if you want to prevent this popover from hiding
     *  in instances where locking would not prevent parent popover behavior.
     *
     *  @private
     *  @type {integer}
     */

    var _lock_level = LOCK_UNLOCK;

    /**
     *  A list of attribute names that have changed upon the previous update() function
     *  Initialize with one element so that the first refresh() is guaranteed to load skin
     *
     *  @private
     *  @type {array}
     */

    var _attrs_changed = [1];

    /**
     *  An integer to indicate the status of the popover
     *
     *  @private
     *  @type {integer}
     */

    var _status = STATUS_UNLOADED;

    /**
     *  The popover which contains the trigger for this popover
     *
     *  @public
     *  @type {object}
     */

    this.parent = null;

    /**
     *  An array containing the popovers whos trigger is a child of this popover's DOM nodes
     *
     *  @public
     *  @type {array}
     */

    this.children = [];

    /**
     * An object for display-related functions, specific to the popover type, that
     * are injected upon popover instance initialization (dependency injection pattern).
     *
     * @public
     * @type {object}
     */
    this.typeSpecificFunctions = {};

    /**
     *  An object for injected attributes
     *
     *  @public
     *  @type {object}
     */

    this.attributes = {
      /**
       *  The positioning strategy used by this popover.  See the "a-popover-position" module for options.
       *
       *  @public
       *  @type {boolean}
       */
      position: 'triggerVertical',

      /**
       *  Should this popover be the only active popover in its scope
       *
       *  @public
       *  @type {boolean}
       */
      alone: false,

      /**
       *  We wanted to name this propery "modal" but since there's already a popover type called modal,
       *  we didn't do that.  Basically, if this popover takes over the user's focus and must be dealt with
       *  before the user can do anything else, this is set to true.
       *
       *  @public
       *  @type {boolean}
       */
      immersive: false,

      /**
       *  By default, popovers will attempt to restore focus to the previous active element when they are closed.
       *  This attribute, when set to false, will disable this behavior (e.g. tooltips)
       *
       *  @public
       *  @type {boolean}
       */
      restoreFocusOnHide: true
    };

    /**
     *  Trigger the popover visible/invisible event
     *  Called within showMethod/hideMethod whenever there is a change in visibility of the component
     *  Should be called after the animation(if any) concludes
     *
     *  @private
     *
     *  @return {object}  popover instance
     */

    var _triggerVisibilityChange = function() {
     var popover = this;
     if (popover.isActive()) {
       if (popover._willTriggerEvents) {
         util.trigger(POPOVER_VISIBLE_EVENT, popover);
      }
     }
     else {
       util.trigger(POPOVER_INVISIBLE_EVENT, popover);
     }
     return popover;
    };

    /**
     *  Refresh a popover.  If the forceContentRefresh parameter is true, the content will be refreshed no matter what.
     *
     *  @private
     *  @param {boolean} forceContentRefresh
     *  @param {boolean} forceSkinRefresh
     *
     *  @return {PopoverObject}
     */

    var _refreshPopover = function (forceContentRefresh, forceSkinRefresh) {
      var popover = this;
      var isActive = popover.isActive();
      var dataStrategy = popover.getDataStrategy();
      var isFirstRender = !popover.$popover;
      var isRefreshSkin = forceSkinRefresh || isFirstRender;
      var hasUnloadedContent = false;
      forceContentRefresh = forceContentRefresh || isRefreshSkin;

      // Check if skin refresh required
      if (!isRefreshSkin) {
        var i = _attrs_changed.length;
        while (i-- && !isRefreshSkin) {
          isRefreshSkin = !NO_SKIN_REFRESH_NAMES[_attrs_changed[i]];
        }
      }

      if (isRefreshSkin) {
        // Load skin
        var newContainer = _skin.apply(popover),
          $newContainer = $(newContainer);

        // Backup content and remove current popover DOM
        if (!isFirstRender) {
          dataStrategy.unloadContent(popover);
          popover.$container.remove();
          hasUnloadedContent = true;
        }

        // Update $container and $popover
        $('body').append($newContainer);
        popover.$container = $newContainer;
        popover.$popover = popover.$container.hasClass("a-popover") ? popover.$container : popover.$container.find(".a-popover");
        popover.$startAnchor = popover.$popover.hasClass("a-popover-start") ? popover.$popover : popover.$popover.find(".a-popover-start");
        popover.$endAnchor = popover.$popover.find(".a-popover-end");
        popover.$popover.attr('id', 'a-popover-' + popover.id).data(POPOVER_ID_DATA_ATTR, popover.id);

      }

      // Make sure a non-modal popover will show up on top of its parent
      if (!popover.attrs("immersive")) {
        var zIndex = parseInt(popover.parent.$popover.css("z-index"), 10);
        if (!A.isFiniteNumber(zIndex)) {
          zIndex = popover.parent.attrs("immersive") ? 1010 : 0;
        }
        popover.$popover.css("z-index", Math.max(NAV_ZINDEX, 100 + zIndex));
      }

      if (dataStrategy.shouldRefreshContent(popover) || forceContentRefresh) {
        // Load content
        if (!hasUnloadedContent) {
          dataStrategy.unloadContent(popover);
        }
        dataStrategy.loadContent(popover, isFirstRender);
      }

      // Update popover dimension
      if (popover.typeSpecificFunctions.updateDimensions !== undefined) {
        popover.typeSpecificFunctions.updateDimensions.apply(popover);
      }

      // Clear changed attributes (set isDirty()=false) before show() to prevent calling refresh() again
      _attrs_changed = [];

      // Show (update position) if it is displaying now
      if (isActive) {
        _displayPopover.call(popover, [], false);
      }

      // Get tabbable elements and set the first/last element as an attribute,
      // these attributes need to be accessed later for accesibility reasons.
      var tabbableContent = popover.$popover.find(".a-popover-inner").find(TABBABLE_SELECTOR);
      tabbableContent = tabbableContent.not('.a-dropdown-link'); // tabbing should be handled by parent ".a-dropdown-item"
      // Close button will be always there and focusable (for screen reader user) and should be the first tabbable element.
      popover.$firstTabbable = popover.$popover.find('[data-action="a-popover-close"]');
      // Fallback if there's really no close button (e.g. split dropdown or desktop dropdown)
      popover.$firstTabbable = popover.$firstTabbable.length ? popover.$firstTabbable : tabbableContent.first();
      popover.$lastTabbable = tabbableContent.length === 0 ?  popover.$firstTabbable : tabbableContent.last();

      return popover;
    };

    /**
     *  The main popover display logic.  Executing beforeShowMethod, showMethod and afterShowMethod
     *  in sequence to show a popover.
     *
     *  @private
     *  @param {array}  args arguments passed from the public API show() method to the three subsequent methods
     *  @param {boolean}  willTriggerEvents  a boolean to determine if events will be triggered.  Used for refresh() when triggers should not be fired.
     */
    var _displayPopover = function (args, willTriggerEvents) {
      var popover = this,
        willTriggerEvents = !! willTriggerEvents,
        typeSpecificFunctions = popover.typeSpecificFunctions,
        showMethod = typeSpecificFunctions.showMethod !== undefined ? typeSpecificFunctions.showMethod : _baseShowMethod,
        beforeShowMethod = typeSpecificFunctions.beforeShowMethod !== undefined ? typeSpecificFunctions.beforeShowMethod : null,
        afterShowMethod = typeSpecificFunctions.afterShowMethod !== undefined ? typeSpecificFunctions.afterShowMethod : null;

      // Set popover as active after we are certain we have popover.$popover after refresh()
      _status = STATUS_ACTIVE;

      // Used in the triggerVisibilityChange function, which is called within the instance specific showMethod
      // and does not have access to this boolean
      popover._willTriggerEvents = willTriggerEvents;

      // Record current focus to restore during hide operation
      popover.attrs('originalFocus', document.activeElement);

      // Set to visibility:hidden so that updatePosition() can be called before the show function
      // Added a-popover-hidden as a workaround for carousel-in-popover, remove then SC-1499 is resolved
      popover.$popover.css("visibility", "hidden").addClass("a-popover-hidden").show();

      if (beforeShowMethod) {
        // Accepting abitrary arguments from input
        beforeShowMethod.apply(popover, args);
      }

      // Real show method.
      // Add delay to ensure correct dimension calculations during updatePosition() unless the config options forbid it
      function realShow() {
        popover.updatePosition();
        var prevNavigate = popover.attrs("navigate");

        // This is a temporary solution to a bigger problem. If the content of a secondary view
        // gets updated during the "show" process, then the containing method gets called twice.
        // On the second pass-through, the willTriggerEvents arg will be false.  If willTriggerEvents
        // is false, we don't want to push stuff onto the navigation stack.  If we did, it would cause
        // two hashes to be pushed onto the stack.  Since clicking back only removes one, the same
        // secondary view would be shown a second time and two more hashes would be created.  Thus,
        // the popover could never be closed.
        if (!willTriggerEvents && prevNavigate) {
          popover.attrs("navigate", false);
        }
        // Accepting abitrary arguments from input
        showMethod.call(popover, _triggerVisibilityChange, args);

        if (willTriggerEvents) {
          util.trigger('show', popover);
        }

        if (afterShowMethod) {
          // Accepting abitrary arguments from input
          afterShowMethod.apply(popover, args);
        }

        if (willTriggerEvents) {
          util.trigger('afterShow', popover);
        }

        popover.$popover.attr("aria-hidden", "false");

        if (!willTriggerEvents && prevNavigate) {
          popover.attrs("navigate", prevNavigate);
        }

        // Indicate the state of popover as visible
        _status = STATUS_VISIBLE;
      }

      if (popover.attrs("synchronous")) {
        realShow();
      } else {
        A.delay(function () {
          realShow();
        }, 0);
      }
    };

    /**
     *  Take a given popover and return a function which wraps the popover's show
     *  function an allows for default functionality to be run whenever the popover's
     *  show function is executed.
     *
     *  @public
     */

    this.show = function () {
      var popover = this,
        lightboxOptions = popover.attrs("lightboxOptions") || null;

      if (popover.isActive() || animation.isAnimating(popover)) {
        return this;
      }

      // Lock popover to prevent hide when animation
      popover.lock(LOCK_SYSTEM);

      // If this popover needs lightbox, lock lightbox so that it will not be hidden
      if (lightboxOptions) {
        lightbox.lock(LOCK_SYSTEM);
      }

      // Hide all sibling popovers if this popover wants to be the only open popover in this context
      if (popover.attrs("alone")) {
        A.each(popover.parent.children, function (sibling) {
          // Skip if sibling is a modeless model
          if (sibling.isActive() && sibling.id !== popover.id && !sibling.attrs("modeless")) {
            sibling.unlock().hide();
          }
        });
      }

      // Trigger beforeShow before refresh() to include content changes
      util.trigger('beforeShow', popover);

      // Load content by repainting popover if data is not loaded yet or the data strategy requires a refresh
      if (!popover.$container || popover.isDirty() || popover.getDataStrategy().shouldRefreshContent(popover)) {
        // Added this trigger for AUI-5568
        util.trigger('refresh',popover);
        _refreshPopover.call(popover);
      }

      if (popover.draggable) {
        var $container = popover.$container;
        A.draggable($container, {
          handle: $container.find('.a-popover-draggable-handle')
        });
      }

      // Show lightbox if the popover requires it
      if (lightboxOptions) {
        lightbox.show(A.extend({
          popover: popover
        }, lightboxOptions));
      }

      // Real show method
      _displayPopover.call(popover, arguments, true);

      // Add delay to locking popover and lightbox
      A.delay(function () {
        popover.unlock(LOCK_SYSTEM);
        if (lightboxOptions) {
          lightbox.unlock(LOCK_SYSTEM);
        }
      }, 0);
      return this;
    }

    /**
     *  Take a given popover and return a function which wraps the popover's hide
     *  function an allows for default functionality to be run whenever the popover's
     *  hide function is executed.
     *
     *  @public
     */
    this.hide = function () {
      var popover = this,
        typeSpecificFunctions = popover.typeSpecificFunctions,
        hideMethod = typeSpecificFunctions.hideMethod !== undefined ? typeSpecificFunctions.hideMethod : _baseHideMethod,
        beforeHideMethod = typeSpecificFunctions.beforeHideMethod !== undefined ? typeSpecificFunctions.beforeHideMethod : null,
        afterHideMethod = typeSpecificFunctions.afterHideMethod !== undefined ? typeSpecificFunctions.afterHideMethod : null,
        lightboxOptions = popover.attrs("lightboxOptions") || null;

      if (!popover.isActive() || popover.isLocked() || animation.isAnimating(popover)) {
        return this;
      }

      // Set popover as inactive
      _status = STATUS_INACTIVE;

      // Hide its children first
      popover.hideChildren();

      util.trigger('beforeHide', popover);
      if (beforeHideMethod) {
        // Accepting abitrary arguments from input
        beforeHideMethod.apply(popover, arguments);
      }

      // Real hide method
      // Accepting abitrary arguments from input
      hideMethod.call(popover, _triggerVisibilityChange, arguments);
      util.trigger('hide', popover);

      A.delay(function () {
        if (afterHideMethod) {
          // Accepting abitrary arguments from input
          afterHideMethod.apply(popover, arguments);
        }

        popover.$popover.attr("aria-hidden", "true");

        // Hide lightbox if the popover requires it
        if (lightboxOptions) {
          // Unless the parent also requires lightbox, hide lightbox
          if (popover.parent.attrs("lightboxOptions")) {
            lightbox.show(A.extend({
              popover: popover.parent
            }, lightboxOptions));
          } else {
            lightbox.hide(lightboxOptions);
          }
        }

        // Currently, the screen (e.g. lightbox for modal or "white" for secondary view)
        // has different animation times. And they don't have a shared event
        // while the animation is done. We need to make sure the screen is gone
        // then focus on the target. A large delay is set to cover
        // the worst case of modal (250ms) and secondary view (350ms).
        var DELAY_MILLI_SECONDS_FOR_FOCUS_CHANGING = 400;

        util.trigger('afterHide', popover);

        // Indicate the state of popover as unloaded
        _status = STATUS_UNLOADED;

        // 1. Fix focused target when popover dismisses.
        // Restore the focus to popover's trigger if it has one. If it doesn't, jump to the previously focused element.
        // Don't do this with tooltips because that prevents navigating out of the element with the tooltip (AUI-4451)
        // 2. Fix focusability of target.
        // [AUI-8786] Currently, best practice of using "popover trigger" is
        // wrapping it with declarative action rather than directly put action data
        // on it. See https://aui.amazon.com/development/interactive_components/popover/popover
        // However, the trigger will be the declarative layer (<span>)
        // rather than the "popover trigger" (<a>). And span can't get complete focus state.
        if (popover.attrs('restoreFocusOnHide')){

          var $nextFocus = null;

          if (popover.type === 'dropdown') {
            $nextFocus = popover.sourceButton.find("[aria-pressed]");
          } else {
            var focusCandidates = 'a, input, button';
            if (popover.$trigger && $(popover.$trigger).length) {
              $nextFocus = popover.$trigger.is(focusCandidates) ?
                           popover.$trigger :
                           popover.$trigger.find(focusCandidates);
            }
          }

          if (!$nextFocus || !$nextFocus.length) {
            $nextFocus = $(popover.attrs('originalFocus'));
          }

          if ($nextFocus.length && (!IS_LT_IE9 || $nextFocus.is(":visible"))) {
            A.delay(function() {
              $nextFocus.focus();
            }, DELAY_MILLI_SECONDS_FOR_FOCUS_CHANGING);
          }
        }
      }, 0);

      return this;
    };

    /**
     *  Popover API, updating popover
     *  This function will only update attributes that are in the OVERRIDE_ATTRS whitelist
     *
     *  @public
     *
     *  @param {object} attributes  a key/value of attributes to change
     *                              also accepting a string for backward compatibility
     *  @return {object}  popover instance
     */

    this.update = function (inAttrs) {
      var popover = this;
      var attributes = typeof inAttrs === "string" ? {
        content: inAttrs
      } : A.copy(inAttrs); // For backward compatibility
      var oldAttrs = this.attrs();
      var oldStrategy = popover.getDataStrategy();

      // Compare old and new set of attributes and find the diff
      A.each(attributes, function (val, key) {
        if ((val && !oldAttrs[key]) || (oldAttrs[key] && oldAttrs[key] !== val)) {
          _attrs_changed.push(key); // we should not care too much about dups here
        }
      });

      if (popover.isDirty()) {
        // Save updated attributes
        var newAttrs = A.extend({}, oldAttrs, attributes);
        popover.attrs(newAttrs);

        // Determine new data strategy
        var newStrategy = popover.getDataStrategy(newAttrs);

        // Backup if popover has been initialized
        if (popover.$popover) {
          oldStrategy.unloadContent(popover);
        }

        if (popover.isActive()) {
          _refreshPopover.call(popover, true);
          popover.focus();
        }
      }
      return popover;
    };

    /**
     *  Load/Reload skin and html content
     *
     *  @public
     *  @param {boolean} isRefreshSkin  force refresh skin
     *  @param {boolean} isRefreshSkin  force refresh skin
     *
     *  @return {object}  popover instance
     */
    this.refr    };

    /**
     *  Determine whether the current popover is activated
     *  meaning a show() is triggered, but perhaps not shown onto viewport yet
     *
     *  @public
     *  @return {boolean}
     */
    this.isAct    };

    /**
     *  Determine whether the popover is visible/shown on the page
     *
     *  @public
     *  @return {boolean}
     */
    this.isVisible = function () {
      return _status === STATUS_VISIBLE;
    };

    /**
     * Determine whether the content is current loading (waiting on ajax)
     * - used for the ajax data strategy
     * - should be true while waiting on an ajax request
     *
     * @public
     * @return {boolean}
     */
    this.isContentLoading = function () {
      return _status === STATUS_CONTENT_LOADING;
    };

    this.setContentLoading = function () {
      _status = STATUS_CONTENT_LOADING;
    };

    /**
     * Determine whether the content has been loaded into the popover
     * - used for ajax data strategy
     *
     * @public
     * @return {boolean}
     */
    this.isContentLoa    };

    this.setContentLoa    };

    /**
     *  Determine whether a force refresh is necessary
     *
     *  @public
     *  @return {boolean}
     */

    this.isDi    };

    /**
     *  Set current lock level, higher the more powerful
     *
     *  @public
     *  @param {integer} lockLevel
     *
     *  @return {object}  popover instance
     */

    this.lock = function (lockLevel) {
      // Assume a user lock if lock level is not set
      if (!lockLevel) {
        lockLevel = LOCK_USER;
      }
      if (_lock_level < lockLevel) {
        _lock_level = lockLevel;
      }
      return this;
    };

    /**
     *  Remove lock if lockLevel is high enough
     *
     *  @public
     *  @param {integer} lockLevel
     *
     *  @return {object}  popover instance
     */

    this.unlock = function (lockLevel) {
      //assume a user lock if lock level is not set
      if (!lockLevel) {
        lockLevel = LOCK_USER;
      }
      if (_lock_level <= lockLevel) {
        _lock_level = LOCK_UNLOCK;
      }
      return this;
    };

    /**
     *  Check lock status
     *
     *  @public
     *
     *  @return {boolean}  lock or unlock
     */

    this.isLoc    };

    // Constructor starts here
    this.typeSpecificFunctions = typeSpecificFunctions;
    this.attrs(attributes);


    //TODO right now we do not have a good idea on what each dependencies passes to popover in and how they use it,
    //     eventually we will only allow dependencies to mess around with using popover.attrs(),
    //     need to remove this when we have better control of our attributes
    //by 8/15/2013, list of items need to be switched:
    //      id
    //      $trigger
    //      $triggerWrapper
    //      data
    //      header
    //      content
    //      position
    //      sourceSelect
    //      sourceButton
    //      name
    //      preventNameReuse
    //      type
    //      footer
    //      width
    //      height
    //      url
    //      ajaxFailMsg
    //      cache
    //      disableAnimation
    //      animationLength
    //      hideHeader
    //      padding
    //      scrollable
    //      data
    A.extend(this, this.attributes);
  }


  /*******************************************************************************
  POPOVER CLASS PROTOTYPE (FUNCTIONS WHICH DON'T NEED ACCESS TO PRIVATE VARIABLES)
  *******************************************************************************/


  // Alias the prototype for better file compression
  var prototype = PopoverClass.prototype;

  /**
   *  Get data strategy used in this popover
   *
   *  @public
   *  @param {object} attrs  hash of popover instance attributes, if empty, return the existing dataStrategy
   *
   *  @return {object}  popover data strategy object
   */
  prototype.getDataStrategy = function (attrs) {
    var popover = this,
      typeSpecificFunctions = popover.typeSpecificFunctions,
      newDataStrategy;

    // If getting dataStrategy without having one, determine data strategy from existing attributes
    if (!attrs && !popover.attrs("currentDataStrategy")) {
      attrs = popover.attrs();
    }

    if (attrs) {
      newDataStrategy = attrs.dataStrategy ? data.getStrategyByName(attrs.dataStrategy) : data.guessStrategyByAttrs(attrs);
      if (newDataStrategy) {
        typeSpecificFunctions.dataStrategy = newDataStrategy;
        popover.attrs("currentDataStrategy", newDataStrategy.name);
      }
    }
    return typeSpecificFunctions.dataStrategy;
  };

  /**
   *  Obtain content DOM node of the popover
   *  Used by popover_data
   *
   *  @return {object}  jquery wrapped DOM of the content parent
   */
  prototype.getCont;
  };

  /**
   *  Update content of the popover
   *  Used by popover_data
   *
   *  @public
   *  @param {string|object} content  html DOM or content, please handle both cases
   */
  prototype.updateContent = function (content) {
    if (this.typeSpecificFunctions.updateContent !== undefined) {
      this.typeSpecificFunctions.updateContent.apply(this, arguments);
    }

    return this;
  };

  prototype.setAriaBusy = function(busy) {
    if (this.typeSpecificFunctions.setAriaBusy !== undefined) {
      this.typeSpecificFunctions.setAriaBusy.apply(this, arguments);
    }
    return this;
  };

  /**
   *  @deprecated
   *  An adapter to update the url of a popover
   *
   *  @public
   *
   *  @param {string} url  new url to load
   *  @return {object}  popover instance
   */

  prototype.a;
  };

  /**
   *  Recursively update position for children of the popover
   *  @public
   *
   *  @return {object}  popover instance
   */

  prototype.updateChildrenPosition = function () {
    A.each(this.children, function (child) {
      if (child.isActive()) {
        child.updatePosition();
      }
    });
    return this;
  };

  /**
   *  Measure the popover and trigger and set the position of the popopver
   *  based on which strategy is set (position attribute)
   *
   *  @public
   *
   *  @return {object}  popover instance
   */

  prototype.updatePosition = function () {
    var popover = this;
    // The root popover should never be visible, so doing these calculations is pointless
    if (popover.id === ROOT_POPOVER_ID) {
      A.each(popover.children, function (child) {
        if (child.isActive()) {
          child.updatePosition();
        }
      });
    } else {
      if (this.typeSpecificFunctions.updatePosition !== undefined) {
        this.typeSpecificFunctions.updatePosition.apply(this, arguments);
        return popover;
      }

      var $popover = popover.$popover;

      // Unfortunately, in some cases, Metro IE will drop focus on an element if visibility: hidden is used...
      // This can cause the keyboard to pop up and go back down and make it impossible to enter text in a modal
      // At least that's the hunch as switching from visibility to opacity seems to have resolved it as far as
      // I was able to test.
      if (A.capabilities.isMetroIEGuess && A.capabilities.isIETouchCapable) {
        $popover.css('opacity', 0.01);
      } else {
        $popover.css("visibility", "hidden");
      }

      var _runUpdate = function () {
        var $inner = $popover.find(".a-popover-inner").css({
          "height": "auto",
          "overflow-y": "auto"
        });
        var posKey = popover.attrs("position");
        var offset = {};
        var positioningObj;

        if (popover.typeSpecificFunctions.positionStrategy) {
          offset = position[CUSTOM_POSITION_KEY](popover, popover.typeSpecificFunctions.positionStrategy);
        } else {
          offset = position[posKey](popover);
        }

        util.trigger('beforeUpdatePosition', popover);

        positioningObj = {
          top: offset.top + "px",
          left: offset.left + "px"
        }

        if (A.capabilities.isMetroIEGuess && A.capabilities.isIETouchCapable) {
          positioningObj.opacity = 1;
        } else {
          positioningObj.visibility = "visible";
        }

        $popover.css(positioningObj);

        // Focus on popover, if:
        // - This is not the first update (the first update is always called from the show method which will call focus)
        // - The current focus is out of popover
        // - Prevent losing focus on form elements inside popover upon resizing
        // - Only call focus when we need to update for other reasons (resizing)
        // - only if the focusWhenShown option is set to true
        // - when content has been loaded (wait for the ajax response)
        if (popover.isContentLoaded() && $(document.activeElement).closest(popover.$popover).length === 0 && popover.attrs("focusWhenShown") === true) {
          popover.focus();
        }

        if ($inner.length && (!$inner[0].style.height || $inner[0].style.height === "auto")) {
          // outerHeight() measures height + padding + border
          var popoverHeight = $popover.outerHeight() || 0;
          // outerHeight(true) measures height + padding + border + margin.
          // Only one of .a-popover-header or .a-modal-close-nohead-top will match.
          var headerHeight = $popover.find(".a-popover-header, .a-modal-close-nohead-top").outerHeight(true) || 0;
          var footerHeight = $popover.find(".a-popover-footer").outerHeight(true) || 0;
          // inner height must not have margin, otherwise height update below is incorrect.
          var innerHeight = $inner.outerHeight() || 0;
          var maxInnerHeight = popoverHeight - headerHeight - footerHeight;
          if (innerHeight > maxInnerHeight) {
            $inner.css({
              height: maxInnerHeight + "px",
              "overflow-y": "scroll"
            });
          }
        }

        util.trigger('afterUpdatePosition', popover);
        util.trigger('positionUpdated', popover); //for backward compatibility

        A.each(popover.chil    });
      };

      // Reset the offset to ensure that the position is calculated correctly
      if (popover.attrs("immersive") && (A.capabilities.mobile || A.capabilities.tablet)) {
        $popover.css({
          top: 0,
          left: 0
        });
        A.    }, 0);
      } else {
        _runUpdate();
      }
    }

    return popover;
  };

  /**
   *  Get attributes from attrs hash
   *
   *  @public
   *  @param {array|string|null} keys  list of attributes to fetch
   *  @param {object} value  value to set for SET case
   *
   *  @return {string|integer|object|null} for GET
   *  @return {object}  this for SET
   */
  prototype.attrs = function (keys, value) {
    var popover = this;

    if (value === undefined && typeof keys !== 'object') {
      //GET
      if (!keys) {
        return this.attributes;
      } else if (typeof keys === "string") {
        return this.attributes[keys] !== undefined ? this.attributes[keys] : null;
      } else {
        return null;
      }
    } else {
      //SET
      if (typeof keys === 'object') {
        A.each(    });
      } else if (typeof keys === "string") {
        this.attributes[keys] = value;

        //TODO right now we do not have a good idea on what each dependencies passes to popover in and how they use it,
        //     eventually we will only allow dependencies to mess around with using popover.attrs(),
        //     need to remove this when we have better control of our attributes
        popover[keys] = value;
      }
      return this;
    }
  };

  /**
   *  @public
   *
   *  @return {object}  popover instance
   */

  prototype.hideChild;
  };


  prototype.focus = function() {
    var popover = this;
    var $window = $(window);
    var scrollTop = $window.scrollTop();
    var offsetTop = popover.$popover.offset().top;

    // In Windows mobile 8.0/8.1, when we focus on a DOM that is above current viewport, the viewport
    // scrolls(windows mobile 8.0) or jumps(windows mobile 8.1) to 0 no matter where the DOM offset is.
    // To workaround this, we scroll viewport to show the to be focused DOM before we set the focus.
    if (IS_IE_MOBILE && scrollTop > offsetTop) {
      $window.scrollTop(offsetTop);
    }
    A.    }, 0);

    return this;
  }

  return {
    PopoverClass: PopoverClass
  };
});
/////////////////////////
// END FILE js/base/popover_objectclass.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/changeover/changeover.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Changeover code for AUI Popover

'use strict';

P.when('jQuery', 'ready').register('a-changeo});
});
/////////////////////////
// END FILE js/changeover/changeover.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/data_strategies/popover_ajax_strategy.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Data source strategies for popover

'use strict';

P.when('A', 'a-popover-util').register('a-popover-ajax-strategy', function (A, util) {
  var undefined,
    $ = A.$,
    AJAXFAILMSG = "Sorry, content is not available.",
    TIMEOUT = 10000,
    STRATEGY_NAME = "ajax";

  return {
    name: STRATEGY_NAME,

    reusePopover: false,

    loadContent: function (popover, isFirstRender) {
      popover.setContentLoading();
      var url = popover.attrs("url"),
        timeout = popover.attrs("timeout") || TIMEOUT,
        ajaxFailMsg = popover.attrs("ajaxFailMsg") || AJAXFAILMSG,
        cache = !! popover.attrs("cache"),
        spinnerTimer = popover.attrs("spinnerTimer"),
        ajaxHandler = popover.attrs("ajaxHandler");

      /**
       * @deprecated
       * content param is an ultimate param that overrides existing content no matter which strategy it uses
       * performing the override here if content param has been changed and ignoring default dataStrategy
       * content-loading method
       */
      var content = popover.attrs("content");
      popover.attrs("content", null);

      // There is a requirement that when a popover is not initialized, any "content" changes done to ajax popovers will be removed, thus this rule
      if (content && !isFirstRender) {
        popover.updateContent(content);

        // Stop potential timers and XHRs
        if (spinnerTimer) {
          clearTimeout(spinnerTimer);
        }
        if (ajaxHandler && ajaxHandler.abort) {
          ajaxHandler.abort();
        }
      } else {
        var shouldProcessResponse = function() {
          return !popover.attrs("content")
              && popover.attrs("currentDataStrategy") === STRATEGY_NAME
              && (popover.isVisible() || popover.isActive());
        }

        // To prevent the spinner coming out for a split second for fast content,
        // that the spinner might flashes and scares users
        spinnerTimer = A.delay(function () {
          // Only process when the strategy and override doesn't change
          if (shouldProcessResponse()) {
            util.showSpinner(popover);
            popover.setAriaBusy(true);
          }
        }, 100);

        var updateContent = function(content, ajaxStatus, triggerContentLoaded) {
          // Only process when the strategy and override doesn't change
          // Don't update the content if the user closed the popover while the content was loading
          if (shouldProcessResponse()) {
            clearTimeout(spinnerTimer);
            popover.setContentLoaded();
            util.trigger(ajaxStatus, popover);
            popover.setAriaBusy(false);
            popover.update({'content' : content});

            if (popover.isActive()) {
              popover.updatePosition();
            }

            if (triggerContentLoaded) {
              util.trigger('ajaxContentLoaded', popover);
            }
          }
        }

        ajaxHandler = A.ajax(url, {
          type: 'GET',
          timeout: timeout,
          cache: cache,
          suc    },

          e    }
        });

        popover.attrs({
          "spinnerTimer": spinnerTimer,
          "ajaxHandler": ajaxHandler
        });
      }
      return this;
    },

    unloadCon    },

    shouldRefreshCon    },

    isValidStrategy: function (attributes) {
      return !!attributes.url;
    }
  };
});
/////////////////////////
// END FILE js/data_strategies/popover_ajax_strategy.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/data_strategies/popover_inline_strategy.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Data source strategies for popover

'use strict';

P.when('A', 'a-popover-util').register('a-popover-inline-strategy', function (A, util) {
  var undefined,
    $ = A.$;

  return {
    name: "inline",

    reusePopover: false,

    loadContent: function (popover) {
      popover.setContentLoading();
      /**
       * @deprecated
       * content param is an ultimate param that overrides existing content no matter which strategy it uses
       * performing the override here if content param has been changed and ignoring default dataStrategy
       * content-loading method
       */
      var content = popover.attrs("content");

      if (content) {
        popover.attrs("content", null);
      }

      if (!content) {
        var $trigger = popover.$trigger;
        var actionName = $trigger.data("action");
        var data = $trigger.data(actionName) || {};
        content = data.inlineContent ? data.inlineContent : null;
      }

      if (!content) {
        content = popover.attrs("inlineContent");
      }

      popover.updateContent(content);
      popover.setContentLoaded();
      return this;
    },

    unloadContent: function (popover) {
      // Update the content on the trigger node to ensure any forced refresh
      // maintains the updated content
      var contentDOM = popover.getContent();
      var inlineContent = contentDOM && contentDOM.length > 0 ? contentDOM.html() : popover.attrs("inlineContent");
      var $trigger = popover.$trigger;
      var actionName = $trigger.data("action");
      var data = $trigger.data(actionName) || {};
      data.inlineContent = inlineContent;
      $trigger.data(actionName, data);

      // Now clear out whatever's there
      util.clearContent(popover);
      return this;
    },

    shouldRefreshContent: function (popover) {
      return popover.isDirty();
    },

    isValidStra    }
  };
});
/////////////////////////
// END FILE js/data_strategies/popover_inline_strategy.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/data_strategies/popover_preload_strategy.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Data source strategies for popover

'use strict';

P.when('A', 'a-popover-util').register('a-popover-preload-strategy', function (A, util) {
  var undefined,
    $ = A.$;

  /**
   *  Search the DOM for preloaded content associated with the popover with a given name.
   *
   *  @private
   *  @param {string} name  popover name
   *
   *  @return {Document Fragment|false}  A document fragment containing the HTML for the popover content or false if content was not found
   */

  function _getPreloadContent(name) {
    var $preloadContent = $('#a-popover-' + name);
    $preloadContent.detach();

    if ($preloadContent.length) {
      // If we copy the HTML, then some style attributes like _margin-right will
      // be re-processed and removed by the browser.  Since we want to preserve
      // those, we'll need to move the entire DOM node as is.
      var contentDiv = $preloadContent[0];
      var fragment = document.createDocumentFragment();
      while (contentDiv.firstChild) {
        fragment.appendChild(contentDiv.firstChild);
      }
      return fragment;
    } else {
      return false;
    }
  }

  /**
   *  Get or create a preload div for a popover
   *
   *  @private
   *  @param {string} name  The name of the popover
   *
   *  @return {DOM node}  The preload div
   */

  function _getPreloadContentDiv(name) {
    var preloadName = 'a-popover-' + name;
    var $preloadContent = $('#' + preloadName);
    var preloadContent;

    // Use or create a preload DOM, reset content
    if (!$preloadContent.length) {
      preloadContent = document.createElement("div");
      preloadContent.id = preloadName;
      preloadContent.className = "a-popover-preload";
      document.body.appendChild(preloadContent);
    } else {
      preloadContent = $preloadContent[0];
    }
    return preloadContent;
  }

  /**
   *  Replace the contents of a popover preload div.
   *
   *  @private
   *  @param {DOM Node} div  The preload div
   *  @param {string|DOM Node}  The new content
   */

  function _replacePreloadContent(div, content) {
    if (typeof content === "string") {
      $(div).html(content);
    } else {
      var fragment = document.createDocumentFragment();
      while (content.firstChild) {
        fragment.appendChild(content.firstChild);
      }
      div.appendChild(fragment);
    }
  }

  /**
   *  Put(Move) the preload content back to "#a-popover-<name>", before the popover is removed
   *
   *  @private
   *  @param {string} name  popover name
   *  @param {object} popover
   */

  function _putPreloadContent(name, popover) {
    var $content = popover.getContent();

    // Do not process if the popover does not support getContent
    // or there is no content to unload
    if (!$content || !$content.html()) {
      return;
    }

    var preloadContent = _getPreloadContentDiv(name);

    // Add the existing content back to the preload div if the user hasn't updated the content
    var html = A.trim(preloadContent.innerHTML);
    if (!html) {
      _replacePreloadContent(preloadContent, $content[0]);
    }

    // Empty popover's content
    util.clearContent(popover);
  }

  return {
    name: "preload",

    reusePopover: true,

    loadContent: function (popover) {
      popover.setContentLoading();
      var name = popover.attrs("name");

      /**
       * @deprecated
       * content param is an ultimate param that overrides existing content no matter which strategy it uses
       * performing the override here if content param has been changed and ignoring default dataStrategy
       * content-loading method
       */
      var content = popover.attrs("content");
      popover.attrs("content", null);

      // Even if we use content override, we still need to remove preload content in order not
      // to treat as new content, therefore we are getting(removing) content in preload div anyway
      var preloadContent = _getPreloadContent(name);

      if (content) {
        popover.updateContent(content);
      } else if (name) {
        popover.updateContent(preloadContent);
      }
      popover.setContentLoaded();
      return this;
    },

    unloadContent: function (popover) {
      var name = popover.attrs("name");
      if (name) {
        _putPreloadContent(name, popover);
      }
      return this;
    },

    shouldRefreshContent: function (popover) {
      var name = popover.attrs("name"),
        $preload = name ? $('#a-popover-' + name) : null;
      return !!($preload && $preload.length && $preload.html() !== "")
    },

    isValidStrategy: function (attributes) {
      // This strategy is valid if attr name exist and its popover preload content exists
      if (!attributes.name) {
        return false;
      }

      // Since we remove preload container when preload content is used,
      // if the current data strategy is preload, we can restreo the preload container div
      // thus preload is still a valid strategy
      if (attributes.currentDataStrategy === "preload") {
        return true;
      }

      var preloadName = 'a-popover-' + attributes.name;
      var $preloadContent = $('#' + preloadName);
      return !!$preloadContent.length;
    }
  };
});
/////////////////////////
// END FILE js/data_strategies/popover_preload_strategy.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base_positions.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Dropdown positions - standard file for desktop/non-touch devices
 *
 */

'use strict';

P.when('A').register('a-dropdown-base-positions', function (A) {
  var undefined,
    $ = A.$;

  function nativeDropdownDefineTop($popover, position, coords, triggerTopSpace, triggerBottomSpace) {
    var $inner = $popover.find(".a-popover-inner"),
      totalSpace;

    if (triggerTopSpace > triggerBottomSpace && triggerBottomSpace < coords.popoverHeight) {
      totalSpace = triggerTopSpace;
      position.top = triggerTopSpace < coords.popoverHeight ? coords.triggerBottom - triggerTopSpace : coords.triggerBottom - coords.popoverHeight;
    } else {
      totalSpace = triggerBottomSpace;
      position.top = coords.triggerTop;
    }

    //css changes
    $inner.css('height', totalSpace < coords.popoverHeight ? totalSpace - coords.headerHeight + "px" : "auto");
    if (coords.popoverHeight > totalSpace) {
      $inner.addClass("a-lgtbox-vertical-scroll");
    } else {
      $inner.removeClass("a-lgtbox-vertical-scroll");
    }
    return position;
  }

  return {
    /**
     *  Determine top/left of the split dropdown,
     *  and some css changes that I think should be moved somewhere
     *
     *  @public
     *  @param {Object} options  hash of info from popover_position
     *
     *  @return {Object}  top/left values
     */

    // TODO [AUIQA-1172] is fixed for mobile only due to the initial root cause
    // is limited in mobile. However, if the limitation changes in the future
    // (i.e. launching SKY in desktop), we need to apply the fix to desktop, too.
    positionStrategy: function (options) {
      var $popover = options.$popover,
        $trigger = options.$trigger,
        measure = options.measure,
        $inner = $popover.find(".a-popover-inner");

      //css reset for inner before measure() is done
      $inner.css({
        "min-width": "0px",
        "width": "auto",
        "height": "auto"
      });

      var $triggerBtn = $trigger.closest(".a-button-dropdown");
      if (!$triggerBtn.length){
        $triggerBtn = $trigger.closest(".a-button-group");
      }

      var coords = measure($popover, $triggerBtn);
      var popoverRightSpace = coords.windowWidth - (coords.triggerLeft + coords.popoverWidth);
      var triggerTopSpace = coords.triggerTop - coords.windowTop;
      var triggerBottomSpace = coords.windowBottom - coords.triggerBottom;
      var triggerRightSpace = coords.windowWidth - coords.triggerLeft - coords.triggerWidth;
      var triggerLeftSpace = coords.triggerLeft;
      var position = nativeDropdownDefineTop($popover, {}, coords, triggerTopSpace, triggerBottomSpace);

      // If left unchecked, the vertical scroll bar in Windows desktop browsers can eat into the
      // width of its container and end up covering up text in the "options" or making the
      // padding look wrong. We also need to be sure to set the width before the position
      // to ensure accurate positioning in a right aligned trigger use case.
      //
      // Switched from checking overflow-y scroll as that is getting overridden elsewhere
      // in the Popover code to "auto" and it was getting set to scroll as a result of
      // this class, so checking for this class, instead, accomplishes the same end.
      if ($inner.hasClass("a-lgtbox-vertical-scroll") && navigator.appVersion.indexOf("Windows") > -1) {
        var width = Math.max(coords.popoverWidth, coords.triggerWidth) + A.scrollBarWidth(true);
        $inner.width(width);
      } else {
        $inner.css("min-width", coords.triggerWidth + "px");
      }
      coords.popoverWidth = $popover.width();

      if (popoverRightSpace < 50 && triggerLeftSpace > triggerRightSpace) {
        position.left = coords.triggerRight - coords.popoverWidth;
      } else {
        position.left = coords.triggerLeft;
      }

      return position;
    }
  }
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base_positions.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/base/dropdown_base_view_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Common methods for Dropdowns
 *
 */

'use strict';

P.when('A', 'a-dropdown-base-positions').register('a-dropdown-base-view-base', function (A, positions) {
  var undefined,
    $ = A.$;

  /**
   *  Popover lock level
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LOCK_SYSTEM = 1;

  return A.extend(positions, {
    /**
     *  method to update dropdown popover content
     *
     *  @public
     *  @param {string|DOM Node} content
     */
    updateContent: function (content) {
      if (typeof content === "string") {
        this.$popover.find('.a-popover-inner').html(content);
      } else if (content) {
        this.$popover.find('.a-popover-inner').html("").append(content);
      }
    },

    /**
     *  Operations before standard show function completes
     *
     *  @public
     */
    beforeShowMethod: function () {
      this.parent.lock(LOCK_SYSTEM);

      // NOTE: we are not using aria-owns here b/c it causes
      // JAWS to read off all the contents of the list of options
      // as one giant string when closing the dropdown and focusing
      // on the dropdown button. This bug appeared in JAWS
      // 16.0.2339
      this.$trigger.attr("aria-pressed", true);
    },

    /**
     *  Operations after standard show function completes
     *
     *  @public
     */

    afterShowMethod: function () {
      var $popover = this.$popover,
        $selected = $popover.find(".a-active");

      // Ensure the selected or first item has focus for accessibility
      A.delay(function () {
        if ($selected.length) {
          $selected.closest("li").focus();
        } else {
          $selected = $popover.find("li").first().focus();
        }
      }, 0);
    },

    /**
     *  Operations before standard hide function completes
     *
     *  @public
     */

    beforeHideMe    },

    /**
     *  Operations after standard hide function completes
     *
     *  @public
     */

    afterHideMethod: function () {
      this.$trigger.attr("aria-pressed", false);
      var $popover = this.$popover;

      $popover.css("width", "auto");
    }
  });
});
/////////////////////////
// END FILE js/dropdowns/base/base/dropdown_base_view_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Dropdown base view
 *
 */

'use strict';

P.when('A', 'a-dropdown-base-view-base').register('a-dropdown-base-view', function (A, viewBase) {
    return viewBase;
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Base class for dropdown, providing pointers to show popovers and manipulate select tags
 */
"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */

P.when("A", "a-popover-base-factory", "a-dropdown-base-view").register("a-dropdown-base-factory", function (A, baseFactory, view) {
  var $ = A.$;
  var POPOVER_TYPE = "dropdown";
  var firstAfterGroup = false;
  var idCount = 1;

  /**
   *  The CSS class of the container of any dropdown list
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var INNER_CLASS = "a-popover-inner";

  /**
   *  Given a jQuery wrapped <option> tag, generate the corresponding <li>
   *  from the data attributes present
   *
   *  @private
   *  @param {DOM node} $option  jQuery wrapped <option> to process
   *  @param {boolean} preselected  Is this option supposed to be selected by default
   *
   *  @return {string}  The HTML for the <li>
   */

  function _makeRichOption($option, preselected, labelId) {
    var li = ['<li tabindex="0" role="option"'];
    var optionClass = $option.data('aCssClass');
    var optionId = $option.data('aId');
    var htmlContent = $option.data('aHtmlContent');
    var imageSource = $option.data('aImageSource');

    // The value should be set in the data attribute as an object to prevent the data API from type coercing a zero padded number to an integer, which messes everything up.
    // Since we're using string buffers, we also have to watch out for double quotes in the data-value string and the existing value, so go ahead and play with that as well
    // AUI-8874 we need to properly escape both json and HTML.
    var anchorDataValue = JSON.stringify({ 'stringVal': $option.val() });
    var anchor = ['<a tabindex="-1" href="javascript:void(0)" data-value="', A.escapeHtml(anchorDataValue), '"'];
    var anchorClasses = ["a-dropdown-link"];
    var liClasses = ["a-dropdown-item"];
    var content;

    if (preselected) {
      anchorClasses.push("a-active");
      li.push(' aria-checked="true"');
    }

    if (firstAfterGroup && (A.capabilities.mobile || A.capabilities.tablet)) {
      anchorClasses.push("a-list-link-after-group");
    }
    firstAfterGroup = false;

    if (optionClass) {
      liClasses.push(optionClass);
    }

    if (optionId) {
      li.push(' id="' + optionId + '"');
    }

    li.push('aria-labelledby="');
    li.push(labelId);
    li.push('"');

    anchor.push(' id="');
    anchor.push(labelId);
    anchor.push('"');

    li.push(' class="' + liClasses.join(" ") + '"');
    li.push('>');

    if (htmlContent) {
      content = htmlContent;
    } else {
      content = [];
      if (imageSource) {
        anchorClasses.push("a-option-has-image");
        content.push('<img src="' + imageSource + '" class="a-rich-option-image" />');
      }
      content.push($option.html());
      content = content.join('');
    }
    anchor.push(' class="');
    anchor.push(anchorClasses.join(' '));
    anchor.push('">');
    anchor.push(content);
    anchor.push('</a>');

    li.push(anchor.join(''));
    li.push('</li>');
    return li.join('');
  }

  /**
   *  Generate the HTML for the actual list which serves as the dropdown for a corresponding <select> tag.
   *
   *  @private
   *  @param {DOM Node} The jQuery wrapped <select> node
   *
   *  @return {string}  The HTML for the popover list
   */

  function _subskin($select) {
    if (!$select.jquery) {
      $select = $($select);
    }
    var $children = $select.children('optgroup,option:not(.a-prompt)');
    var trailingDivider = false;
    var select = $select[0];
    var selectId = $select.attr('id') ? $select.attr('id') : "dropdown" + idCount++;

    var selectValue;
    var buffer;

    if (select.selectedIndex > -1) {
      selectValue = select.options[select.selectedIndex].value;
    }

    // Use role="application" so we can handle ARROW, ENTER, and ESCAPE keys
    // ourselves in JAWS screen reader.  This isn't ideal.  NVDA worked
    // fine without it, but JAWS would not do what we wanted without this change.
    buffer = ['<ul tabindex="-1" class="a-nostyle a-list-link',
      $select.data('a-has-images') ? ' a-box-list' : '',
      '" role="application" aria-multiselectable="false">'
    ];

    var count = 0;
    $children.each(function () {
      var $child = $(this);
      if ($child.is('optgroup')) {
        $child.children()    });
        buffer.push('<li tabindex="-1" class="divider"><hr /></li>');
        firstAfterGroup = true;
        trailingDivider = true;
      } else {
        // Child is <option>
        buffer.push(_makeRichOption($child, selectValue === this.value, selectId + '_' + count++));
        trailingDivider = false;
      }
    });

    if (trailingDivider) {
      buffer.pop();
    }

    buffer.push('</ul>');
    return buffer.join('');
  }

  /**
   * Base Dropdown popover creation, allowing overriding from child dropdowns
   *
   * @public
   * @param {object} $trigger   jQuery wrapped DOM of the trigger
   * @param {object} options    A dropdown-specific options object for the dropdown
   * @param {object} childView  Display-related functions that are specific to the popover type
   *
   * @return {object} popover
   */
  function create($trigger, options, childView) {
    var $button = options.$button,
      $sourceSelect = options.$sourceSelect,
      sourceSelect = $sourceSelect[0],
      $dropdownLabel = $button.find(".a-dropdown-label");

    var s    };

    var header = $sourceSelect.data("aTouchHeader");
    if (!header || (!header.length && $dropdownLabel.length)) {
      header = $dropdownLabel.text();
    }

    var attributes = {
      type: POPOVER_TYPE,
      header: header,
      closeButtonLabel: options.closeButtonLabel ? options.closeButtonLabel : "Close",
      inlineContent: $sourceSelect,
      position: options.position,
      alone: true,
      sourceSelect: $sourceSelect,
      sourceButton: $button,
      name: $sourceSelect[0].name,
      preventNameReuse: true,
      lightboxOptions: A.capabilities.mobile || A.capabilities.tablet ? {
        showDuration: A.capabilities.ios ? null : 0,
        hideDuration: 0
      } : null
    };

    return baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: A.extend({}, view, childView, {
        skin: skin
      }),
      actionCheck: false
    });
  }

  //extending methods from popover baseFactory
  return A.extend({
    create: baseFactory.create,
    remove: baseFactory.remove,
    get: baseFactory.get
  }, {
    type: POPOVER_TYPE,
    create: create
  });
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
'use strict';

/**
 * Events and delegations for all types of Dropdowns
 *
 * Nothing to do for desktop.
 */
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/keyboard_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Events and delegations for all types of Dropdowns
 *
 */

'use strict';

P.when('A', 'a-dropdown-base-factory').register('a-dropdown-keyboard-handlers', function (A, factory) {
  var $ = A.$;
  var KEYS = A.constants.keycodes;

  // Number of milliseconds before a dropdown will "forget" what the user was typing,
  // for the purpose of keyboard navigation.
  var KEYBOARD_NAVIGATION_TIMEOUT = 1000;

  // Data attributes //
  // Index of the last prefix match, or -1 if no possible match
  var USER_NAVIGATED_IDX = "a-user-navigated-idx",
    // What the user has entered so far, for keyboard navigation
    USER_NAVIGATED_TEXT = "a-user-navigated-text",
    // The debounced method for resetting the idx and text fields
    USER_NAVIGATED_DEBOUNCER = "a-user-navigated-debouncer";

  /**
   * Reset all state related to keyboard navigation to its default state.
   *
   * @param {object} $el  The jQuery object representing the node to reset.
  ;
  }

  /**
   * Get the highlighted (focused or checked) option in the list (dropdown)
   *
   * @private
   *
   * @param {jQueryElement} list The dropdown list.
   */
  function _getHighlighted($list) {
    // if an option has focus, start there
    var $highlighted = $list.find(':focus');

    // otherwise start with the checked option
    if($highlighted.length < 1) {
      $highlighted = $list.find('[aria-checked="true"]');
    }

    return $highlighted;
  }

  /**
   * Change the focused element
   *
   * @param {jQueryElement} $from the previously focused element
   * @param {jQueryElement} $to the element to be focused
   */
  function _changeFocus($from, $to) {
    // TODO don't just focus, for mobile need to set appropriate "active" classes
    $from.removeAttr('aria-selected');

    // don't select dividers, only real options
    if($to.attr('role') === 'option') {
      $to.attr('aria-selected', 'true');
    }

    $to.focus();
  }

  function _getCurrent($current) {
    var $list = $current.parent('ul');

    // select the <ul> element (so we can boundary check)
    var $options = $list.find('li');

    // get the index of the selected element
    var $highlighted = _getHighlighted($list);

    return {
      index: ($highlighted.length > 0) ? $highlighted.index() : 0,
      $options: $options
    }
 ;
  }

  function keyDownHandler(event) {
    /*jshint validthis:true */
    var $current = $(this),
      $parent = $current.parent();

    switch (event.which) {
    case KEYS.UP_ARROW:
      event.preventDefault();
      _clearNavigationState($parent);

      if(_getCurrent($current).index > 0) {
        _changeFocus($current, $current.prev());
      }

      break;

    case KEYS.DOWN_ARROW:
      event.preventDefault();
      _clearNavigationState($parent);

      var currentData = _getCurrent($current);
      var index = currentData.index;

      if(index >= 0 && index + 1 < currentData.$options.length) {
        _changeFocus($current, $current.next());
      }

      break;

    case KEYS.ENTER:
      _spaceHandler(event, $current, $parent);

      break;

    case KEYS.ESCAPE:
      event.preventDefault();
      var popover = factory.get($current.closest(".a-popover"));
      popover.sourceButton.find(".a-button-text").focus();
      popover.hide();
      _clearNavigationState($parent);

      break;

    case KEYS.SPACE:
      if (!$parent.data(USER_NAVIGATED_TEXT)) {
        _spaceHandler(event, $current, $parent);
      }

      break;

    case KEYS.TAB:
      // clear state, everything else is normal tab behavior
      // handled elsewhere

      _clearNavigationState($parent);

      break;

    // People might hit backspace in an attempt to correct their autocomplete.
    // In Chrome, with a standard <select>, backspace does *nothing*. It doesn't
    // edit the queried text, and importantly, does *not* navigate backwards
    // through the browser history. We mimic that behavior here.
    case KEYS.BACKSPACE:
      event.preventDefault();
      break;
    }
  }

  function _navigationDebouncer($parent) {
    var debouncer = $parent.data(USER_NAVIGATED_DEBOUNCER);

    if (!debouncer) {
      debouncer = A.debounce(function() {
        _clearNavigationState($parent);
      }, KEYBOARD_NAVIGATION_TIMEOUT);

      $parent.data(USER_NAVIGATED_DEBOUNCER, debouncer);
    }

    debouncer();
  }

  function keyPressHandler(event) {
    /*jshint validthis:true */
    var $current = $(this),
      $parent = $current.parent(),
      popover = factory.get($current.closest(".a-popover")),
      key = event.which;

    // Abort if the popover is actually closed, i.e. it was closed by the preceding keyDown handler.
    if (!popover || !popover.isActive()) {
      return;
    }

    // we don't want to match TAB as a character, and TAB nav handled elsewhere
    if(key === KEYS.TAB || key === 0) {
        return;
    }

    /**
     * Keyboard navigation notes:
     * 1) Uses keydown, which is unreliable (read: unusable) for punctuation characters
     *    (See http://www.quirksmode.org/js/keys.html#link5 Punctuation keys)
     * 2) Clears state KEYBOARD_NAVIGATION_TIMEOUT milliseconds after the last keypress.
     * 3) Because this is a prefix search, this optimizes subsequent keypresses by not
     *    rescanning elements that couldn't possibly match.
     * 4) Ignores backspace.
     * 5) If no match can be found, the current state is "poisoned" so we won't keep checking
     *    until the state is cleared.
     * 6) Because of optimizations made herein, modifying the dropdown options, even via API,
     *    will result in undefined behavior if the user is in the middle of typing.
     * 7) If the user hits a key that closes the popover (e.g. Enter), clearNavigationState
     *    will ultimately be called twice -- once immediately when Enter is hit, and again
     *    when the navigationDebouncer finally executes.  However, this is harmless; the
     *    "clear on Enter" case is vital so the state is clean if the dropdown is quickly
     *    reopened; and tracking enough state to keep the debouncer from actually executing
     *    would be a bit of a pain.
     */

    // We want to "reset" the state after a bit so they can start over with a new query.
    _navigationDebouncer($parent);

    var startingIndex = $parent.data(USER_NAVIGATED_IDX) || 0;

    if (startingIndex < 0) {
      // Query is doomed, no possible match.
      return;
    }

    // Append onto the text so far, unless it's whitespace.
    var query = ($parent.data(USER_NAVIGATED_TEXT) || '') + String.fromCharCode(key).toLocaleLowerCase();
    $parent.data(USER_NAVIGATED_TEXT, query);

    var $optionsToCheck = $parent.children();

    // Optimization: skip ahead to the last found entry and start searching from there.
    for (var i = startingIndex; i < $optionsToCheck.length; i++) {
      var $option = $optionsToCheck.eq(i);

      if (A.trim($option.text().toLocaleLowerCase()).indexOf(query) === 0) {
        $option.focus();
        $parent.data(USER_NAVIGATED_IDX, i);
        return;
      }
    }

    // Mark query as doomed, no possible match, since nothing has been found so far.
    $parent.data(USER_NAVIGATED_IDX, -1);

    // if it hasn't matched and the final key was a space, select the option
    if(key === KEYS.SPACE) {
      _spaceHandler(event, $current, $parent);
    }
  }

  return {
    keyDown: keyDownHandler,
    keyPress: keyPressHandler
  };
});
/////////////////////////
// END FILE js/dropdowns/base/keyboard_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Base class for dropdown, providing pointers to show popovers and manipulate select tags
 *
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */

P.when("A", "a-dropdown-select-apis", "a-dropdown-base-factory", "a-popover-base").register("a-dropdown-base", function (A, dropdownSelect, factory, popoverBase) {
  var undefined,
    $ = A.$;

  /**
   * Creates and shows the popover which serves as the proxy <select> tag
   *
   * @private
   * @param {object} event  The declarative event which triggered the creation of the popover
   * @param {object} typeSpecificFunctions  Display-related functions that are specific to the popover type
   */
  function showDropdown(event, options, typeSpecificFunctions) {
    // IE 8 somtimes throws an error when attempting to do things
    // to the event.  The jist is by the time you attempt to prevent default,
    // the event object has been replaced or invalidated, even if in a closure.  This
    // causes a "member not found" error to be thrown.  Related jQuery bug is
    // marked "won't fix".  Corresponding MS bug exists, but very little activity,
    // and nothing from MS. You have to register with their feedback thing to get
    // a non-404 page with the MS link, unfortunately.
    //   jQuery:  http://bugs.jquery.com/ticket/12577
    //   MS:  https://connect.microsoft.com/IE/feedback/details/774078
    try {
      event.$event.preventDefault();
    } catch (e) {}

    // To allow the preventClickThrough stuff to work, we need to give the timer a chance to fire.
    A.delay(function () {
      var $button = options.$button ? options.$button : options.getButtonFromEvent(event),
        $sourceSelect = options.$select ? options.$select : options.getSelectFromEvent(event);

      if (!$button.hasClass("a-button-disabled")) {
        // Refresh popover if the content in the popover is different than in <select>
        var selectInstance = getSelect($sourceSelect, options);
        if (!selectInstance.isSynced()) {
          refreshPopover($.extend({
            $button: $button,
            $select: $sourceSelect
          }, options));
        }

        // Variables to initiate a popover
        var $trigger = event.$declarativeParent,
          newOptions = A.extend({}, options, {
            $button: $button,
            $sourceSelect: $sourceSelect
          }),
          popover = factory.create($trigger, newOptions, typeSpecificFunctions);

        if (popover) {
          popover.show();
          $button.data("a-popover-id", popover.id).data("popover", popover).data("isPressed", true);

          // When images haven't been loaded, the height and width are small.  However, after loading,
          // they can affect the total height of the popover.  Ensure that when images are loaded,
          // the popover has been resized and/or made scrollable to accommodate the new size.
          if (!popover.hasOnLoad) {
            popover.hasOnLoad = true;
            var deferreds = [];
            var $images = popover.$popover.find("img");
            if ($images.length) {
              $images    });

              if (deferreds.length) {
                $.when.apply($, deferreds).done(function () {
                  popover.updatePosition();
                });
              } else {
                popover.updatePosition();
              }
            }
          }
        }
      }
    });
  }

  /**
   *  @deprecated
   *  A default event handler which will toggle the visible state of the dropdown popover
   *  and create it if necessary.  Calling this function will also update the data/aria
   *  attributes to accurately reflect the state of the popover.
   *
   *  @public
   *  @param {object} event  The event which triggered this function
   *  @param {object} mandatory options hash
   */

  function toggleDropdown(event, options) {
    var $button = options.$button ? options.$button : options.getButtonFromEvent(event),
      popover = $button.data("popover");

    if (popover && popover.$popover.is(":visible")) {
      popover.hide();
    } else {
      showDropdown(event, options);
    }
  }

  /**
   *  Hides the dropdown popover
   *
   *  @public
   *  @param {object} mandantory options hash
   *
   *  @return boolean  if the remove process succeed
   */

  function hidePopover(options) {
    var $button = options.$button;
    var $select = options.$select;

    if (!$button) {
      $button = $select.nextAll(".a-button-dropdown");
    }
    if ($select.length) {
      var popover = factory.get($button);
      if (popover) {
        popover.hide();
      }
      return true;
    }
    return false;
  }

  /**
   *  Refreshes content of dropdown popover, especially after updates
   *
   *  @public
   *  @param {object} mandantory options hash
   *
   *  @return boolean  if the remove process succeed
   */

  function refreshPopover(options) {
    var $button = options.$button;
    var $select = options.$select;

    if (!$button) {
      $button = $select.nextAll(".a-button-dropdown");
    }
    if ($select.length) {
      var popover = factory.get($button);
      if (popover) {
        factory.remove(popover.id);
      }
      $select.data("a-info", null); // Clear cached option info
      return true;
    }
    return false;
  }

  /**
   *  Returns the select object
   *
   *  @public
   *  @param {string} selectNativeIdOrDom  native_id of the select tag
   *  @param {object} mandantory options hash
   *
   *  @return {object}  select object
   */

  function getSelect(selectNativeIdOrDom, options) {
    var $select, select, $button;

    if (options.$select) {
      $select = options.$select;
    } else if (typeof selectNativeIdOrDom === "string") {
      $select = $("select#" + selectNativeIdOrDom);
    } else {
      $select = selectNativeIdOrDom.jquery ? selectNativeIdOrDom : $(selectNativeIdOrDom);
    }
    if (!$select.length) {
      return null;
    }

    if (options.$button) {
      $button = options.$button;
    } else {
      $button = options.getButtonFromSelect($select);
    }

    if (!$select.data("a-select")) {
      select = A.extend({
        hidePopover: hidePopover,
        refreshPopover: refreshPopover,
        options: A.extend({
          $select: $select,
          $button: $button
        }, options)
      }, dropdownSelect);
      $select.data("a-select", select);
    } else {
      select = $select.data("a-select");
    }
    return select;
  }

  return {
    toggleDropdown: toggleDropdown,
    showDropdown: showDropdown,
    getSelect: getSelect
  };
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_options_apis.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown options APIs
 *
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */
P.when("A", "jQuery").register("a-dropdown-options-apis", function (A, $) {
  var undefined;
  /**
   *  Updates the native <option> with the given ID and invalidate the cached popover, if it exists.
   *  Only options exposed on the dropdownOption tempate are accepted.  Any other options which
   *  are passed will be ignored.  Any options which are not passed in will remain the same.
   *
   *  @public
   *  @param {object} hash  A hash of new option values to set on the <option>
   */

  function update(hash) {
    /*jshint validthis:true */
    if (typeof hash !== "object") {
      P.error("input of options.update() function must be a hash");
    }

    this.hidePopover(this.options);

    for (var i = 0, last = this.size(); i < last; i++) {
      var $item = this.options.elements[i];
      var item = $item[0];

      if (hash.value) {
        $item.val(hash.value);
      }

      if (hash.selected !== undefined) {
        if (!item.selected && hash.selected) {
          this.options.$select.val(item.value);
        } else if (item.selected && !hash.selected) {
          this.options.$select.val("");
        }
      }

      if (hash.html_content) {
        $item.data("a-html-content", hash.html_content);
      }

      if (hash.image_source) {
        $item.data("a-image-source", hash.image_source);
      }

      if (hash.native_css_class) {
        item.className = hash.native_css_class;
      }

      if (hash.css_class) {
        $item.data("a-css-class", hash.css_class);
      }

      if (hash.native_id) {
        item.id = hash.native_id;
      }

      if (hash.id) {
        $item.data("a-id", hash.id);
      }

      if (hash.text) {
        $item.text(hash.text);
        if (item.selected) {
          this.setSelectValue(item.value);
        }
      }
    }

    this.refreshPopover(this.options);
    return this;
  }

  /**
   *  remove current set of options
   *
   *  @public
   *
   *  @return {boolean} always true
   */

  function remove() {
    /*jshint validthis:true */

    this.hidePopover(this.options);

    for (var i = 0, last = this.size(); i < last; i++) {
      var $option = this.options.elements[i];

      //remove set value if we are removing this option
      if ($option.is(":selected")) {
        this.setSelectValue("");
      }
      //remove option node
      //potential bug fix when the option is in an option group option is not
      //removed (added by gorkem)
      $option.remove();
    }

    this.refreshPopover(this.options);
    return true;
  }

  /**
   *  get options' info
   *
   *  @public
   *
   *  @return {object}  array of [{text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}]
   */

  function info() {
    /*jshint validthis:true */
    var infoArray = [];

    for (var i = 0, last = this.size(); i < last; i++) {
      var $option = this.options.elements[i];

      infoArray.push({
        value: $option[0].value,
        text: $option.text(),
        selected: $option[0].selected,
        html_content: $option.data('a-html-content'),
        image_source: $option.data("a-image-source"),
        native_css_class: $option[0].className,
        css_class: $option.data("a-css-class"),
        native_id: $option[0].id,
        id: $option.data("a-id")
      });
    }
    return infoArray;
  }

  /**
   *  get options' size
   *
   *  @public
   *
   *  @return {number}  number of items in options array
   */

  function size() {
    /*jshint validthis:true */
    return this.options.elements.length;
  }

  return {
    update: update,
    remove: remove,
    info: info,
    size: size
  };
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_options_apis.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/base/dropdown_select_apis.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown select APIs
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */
P.when("A", "jQuery", "a-dropdown-options-apis").register("a-dropdown-select-apis", function (A, $, dropdownOptions) {
  var undefined;

  /**
   *  When looking for child options, the jQuery selector isn't quite as obvious as you'd think.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var CHILD_OPTION_SELECTOR = "optgroup, option:not(.a-prompt)";

  /**
   *  Disabled css class name for the button
   *
   *  @private
   *  @constant
   *  @type {string}
   */

  var BUTTON_DISABLED_CSS_CLASS = "a-button-disabled";

  /**
   *  Error css class name for the button
   *
   *  @private
   *  @constant
   *  @type {string}
   */

  var BUTTON_ERROR_CSS_CLASS = "a-button-error";

  /**
   *  Toggle the disabled status by the given isDisabled flag.
   *  When isDisabled is true, the dropdown will be disabled.
   *
   *  @private
   *  @param {Element} select The native select element
   *  @param {jquery} $buttonCollection The button collection jquery object
   *  @param {boolean} isDisabled The flag indicating if it should disable the dropdown
   */

  function toggleDisabledDropdown(select, $buttonCollection, isDisabled) {
    // the select doesn't need aria-disabled because screen readers already recognize "disabled" attribute
    select.disabled = isDisabled;

    // toggling disabled css class
    $buttonCollection.toggleClass(BUTTON_DISABLED_CSS_CLASS, isDisabled);

    // toggling a11y aria-disabled attribute
    isDisabled ? $buttonCollection.attr('aria-disabled', 'true') :
      $buttonCollection.removeAttr('aria-disabled');
  }

  /**
   *  Toggle the error status by the given isError flag.
   *  When isError is true, the dropdown's button status will be set to error.
   *
   *  @private
   *  @param {jquery} $buttonCollection The button collection jquery object
   *  @param {boolean} isDisabled The flag indicating if it should disable the dropdown
  ;
  }

  function updateDropdownStatus(select, $button, status) {
    // $buttonCollection will represent one or two buttons
    // depending on dropdown type (standard or split)
    var $buttonCollection = $button
        .closest(".a-dropdown-container, .a-splitdropdown-container")
        .find(".a-button");

    // status flags
    var isDisabled = status === 'disabled',
      isError = status === 'error';

    toggleDisabledDropdown(select, $buttonCollection, isDisabled);
    toggleErrorButton($buttonCollection, isError);
  }
  /**
   * Check if the options is synchronized with content of popover. Since popover recreation
   * requires DOM manipulation, checking two levels of hash values should still be faster.
   *
   * @public
   *
   * @return {boolean} true for the content has not been changed since last dropdown displayed, false otherwise.
   */

  function isSynced() {
    /*jshint validthis:true */
    var $select = this.options.$select,
      prev = $select.data("a-info"),
      current = this.getOptions().info();

    $select.data("a-info", current);

    // No "prev" means popover never displayed, thus it is clean
    return prev ? A.equals(prev, current) : true;
  }

  /**
   *  Updates classes and data attributes on the native <select> node as well as the generated dropdown button.  If the
   *  dropdown is currently "open", it will "close". Only options exposed on the dropdown tempate are accepted.
   *  Any other options which are passed will be ignored.  Any options which are not passed in will remain the same.
   *
   *  @public
   *  @param {object} hash  A hash of new option values for the dropdown template
   *
   *  @return {object} self pointer
   */

  function update(hash) {
    /*jshint validthis:true */
    if (typeof hash !== "object") {
      P.error("input of select.update() function must be an object");
    }

    this.hidePopover(this.options);

    var validSpacing = {
      none: true,
      micro: true,
      mini: true,
      small: true,
      base: true,
      medium: true,
      large: true,
      "extra-large": true,
      "double-large": true,
      block: true
    };
    var $select = this.options.$select;
    var select = $select[0];
    var $button = this.options.$button;
    var button = $button[0];
    var $label = $select.siblings("label");

    if (hash.name) {
      select.name = hash.name;
    }

    if (hash.option_prompt) {
      var $prompt = $select.find(".a-prompt");
      if ($prompt.length) {
        $prompt.text(hash.option_prompt);
        if ($prompt.prop("selected")) {
          $button.find(".a-dropdown-prompt").text(hash.option_prompt);
        }
      } else {
        $select.prepend($("<option class='a-prompt' />").text(hash.option_prompt));
        $button.find(".a-dropdown-prompt").text(hash.option_prompt);
      }
    }

    if (hash.has_images !== undefined) {
      $select.data("a-has-images", !!hash.has_images);
    }

    if (hash.button_size !== undefined && $button.length) {
      if (hash.button_size === "small") {
        $button.addClass("a-button-small");
      } else {
        $button.removeClass("a-button-small");
      }
    }

    if (hash.spacing !== undefined) {
      if (validSpacing.hasOwnProperty(hash.spacing)) {
        var spacingClassRegex = /\ba-spacing-[a-z]+\b/g
        select.className = select.className.replace(spacingClassRegex, "");
        button.className = button.className.replace(spacingClassRegex, "");
        $select.addClass("a-spacing-" + hash.spacing);
        $button.addClass("a-spacing-" + hash.spacing);
      }
    }

    if (hash.grid_units !== undefined) {
      var gridUnitsClassRegex = /\ba-button-span\d{1,2}\b/g;
      select.className = select.className.replace(gridUnitsClassRegex, "");
      button.className = button.className.replace(gridUnitsClassRegex, "");

      if (isFinite(hash.grid_units) && hash.grid_units > 0 && hash.grid_units < 13) {
        $select.addClass("a-button-span" + hash.grid_units);
        $button.addClass("a-button-span" + hash.grid_units);
      }
    }

    if (hash.width_name) {
      if (hash.width_named === "base") {
        $button.addClass("a-button-width-normal");
      } else {
        $button.removeClass("a-button-width-normal");
      }
    }

    if (hash.status) {
      updateDropdownStatus(select, $button, hash.status);
    }

    if (hash.native_id) {
      select.id = hash.native_id;
      if ($label.length) {
        $label[0].htmlFor = hash.native_id;
      }
    }

    if (hash.id) {
      button.id = hash.id;
    }

    if (hash.native_css_class) {
      var nativeClass = $select.data("a-native-class");
      if (nativeClass) {
        $select.removeClass(nativeClass);
      }
      $select.addClass(hash.native_css_class).data("a-native-class", hash.native_css_class);
    }

    if (hash.css_class) {
      var buttonClass = $button.data("a-class");
      if (buttonClass) {
        $button.removeClass(buttonClass);
      }
      $button.addClass(hash.css_class).data("a-class", hash.css_class);
    }

    if (hash.label_text !== undefined) {
      if (hash.label_text === "") {
        $button.find(".a-dropdown-label").remove();
        $select.siblings("label").remove();
      } else {
        var $dropdownLabel = $button.find(".a-dropdown-label");
        if ($dropdownLabel.length) {
          $dropdownLabel.text(hash.label_text);
        } else {
          $button.find(".a-dropdown-prompt").before($("<span class='a-dropdown-label' />").text(hash.label_text));
        }

        if ($label.length) {
          $label.text(hash.label_text);
        } else {
          $label = $select.before($("<label for='" + select.id + "' class='a-native-dropdown' />").text(hash.label_text));
        }
      }
      // Some browsers don't update the button's width after adding or removing the label span when the button is display:inline
      // This results in text that's cut off or a button that's too wide.
      // Set min-width to effectively "touch" it and force an update.
      $button.css("min-width", hash.label_text === "" ? "0.1%" : "0%");
    }

    this.refreshPopover(this.options);
    return this;
  }

  /**
   *  Alter the dropdown with the given native_id so that the option with the value passed is selected.
   *  Pass in an empty string to set the value to the default.
   *
   *  @public
   *  @param {string} value  The new value to set
   *
   *  @return {object} self pointer
   */

  function setValue(value) {
    /*jshint validthis:true */
    var $select = this.options.$select;
    var $button = this.options.$button;
    var select = $select[0];

    // The value attribute of options is always a string, but trying to set the value to 3 seems legit.
    if (typeof value === "number") {
      value = value.toString();
    }

    // Find the option which matches the value
    for (var i = 0, l = select.options.length; i < l; i++) {
      if (select.options[i].value === value) {
        break;
      }
    }

    // Passing in an empty string for value means selecting the first option in the list
    // if there isn't an existing option with that value.
    if (i === l && value === "") {
      i = 0;
    }

    // If the value has actually changed, update stuff.
    if (i < l) {
      // Make sure that the button text is up to date no matter what
      $button.find(".a-dropdown-prompt").html(select.options[i].innerHTML);
      $button.css("min-width", i / select.options.length + "%");

      if ($select.val() !== value) {
        // Manually trigger the element-changed event on the native component
        // Only triggers if the value changed, mimicking native
        // We don't want to trigger events using A.trigger when using this API because the user didn't select anything
        $select.val(value);
        $select.trigger("change", [undefined, true]);
      }
    }

    return this;
  }

  /**
   * A shorthand for setValue/getValue to align with jQuery style
   *
   * @public
   *  @param {string} value  The new value to set
   *
   *  @return {object/string}  Depending on whether the value is set
   */

  function val(value) {
    /*jshint validthis:true */
    if (value === undefined) {
      //get value
      return this.options.$select.val();
    } else {
      //set value
      this.setValue = setValue;
      return this.setValue(value);
    }
  }

  /**
   *  Returns options instance for option level operations
   *
   *  @public
   *  @param {number/string/object} nativeIdsOrIndexesOrDoms  an array of numbers(indexes), strings(ids), or objects(DOM) to locate the options
   *
   *  @return {object}  options instance
   */

  function getOptions(nativeIdsOrIndexesOrDoms) {
    /*jshint validthis:true */
    var keys = [];
    var $select = this.options.$select;
    var elements = [];

    if (nativeIdsOrIndexesOrDoms === undefined) {
      keys = $select.children(CHILD_OPTION_SELECTOR);
    } else if ($.isArray(nativeIdsOrIndexesOrDoms)) {
      keys = nativeIdsOrIndexesOrDoms;
    } else {
      keys = [nativeIdsOrIndexesOrDoms];
    }

    for (var i = 0, last = keys.length; i < last; i++) {
      var key = keys[i];
      var $option = [];
      if (A.isFiniteNumber(key)) {
        $option = $select.children(CHILD_OPTION_SELECTOR).eq(key);
      } else if (typeof key === "string") {
        $option = $select.children('option#' + key);
      } else if (typeof key === "object") {
        $option = key.jquery ? key : $(key);
      }
      if ($option.length) {
        elements.push($option);
      }
    }

    return A.extend({
      hidePopover: this.hidePopover,
      refreshPopover: this.refreshPopover,
      setSelectValue: val,
      options: A.extend({
        elements: elements //array of dropdown options
      }, this.options)
    }, dropdownOptions);
  }

  /**
   * Returns options instance for option level operations
   *
   * @public
   *  @param {number/string/object} nativeIdOrIndexOrDom  number(index), string(id), or object(DOM) to locate the option
   *
   *  @return {object}  options instance
   */

  function getOption(nativeIdOrIndexOrDom) {
    /*jshint validthis:true */
    return this.getOptions(nativeIdOrIndexOrDom);
  }

  /**
   *  Add multiple options into dropdown. Options with existing id will not be inserted again.
   *  @public
   *  @param {object} options  [{text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}]
   *  @param {number} position  where the option is inserted, starting from 0
   *
   *  @return {object} self pointer
   */

  function addOptions(elements, position) {
    /*jshint validthis:true */
    if (!$.isArray(elements)) {
      elements = [elements];
    }

    // Loop in reserve order to preserve options sequence
    var i = elements.length;
    while (i--) {
      this.addOption(elements[i], position)
    }
    return this;
  }

  /**
   *  Add one option into dropdown. Options with existing id will not be inserted again.
   *
   *  @public
   *  @param {object} hash  {text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}
   *  @param {number} position  where the option is inserted, starting from 0
   *
   *  @return {object} self pointer
   */

  function addOption(hash, position) {
    /*jshint validthis:true */
    var $select = this.options.$select;

    // Only add an option if that option native id does not exist or there is no native_id
    if (!hash.native_id || !$select.find("option#" + hash.native_id).length) {
      var $options = $select.children(CHILD_OPTION_SELECTOR);
      var newOption = document.createElement("option");
      var index = position && position > 0 && position <= $options.length ? position : 0;

      if (hash.native_id) {
        newOption.id = hash.native_id;
      }

      if ($options.length === 0 || index === $options.length) {
        $select[0].appendChild(newOption);
      } else {
        $options.eq(index).before(newOption);
      }
      this.getOption(newOption).update(hash);
    }
    return this;
  }

  /**
   *  This is a convenience function which delegates to addOption and uses the proper index.
   *
   *  @public
   *  @param {object} hash  {text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}
   *
   *  @return {object} self pointer
   */

  function appendOption(hash) {
    /*jshint validthis:true */
    return this.addOption(hash, this.options.$select.children(CHILD_OPTION_SELECTOR).length);
  }

  /**
   *  A convenience function for appending multiple options to a dropdown
   *
   *  @public
   *  @param {array} hashes  An array of hashes representing options.  Format for the hashes: {text:<string>,value:<string>,selected:<boolean>,css_class:<string>,image_source:<url>,native_css_class:<class>,native_id:<string>,id:<string>}
   *
   *  @return {object} self pointer
   */

  function appendOptions(hashes) {
    /*jshint validthis:true */
    if ($.isArray(hashes)) {
      for (var i = 0, l = hashes.length; i < l; i++) {
        this.addOption(hashes[i]);
      }
    }
    return this;
  }

  /**
   *  Remove options from dropdown by option's nativeIds or by their indexes
   *
   *  @public
   *  @param {object} idsOrIndexes  array of nativeIds(strings) or indexes(numbers), or a mixture of both
   *
   *  @return {object} self pointer
   */

  function removeOptions(idsOrIndexes) {
    /*jshint validthis:true */
    this.getOptions(idsOrIndexes).remove();
    return this;
  }

  /**
   *  Remove one option from dropdown by option's nativeId or by their index
   *
   *  @public
   *  @param {string/number} idOrIndex  nativeId (strings) or index(numbers)
   *
   *  @return {object} self pointer
   ;
  }

  return {
    isSynced: isSynced,
    update: update,
    setValue: setValue,
    val: val,
    getOptions: getOptions,
    getOption: getOption,
    addOptions: addOptions,
    addOption: addOption,
    removeOptions: removeOptions,
    removeOption: removeOption,
    appendOption: appendOption,
    appendOptions: appendOptions
  };
});
/////////////////////////
// END FILE js/dropdowns/base/dropdown_select_apis.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown code for AUI Popover
 *
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */
P.when("A", "a-dropdown-options", "a-dropdown-apis", "a-dropdown-keyboard-handlers").register("a-dropdown", function (A, options, apis, handlers) {
  var undefined,
    $ = A.$,
    $doc = $(document);

  /**
   *  Selector used to find the root DOM node of the dropdown button.
   *
   *  @private
   *  @constant
   *  @type {string}
   */

  var BUTTON_SELECTOR = ".a-button-dropdown";

  /**
   *  The name of the class applied to the selected item in a dropdown.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var SELECTED_ITEM_CLASS = "a-active";

  /**
   *  Trigger the events associated with a user selecting a new dropdown value.
   *  Convenience function to make reading the change event handler easier to read.
   *
   *  @private
   *  @param {DOM Node} select  The native select DOM node whos value changed
   *  @param {DOM Node} itemNode  If an <li> was selected in the popover, it should be passed here (optional)
   *
   *  triggers a:dropdown:selected:[name]
   *  triggers a:dropdown:[name]:select
   *  triggers a:dropdown:[id]:select
   *  triggers a:dropdown:select
   */
  function triggerDropdownEvents(select, itemNode) {
    var name = select.name,
      value = select.value,
      selectId = select.id,
      eventHash = {
        auiItemNode: itemNode,
        nativeItemNode: select.options[select.selectedIndex],
        selectNode: select,
        id: selectId,
        name: name,
        value: value
      };

    if (name && name !== "") {
      A.trigger("a:dropdown:" + name + ":select", eventHash);
      /**
       *  Aimed to replace by a:dropdown:<name>:select to recitfy with the rest of the triggers
       *  jira: https://jira2.amazon.com/browse/SC-794
       *  @deprecated
       */
      A.trigger("a:dropdown:selected:" + name, eventHash);
    }

    if (selectId && selectId !== "") {
      // Name specific event
      A.trigger("a:dropdown:" + selectId + ":select", eventHash);
    }

    // Global event
    A.trigger("a:dropdown:select", eventHash);
  }

  /**
   * Common delegates
   */
  // Update the UI when the native select's value changes
  $doc.delegate(".a-native-dropdown", "change", function (event, $item, silent) {
    var $button = options.getButtonFromEvent(event),
      displayText = "",
      select = this,
      value = select.selectedIndex > -1 ? select.options[select.selectedIndex].value : "", // Can't use select.value since it's not available in IE 6
      popover = $button.data("popover"),
      itemExists = false,
      option;

    // Make sure we have a button to update.  If not, the rest of this is unnecessary because something
    // went terribly wrong.
    if (!$button.length) {
        return;
    }

    $button = $button.eq(0);

    // Get the text we're going to display in the button and make sure the correct option
    // is listed as "selected"
    var i = select.length;
    while (i--) {
      option = select.options[i];
      if (option.value === value) {
        displayText = option.innerHTML;
        break;
      }
    }

    // If a popover item hasn't been passed in, then someone triggered a change event via JS
    // and we need to try and find it using the data on the $button
    if (popover && popover.$popover) {
      // Clear the active class and aria attributes from the popover DOM
      var $selected = popover.$popover.find("." + SELECTED_ITEM_CLASS);
      $selected.removeClass(SELECTED_ITEM_CLASS).closest("li").attr("aria-checked", false);

      if ($item === undefined) {
        // AUI-8874 we let JSON do the dirty work
        var valString = JSON.stringify({ 'stringVal': value });
        // we also need to escape one more time for jQuery selector
        $item = popover.$popover.find('a[data-value="' + A.escapeJquerySelector(valString) + '"]');
      }
    }

    // If we have a popover item, then we need to update the UI for that component
    if ($item && $item.length) {
      itemExists = true;

      // ARIA attributes and classes need to be updated
      $item.addClass(SELECTED_ITEM_CLASS).closest("li").attr("aria-checked", true);
    }

    // Update the trigger button text and hide the popover.
    // Some browsers don't update the button's width after updating the prompt span when the button is display:inline.
    // This results in text that's cut off or a button that's too wide.
    // Set min-width to force a repaint and ensure the button is the correct width.
    $button.find(".a-dropdown-prompt").html(displayText);
    $button.css("min-width", select.selectedIndex / select.options.length + "%");

    if (popover) {
      popover.hide();

      // We need to update the info cache or the popover will be invalidated after every odd numbered selection
      var selectObj = apis.getSelect(select);
      if (selectObj) {
        $(this).data("a-info", selectObj.getOptions().info());
      }
    }

    // Trigger a selection event if necessary and able
    if (!silent) {
      triggerDropdownEvents(this, itemExists ? $item[0] : null);
    }
  });

  // Focusing on a button's containing span using JS should actually focus the element (a, button, input) within
  $doc.delegate(BUTTON_SELECTOR + ":not(.a-button-disabled)", "focusin", function () {
    $(this).find(".a-button-text").focus();
  });

  // Returning dropdown APIs
  return apis;
});
/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown_apis.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown APIs
 *
 */

"use strict";

P.when("A", "a-dropdown-base", "a-dropdown-options").register("a-dropdown-apis", function (A, base, options) {
  var undefined,
    $ = A.$;

  /**
   *  Returns the select object
   *
   *  @public
   *  @param {string} selectNativeIdOrDom  native_id of the select tag
   *
   *  @return {object}  select object
   */

  function getSelect(selectNativeIdOrDom) {
    return base.getSelect(selectNativeIdOrDom, options);
  }

  /**
   *  @deprecated
   *
   *  Updates the native <option> with the given ID and invalidate the cached popover, if it exists.
   *  Only options exposed on the dropdownOption tempate are accepted.  Any other options which
   *  are passed will be ignored.  Any options which are not passed in will remain the same.
   *
   *  @public
   *  @param {string} nativeId  The native_id parameter used in the dropdownOption template
   *  @param {object} hash  A hash of new option values to set on the <option>
   */

  function updateOption(nativeId, hash) {
    var $select = $("option#" + nativeId).closest("select");
    getSelect($select).getOption(nativeId).update(hash);
  }

  /**
   *  @deprecated
   *
   *  Updates classes and data attributes on the native <select> node as well as the generated dropdown button.  If the
   *  dropdown is currently "open", it will "close". Only options exposed on the dropdown tempate are accepted.
   *  Any other options which are passed will be ignored.  Any options which are not passed in will remain the same.
   *
   *  @public
   *  @param {string} nativeId  The native_id parameter used in the dropdown template
   *  @param {object} hash  A hash of new option values for the dropdown template
   */

  function updateSelect(nativeId, hash) {
    getSelect(nativeId).update(hash);
  }

  /**
   *  @deprecated
   *
   *  Alter the dropdown with the given native_id so that the option with the value passed is selected.
   *  Pass in an empty string to set the value to the default.
   *
   *  @public
   *  @param {string} nativeId  The native_id param used when creating the dropdown template
   *  @param {string} value  The new value to set
   *
   *  @return {boolean}  Returns true if the value was present and set succeeded, false otherwise
   ;
  }

  /*
  On DOM ready, it's possible for the UI of the dropdown component to not match the value
  of the underlying <select> tag due to browsers autocompleting or changing the value provided
  by the server to whatever the user had selected on a previous page view.
  */
  A.on("beforeReady", function () {
    $(".a-dropdown-container select").each(function () {
      var auiSelect = getSelect(this);
      if (auiSelect) {
        auiSelect.val(auiSelect.val());
      }
    });
  });

  return {
    getSelect: getSelect,
    updateOption: updateOption, // deprecated
    updateSelect: updateSelect, // deprecated
    setValue: setValue // deprecated
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown_apis.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Dropdown view
 *
 */

'use strict';

P.when('A', 'a-popover-accessibility').register('a-dropdown-view', function (A, a11y) {
  var undefined,
    $ = A.$;

  return {
    /**
     *  Creates the outer skin (popover container) for desktop dropdowns
     *
     *  @private
     *  @param {object} popover  Popover instance
     *
     *  @return {string}  The HTML for the dropdown popover
     */

    skin: function (popover) {
      var header = popover.attrs("header") || "";
      var id = popover.id;
      var accesibility_params = {
          id : id,
          header_str: header,
          needs_declarative: false
      };

      return [
        '<div class="a-popover a-dropdown a-dropdown-common a-declarative" data-action="a-popover-a11y">',
        a11y.getStartAnchorHtml(accesibility_params),
        '<div class="a-popover-wrapper">',
        '<div class="a-popover-inner"></div>',
        '</div>',
        a11y.getEndAnchorHtml(accesibility_params),
        '</div>'].join('');
    }
  }
});
/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/dropdowns/dropdown/common/dropdown_handlers_common.js */
/**
 *  Events and delegations for Dropdowns
 *
 */
 
'use strict';

P.when("A", "a-dropdown-base", "a-dropdown-view", "a-dropdown-options", "a-dropdown-apis", "a-dropdown-base-factory", "a-dropdown-keyboard-handlers").register('a-dropdown-handlers', function (A, base, view, options, apis, factory, handlers) {
  var $ = A.$,
      $doc = $(document);

  /**
   *  Update the value of the dropdown with the value of a given item.
   *
   *  @this {HTMLElement}
   *  @private
   *  @param {Event} event
   */
  function _selectItem(event) {
    /*jshint validthis:true */
    event.preventDefault();
    var $this = $(this);
    var popover = factory.get($this.closest(".a-popover"));

    if (!$this.hasClass("a-active")) {
      var value = $this.data("value").stringVal,
        $select = popover.sourceSelect;

      $select.val(value).trigger("change", [$this]);
    } else {
      popover.hide();
    }
  }

  /**
   *  Bind to the dropdown button's click event via the declarative API
   */
  A.declarative("a-dropdown-button", "click", function (event) {
    var $button = options.getButtonFromEvent(event);
    base.showDropdown(event, A.extend({
      $button: $button
    }, options), view);
  });

  /**
   *  Ensure that the dropdown can also be accessed via the keyboard.
   */
  A.declarative("a-dropdown-button", "keydown", function (event) {
    var $button = options.getButtonFromEvent(event);
    var keycodes = A.constants.keycodes;
    var key = event.$event.which;
    if (key === keycodes.DOWN_ARROW || key === keycodes.ENTER || key === keycodes.SPACE) {
      base.showDropdown(event, A.extend({
        $button: $button
      }, options), view);
    }
  });

  // Handle user selecting an item in the popover with a mouse
  // and gets triggered by SPACE key event handler.
  // TODO make selector more efficient
  $doc.delegate(".a-popover.a-dropdown a", "click", _selectItem);

  if (handlers) {
    // Keyboard navigation
    if (handlers.keyDown) {
      $doc.delegate(".a-dropdown li", "keydown", handlers.keyDown);
    }
    if (handlers.keyPress) {
      $doc.delegate(".a-dropdown li", "keypress", handlers.keyPress);
    }
  }
});
/* Done importing js/dropdowns/dropdown/common/dropdown_handlers_common.js */

/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown/dropdown_options.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Dropdown specific selector and locators
 *
 */

"use strict";

P.when("A").register("a-dropdown-options", function (A) {
  var undefined,
    $ = A.$;

  /**
   *  Selector used to find the root DOM node of the dropdown button.
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var BUTTON_SELECTOR = ".a-button-dropdown";

  /**
   * Obtain button DOM for event calls
   *
   * @private
   * @param {object} event  event object
   *
   * @return {object} DOM of the dropdown button
   */

  function getButtonFromEvent(event) {
    if (event.popover) {
      return event.popover.$trigger.closest(BUTTON_SELECTOR);
    } else if (event.$target) {
      return event.$target.closest(BUTTON_SELECTOR);
    } else {
      return $(event.target).nextAll(BUTTON_SELECTOR)
    }
  }

  /**
   * Obtain button DOM for event calls
   *
   * @private
   * @param {object} $select  select jquery object
   *
   * @return {object} jquery object of the dropdown button
   */

  function getButtonFromSelect($select) {
    return $select.nextAll(BUTTON_SELECTOR);
  }

  /**
   * Obtain select DOM for event calls
   *
   * @private
   * @param {object} event  event object
   *
   * @return {object} DOM of the dropdown select
   */

  function getSelectFromEvent(event) {
    var $select = getButtonFromEvent(event).prevAll("select").eq(0);

    if (!$select.length) {
      P.error("Cannot locate the <select> of dropdown");
    }
    return $select;
  }

  /**
   * A list of options to be injected into dropdown base class
   *
   * @private
   */
  return {
    getButtonFromEvent: getButtonFromEvent,
    getButtonFromSelect: getButtonFromSelect,
    getSelectFromEvent: getSelectFromEvent,
    triggerSelector: BUTTON_SELECTOR
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown/dropdown_options.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Split Dropdown view
 *
 */

'use strict';

P.when('A', 'a-popover-accessibility').register('a-dropdown-split-view', function (A, a11y) {
  var undefined;

  return {
    /**
     *  Creates the outer skin (popover container) for desktop split dropdowns
     *
     *  @public
     *  @param {object} popover  Popover instance
     *
     *  @return {string}  The HTML for the dropdown popover
     */

    skin: function (popover) {
      var label = popover.attrs("header") || "";
      var id = popover.id;
      var accesibility_params = {
          id : id,
          label_str: label,
          needs_declarative: false
      };

      return [
        '<div class="a-popover a-splitdropdown a-dropdown-common a-declarative" data-action="a-popover-a11y">',
        a11y.getStartAnchorHtml(accesibility_params),
        '<div class="a-popover-wrapper">',
        '<div class="a-popover-inner"></div>',
        '</div>',
        a11y.getEndAnchorHtml(accesibility_params),
        '</div>'].join('\n');
    }
  }
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Events and delegations for Split Dropdowns
 *
 */

'use strict';

P.when("A", "a-dropdown-base", "a-dropdown-split-utils", "a-dropdown-split-view", "a-dropdown-split-options", "a-dropdown-base-factory", "a-dropdown-keyboard-handlers").register('a-dropdown-split-handlers', function (A, base, utils, view, options, factory, handlers) {
  var undefined,
    $ = A.$;

  /**
   *  Bind to the dropdown button's click event via the declarative API
   */
  A.declarative("a-splitdropdown-button", "cl;
  });

  /**
   *  Bind to the split dropdown's main action's click event via the declarative API
   */
  A.declarative("a-splitdropdown-main", "cl;
  });

  /**
   *  Ensure that the dropdown can also be accessed via the keyboard.
   */
  A.declarative("a-splitdropdown-button", "keydown", function (event) {
    var $button = options.getButtonFromEvent(event);
    var keycodes = A.constants.keycodes;
    var key = event.$event.which;
    if (key === keycodes.DOWN_ARROW || key === keycodes.ENTER || key === keycodes.SPACE) {
      base.showDropdown(event, $.extend({
        $button: $button
      }, options), view);
    }
  });

  // Handle user selecting an item in the popover
  $(document)
    .delegate(".a-popover.a-splitdropdown a", "cl    })

    // Keyboard navigation
    .delegate(".a-splitdropdown li", "keydown", handlers.keyDown)
    .delegate(".a-splitdropdown li", "keypress", handlers.keyPress);
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split_options.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Split dropdown specific selector and locators
 *
 */

"use strict";

P.when("A").register("a-dropdown-split-options", function (A) {
  var undefined,
    $ = A.$;

  /**
   * obtain button DOM for event calls
   *
   * @private
   * @param {object} event  event object
   *
   * @return {object} DOM of the dropdown button
   */

  function getButtonFromEvent(event) {
    if (event.popover) {
      return event.popover.$trigger.closest(".a-button-splitdropdown");
    } else if (event.$target) {
      return event.$target.closest(".a-button-splitdropdown");
    } else {
      return $(event.target).nextAll(".a-button-splitdropdown");
    }
  }

  /**
   * Obtain button DOM for event calls
   *
   * @private
   * @param {object} $select  select jquery object
   *
   * @return {object} jquery object of the dropdown button
   ;
  }

  /**
   * Obtain select DOM for event calls
   *
   * @private
   * @param {object} event  event object
   *
   * @return {object} DOM of the dropdown select
   */

  function getSelectFromEvent(event) {
    var $select = getButtonFromEvent(event).closest(".a-splitdropdown-container").find("select");

    if (!$select.length) {
      P.error("cannot locate the <select> of the split dropdown");
    }
    return $select;
  }

  return {
    getButtonFromEvent: getButtonFromEvent,
    getButtonFromSelect: getButtonFromSelect,
    getSelectFromEvent: getSelectFromEvent
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split_options.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split_utils.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Split dropdown specific util functions
 *
 */

"use strict";

P.when("A").register("a-dropdown-split-utils", function (A) {
  var undefined,
    $ = A.$;

  function triggerEvent(selectId, $select, value) {
    var eventHash = {
      $select: $select,
      value: value,
      id: selectId
    };
    A.trigger('a:splitdropdown:' + selectId + ':select', eventHash);
    A.trigger('a:splitdropdown:select', eventHash);
  }

  return {
    triggerEvent: triggerEvent
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split_utils.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/dropdowns/dropdown_split/dropdown_split.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Split dropdown, variation of popover
 *
 */

"use strict";

/**
 *  Module used to create and maintain dropdown popovers
 */
P.when("A", "a-dropdown-base", "a-dropdown-split-options", "a-dropdown-split-utils", "a-dropdown-split-handlers").register("a-splitdropdown", function (A, base, options, utils, handlers) {
  var undefined,
    $ = A.$;

  /**
   *  Returns the select object
   *
   *  @public
   *  @param {string} selectNativeIdOrDom  native_id of the select tag
   *
   *  @return {object}  select object
   */

  function getSelect(selectNativeIdOrDom) {
    return base.getSelect(selectNativeIdOrDom, options);
  }

  /**
   *  Common event handlers
   */

  // broadcast event when the native select's value changes when native dropdown are used
  $(document)
    .delegate(".a-native-splitdropdown", "change", function (event, $item, silent) {
      var $this = $(this),
        value = $this.val(),
        selectId = $this.attr("id");

      //Trigger events
      if (!silent) {
        utils.triggerEvent(selectId, $this, value);
      }
    })

  // Focusing on a button's containing span using JS should actually focus the element (a, button, input) within
  .delegate(".a-button-splitdropdown:not(.a-button-disabled)", "focu;
  })

  /**
   * Public API endpoints
   */

  return {
    getSelect: getSelect
  };
});
/////////////////////////
// END FILE js/dropdowns/dropdown_split/dropdown_split.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_accessibility.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Accessibility Utils for AUI Popover
 */

'use strict';

P.when('A', 'a-popover-accessibility-templates').register('a-popover-accessibility', function (A, templates) {
  var $ = A.$;
  var undefined;

  var startAnchorTemplate = templates.startAnchorTemplate;
  var startAnchorDeclarativeTemplate = templates.startAnchorDeclarativeTemplate;
  var endAnchorTemplate = templates.endAnchorTemplate;

  var descriptionTemplate = templates.descriptionTemplate;

  /**
   * Generates the html for the popover aria description.
   * - To be referenced by the popover's aria-describedby attribute
   *
   * @private
   * @param {string} id  The description element's id.
   * @param {string} description  The aria description text.
   *
   * @return {string}
   */
  var _getDescriptionHtml = function(id, aria_description) {
    var template = descriptionTemplate;
    var map = {
      "{{DESCRIPTION}}": aria_description,
      "{{DESCRIPTION_ID}}" : id
    }

    var mapMatch = function(match){
      return map[match];
    };

    return template.replace(/\{\{[\w_]*\}\}/g, mapMatch);
  }

  /**
   * Generates the html for the two 'anchoring' elements that bookend the popover content
   *
   * @private
   * @param {object} params  The accesibility_params. EG: id, aria label, aria describedby, etc
   *                 {string} id  popover ID
   *                 {string} label_str  popoverLabel action param
   *                 {string} header_str  header action param
   *                 {boolean} needs_declarative  whether a declarative action is needed
   *
   * @return {string}
   */
  var _getStartAnchorHtml = function(params) {
    var id = params.id;
    var header_str = params.header_str;
    var label_str = params.label_str;
    var aria_description = params.aria_description;
    var description_html = "";
    var description_id;
    var template;

    // Since popover IDs are auto-generated, there should be no use case of no ID, just in case.
    if (!id) {
      return "";
    }

    var map = {
      "{{ROLE}}": 'role="dialog"',
      "{{ANCHOR_NAME}}": "a-popover-start",
      "{{ARIA_LABEL}}": _getAriaLabel(params),
      "{{LABEL_STR}}": label_str || '', // avoid literal 'undefined'
      "{{ARIA_DESCRIBEDBY}}": ""
    };
    var mapMatch = function(match){
      return map[match];
    };

    template = params.needs_declarative ? startAnchorDeclarativeTemplate : startAnchorTemplate;

    // Add the aria aria-describedby attribute to the start content, if provided
    // iOS Bug: Do not add aria-describedby for iOS because that prevents the VoiceOver cursor from focusing in the popover when the popover opens
    if (aria_description && !A.capabilities.ios) {
      description_id = 'a-popover-aria-description-' + id;
      map["{{ARIA_DESCRIBEDBY}}"] = 'aria-describedby="' + description_id + '"';
      description_html = _getDescriptionHtml(description_id, aria_description);
    }

    // iOS issue: Voice Over ignores our hidden element which holds the aria-label
    // if the the element content is empty and the element has a role attribute set.
    // (e.g. <span role="dialog" aria-label="This is a popover label"></span>)
    // Removing the role attribute fixes the issue. But without the role,
    // the screen reader will announce the aria-label AND the name tag of the element
    // (in our case, it's button).
    // However, considering Voice Over on iOS is the prevailing combination
    // for mobile screen reader user,
    // we will apply a workaround to remove the role attribute only for iOS.
    if (A.capabilities.ios) {
      map['{{ROLE}}'] = '';
    }

    template = template.replace(/\{\{[\w_]*\}\}/g, mapMatch) + description_html;

    // iOS issue: empty <span index="0"> doesn't works well with iOS 
    // when we want to programmatically focus the element (i.e. startAnchor)
    if (A.capabilities.ios) {
      template = template.replace(/span/g, 'button');
    }

    // trim whitespace that comes before ">"
    return template.replace(/\s\s>|\s>/g, ">");
  }

  /**
   * Generate aria-label depending on header/label combinations
   *
   * @private
   * @param {object} params  The accesibility_params. EG: id, aria label, aria describedby, etc
   *
   * @return {string}
   */
  var _getAriaLabel = function(params) {
    var id = params.id;
    var header_str = params.header_str;
    var label_str = params.label_str;

    if (label_str) {
      return 'aria-label="' + label_str + '"';
    } else if (header_str) {
      return 'aria-labelledby="a-popover-header-' + id + '"';
    }
    return "";
  };

  var _getEndAnchorHtml = function(params) {
    var template = endAnchorTemplate;
    if (A.capabilities.ios) {
      template = template.replace(/span/g, 'button');
    }
    return template;
  };


  return {
    getStartAnchorHtml: _getStartAnchorHtml,
    getEndAnchorHtml: _getEndAnchorHtml
  };
});
/////////////////////////
// END FILE js/mixins/popover_accessibility.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_accessibility_templates.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
*  Accessibility Templates for Popover Start Anchor
*/

'use strict';

P.declare('a-popover-accessibility-templates', {
    startAnchorTemplate  : '<span tabindex="0" role="dialog" class="{{ANCHOR_NAME}} a-popover-a11y-offscreen" {{ARIA_LABEL}} {{ARIA_DESCRIBEDBY}}></span>',
    startAnchorDeclarativeTemplate  : '<span tabindex="0" role="dialog" data-action="a-popover-a11y" class="{{ANCHOR_NAME}} a-popover-a11y-offscreen a-declarative" {{ARIA_LABEL}} {{ARIA_DESCRIBEDBY}}>{{LABEL_STR}}</span>',
    endAnchorTemplate   : '<span tabindex="0" class="a-popover-end a-popover-a11y-offscreen"></span>',
    descriptionTemplate : '<span id="{{DESCRIPTION_ID}}" class="a-popover-a11y-offscreen">{{DESCRIPTION}}</span>'
  }
);
/////////////////////////
// END FILE js/mixins/popover_accessibility_templates.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_ajax.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  @deprecated
 *
 *  Deprecated popover ajax APIs
 */

'use strict';

P.when('A', 'a-popover-util').register('a-popover-ajax', function (A, util) {
  var undefined;

  return {
    /**
     * @deprecated
     * deprecated, please use popover.update()
     *
     * @public
     * @param {object} popover  popover instance
     * @param {string} url  url string
     * @param {object} options  hash of ajax related options
     */
    update: function(popover, url, options) {
      var hash = {};

      hash.url = url;
      if(options.timeout){
        hash.timeout = options.timeout;
      }
      if(options.ajaxFailMsg){
        hash.ajaxFailMsg = options.ajaxFailMsg;
      }
      if(options.cache){
        hash.cache = options.cache;
      }
      popover.update(hash);
    },

    /**
     * @deprecated
     * deprecated, please use popover.update() to achieve this functionality
     *
     * @public
     * @param {object} popover  popover instance
     *
     * @return {object} popover instance
     */
    showSpinner: function(popover) {
      return util.showSpinner(popover);
    }
  }
});
/////////////////////////
// END FILE js/mixins/popover_ajax.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_animate.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Abstraction for animating popovers and properly invoking callbacks when they finish

'use strict';

P.when('A').register('a-popover-animate', function (A)}
  }

  function _callback(popover, finished) {
    r    }
 ;
  }

  function animate(popover, properties, time, easing, finished) {
    popover._isAnimating = (time > 0);

    A.animationFrameDelay(_animate('animate', [popover.$popover, properties, time, easing, _callback(popover, finished)]));
  }

  function fadeOut(popover, time, easing, finished) {
    popover._isAnimating = (time > 0);

    A.animationFrameDelay(_animate('fadeOut', [popover.$popover, time, easing, _callback(popover, finished)]));
  }

  function fadeIn(popover, time, easing, finished) {
    popover._isAnimating = (time > 0);

    A.animationFrameDelay(_animate('fadeIn', [popover.$popover, time, easing, _callback(popover, finished)]));
  }

  return {
    isAnimating: isAnimating,
    animate: animate,
    fadeOut: fadeOut,
    fadeIn: fadeIn
  }

});
/////////////////////////
// END FILE js/mixins/popover_animate.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_data.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Data source strategies for popover

'use strict';

P.when('A', 'a-popover-util', 'a-popover-inline-strategy', 'a-popover-preload-strategy', 'a-popover-ajax-strategy').register('a-popover-data', function (A, util, inlineDataStrategy, preloadDataStrategy, ajaxDataStrategy) {
  var undefined;
  var $ = A.$;

  /**
   *  List of strategies ordered by priority
   *
   *  @public
   *  @type {array}
   */
  var STRATEGIES = [ajaxDataStrategy, preloadDataStrategy, inlineDataStrategy];

  /**
   *  Determine which strategy to use according to income popover attributes
   *  Since users does not specify which data strategy to use up front for history
   *    reason, this function helps guessing which strategy application wants to use
   *    by checking which attribute the popover contains.
   *
   *  @public
   *
   *  @param attributes  hash of attrs of the popover
   *  @return dataStrategyObject
   */

  function guessStrategyByAttrs(attributes) {
    for(var i=0, j=STRATEGIES.length; i<j; i++) {
      var strategy = STRATEGIES[i];
      if (strategy.isValidStrategy(attributes)){
        return strategy;
      }
    }
  }

  /**
   *  Get strategy object by strategy name
   *
   *  @public
   *
   *  @param name  name of the strategy
   *  @return {object}
   */

  function getStrategyByName(name){
    for(var i=0, j=STRATEGIES.length; i<j; i++) {
      var strategy = STRATEGIES[i];
      if (strategy.name === name){
        return strategy;
      }
    }
    return null;
  }

  return {
    guessStrategyByAttrs: guessStrategyByAttrs,
    getStrategyByName: getStrategyByName,
    showSpinner: util.showSpinner
  }
});
/////////////////////////
// END FILE js/mixins/popover_data.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_lightbox.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  A simple generic lightbox for dropdowns and modals
 */

'use strict';

P.when('A', 'a-popover-lightbox-markup', 'a-timing-analytics', 'ready')
      .register('a-popover-lightbox', function (A, markup, timingAnalytics) {
    /* Importing js/mixins/popover_lightbox_code.js */
  var $ = A.$;
  var htmlClass = document.documentElement.className;
  var IS_IE = htmlClass.indexOf("-ie") > -1;
  var IS_WIN_PHONE = A.capabilities.isIE10Plus && A.capabilities.mobile;
  var IS_ANDROID_4 = (A.capabilities.androidVersion + "").indexOf("4.") === 0;
  var IS_UC_BROWSER = A.capabilities.isUCBrowser;
  var LIGHTBOX_ID = markup.id;
  var LIGHTBOX_DIV = markup.div;
  var clicksKilled = false;
  var $body = $('body');

  // Parameters to control the polling interval and attempts for an iOS8 hacks
  var IOS8_SCROLLBACK_INTERVAL = 200;
  var IOS8_SCROLLBACK_ATTEMPTS = 5

  /**
   *  Lightbox lock levels
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LOCK_SYSTEM = 1,
    LOCK_USER = 10,
    LOCK_UNLOCK = -1;

  /**
   *  Default duration of the fadein effect for lightbox
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LIGHTBOX_FADEIN_DURATION = 200;

  /**
   *  Default duration of the fadeout effect on hide
   *
   *  @private
   *  @constant
   *  @type {integer}
   */
  var LIGHTBOX_FADEOUT_DURATION = 250;

  /**
   *  Lightbox DOM object, will create on demand
   *
   *  @private
   *  @type {object}
   */
  var $lgtbox = null;

  /**
   *  We might need to kill the timer which fully hides the lightbox after touchend, so
   *  keep track of that here.
   *
   *  @private
   *  @type {boolean}
   */
  var clickThroughTimer = 0;

  /**
   *  This is a soft lock which prevents hiding the lightbox
   *
   *  @private
   *  @type {integer}
   */
  var _lock_level = LOCK_UNLOCK;

  /**
   *  A value to restore the scrollTop/scrollLeft if lockScroll messed with heights
   *  Useful especially for IE6
   *
   *  @private
   *  @type {integer}
   */

  var _scrollTop = -1;
  var _scrollLeft = -1;

  /**
   *  The popover instance floating above lightbox.
   *  If option.popover is included in the show() method, the z-index of the lightbox will be adjusted properly.
   *  Lightbox will close the floating popover when this is specified as well.
   */
  var _floatingPopover = null;

  /**
   *  Allow binding to an event and stopping it in its tracks.
   *
   *  @return {boolean} false
   */
  function _killClicks(event) {
    event.preventDefault();
    event.stopPropagation();
    event.stopImmediatePropagation();
    return false;
  }

  /**
   *  Stop all clicks on the body during the capture phase.
   */
  function _stopClicks() {
    $body.bind('click', _killClicks);
    clicksKilled = true; // Prevent double clicks from causing issues.
  }

  /**
   *  Allow clicks to propogate down to the children of the body.
 e;
  }

  /**
   *  Show black lightbox
   *
   *  @public
   *  @param {object} options
   *                          {popover} popover  the popover instance that floats on top of the lightbox
   *                          {boolean} lockScroll  whether page scroll should be locked
   *                          {number} showDuration  lightbox fadein animation duration
   */

  function show(options) {
    $('#a-page').attr('aria-hidden', 'true');

    var $window = $(window);

    if (!$lgtbox) {
      // Lazy add lightbox dix
      $('body').append(LIGHTBOX_DIV);
      $lgtbox = $("#" + LIGHTBOX_ID);
    }

    options = options || {};

    // Prevent the user from closing the modal while it is animating
    _stopClicks();

    if (options.lockScroll) {
      // Store scroll top temporarily to restore later, only respect the first set
      if (_scrollTop === -1) {
        _scrollTop = $window.scrollTop();
        _scrollLeft = $window.scrollLeft();
      }

      // Set margin-right with !important to override the css class !important in site-wide css
      A.setCssImportant($("body"), "margin-right", A.scrollBarWidth() + "px");

      // Explicitly filter out windows phone here as applying overflow hidden causes
      // a page-level overscroll but the measured offset is just shifting for 1px
      if (!IS_WIN_PHONE) {
        // Prevent page from scrolling. Scrollbar in IE is in <html>, however, adding
        // overflow hidden to FF/chrome jumps the page to top. Therefore only apply
        // overflow hidden to IE
        if (IS_IE) {
          $("html, body").css("overflow", "hidden");
        } else {
          $("body").css("overflow", "hidden");
        }
      }
    }

    _floatingPopover = options.popover || null;
    var zindex = _floatingPopover ? _floatingPopover.$popover.css("z-index") - 2 : -1; //for some reason, -1 will cause page overscrolling in dropdown
    if (zindex > 0) {
      $lgtbox.css("z-index", zindex);
      // A Samsung S4 Android 4.4.2 stock browser refuses to repaint the z-index
      // change without a kick in the pants. The Interwebs suggested reading an
      // element size, and it does seem to work. Using $window since we already
      // have it. Limiting devices, to protect old buggy browsers. See sim/AUI-2519
      if (IS_ANDROID_4) {
         $window.width();
      }
    }

    // Add default duration
    if (typeof options.showDuration !== "number") {
      options.showDuration = LIGHTBOX_FADEIN_DURATION;
    }

    /*
      UC Browser has an issue with displaying popovers (modals, specifically).
      A current workaround is to apply overflow: auto to the modal which forces
      the browser to display it. This sniffs for the browser and applies the fix.

      More info:
      https://w.amazon.com/index.php/UC_Browser_Issues_%26_Resolutions
    */
    if(IS_UC_BROWSER) {
      _floatingPopover.$popover.css('overflow', 'auto');
    }

    if (options.showDuration > 0) {
      A.fadeIn($lgtbox, options.showDuration);
    } else {
      $lgtbox.css("display", "block");
    }

    A.delay(_allowClicks, options.showDuration + 300);
  }

  /**
   * Hide black lightbox
   *
   * @public
   * @param {object} options
   *                          {number} hideDuration  lightbox fadein animation duration
   *                          {boolean} lockScroll  whether page scroll should be loc
   */

  function hide(options) {
    var $window = $(window);

    // Cannot hide if the lightbox is locked
    if (_lock_level > LOCK_UNLOCK) {
      return;
    }

    // Require lightbox DOM
    if (!$lgtbox) {
      return;
    }

    options = options || {};

    // Prevent the user from closing the modal while it is animating
    _stopClicks();

    // Add default duration
    if (typeof options.hideDuration !== "number") {
      options.hideDuration = LIGHTBOX_FADEOUT_DURATION;
    }

    if (options.hideDuration > 0) {
      A.fadeOut($lgtbox, options.duration, "linear", function () {
        if (options.lockScroll) {
          // Enable page scrolling
          $("html, body").css("overflow", "");
          $("body").css("margin-right", "");

          // Restore scrollTop (especially for IE6)
          // Add A.delay as IE11 on tablet can only be scrolled when animation is completely done
          A.delay(function() {
            if (_scrollTop > 0) {
              $window.scrollTop(_scrollTop);
              _scrollTop = -1;
            }
            if (_scrollLeft > 0) {
              $window.scrollLeft(_scrollLeft);
              _scrollLeft = -1;
            }
          }, 100);
        }

        // Reset floating popover
        _floatingPopover = null;
      });
    } else {
      $lgtbox.css("display", "none");

      if (options.lockScroll) {
        // Enable page scrolling
        $("html, body").css("overflow", "");
        $("body").css("margin-right", "");

        // Restore scrollTop (especially for IE6)
        if (_scrollTop > 0) {
          $window.scrollTop(_scrollTop);
          _scrollTop = -1;
        }
      }

      // Reset floating popover
      _floatingPopover = null;
    }

    // There are occasions that we are changing the width and height of the
    //     lightbox, that might impact after document width/height calculation
    //     resetting the height/width here
    $lgtbox.css({
        "height": "",
        "width": ""
    });

    // Wait for a bit, then allow clicks to be generated again.
    A.delay(_allowClicks, options.hideDuration + 350);

    $('#a-page').removeAttr('aria-hidden');
  }

  /**
   *  Set current lock level, higher the more powerful
   *
   *  @public
   *  @param {integer} lockLevel
   *
   *  @return {object}  lightbox instance
   */

  function lock(lockLevel) {
    //assume a user lock if lock level is not set
    if (!lockLevel) {
      lockLevel = LOCK_USER;
    }
    if (_lock_level < lockLevel) {
      _lock_level = lockLevel;
    }
  }

  /**
   *  Remove lock if lockLevel is high enough
   *
   *  @public
   *  @param {integer} lockLevel
   *
   *  @return {object}  lightbox instance
   */

  function unlock(lockLevel) {
    //assume a user lock if lock level is not set
    if (!lockLevel) {
      lockLevel = LOCK_USER;
    }
    if (_lock_level <= lockLevel) {
      _lock_level = LOCK_UNLOCK;
    }
  }

  /**
   *  Does nothing when lightbox is clicked to avoid unintentional clicks
   */
  $(document).delegate("#" + LIGHTBOX_ID, "click " + A.action.start + " " + A.action.move, function (event) {
    event.preventDefault();
  });

  /**
   *  Handle closing the current popover floating on top of lightbox when lightbox/a-modal-scroller
   *  is clicked or tapped.
   */
  A.declarative('a-popover-floating-close', A.capabilities.touch ? A.action.end : "click", function (event) {
    // Only executes when the target immediately has the a-popover-floating-close action
    if (!clicksKilled && event.$target.data("action") && event.$target.data("action").indexOf("a-popover-floating-close") > -1) {
      // Only close the floating popover if it is completely shown
      if (_floatingPopover && _floatingPopover.isActive()) {
        /*
         *  Clicking or tapping especially on the modal scroller and/or lightbox is a strong
         *  indictation that the user wants to close the popover. Therefore we will unlock it in
         *  the highest lock level.
         */
        _floatingPopover.unlock().hide();
        event.$event.preventDefault();
      } else {
        // we've managed to get into a state where the lightbox is open but there's no popover
        // probably want to hide the lightbox
        hide();
      }
    }
  });

  /**
   * In iOS8, upon orientation change of dropdown/modal, the scrollTop of the window might scroll off the
   * intended positon and leaves a (large) portion of white in the screen with the dropdown/model shifted offscreen.
   * We are implementing this workaround to catch the timing when the orientation change animation is done and scroll
   * the page to align with the dropdown/modal.  The polling is needed, as the scroll will not happen until the
   * orientation change animation is done.
   */
  if (A.capabilities.isiOS8) {
    A.on("a:popover:afterUpdatePosition", function(data){
      var popover = data.popover;
      var $lightboxDom = $('#'+LIGHTBOX_ID);
      var lightboxTop = $lightboxDom.length ? $lightboxDom.offset().top : -1;
      var $window = $(window);
      var counter;
      var trial;

      // Only start when the popover is active and it has ligthbox
      if(popover.isActive() && popover.attrs("lightboxOptions") && lightboxTop) {
        counter = 0;
        trial = setInterval(function() {
          // Apparently during the animation stage, getting $window.scrollTop will give us
          // our desired value without actually fulfilling it, therefore we are literally
          // setting scrollTop five times to ensure the right scrollTop is set.
          // I like iOS less...
          $window.scrollTop(lightboxTop);
          if(++counter > IOS8_SCROLLBACK_ATTEMPTS) {
            clearInterval(trial);
          }
        }, IOS8_SCROLLBACK_INTERVAL);
      }
    });
  }

  timingAnalytics.stopWidgetLogging('dropdown');
  return {
    show: show,
    hide: hide,
    lock: lock,
    unlock: unlock,
    LIGHTBOX_ID: LIGHTBOX_ID
  }
/* Done importing js/mixins/popover_lightbox_code.js */

});
/////////////////////////
// END FILE js/mixins/popover_lightbox.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_lightbox_markup.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  An abstraction for the markup for the lightbox
 */
P.declare('a-popover-lightbox-markup', {
    id: "a-popover-lgtbox",
    div: '<div id="a-popover-lgtbox" class="a-declarative" data-action="a-popover-floating-close" />'
});
/////////////////////////
// END FILE js/mixins/popover_lightbox_markup.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_navigate.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// Popover Hash Navigation Code For AUI

'use strict';

/**
 *  nathanir@ - Any changes to the hash outside of AUI popover navigation could result in unexpected behavior. It is
 *  not recommended to use popover navigation if an application is also modifying hash.
 */
P.when('A', 'ready').register('a-popover-navigate', function(A){
  var $ = A.$;
  var $window = $(window);

  /**
   *  A stack of visible navigable popovers.  Used when hiding popovers after altering the history stack.
   *
   *  @private
   *  @type {array}
   */
  var activeStack = [];

  /**
   *  Known history of hash navigation for the current page. Browser back button actually appends to this list, while
   *  programmatic back action will pop from this list.
   *
   *  Examples 1
   *  Navigate to #a       | hashes state = ['', 'a']            | browser history ['', 'a']
   *  Navigate to #b       | hashes state = ['', 'a', 'b']       | browser history ['', 'a', 'b']
   *  Programmatic back    | hashes state = ['', 'a']            | browser history ['', 'a']
   *  Programmatic forward | hashes state = ['', 'a', 'b']       | browser history ['', 'a', 'b']
   *  Navigate to #c       | hashes state = ['', 'a', 'b', 'c']  | browser history ['', 'a', 'b', 'c']
   *
   *  Example 2
   *  Navigate to #a  | hashes state = ['', 'a']                          | browser history ['', 'a']
   *  Navigate to #b  | hashes state = ['', 'a', 'b']                     | browser history ['', 'a', 'b']
   *  Navigate to #c  | hashes state = ['', 'a', 'b', 'c']                | browser history ['', 'a', 'b', 'c']
   *  Browser back    | hashes state = ['', 'a', 'b', 'c', 'b']           | browser history ['', 'a', 'b']
   *  Browser forward | hashes state = ['', 'a', 'b', 'c', 'b', 'c']      | browser history ['', 'a', 'b', 'c']
   *  Navigate to #d  | hashes state = ['', 'a', 'b', 'a', 'b', 'c', 'd'] | browser history ['', 'a', 'b', 'c', 'd']
   *
   *  Example 3
   *  Navigate to #a    | hashes state = ['', 'a']           | browser history ['', 'a']
   *  Navigate to #b    | hashes state = ['', 'a', 'b']      | browser history ['', 'a', 'b']
   *  Browser back      | hashes state = ['', 'a', 'b', 'a'] | browser history ['', 'a']
   *  Programmatic back | hashes state = ['', 'a', 'b']      | browser history [''] (This would likely result in bug, opening b)
   *
   *  @private
   *  @type {array}
   */
  var hashes =[];

  /**
   * Ignore enables the hash change function to bypass automatic navigation. Ignore is set to true when programmatically
   * setting a hash, and is then reset to false from the hash change handler. This only occurs when using the forward
   * API method.
   *
   * @private
   * @type {boolean}
   */
  var ignore = false;

  /**
   * The known object, associated hash values with navigable popovers.
   *
   * @private
   * @type {object}
   */
  var known = {};

  /**
   * _isBack disabled the hash change function from pushing new hash values to the hashes array. _isBack is set to true
   * when using the back API method, and it is then reset to false from the hash change handler. It is worth noting
   * that as indicated in examples above _isBack is not set when using the browser back button.
   *
   * @private
   * @type {boolean}
   */
  var _isBack = false;

  // Update browser hash or read browser hash
  function hash(value){
    if (typeof value === 'string'){
      ignore = true;
      window.location.hash = value;
    }

    return window.location.hash || '';
  }

  // Push initial window hash
  hashes.push(hash());

  // Determines hash from popover name and timestamp, updates browser hash, hashchange will fire with ignore=true
  // Known updated with popover handle
  function forward(popover){
    var name = popover.name + '_' + A.now();
    known['#' + name] = popover;
    hash(name);
  }

  // Pop off the last hash from hashes array, navigate the browser back, hashchange will fire with _isBack=true
  function back(){
    if (hashes.length > 0){
      hashes.pop();
    }

    _isBack = true;
    window.history.back();
  }

  // There are four expected methods of reaching this hashchagne event
  // - forward API with ignore=true
  // - back API with _isBack=true
  // - browser back (nathanir@ - unclear why this is handled different than back API)
  // - browser forward
  $window.bind('hashchange', function(event){
    event.preventDefault();

    if (!_isBack) {
      hashes.push(hash());
    } else {
      _isBack = false;
    }

    // Keep only the last 32 hashes on the stack
    if (hashes.length >= 32){
      hashes.shift();
    }

    if (ignore){
      ignore = false;
      return;
    }

    // For navigation, the last hash value is used. In expected use cases this would be the same as hash()
    var currentHash = hashes[hashes.length - 1];
    var popover = known[currentHash];

    // Navigate to popover for back API, browser back, or browser forward
    A.trigger('a:popover:navigate', popover);
  });

  /**
   *  When a popover needs to alter the history stack, we alter the stack first
   *  and then we either show or hide the popover.
   *
   *  nathanir@ - This handling seems confusing. It would seem that showing a popover will always contribute to
   *  activeStack. This would mean simply opening nested popovers, and clicking back for each one, would cause
   *  unexpected behavior.
   *
   *  For example:
   *  Navigate to #a     | hashes state = ['', 'a']      |          | activeStack = ['a']
   *  Navigate to #b     | hashes state = ['', 'a', 'b'] |          | activeStack = ['a', 'b']
   *  Programmatic back  | hashes state = ['', 'a']      | show 'a' | activeStack = ['a', 'b', 'a']
   *  Programmatic back  | hashes state = ['']           | hide 'a' | activeStack = ['a', 'b'] (This would likely result in bug, leaving b open)
   */
  A.on('a:popover:navigate', function (popover) {
    if (popover) {
      // Navigating to a popover, based on last hash value in hashes array on navigable hash change
      // preventNavigate prevents recursive calls to forward API
      popover.show({preventNavigate: true});
    } else {
      // Navigating to no popover, based on empty hash value or hash that does not match known popover
      // The expected use case would be based on empty hash value

      // If any popovers in the active stack, hide the last one.
      var lastActive = activeStack.length - 1 >= 0 ? activeStack[activeStack.length - 1] : null;
      if (lastActive) {
        // preventNavigate prevents recursive calls to back API
        lastActive.unlock().hide({preventNavigate: true});
      }
    }
  });

  /**
   *  Push active stack when a new popover is opened
   *  and then we either show or hide the popover.
   *
   *  AUI-5884 attempted to narrow popover types that contribute to active stack. Unfortunately this broke cases
   *  that dependent on this side effect AUI-6393. A legacy event is provided until these dependencies can be resolved.
   */
  A.on('a:popover:showNavigable a:popover:showNavigableLe);
  });

  /**
   *  Pop active stack when a new popover is opened
   *  and then we either show or hide the popover.
   *
   *  AUI-5884 attempted to narrow popover types that contribute to active stack. Unfortunately this broke cases
   *  that dependent on this side effect AUI-6393. A legacy event is provided until these dependencies can be resolved.
   */
  A.on('a:popover:hideNavigable a:popover:hideNavigableLe);
  });

  return {
    forward : forward,
    back : back
  }
});
/////////////////////////
// END FILE js/mixins/popover_navigate.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_position.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Positioning code for AUI Popover

'use strict';

P.when('A').register('a-popover-position', function (A) {
  var undefined,
    $ = A.$,
    $window = $(window),
    $offsetTracker = null,
    TRIGGER_SPACING = 3,
    POPOVER_SPACING = 1,
    PADDING = 20,
    IS_IE_MOBILE = A.capabilities.mobile && A.capabilities.isIE10Plus;

  P.when('prv:skin-vars-desktop').eG;
  });

  /**
   *  Insert a 1px DOM at (0,0). At the time when zooming happens, this DOM could
   *  provide offset information to fix the offset() function calls to other DOMs
   *
   *  @private
   *
   *  @return {object}  hash of top/left pixel values
   */

  function _getZoomOffset() {
    if (A.viewport().zoom === 1) {
      return {
        top: 0,
        left: 0
      }
    }
    // Lazy add offset tracker
    if (!$offsetTracker) {
      $offsetTracker = $('<span id="a-popover-offset-tracker"></span>');
      $("body").prepend($offsetTracker);
    }
    return $offsetTracker.offset();
  }

  /**
   *  A universal coordinate measurement function.  Returns window, popover, and trigger coordinates.
   *
   *  @public
   *  @param {DOM Node} $popover  The jQuery wrapped DOM Node for the popover
   *  @param {DOM Nods} $trigger  The jQuery wrapped DOM Node for the popover's trigger
   *
   *  @return {object}
   */

  function measure($popover, $trigger) {

    // Window dimensions
    var viewport = A.viewport();

    // Page zoom offset
    var zoomOffset = _getZoomOffset();

    // Trigger and Popover offset
    var triggerOffset = $trigger.offset(),
      popoverOffset = $popover.offset();

    // Fix: IE Mobile
    // In the IE Mobile webview, sometimes window.pageYOffset is incorrect. This problem traces all the way up to jQuery
    // where it uses window.pageYOffset to determine the scroll position of the webview. In *SOME, ONLY SOME* cases,
    // this value differs from document.documentElement.scrollTop, and in the cases where it does, it is incorrect and
    // the value from the document element is correct. Because popoverOffset and triggerOffset have their top values
    // calculated based on the window.pageYOffset value in jQuery, we want to take the final value and adjust it by the
    // difference of the two numbers.
    //
    // Without this code, the popover and tooltips can render themselves in the wrong positions, typically further down the
    // page than they should be by the exact amount of the difference between these two scroll values. In the browser
    // the values are always the same, so this code does not affect the values.
    if (IS_IE_MOBILE) {
      var offsetScrollDifferential = window.pageYOffset - document.documentElement.scrollTop;
      triggerOffset.top -= offsetScrollDifferential;
      popoverOffset.top -= offsetScrollDifferential;
    }

    // Fix: page zoom
    // When the page is zoomed the offset values are wrong. Fix that by subtracting the offset tracker.
    triggerOffset.top -= zoomOffset.top;
    triggerOffset.left -= zoomOffset.left;
    popoverOffset.top -= zoomOffset.top;
    popoverOffset.left -= zoomOffset.left;

    // Trigger and Popover dimensions
    var triggerWidth = $trigger.outerWidth(),
      triggerHeight = $trigger.outerHeight(),
      popoverWidth = $popover.outerWidth(true),
      popoverHeight = $popover.outerHeight(true);

    // Popover header dimensions
    var $popoverHeader = $popover.find(".a-popover-header");
    var headerHeight = $popoverHeader.length ? $popoverHeader.outerHeight(true) : 0;

    return {
      // Window
      windowWidth: viewport.width,
      windowHeight: viewport.height,
      windowTop: viewport.scrollTop,
      windowLeft: viewport.scrollLeft,
      windowRight: viewport.scrollLeft + viewport.width,
      windowBottom: viewport.scrollTop + viewport.height,

      // Zoom offset
      zoomTop: zoomOffset.top,
      zoomLeft: zoomOffset.left,

      // Trigger
      triggerWidth: triggerWidth + 1,
      triggerHeight: triggerHeight,
      triggerTop: triggerOffset.top - POPOVER_SPACING,
      triggerLeft: triggerOffset.left - POPOVER_SPACING,
      triggerRight: triggerOffset.left + triggerWidth + POPOVER_SPACING,
      triggerBottom: triggerOffset.top + triggerHeight + POPOVER_SPACING,
      triggerVerticalCenter: triggerOffset.top + (triggerHeight / 2),
      triggerHorizontalCenter: triggerOffset.left + (triggerWidth / 2),

      // Popover
      popoverWidth: popoverWidth,
      popoverHeight: popoverHeight,
      popoverTop: popoverOffset.top,
      popoverLeft: popoverOffset.left,
      popoverRight: popoverOffset.left + popoverWidth,
      popoverBottom: popoverOffset.top + popoverHeight,
      popoverVerticalCenter: popoverOffset.top + (popoverHeight / 2),
      popoverHorizontalCenter: popoverOffset.left + (popoverWidth / 2),

      // Popover header
      headerHeight: headerHeight
    }
  }

  /**
   *  Remove the CSS classes which place the arrow on the popover.
   *
   *  @private
   *  @param {DOM Node} $popover  The jQuery wrapped DOM node for the popover
  );
  }

  /**
   *  Determine the CSS top property for popovers which are positioned horizontally (triggerLeft,
   *  triggerRight, triggerHorizontal)
   *
   *  @private
   *  @param {object} coords  The coordinates returned by the measure function
   *
   *  @return {object}  The generated properties object.
   */

  function _determineTopHorizontal(coords) {
    var position = {
      deltaTop: 0
    };
    var padding = 0;

    position.top = coords.triggerVerticalCenter - (coords.popoverHeight / 2);
    if (position.top < coords.windowTop + PADDING) {
      padding = Math.min(coords.windowTop + PADDING, coords.triggerTop - PADDING);
      position.deltaTop = position.top - padding;
      position.top = padding;
    } else if (position.top + coords.popoverHeight > coords.windowBottom - PADDING) {
      padding = Math.min(PADDING, coords.windowBottom - coords.triggerBottom + PADDING);
      position.deltaTop = (position.top + coords.popoverHeight) - (coords.windowBottom - padding);
      position.top = coords.windowBottom - padding - coords.popoverHeight;
    }

    return position;
  }

  /**
   *  Determine the CSS left property for popovers which are positioned vertically (triggerTop,
   *  triggerBottom, triggerVertical)
   *
   *  @private
   *  @param {object} coords  The coordinates returned by the measure function
   *
   *  @return {object}  The generated properties object.
   */

  function _determineLeftVertical(coords) {
    var position = {
      deltaLeft: 0
    };
    var padding = 0;

    position.left = coords.triggerHorizontalCenter - (coords.popoverWidth / 2);
    if (position.left < PADDING) {
      padding = Math.min(PADDING, coords.triggerLeft - PADDING);
      position.deltaLeft = position.left - padding;
      position.left = padding;
    } else if (position.left + coords.popoverWidth > coords.windowRight - PADDING) {
      padding = Math.min(PADDING, coords.windowRight - coords.triggerRight + PADDING);
      position.deltaLeft = (position.left + coords.popoverWidth) - (coords.windowRight - padding);
      position.left = coords.windowRight - padding - coords.popoverWidth;
    }

    return position;
  }

  var strategies = {
    // Window
    windowCenter: function (popover) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      var coords = measure($popover, $trigger),
        position = {};

      position.top = (coords.windowHeight - coords.popoverHeight) / 2;
      position.left = (coords.windowWidth - coords.popoverWidth) / 2;

      // Set top to 0 instead of a nice padding for each popover type to include its specific padding
      if (position.top < 0) {
        position.top = 0;
      }
      return position;
    },

    windowTop: function (popover) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      var coords = measure($popover, $trigger);
      var position = {};

      position.top = 0;
      position.left = (coords.windowWidth / 2) - (coords.popoverWidth / 2);

      return position;
    },

    windowFull
    },

    // Manual
    triggerRight: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }

      var position = _determineTopHorizontal(coords);
      position.left = coords.triggerRight;

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass('a-arrow-right');
        $popover.find('.a-arrow-border').css('top', coords.popoverHeight / 2 + position.deltaTop);
      }

      return position;
    },

    triggerLeft: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }

      var position = _determineTopHorizontal(coords);
      position.left = coords.triggerLeft - coords.popoverWidth;
      position.left = (position.left > 0) ? position.left : 0;

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass('a-arrow-left');
        $popover.find('.a-arrow-border').css('top', coords.popoverHeight / 2 + position.deltaTop);
      }

      return position;
    },

    triggerTop: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }

      var position = _determineLeftVertical(coords);
      position.top = coords.triggerTop - coords.popoverHeight;

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass('a-arrow-top');
        $popover.find('.a-arrow-border').css('left', coords.popoverWidth / 2 + position.deltaLeft);
      }

      return position;
    },

    triggerBottom: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }

      var position = _determineLeftVertical(coords);
      position.top = coords.triggerBottom;

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass('a-arrow-bottom');
        $popover.find('.a-arrow-border').css('left', coords.popoverWidth / 2 + position.deltaLeft);
      }
      return position;
    },

    // Auto
    triggerHorizontal: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }
      var position = {};

      var triggerLeftSpace = coords.triggerLeft - coords.windowLeft;
      var triggerRightSpace = coords.windowRight - coords.triggerRight;

      // Put it on the side with more room
      return (triggerLeftSpace > triggerRightSpace) ? this.triggerLeft(popover, coords) : this.triggerRight(popover, coords);
    },

    triggerVertical: function (popover, inCoords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      var coords = inCoords ? inCoords : measure($popover, $trigger);
      var position = {};

      var triggerTopSpace = coords.triggerTop - coords.windowTop;
      var triggerBottomSpace = coords.windowBottom - coords.triggerBottom;

      return (triggerTopSpace > coords.popoverHeight + PADDING) ? this.triggerTop(popover, coords) : this.triggerBottom(popover, coords);
    },

    triggerVerticalAlignLeft: function (popover, coords) {
      var $popover = popover.$popover;
      var $trigger = popover.$trigger;
      if (!coords) {
        coords = measure($popover, $trigger);
      }
      var position = {};
      var delta = 0;
      var padding = 0;

      var triggerTopSpace = coords.triggerTop - coords.windowTop;
      var triggerBottomSpace = coords.windowBottom - coords.triggerBottom;

      position.left = coords.triggerLeft;
      position.top = (triggerBottomSpace > coords.popoverHeight) ? coords.triggerBottom + TRIGGER_SPACING : coords.triggerTop - coords.popoverHeight - TRIGGER_SPACING;
      if (position.left < PADDING) {
        padding = Math.min(PADDING, coords.triggerLeft - PADDING);
        delta = position.left - padding;
        position.left = padding;
      } else if (position.left + coords.popoverWidth > coords.windowRight - PADDING) {
        padding = Math.min(PADDING, coords.windowRight - coords.triggerRight + PADDING);
        delta = (position.left + coords.popoverWidth) - (coords.windowRight - padding);
        position.left = coords.windowRight - padding - coords.popoverWidth;
      }

      if (popover.attrs("popoverArrow")) {
        _clearPosition($popover).addClass((triggerBottomSpace > coords.popoverHeight) ? 'a-arrow-bottom' : 'a-arrow-top');
        $popover.find('.a-arrow-border').css('left', coords.triggerWidth / 2 + delta);
      }
      return position;
    },

    /**
     * Custom Strategy by injection
     *
     * @public
     * @param {object} $popover
     * @param {object} $trigger
     * @param {object} func  The injected method that will be run to determine position
     *
     * @return {object}  top/left hash
     */
    customPos
    }
  };

  return strategies;
});
/////////////////////////
// END FILE js/mixins/popover_position.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/mixins/popover_util.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Util for AUI Popover
 */

'use strict';

P.when('A').register('a-popover-util', function (A) {
  var $ = A.$;
  var undefined;
  var SPINNER = '<div class="a-popover-loading-wrapper a-text-center"><div class="a-box a-color-base-background a-popover-loading"></div></div>';


  /**
   *  The class defined as a declarative element
   *
   *  @private
   *  @constant
   *  @type {string}
   */
  var DECLARATIVE_CLASS = "a-declarative";

  /**
   *  A regular expression used to test whether or not a string is numeric.
   *
   *  @private
   *  @type {RegExp}
   */
  var NUMERIC = /^-?\d+(?:\.\d+)?$/;

  /**
   *  Determines if the first DOM node is a child of the second.
   *
   *  @private
   *  @param {DOM node} $target
   *  @param {DOM node} $node
   *
   *  @return {boolean}
   */

  function _isChild($target, $node) {
    return $target.closest($node).length > 0;
  }

  /**
   *  Do a depth-first search of the popover tree for popovers which causes the supplied condition
   *  function to return true.
   *
   *  @public
   *  @param {object} node  The root popover for this search
   *  @param {function} condition  A function which accepts a popover and returns a boolean
   *
   *  @return {undefined|object} popover
   */

  function search(node, condition) {
    var i = node.children.length;
    while (i--) {
      var found = search(node.children[i], condition);
      if (found) {
        return found;
      }
    }

    if (condition(node)) {
      return node;
    }
  }

  /**
   *  Determines whether or not the provided event occured within a given popover
   *
   *  @public
   *  @param {object} event
   *  @param {object} popover
   *
   *  @return {boolean}
   */

  function occursWithinPopover(event, popover) {
    var $target = $(event.target);

    return _isChild($target, popover.$trigger) || _isChild($target, popover.$popover);
  }

  /**
   *  Trigger a properly namespaced popover event
   *
   *  @public
   *  @param {string} eventName
   *  @param {object} popover
   *
   *  trigger a:popover:<eventName>
   *  trigger a:popover:<eventName>:<popover.name>
   */

  function triggerEvent(eventName, popover) {
    A.trigger('a:popover:' + eventName, {
      'popover': popover
    });

    if (popover.name) {
      A.trigger('a:popover:' + eventName + ':' + popover.name, {
        'popover': popover
      });
    }
  }

  /**
   *  Check if the dom has declarative action of a popover, if yes, return its attributes
   *
   *  @public
   *  @param {object} dom
   *  @param {string} type  popover type
   *
   *  @return {object} hash of info from declarative action
   */

  function extractDeclarativeParams(dom, type) {
    var $dom = $(dom),
      $trigger = $dom.hasClass(DECLARATIVE_CLASS) ? $dom : $dom.find("." + DECLARATIVE_CLASS).eq(0),
      actionName = "a-" + type,
      actionData = $trigger.data('action'),
      validDeclarAction = (actionData && A.contains(actionData, actionName));

    if (validDeclarAction) {
      return {
        attributes: $trigger.data(actionName) || null,
        $trigger: $trigger
      }
    } else {
      return null;
    }
  }

  /**
   *  If a CSS parameter is a number or a numeric string, assume pixels and add "px"
   *  to the property.
   *
   *  @private
   *  @param {object} attr
   *
   *  @return {string}
   */
  function getProperty(attr) {
    if (A.isFiniteNumber(attr) || NUMERIC.test(attr)) {
      attr += "px";
    }
    return attr;
  }

  /**
   *  Take the popvoer attributes hash and pull out all the CSS attributes.
   *
   *  @public
   *  @param {object} hash
   *
   *  @return {object}
   */
  function getCSSHash(hash) {
    var css = {};
    A.each(["height", "width", "max-height", "max-width", "min-height", "min-width"], function (attr) {
      if (hash[attr]) {
        css[attr] = getProperty(hash[attr]);
      }
    });
    if (css.height && !css["max-height"]) {
      css["max-height"] = "none";
    }
    if (css.width && !css["max-width"]) {
      css["max-width"] = "none";
    }
    return css;
  }

  /**
   *  Clear content area to standardize the unload operation
   *
   *  @private
   *  @param {object} popover
   */

  function clearContent(popover) {
    var $content = popover.getContent();
    if ($content) {
      $content.empty();
    }
  }

  /**
   * Simply show the spinner logo
   *
   * @public
   * @param {object} popover  popover instance
   *
   * @return {object} popover instance
   */

  function showSpinner(popover) {
    popover.updateContent(SPINNER);
    popover.updatePosition();

    return popover;
  }

  /**
   *  helper function to parse string/boolean true/false value and return the corresponding boolean value
   *
   *  @public
   *  @param {string|boolean} val
   *  @param {boolean} defaultVal  Default value if val is not defined. Default is false.
   *
   *  @return {boolean} true/false
   */

  function getBool(val, defaultVal) {
    return (val !== undefined) ?
        (val === true || val === 'true') : defaultVal === true;
  }

  return {
    trigger: triggerEvent,
    extractDeclarativeParams: extractDeclarativeParams,
    eventOccursWithin: occursWithinPopover,
    search: search,
    getCSSHash: getCSSHash,
    clearContent: clearContent,
    showSpinner: showSpinner,
    getBool: getBool
  };
});
/////////////////////////
// END FILE js/mixins/popover_util.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/base/modal_view_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Modal view - base class
 *
 */

'use strict';

P.when('A', 'a-popover-util', 'a-popover-animate').register('a-modal-view-base', function (A, util, animation) {
  var $ = A.$;

  /**
   *  Whether the browser is IE < 9
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_LT_IE9 = $("html").hasClass("a-lt-ie9");

  /**
   * The duration of the fadein effect when showing a modal.
   *
   * @private
   * @constant
   * @type {integer}
   */
  var SHOW_FADEIN_DURATION = 500;

  /**
   * The duration of the fadeout effect when hiding a modal.
   *
   * @private
   * @constant
   * @type {integer}
   */
  var HIDE_FADEOUT_DURATION = 250;

  return {

    /**
     * Update the aria-busy attribute for the overlay's wrapper element
     *
     * @public
     * @param {boolean} busy
     */
    setAriaBusy: function(busy) {
      this.$popover.find('.a-popover-wrapper').attr("aria-busy", busy);
    },

    /**
     *  If a modal's contents need to be updated after it has been created, call this function
     *
     *  @public
     *  @param {string|DOM Node} content
     */
    updateContent: function (content) {
      if (typeof content === "string") {
        this.$popover.find('.a-popover-inner').html(content);
      } else if (content) {
        this.$popover.find('.a-popover-inner').html("").append(content);
      }
    },

    /**
     *  Change the width and height of a popover
     *  Please make sure both the "off" and "on" cases are presented
     *
     *  @public
     *  @return {object}  DOM node
     */

    updateDimensions: function () {
      var popover = this;
      var $popover = popover.$popover;
      var cssHash = util.getCSSHash(popover.attrs());

      // If modal is draggable, give it firm width to avoid resizing when dragged
      // outside the window (caused by default width: auto)
      if (popover.draggable && (!cssHash.width || cssHash.width === 'auto')) {
        cssHash.width = $popover.width() + 'px';
      }

      $popover.css(cssHash);

      if (cssHash.height) {
        $popover.addClass("a-popover-modal-fixed-height");
      } else {
        $popover.removeClass("a-popover-modal-fixed-height");
      }

      if (popover.isActive()) {
        popover.updatePosition();
      }
      return popover;
    },

    /**
     *  Get content wrapper modal
     *
     *  @private
     *  @return {object}  DOM node
     */

    getContent: function () {
      return this.$popover ? this.$popover.find('.a-popover-inner') : null;
    },

    /**
     *  Show modal with a fadein effect
     *
     *  @public
     *  @param {function} triggerVisibilityChange The function that triggers the visibility event
     */

    showMethod: function (triggerVisibilityChange) {
      var popover = this;
      var $popover = popover.$popover;

      // Manipulating a-popover-hidden as a workaround for carousel-in-popover, remove then SC-1499 is resolved
      $popover.css({
        "visibility": "visible"
      }).removeClass("a-popover-hidden");

      // No fadeIns for IE < 9
      // No animation for ajax since position change during css transition produces a awkward shift animation
      if (!IS_LT_IE9 && popover.attrs("currentDataStrategy") !== "ajax") {
        $popover.css({
          opacity: 0
        });

        animation.animate(popover, { opacity: 1 }, SHOW_FADEIN_DURATION, "linear", function() {
          triggerVisibilityChange.call(popover);
        });
      }
      else {
        triggerVisibilityChange.call(popover);
      }

      // Focus on popover for keyboard accessibility
      A.animationFrameDelay(function() {
        popover.focus();
      });

      // Temporary event to mitigate dependencies on side effect navigation
      if (popover.attrs("legacyNavigable")) {
        util.trigger('showNavigableLegacy', popover);
      }
    },

    /**
     *  Override base hide method
     *
     *  @public
     *  @param {function} triggerVisibilityChange The function that triggers the visibility event
     */

    hideMethod: function (triggerVisibilityChange) {
      var popover = this;

      // Animating in IE < 9 is very slow when the DOM is large, so don't do that
      if (IS_LT_IE9) {
        popover.$popover.hide().css("visibility", "hidden").find(".a-lgtbox-vertical-scroll").removeClass("a-lgtbox-vertical-scroll");
        triggerVisibilityChange.call(popover);
      } else {
        animation.fadeOut(popover, HIDE_FADEOUT_DURATION, "linear", function() {
          triggerVisibilityChange.call(popover);
        });
      }

      // Temporary event to mitigate dependencies on side effect navigation
      if (popover.attrs("legacyNavigable")) {
        util.trigger('hideNavigableLegacy', popover);
      }
    }
  };
});
/////////////////////////
// END FILE js/modal/base/modal_view_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/modal/common/modal_view_standard.js */
/**
 *  Modal view - standard
 *
 */

'use strict';

P.when('A', 'a-modal-view-base', 'a-modal-positions', 'a-popover-accessibility').register('a-modal-view', function (A, viewBase, positions, a11y) {
  var undefined,
    $ = A.$;

  var PADDING_NONE_CLASS = 'a-padding-none';

  /**
   *  Whether the browser is IE < 9
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_LT_IE9 = $("html").hasClass("a-lt-ie9");

  /**
   *  Position strategy, and possibiliy before/after show/hide methods overrides
   *
   *  @private
   *  @constant
   *  @type {object}
   */
  var posStrategy = A.capabilities.touch || A.capabilities.mobile || A.capabilities.tablet || IS_LT_IE9 ? positions.innerScroll : positions.modalScroll;

  return A.extend(viewBase, posStrategy, {

    /**
     *  Skin function which determines the look of the modal.
     *
     *  @public
     *  @param {object} popover  Popover instance
     *
     *  @return {string} popover html
     */

    skin: function (popover) {
      var id = popover.attrs("id");
      var header = popover.attrs("header") || "";
      var hideHeader = popover.attrs("hideHeader") || false;
      var footer = popover.attrs("footer");
      var modeless = popover.attrs('modeless') || false;
      var hasCloseButton = popover.attrs("closeButton");
      var close_button_label = popover.attrs("closeButtonLabel") ? popover.attrs("closeButtonLabel")  : '';
      var hide_header_close_button_layout = popover.attrs("hideHeaderCloseButtonLayout") || '';
      var popover_label = popover.attrs("popoverLabel") ? popover.attrs("popoverLabel"): '';
      var padding = popover.attrs("padding");
      var aria_description = popover.attrs("ariaDescription");
      var accesibility_params = {
          id : id,
          header_str: header,
          label_str: popover_label,
          aria_description: aria_description
      };

      // with hide_header_close_button_layout 'top', the close button layout will occupy top space of hideHeader modal.
      var close_button_css_class = hide_header_close_button_layout === 'top' ?
          ' a-modal-close-nohead-top' : ' a-button-top-right';

      // build the close button HTML if a close button was requested
      var closeButton = ['<button data-action="a-popover-close" class="',
          !hasCloseButton ? ' a-button-close-a11y' : '',
          ' a-button-close a-declarative',
          // if the header is hidden and the close button is present, the close button will appear in the popover inner body and needs an extra class to position it
          hasCloseButton && hideHeader ? close_button_css_class : '',
          '" aria-label="',
          close_button_label,
          '"><i class="a-icon a-icon-close"></i></button>'].join('');

      // build the header if it is not suppressed by the hideHeader option:
      var header_str = hideHeader ? '' : [
        '<div class="a-popover-header">',
        closeButton,
        '<h4 class="a-popover-header-content' + (modeless ? ' a-popover-draggable-handle' : '') + '" id="a-popover-header-', id,'">', header, '</h4>',
        '</div>'].join('');

      // Do not render footer if footer not set
      var footer_str = footer ? [
        '<div class="a-popover-footer">',
        footer,
        '</div>'
      ].join('') : '';

      // If padding is none, add the a-padding-none class to a-popover-inner
      var paddingClass = (padding === 'none') ? " " + PADDING_NONE_CLASS : '';

      return [
        modeless ? '' : '<div class="a-modal-scroller a-declarative" data-action="a-popover-floating-close">',
        // Build the popover div, add in modeless class if modeless dialog was requested
        '<div class="a-popover a-popover-modal a-declarative' + (modeless ? ' a-modal-modeless' : ' ') + '" data-action="a-popover-a11y">',
        a11y.getStartAnchorHtml(accesibility_params),
        '<div class="a-popover-wrapper">',
        header_str,
        // If the header is hidden, the close button goes inside the popover wrapper
        hideHeader ? closeButton : '',
        '<div class="a-popover-inner', paddingClass, '" id="a-popover-content-', id, '"></div>',
        footer_str,
        '</div>',
        a11y.getEndAnchorHtml(accesibility_params),
        '</div>',
        modeless ? '' : '</div>'
      ].join('');
    }
  });
});
/* Done importing js/modal/common/modal_view_standard.js */

/////////////////////////
// END FILE js/modal/modal_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal_positions.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Modal position strategies
 *
 */

'use strict';

P.when('A', "a-popover-lightbox", 'a-popover-optional-helpers')
    .register('a-modal-positions', function (A, lgtbox, helpers) {
  var undefined;
  var $ = A.$;

  /**
   *  A flag to determine if this is a IE10+ mobile device for special handling for those devices
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_WIN_MOBILE = A.capabilities.isIE10Plus && A.capabilities.mobile;

  /**
   *  Ratio of screen size that may be occupied by modal dialog before scrolling begins.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var SCROLL_THRESHOLD = 0.8;

  /**
   *  Ratio of screen size that may be used for left position and right padding when horizontal scroll is active.
   *
   *  @private
   *  @constant
   *  @type {number}
   */
  var SCROLL_HORIZONAL_PADDING_RATIO = 0.05;

  var optionalButtonHeight = 0;
  P.when('prv:skin-vars').execute(function(vars) {
    optionalButtonHeight = vars.popover.optionalButtonHeight;
  });

  /**
   * Return measurements for popover maximum inner height.
   *
   * @public
   * @param {object} popover  popover instance
   * @return {Object}  maximum height value
   */
  function determineMaximumInnerHeight(popover) {
    var $popover = popover.$popover;

    // determine available height, multiply viewport by modal scrolling factor
    var maximumInnerHeight = A.viewport().height * SCROLL_THRESHOLD;

    // subtract header and footer height
    // only one of .a-popover-header or .a-modal-close-nohead-top will match
    var headerHeight = $popover.find(".a-popover-header, .a-modal-close-nohead-top").outerHeight(true) || 0;
    var footerHeight = $popover.find(".a-popover-footer").outerHeight(true) || 0;
    var maximumInnerHeight = maximumInnerHeight - headerHeight - footerHeight;

    return maximumInnerHeight;
  }

  /**
   * Return measurements for popover inner vertical padding.
   *
   * @public
   * @param {object} popover  popover instance
   * @return {Object}  inner vertical padding value
   */
  function determineInnerVerticalPadding(popover) {
    var $popover = popover.$popover;

    // subtract inner popover padding
    var $innerPopover = $popover.find('.a-popover-inner');
    var innerPopoverPadding = $innerPopover.outerHeight() - $innerPopover.height();

    return innerPopoverPadding;
  }

  /**
   * Enable modal scroll if popover is taller than 80% of viewport
   * requirement is to have 10% top/bottom when modal is scrollable
   *
   * @private
   *
   * @param {object} popover  popover instance
   */
  function _enableModalScroll(popover) {
    var $popover = popover.$popover;
    var $scroller = $popover.closest(".a-modal-scroller");

    //show scroller first for $popover height/width to be accurate
    $scroller.scrollTop(0).css("visibility", "visible");

    $scroller.bind("scroll", function () {
      popover.updateChildrenPosition();
    });
  }

  /**
   * Disable modal scroll
   *
   * @private
   *
   * @param {object} popover  popover instance
   */
  function _disableModalScroll(popover) {
    var $popover = popover.$popover,
      $scroller = $popover.closest(".a-modal-scroller");

    $scroller.css("visibility", "hidden").unbind("scroll");
  }

  /**
   * Special handling with lightbox dimension when win touch
   *
   * @private
   * @param {object} coords  measure result from popover_positions.js
   * @param {number} horizontalPadding  calculated padding from positionStrategy
   */
  function _adjustLightboxDimension(coords, horizontalPadding){
    var docHeight = $(document).height();
    var docWidth = $(document).width();
    var $lgtbox = $("#" + lgtbox.LIGHTBOX_ID);

    // Win mobile makes has DOM rendering issue AND having problem locking document,
    //    therefore trying our best to cover the entire document using position:absolute
    // We also want to ensure the lightbox area can cover the entire popover if
    //    the popover is wide, therefore the width logic below
    $lgtbox.css({
      "height": docHeight,
      "width": docWidth > coords.popoverWidth ? docWidth: coords.popoverWidth + horizontalPadding
    });
  }

  /**
   *  IE Tablet in landscape, in the modern app, positions things incorrectly when the on screen keyboard presents itself.
   *  Because we call this based on a guess, we still want to be sure that this could be the result of a keyboard showing, so
   *  Check the aspect ratio and make sure it's sufficiently large to suggest that may be the case. We can't be too aggressive
   *  and still be safe with this check as larger screens exist and the keyboard doesn't eat the entire screen in those systems.
   *  This safely covers all the tablets we have on hand though as they are 16:9 and end up being 32:9 with the keyboard open.
   *  That may not persist to the Surface Pro 3, and isn't a known constant for laptops, but >2 should be safe.
   *
   *  @private
   *  @param {number} pos
   */
  function _scrollToModalWithTextInput() {
    var viewport = A.viewport();

    if (viewport.width / viewport.height > 2) {
      A     }, 0);
    }
  }

  /**
   *  In general, a modal dialog will attempt to center itself in the viewport based on content size. This behavior will
   *  maintain until the modal dialog width exceeds the viewport width and a new strategy is used. The new strategy
   *  enforces a minimum horizontal padding to indicate to the user that scrolling or panning is available.
   *
   *  Example of rendering when popover exceeds width.
   *
   *  Viewport width: 400px
   *  Minimum horizonal padding: 20px (viewport width x SCROLL_HORIZONAL_PADDING_RATIO)
   *  Popover width: 500px
   *
   *  400px                       400px
   *  +----------------+          +----------------+
   *  |                |          |                |
   *  |20px(left)      |          |   20px(padding)|
   *  |   +------------+          +------------+   |
   *  |   |            |          |            |   |
   *  |   |            |          |            |   |
   *  |   |      500px |  => pan, | 500px      |   |
   *  |   |  (content-b|   scroll |ntent-box)  |   |
   *  |   |            |          |            |   |
   *  |   +------------+          +------------+   |
   *  |                |          |                |
   *  |                |          |                |
   *  +----------------+          +----------------+
   *
   *  @private
   *  @param {number} currentLeft - left as described above, provider by caller
   *  @param {number} minimumHorizonalPadding - horizontal padding as described above, provided by caller
   *  @param {function(object)} applyStylesFn - invoked with popover styles to apply
   *  @return {boolean} left should be reset to minimumHorizonalPadding by caller
   */
  function _applyHorizonalScrollStyles(currentLeft, minimumHorizonalPadding, applyStylesFn) {
    if (currentLeft < 0) {
      applyStylesFn({
        "padding-right": minimumHorizonalPadding + "px",
        // Preserve implicit width of popover
        "box-sizing": "content-box"
      });
      return true;
    } else {
      applyStylesFn({
        "padding-right": "",
        "box-sizing": ""
      });
      return false;
    }
  }
  // visible for testing
  P.declare('prv:a-model-applyHorizonalScrollStyles', _applyHorizonalScrollStyles);

  /**
   *  Simple binding helper for $.css function
   *
   *  @private
   *  @param {jQuery} $popover
   *  @return {function(object)} function invoked with popover styles to apply
 };
  }

  var innerScroll = {
    /**
     *  For mobile devices (actually touch, mobile, tablet, and LT IE9), make a-popover-inner scrollable instead
     *
     *  @public
     *  @param {Object} options  hash of info from popover_position
     *
     *  @return {Object}  top/left values
     */

    positionStrategy: function (options) {
      var popover = options.popover;
      var $popover = options.$popover;
      var $trigger = options.$trigger;
      var $inner = $popover.find(".a-popover-inner").css("height", "auto");
      var $scroller = $popover.closest(".a-modal-scroller");
      var position = {};
      var viewport = A.viewport(true);
      var verticalPadding = viewport.height * 0.1;
      var horizontalPadding = viewport.width * SCROLL_HORIZONAL_PADDING_RATIO;
      var scrollThresholdHeight = viewport.height * SCROLL_THRESHOLD;

      // Resetting height, or ensuring popover height matches attrs
      var popHeight = popover.attrs("height");
      var popMinHeight = popover.attrs("min-height");
      $popover.css({
        "height": popHeight ? popHeight : "",
        "min-height": popMinHeight ? popMinHeight : ""
      });

      // Measure dimention after popover height is restored
      var coords = options.measure($popover, $trigger);

      position.left = (coords.windowWidth - coords.popoverWidth) / 2;

      if (_applyHorizonalScrollStyles(position.left, horizontalPadding, _defaultStylesFnProvider($popover))) {
        position.left = horizontalPadding;
      }

      var actualHeight = helpers.evaluateActualHeight(options, coords.popoverHeight, optionalButtonHeight);
      if (actualHeight > scrollThresholdHeight) {
        // only one of .a-popover-header or .a-modal-close-nohead-top will match
        var headerHeight = $popover.find(".a-popover-header, .a-modal-close-nohead-top").outerHeight(true) || 0;
        var footerHeight = $popover.find(".a-popover-footer").outerHeight(true) || 0;

        var offsetTop = verticalPadding;
        var delta = helpers.getOffsetTopDelta(options, offsetTop, optionalButtonHeight);
        var popoverHeight = scrollThresholdHeight - delta;
        offsetTop += delta;

        // If a modal is set with a height, there is a chance even if innerScroll
        //     the modal itself still needs to be scroll, which violates the
        //     meaning of this strategy, hence set a height on behave if that comes
        var innerHeight = popoverHeight - headerHeight - footerHeight;
        $inner.css({
          "height": innerHeight + "px",
          "overflow-y": "auto"
        });
        $popover.css({
          "height": popoverHeight,
          "min-height": 0
        });

        position.top = offsetTop;
      } else {
        position.top = (coords.windowHeight - coords.popoverHeight) / 2;
        $inner.css("height", "auto");
      }

      position.left += coords.zoomLeft;
      position.top += coords.zoomTop;

      if (IS_WIN_MOBILE) {
        // $scroller is position:absolute now, need to ensure his top is the
        //     scrollTop instead of 0 when position:static
        $scroller.css("top", $(window).scrollTop());

        // In theory we should only add a-popover-pan-x when popover width
        //     is larger then document width, however after some tests this is
        //     the only way to stop the background from scrolling, not even
        //     applying touch-action(none).
        // I believe that is a win phone bug, and for now, we add a-popover-pan-x
        //     for all cases and restrict lightbox width to document width or
        //     popover width, whatever which is larger.
        $popover.removeClass("a-popover-pan-y").addClass("a-popover-pan-x");

        _adjustLightboxDimension(coords, horizontalPadding);
      }

      /*
       * We have a problem with the Metro / Modern UI keyboard. We attempt to guess
       * if we're in Metro (no activeX) and then we rule out cases where the touch
       * keyboard will never display (machines without touch capability never show
       * the on screen keyboard even in Metro / Modern UI IE).
       *
       * This check isn't perfect, this could still run on the desktop version of
       * the client, but it should also be non-damaging to those platforms as we're
       * scrolling to the exact spot the viewport should already be in.
       */
      if (A.capabilities.isMetroIEGuess && A.capabilities.isIETouchCapable) {
        _scrollToModalWithTextInput();
      }

      return position;
    },

    beforeShowMethod: A.constants.NOOP,

    beforeHideMethod: A.constants.NOOP
  };

  var modalScroll = {
    /**
     *  Allow the modal dialog itself to be scrolled within the viewport for desktop.
     *
     *  @public
     *  @param {Object} options  hash of info from popover_position
     *
     *  @return {Object}  top/left values
     */

    // TODO [AUIQA-1172] is fixed for mobile only due to the initial root cause
    // is limited in mobile. However, if the limitation changes in the future
    // (i.e. launching SKY in desktop), we need to apply the fix to desktop, too.
    positionStrategy: function (options) {
      var $popover = options.$popover;
      var $trigger = options.$trigger;
      var $scroller = $popover.closest(".a-modal-scroller");
      var $inner = $popover.find(".a-popover-inner").css("height", "auto");
      if ($popover.hasClass("a-popover-modal-fixed-height")) {
        var $footer = $popover.find(".a-popover-footer")
        $inner.css("padding-bottom", $footer.height() + 15)
      }
      var position = {};
      var viewport = A.viewport(true);
      var viewportHeight = viewport.height;
      var viewportWidth = viewport.width;
      var verticalPadding = viewportHeight * 0.1;
      var horizontalPadding = viewportWidth * SCROLL_HORIZONAL_PADDING_RATIO;
      var scrollThresholdHeight = viewportHeight * SCROLL_THRESHOLD;
      // Need to get popover width/height without margin
      var popoverHeight = $popover.height();
      var popoverWidth = $popover.width();
      var coords = options.measure($popover, $trigger);

      position.left = (coords.windowWidth - popoverWidth) / 2;
      position.top = (coords.windowHeight - popoverHeight) / 2;

      if (_applyHorizonalScrollStyles(position.left, horizontalPadding, _defaultStylesFnProvider($popover))) {
        position.left = horizontalPadding;
      }

      if (popoverHeight > scrollThresholdHeight) {
        if ($scroller.length) {
          position.top = 0;

          $popover.css({
            "position": "relative",
            "margin": (coords.zoomTop + verticalPadding) + "px 0 " + verticalPadding + "px " + (coords.zoomLeft + position.left) + "px"
          });

          position.left = 0;

          // This bottom padding is needed to ensure that the bottom margin of the a-popover div actually creates
          // the necessary space between the bottom of the page and the bottom of the modal
          $scroller.css("padding-bottom", "1px");
        } else {
          if (popoverHeight > scrollThresholdHeight) {
            position.top = padding;
          }
        }
      } else {
        if ($scroller.length) {
          $popover.css({
            "position": "absolute",
            "margin": "0px"
          });
          $scroller.css("padding-bottom", "0px");
        }
      }

      position.left += coords.zoomLeft;
      position.top += coords.zoomTop;

      /*
       * We have a problem with the Metro / Modern UI keyboard. We attempt to guess
       * if we're in Metro (no activeX) and then we rule out cases where the touch
       * keyboard will never display (machines without touch capability never show
       * the on screen keyboard even in Metro / Modern UI IE).
       *
       * This check isn't perfect, this could still run on the desktop version of
       * the client, but it should also be non-damaging to those platforms as we're
       * scrolling to the exact spot the viewport should already be in.
       */
      if (A.capabilities.isMetroIEGuess && A.capabilities.isIETouchCapable) {
        _scrollToModalWithTextInput();
      }

      return position;
    },

    /**
     *  Add scroll effect before showing modal
     *
     *  @public
     */

    beforeShowMethod: function () {
      var popover = this;
      _enableModalScroll(popover);
    },

    /**
     *  Remove scroll effect before hiding modal
     *
     *  @public
     */

    beforeHideMethod: function () {
      var popover = this;
      _disableModalScroll(popover);
    }
  };

  return {
    innerScroll: innerScroll,
    modalScroll: modalScroll,
    util: {
      determineMaximumInnerHeight: determineMaximumInnerHeight,
      determineInnerVerticalPadding: determineInnerVerticalPadding
    }
  }
});
/////////////////////////
// END FILE js/modal/modal_positions.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Modal factory class
 *
 */

"use strict";

P.when('A', 'a-popover-base-factory', 'a-modal-view', 'a-popover-util').register('a-modal-factory', function (A, baseFactory, view, util) {
  var $ = A.$;
  var POPOVER_TYPE = "modal";
  var DECLARATIVE_CLASS = "a-declarative";

  /**
   *  Whether the browser is IE < 9
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IS_LT_IE9 = document.documentElement.className.indexOf("a-lt-ie9") > -1;

  var IS_WIN_MOBILE = A.capabilities.mobile && A.capabilities.isIE10Plus;

  /**
   *  Create a new modal with the given customization options.
   *  When called by customers, it is intended to create declarative action DOM wrapping
   *  the trigger for customers
   *
   *  @public
   *  @param {object} $trigger    jquery wrapped DOM of the trigger
   *  @param {object} attributes  hash of attributes for popover
   *
   *  @return {object} popover
   */

  function create($trigger, attributes) {
    // Disable modeless draggable modals in mobile or table mode as
    // the screen real estate is already small. It will use the regular
    // immersive modals instead
    var modeless = false, draggable = false;
    if (!(A.capabilities.mobile || A.capabilities.tablet)) {
      modeless = util.getBool(attributes.modeless);
      draggable = util.getBool(attributes.draggable);
    }
    
    var attributes = {
      modeless: modeless,
      draggable: draggable,
      type: POPOVER_TYPE,
      alone: true,
      immersive: true,
      position: 'windowCenter',
      header: attributes.header,
      hideHeader: attributes.hideHeader,
      footer: attributes.footer,
      padding: attributes.padding,
      width: attributes.width,
      height: attributes.height,
      "max-width": attributes["max-width"],
      "max-height": attributes["max-height"],
      "min-width": attributes["min-width"],
      "min-height": attributes["min-height"],
      closeButton: util.getBool(attributes.closeButton, true),
      timeout: attributes.timeout,
      lightboxOptions: modeless ? undefined :
          {
            lockScroll: true,
            showDuration: IS_LT_IE9 || IS_WIN_MOBILE ? 0 : null // fadeIn in <= IE8 makes ligthbos entirely black
          },
      //TODO SC-1333 adding back "data" as wish list is using it extensively.
      //     smetke@ has promised to remove the "data" related anchors on their Nov release for us to remove that.
      data: attributes.data || {},
      // Data sources
      dataStrategy: attributes.dataStrategy,
      url: attributes.url,
      manualRefresh: !! attributes.manualRefresh,
      ajaxFailMsg: attributes.ajaxFailMsg,
      cache: util.getBool(attributes.cache, true),
      inlineContent: attributes.inlineContent ? attributes.inlineContent : attributes.content,
      name: attributes.name,
      closeButtonLabel: attributes.closeButtonLabel ? attributes.closeButtonLabel : "Close",
      hideHeaderCloseButtonLayout: attributes.hideHeaderCloseButtonLayout,
      popoverLabel : attributes.popoverLabel,
      ariaDescription : attributes.ariaDescription,
      legacyNavigable: util.getBool(attributes.legacyNavigable, true)
    };

    return baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: view,
      actionCheck: true
    });
  }

  /**
   *  Get a modal, extends from popover_baseFactory
   *  This method creates a popover instance if an existing one could not be found
   *
   *  @public
   *  @param {object|integer|string} id
   *
   *  @return {object}  modal instance
   */

  function get(id) {
    var popover = baseFactory.get(id, POPOVER_TYPE);

    // If there is no popover and the input is a declarative action, the popover instance
    // is not yet created.  Will create one to return now.
    if (!popover && typeof id === "object") {
      var declarInfo = util.extractDeclarativeParams(id, POPOVER_TYPE);
      if (declarInfo) {
        popover = create(declarInfo.$trigger, declarInfo.attributes || {});
      }
    }

    return popover;
  }

  /**
   *  Remove a modal dialog.  Delegates to the base factory.  Will remove the modal declarative action
   *  as well as the popover DOM nodes for the modal dialog itself.
   *
   *  @public
   *  @param {object|number|string} id
   *
   *  @return {boolean} success
   */

  function remove(id) {
    return baseFactory.remove(id, POPOVER_TYPE);
  }

  return {
    type: POPOVER_TYPE,
    create: create,
    get: get,
    remove: remove
  };
});
/////////////////////////
// END FILE js/modal/modal_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/modal/common/modal_handlers_standard.js */
/**
 * Modal desktop event handlers
 *
 */

"use strict";

P.when('A', 'a-popover-base-factory', 'a-modal-factory', 'ready').register('a-modal-handlers', function (A, baseFactory, factory) {
  var undefined,
    $ = A.$,
    POPOVER_TYPE = "modal";

  /**
   * Show modal when click
   */
  A.declarative('a-modal', 'c);
  });

  /**
   *  Does nothing when a-modal-scroller is clicked directly to avoid unintentional clicks
   */

  $(document).delegate(".a-modal-scroller", "click " + A.action.start + " " + A.action }
  });
});
/* Done importing js/modal/common/modal_handlers_standard.js */

/////////////////////////
// END FILE js/modal/modal_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/modal/modal.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * API end point class for Modal
 *
 */

'use strict';

P.when('A', 'a-modal-factory', 'a-popover-base', 'a-modal-handlers').register('a-modal', function (A, factory) {

  /**
   * Returning modal factory
   */
  return factory;
});
/////////////////////////
// END FILE js/modal/modal.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/base/popover_view_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Popover view - base class
 *
 */

'use strict';

P.when('A', 'a-popover-util', 'a-popover-animate').register('a-popover-view-base', function (A, util, animation) {
  var undefined,
    $ = A.$;

  return {

    /**
     * Update the aria-busy attribute for the overlay's wrapper element
     *
     * @public
     * @param {boolean} busy
     */
    setAri
    },

    /**
     *  Load content into the popover, use when create/update a popover
     *
     *  @public
     *  @param {string|DOM Node} content
     */
    updateContent: function (content) {
      if (typeof content === "string") {
        this.$popover.find('.a-popover-content').html(content);
      } else if (content) {
        this.$popover.find('.a-popover-content').html("").append(content);
      }
    },

    /**
     *  Change the width and height of a popover
     *  Please make sure both the "off" and "on" cases are presented
     *
     *  @public
     *  @return {object}  DOM node
     */

    updateDimensions: function () {
      var popover = this;
      popover.$popover.css(util.getCSSHash(popover.attrs()));
      if (popover.isActive()) {
        popover.updatePosition();
      }
      return popover;
    },

    /**
     *  Get content wrapper of the popover
     *
     *  @public
     *  @return {object}  DOM node
     */

    getCo
    },

    /**
     *  Overrides base hide method
     *
     *  @public
     *  @param {function} triggerVisibilityChange The function that triggers the visibility event
     */

    hideMethod: function (triggerVisibilityChange) {
      var popover = this;
      animation.fadeOut(popover, 250, "linear", function() {
        // Reset the offset to ensure that the position is calculated correctly
        popover.$popover.css({
          "top": "auto",
          "left": "auto"
        });
        triggerVisibilityChange.call(popover);
      });
    }
  };
});
/////////////////////////
// END FILE js/popover/base/popover_view_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/common/popover_optional_helpers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

P.when('a-util').register('a-popover-optional-helpers', function(util) {
    'use strict';

    function getOffsetTopDelta(options, offsetTop, minOffsetTop) {
        minOffsetTop = parseFloat(minOffsetTop);
        var needAdjustment = util.isFiniteNumber(minOffsetTop) && minOffsetTop > 0;
        var hasVisibleCloseButton = options.$popover.find('.a-button-close').length &&
                                   !options.$popover.find('.a-button-close-a11y').length;
        // TODO options.popover.attrs('closeButton') should be fixed later
        var isTooSmallForButton = (offsetTop - minOffsetTop) < 0;

        if (needAdjustment && hasVisibleCloseButton && isTooSmallForButton) {
            return minOffsetTop - offsetTop;
        }
        return 0; // By default, no adjustment is needed
    }
    function evaluateActualHeight(options, baseHeight, buttonHeight) {
        var hasVisibleCloseButton = options.$popover.find('.a-button-close').length &&
                                   !options.$popover.find('.a-button-close-a11y').length;
        // TODO options.popover.attrs('closeButton') should be fixed later
        return hasVisibleCloseButton ? baseHeight + buttonHeight : baseHeight;
    }
    return {
        getOffsetTopDelta: getOffsetTopDelta,
        evaluateActualHeight: evaluateActualHeight
    }
});
/////////////////////////
// END FILE js/popover/common/popover_optional_helpers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/popover_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/popover/common/popover_view_standard.js */
/**
 *  Popover view - standard
 *
 */

'use strict';

P.when('A', 'a-popover-view-base', 'a-popover-util', 'a-popover-accessibility').register('a-popover-view', function (A, viewBase, util, a11y) {

  var PADDING_NONE_CLASS = 'a-padding-none';

  var closeButtonEnabled = true;

  P.when('prv:skin-vars').ed;
  })

  return A.extend(viewBase, {
    /**
     *  Skin function which determines the look of the popover.
     *
     *  @public
     *  @param {object} popover  Popover instance
     *
     *  @return {string} popover html
     */

    skin: function (popover) {
      var id = popover.attrs("id");
      var header = popover.attrs("header");
      var hasCloseButton = closeButtonEnabled && popover.attrs("closeButton");
      var close_button_label = popover.attrs("closeButtonLabel") ? popover.attrs("closeButtonLabel")  : '';
      var popover_label = popover.attrs("popoverLabel") ? popover.attrs("popoverLabel"): '';
      var aria_description = popover.attrs("ariaDescription");
      var padding = popover.attrs("padding");
      var hasPopoverArrow = popover.attrs("popoverArrow");
      var accesibility_params = {
          id : id,
          header_str: header,
          label_str: popover_label,
          aria_description: aria_description
      };

      var close_button_a11y_class = !hasCloseButton ? 'a-button-close-a11y' : '';
      var close_button_str = '<button data-action="a-popover-close" class="a-button-close ' + close_button_a11y_class + ' a-declarative" aria-label="' + close_button_label + '"><i class="a-icon a-icon-close"></i></button>';
      var has_header = (header && header !== '');
      var header_str = has_header ? [
        '<div class="a-popover-header">',
        close_button_str,
        '<h4 class="a-popover-header-content" id="a-popover-header-', id,'">' , header , '</h4>',
        '</div>'
      ].join('') : '';
      var has_header_class = has_header ? 'a-popover-has-header' : 'a-popover-no-header';

      // If padding is none, add the a-padding-none class to a-popover-inner
      var paddingClass = (padding === 'none') ? " " + PADDING_NONE_CLASS : '';
      var popover_arrow_str = hasPopoverArrow ? '<div class="a-arrow-border"><div class="a-arrow"></div></div>' : '';

      return [
        '<div class="a-popover ', has_header_class, ' a-declarative" data-action="a-popover-container a-popover-a11y">',
        a11y.getStartAnchorHtml(accesibility_params),
        '<div class="a-popover-wrapper">',
        header_str,
        '<div class="a-popover-inner', paddingClass, '">',
        header_str === '' ? close_button_str : '',
        '<div class="a-popover-content" id="a-popover-content-', id,'"></div>', // It is important to have an additional div for content to prevent the button from being removed during content update
        '</div>',
        popover_arrow_str,
        '</div>',
        a11y.getEndAnchorHtml(accesibility_params),
        '</div>'].join('');
    }
  });
});
/* Done importing js/popover/common/popover_view_standard.js */

/////////////////////////
// END FILE js/popover/popover_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/popover_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  This is a factory class for popovers, inheriting popover_factory
 *
 */

'use strict';

P.when('A', 'a-popover-base-factory', 'a-popover-view', 'a-popover-util').register('a-popover-factory', function (A, baseFactory, view, util) {
  var $ = A.$,
    POPOVER_TYPE = "popover",
    DECLARATIVE_CLASS = "a-declarative";

  /**
   *  Create a new popover with the given customization options.
   *  When called by customers, it is intended to create declarative action DOM wrapping
   *  the trigger for customers
   *
   *  @public
   *  @param {object} $trigger    jquery wrapped DOM of the trigger
   *  @param {object} attributes  hash of attributes for popover
   *
   *  @return {object} popover
   */

  function create($trigger, attributes) {

    var attributes = {
      type: POPOVER_TYPE,
      alone: true,
      header: attributes.header,
      width: attributes.width,
      height: attributes.height,
      "max-width": attributes["max-width"],
      "max-height": attributes["max-height"],
      "min-width": attributes["min-width"],
      "min-height": attributes["min-height"],
      padding: attributes.padding,
      closeButton: util.getBool(attributes.closeButton, true),
      position: attributes.position || 'triggerVertical',
      activate: attributes.activate || 'onmouseover',
      timeout: attributes.timeout,
      //TODO SC-1333 adding back "data" as wish list is using it extensively.
      //     smetke@ has promised to remove the "data" related anchors on their Nov release for us to remove that.
      data: attributes.data || {},
      // Data sources
      dataStrategy: attributes.dataStrategy,
      url: attributes.url,
      manualRefresh: !! attributes.manualRefresh,
      ajaxFailMsg: attributes.ajaxFailMsg,
      cache: util.getBool(attributes.cache, true),
      inlineContent: attributes.inlineContent ? attributes.inlineContent : attributes.content,
      name: attributes.name,
      closeButtonLabel: attributes.closeButtonLabel ? attributes.closeButtonLabel : "Close",
      popoverLabel : attributes.popoverLabel,
      ariaDescription : attributes.ariaDescription,
      focusWhenShown: util.getBool(attributes.focusWhenShown, true),
      popoverArrow: util.getBool(attributes.popoverArrow, true),
      restoreFocusOnHide: util.getBool(attributes.restoreFocusOnHide, true)
    };

    return baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: view,
      actionCheck: true
    });
  }

  /**
   *  Get a popover, extends from popover_baseFactory
   *  This method creates a popover instance if an existing one could not be found
   *
   *  @public
   *  @param {object|integer|string} id
   *
   *  @return {object}  popover instance
   */

  function get(id) {
    var popover = baseFactory.get(id, POPOVER_TYPE);

    // If there is no popover and the input is a declarative action, the popover instance
    // is not yet created.  Will create one to return now.
    if (!popover && typeof id === "object") {
      var declarInfo = util.extractDeclarativeParams(id, POPOVER_TYPE);
      if (declarInfo) {
        popover = create(declarInfo.$trigger, declarInfo.attributes || {});
      }
    }

    return popover;
  }

  /**
   *  Remove a popover dialog.  Delegates to the base factory.  Will remove the popover declarative action
   *  as well as the popover DOM nodes for the popover itself.
   *
   *  @public
   *  @param {object|number|string} id
   *
   *  @return {boolean} success
   */

  function remove(id) {
    return baseFactory.remove(id, POPOVER_TYPE);
  }


  return {
    type: POPOVER_TYPE,
    create: create,
    get: get,
    remove: remove
  };
});
/////////////////////////
// END FILE js/popover/popover_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/popover_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Events and delegations from popover view
 *
 */

'use strict';

P.when('A', 'a-popover-factory').register('a-popover-handlers', function (A, factory) {
  var $ = A.$;

  /**
   *  Teams are capable of delivering desktop assets to tablet and mobile devices
   *  detect this by checking mobile/tablet are not set (they are explicitly not when
   *  desktop assets are requested) and then confirm we're on iOS.
   *
   *  @private
   *  @constant
   *  @type {boolean}
   */
  var IOS_WITH_DESKTOP_ASSETS = !(A.capabilities.mobile || A.capabilities.tablet) && A.capabilities.ios;

  /**
   * The delay between mouseenter and showing the popover.
   * Add a slight delay to handle the case where the user is quickly
   * moving the cursor past the trigger and not stopping on it.
   *
   * @private
   * @constant
   * @type {number}
   */
  var MOUSE_ENTER_DELAY = 200;

  /**
   * The delay between mouseleave and hiding the popover.
   * Add a slight delay to keep the popover open in case the user
   * accidentally moved the cursor outside the popover and back.
   *
   * @private
   * @constant
   * @type {number}
   */
  var MOUSE_LEAVE_DELAY = 250;

  /**
   * The maximum mouse velocity which will cause the popover to open.
   *
   * @private
   * @constant
   * @type {number}
   */
  var VELOCITY_THRESHOLD = 2;

  /**
   *  There's a delay between the event which causes the popover to be hidden
   *  and actually hiding it.  This will set the timer necessary to do that.
   *
   *  @private
   *  @param {object} popover
   */

  function _setDestroyTimer(popover) {
    if (popover && !popover.destroyTimer) {
      popover.destroyTimer = A.delay(function () {
        popover.hide();
      }, MOUSE_LEAVE_DELAY);
    }
  }

  /**
   *  After the destroy timer is set on a popover, it can be canceled
   *  by user actions.  This clears that timer.
   *
   *  @private
   *  @param {object} popover
   */

  function _clearDestroyTimer(popover) {
    if (popover) {
      clearTimeout(popover.destroyTimer);
      popover.destroyTimer = null;
      clearTimeout(popover.parent.destroyTimer);
      popover.parent.destroyTimer = null;
    }
  }

  /**
   * Show popover when click if activate attr === "onclick" or if we detect
   * that desktop assets are in use on iOS. See below if statement for context
   */
  A.declarative("a-popover", "click", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover && (popover.attrs("activate") === "onclick" || IOS_WITH_DESKTOP_ASSETS)) {
      popover.show();
      event.$event.preventDefault();
    }
  });

  /**
   * Show popover when enter is pressed
   */
  A.declarative("a-popover", "keydown", function(event) {
    var keycodes = A.constants.keycodes;
    var key = event.$event.which;

    if (key === keycodes.ENTER || key === keycodes.SPACE) {
      // disable the behavior for "press space bar to page down"
      event.$event.preventDefault();

      factory.get(event.$declarativeParent).show();
    }
  });

  // iOS suspends part of the mouse-emulation event dispatch if certain things happen
  // in mouseenter and mousemove and create unexpected behavior where click events
  // don't dispatch. When we detect that desktop assets have been served to an iOS device
  // we want all popovers to be triggered by click for normalization purposes and
  // to not run any of the mouse handlers.
  // For more information, see: https://issues.amazon.com/issues/AUI-4632
  if (!IOS_WITH_DESKTOP_ASSETS) {
    /**
     * Open popover if cursor movement is slow or hover at target long enough
     */
    var openPopoverTimer;
    A.declarative("a-popover", "mouseenter", function (event) {
      var popover = factory.get(event.$declarativeParent);

      if (popover && popover.attrs("activate") === "onmouseover") {
        _clearDestroyTimer(popover);

        //set open delay timer
        openPopoverTimer = A.delay(function () {
          popover = factory.get(event.$declarativeParent);

          // make sure popover still exists, $declarativeParent may have been removed
          if (popover) {
            popover.show();
          }
        }, MOUSE_ENTER_DELAY)
      }
    });

    A.declarative("a-popover", "mousemove", function (event) {
      if (A.cursor().speed < VELOCITY_THRESHOLD) {
        var popover = factory.get(event.$declarativeParent);

        if (popover && popover.attrs("activate") === "onmouseover") {
          popover.show();
        }
      }
    });

    A.declarative("a-popover", "mouseleave", function (event) {
      var popover = factory.get(event.$declarativeParent);

      if (popover && popover.attrs("activate") === "onmouseover") {
        _setDestroyTimer(popover);

        //clear open delay timer
        if (openPopoverTimer) {
          clearTimeout(openPopoverTimer);
        }
      }
    });

    /**
     * Hide popover if it is not hovering on it for a duration
     */
    A.declarative("a-popover-container", "mouseenter", function (event) {
      var popover = factory.get(event.$declarativeParent);

      if (popover && popover.attrs("activate") === "onmouseover") {
        _clearDestroyTimer(popover);
      }
    });

    A.declarative("a-popover-container", "mouseleave", function (event) {
      var popover = factory.get(event.$declarativeParent),
        setTimer = true,
        $relatedNode = $(event.$event.relatedTarget);

      if (popover && popover.attrs("activate") === "onmouseover" && popover.isActive()) {
        // If the mouse has moved into a child popover, then we shouldn't close this one
        A.each(popover.children, function (child) {
          if ($relatedNode.closest(child.$popover).length) {
            setTimer = false;
            return false;
          }
        });

        if (setTimer) {
          _setDestroyTimer(popover);

          // If the mouse has not moved back to the parent node, close it too
          if (!popover.parent.immersive && $relatedNode.closest(popover.parent.$popover).length === 0) {
            _setDestroyTimer(popover.parent);
          }
        }
      }
    });
  }
});
/////////////////////////
// END FILE js/popover/popover_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/popover/popover.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * API end point class for Popover
 *
 */

'use strict';

P.when('A', 'a-popover-factory', 'a-popover-base', 'a-popover-handlers').register('a-popory;
});
/////////////////////////
// END FILE js/popover/popover.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/secondary_view/secondary_view_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE js/secondary_view/secondary_view_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/secondary_view/secondary_view_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Secondary view factory
 *
 */

'use strict';

P.when('A', 'a-popover-base-factory', 'a-secondary-view-view', 'a-popover-util').register('a-secondary-view-factory', function (A, baseFactory, view, util) {
  var $ = A.$,
    POPOVER_TYPE = "secondary-view",
    DECLARATIVE_CLASS = "a-declarative";

  /**
   *  A boolean to determine if MASH object will load in the page. If mashWillLoad is false, use default fadeIn/fadeOut animation;
   *  If mashWillLoad is false, secondary view will be non-functional until the mash object is defined
   *
   *  @private
   *  @type {boolean}
   */
  var mashWillLoad = false;

  /**
   *  According to contract from MASH team, they will emit an inline script block thru its server-side API
   *  to register an empty "mash-will-load" module if mash should exist in the page.
   */
  P.when("mash-will-load").ee;
  });

  /**
   *  Create a new secondary view with the given customization options.
   *  When called by customers, it is intended to create declarative action DOM wrapping
   *  the trigger for customers
   *
   *  @public
   *  @param {object} $trigger   jquery wrapped DOM of the trigger
   *  @param {object} attribute  hash of attributes for popover
   *
   *  @return {object} popover
   */

  function create($trigger, attrs) {
    attrs.disableAnimation = attrs.disableAnimation || A.capabilities.isOldAndroid;

    var attributes = {
      type: POPOVER_TYPE,
      immersive: true,
      disableAnimation: mashWillLoad || attrs.disableAnimation,
      synchronous: !! (mashWillLoad || (attrs.synchronous && attrs.synchronous !== "false")),
      animationLength: attrs.disableAnimation ? 0 : 300,
      alternateBackground: attrs.alternateBackground || false,
      hideHeader: mashWillLoad || attrs.hideHeader || false,
      scrollable: attrs.scrollable || true,
      header: attrs.header,
      backButtonText: attrs.backButtonText,
      position: 'windowFullWidth',
      timeout: attrs.timeout,
      // Data source
      dataStrategy: attrs.dataStrategy,
      inlineContent: attrs.inlineContent ? attrs.inlineContent : attrs.content,
      url: attrs.url,
      manualRefresh: !! attrs.manualRefresh,
      name: attrs.name,
      cache: attrs.cache === "false" || attrs.cache === false ? false : true,
      data: attrs.data || {},
      popoverLabel : attrs.popoverLabel,
      padding: attrs.padding,
      ariaDescription : attrs.ariaDescription,
      historyApi: attrs.historyApi === "true" || attrs.historyApi === true
    };
    return baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: view,
      actionCheck: true
    });
  }

  /**
   *  Get a popover, extends from popover_baseFactory
   *  This method creates a popover instance if an existing one could not be found
   *
   *  @public
   *  @param {object|integer|string} id
   *
   *  @return {object}  secondary view instance
   */

  function get(id) {
    var popover = baseFactory.get(id, POPOVER_TYPE);

    // If there is no popover and the input is a declarative action, the popover instance
    // is not yet created.  Will create one to return now.
    if (!popover && typeof id === "object") {
      var declarInfo = util.extractDeclarativeParams(id, POPOVER_TYPE);
      if (declarInfo) {
        popover = create(declarInfo.$trigger, declarInfo.attributes || {});
      }
    }

    // Add data into popover. This needs to be done to support the secondary view being used by twister.  Don't remove.
    if (popover && typeof id === "object") {
      var id = $(id),
        $trigger = id.hasClass(DECLARATIVE_CLASS) ? id : id.find("." + DECLARATIVE_CLASS).eq(0),
        actionName = "a-" + POPOVER_TYPE,
        attributes = $trigger ? $trigger.data(actionName) : null;
      popover.data = attributes.data;
    }

    return popover;
  }

  /**
   *  Remove a secondary view.  Delegates to the base factory.  Will remove the secondary view declarative action
   *  as well as the popover DOM nodes for the secondary view itself.
   *
   *  @public
   *  @param {object|number|string} id
   *
   *  @return {boolean} success
   */

  function remove(id) {
    return baseFactory.remove(id, POPOVER_TYPE);
  }

  return {
    type: POPOVER_TYPE,
    create: create,
    get: get,
    remove: remove
  };
});
/////////////////////////
// END FILE js/secondary_view/secondary_view_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/secondary_view/secondary_view_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Filler
/////////////////////////
// END FILE js/secondary_view/secondary_view_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/secondary_view/secondary_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * API end point class for Secondary View
 *
 */

'use strict';

P.when('A', 'a-secondary-view-factory', 'a-popover-base', 'a-secondary-view-handlers').register('a-secondary-view', function (A, factory) {

  /**
   * Returning secondary view factory
   */
  return factory;
});
/////////////////////////
// END FILE js/secondary_view/secondary_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/base/tooltip_view_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Tooltip overrides
 */

'use strict';

P.when('A', 'a-popover-animate').register('a-tooltip-view-base', function (A, animation) {
  var TOOLTIP_INNER = '.a-tooltip-inner';

  return {
    /**
     *  If a tooltip's contents need to be updated after it has been created, call this function.
     *
     *  @public
     *  @param {string|DOM Node} content
     */

    updateCo
    },

    /**
     *  Get content wrapper of the tooltip
     *
     *  @public
     *  @return {object}  DOM node
     */
    getCo
    },

    /**
     *  Override base hide method
     *
     *  @public
     *  @param {function} triggerVisibilityChange The function that triggers the visibility event
     */

    hideM
    }
  };
});
/////////////////////////
// END FILE js/tooltip/base/tooltip_view_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/tooltip_view.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/* Importing js/tooltip/common/tooltip_view_standard.js */
/**
 *  Tooltip overrides
 */

'use strict';

P.when('A', 'a-tooltip-view-base').register('a-tooltip-view', function (A, viewBase) {
  return A.extend(viewBase, {
    /**
     *  Skin function which determines the look of the tooltip.
     *
     *  @public
     *  @param {object} popover  Popover instance
     *
     *  @return {string} popover html
     */

    skin: function (popover) {

      var hasPopoverArrow = popover.attrs("popoverArrow");
      var popover_arrow_str = hasPopoverArrow ? '<div class="a-arrow-border"><div class="a-arrow"></div></div>' : '';

      return [
        '<div role="tooltip" class="a-popover a-tooltip a-declarative" data-action="a-popover-close">',
        '<div class="a-tooltip-inner"></div>',
        popover_arrow_str,
        '</div>'].join('');
    }
  });
});
/* Done importing js/tooltip/common/tooltip_view_standard.js */

/////////////////////////
// END FILE js/tooltip/tooltip_view.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/tooltip_factory.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * Tooltip factory class
 *
 */

'use strict';

P.when('A', 'a-popover-base-factory', 'a-tooltip-view', 'a-popover-util').register('a-tooltip-factory', function (A, baseFactory, view, util) {
  var $ = A.$,
    POPOVER_TYPE = "tooltip",
    DECLARATIVE_CLASS = "a-declarative";

  /**
   *  Create a new tooltip with the given customization options.
   *  When called by customers, it is intended to create declarative action DOM wrapping
   *  the trigger for customers
   *
   *  @public
   *  @param {object} $trigger    jquery wrapped DOM of the trigger
   *  @param {object} attributes  hash of attributes for popover
   *
   *  @return {object} popover
   */
  function create($trigger, attributes) {
    var attributes = {
      type: POPOVER_TYPE,
      name: attributes.name,
      inlineContent: attributes.inlineContent ? attributes.inlineContent : attributes.content,
      position: attributes.position || 'triggerVertical',
      activate: attributes.activate || 'onmouseover',
      popoverArrow: util.getBool(attributes.popoverArrow, true),
      restoreFocusOnHide: false
    };

    var tooltip = baseFactory.create($trigger, {
      attributes: attributes,
      typeSpecificFunctions: view,
      actionCheck: true
    });

    // For accessibility, 'aria-describedby' attribute containing the id
    // of the tooltip element is added to the (focusable) trigger elements.
    // This enables screen readers to announce the content of the tooltip
    // when the trigger element is focused.

    // Known issue: Firefox on OSX with VoiceOver does not announce the
    // content of tooltips when link-based triggers are focused
    $trigger
      .add($trigger.children())
      .filter('a, input')
      .attr('aria-describedby', 'a-popover-' + $trigger.data("a-popover-id"));

    return tooltip;
  }

  /**
   *  Get a popover, extends from popover_baseFactory
   *  This method creates a popover instance if an existing one could not be found
   *
   *  @public
   *  @param {object|integer|string} id
   *
   *  @return {object}  tooltip instance
   */

  function get(id) {
    var popover = baseFactory.get(id, POPOVER_TYPE);

    // If there is no popover and the input is a declarative action, the popover instance
    // is not yet created.  Will create one to return now.
    if (!popover && typeof id === "object") {
      var declarInfo = util.extractDeclarativeParams(id, POPOVER_TYPE);
      if (declarInfo) {
        popover = create(declarInfo.$trigger, declarInfo.attributes || {});
      }
    }

    return popover;
  }

  /**
   *  Remove a tooltip.  Delegates to the base factory.  Will remove the tooltip declarative action
   *  as well as the popover DOM nodes for the tooltip itself.
   *
   *  @public
   *  @param {object|number|string} id
   *
   *  @return {boolean} success
  );
  }

  return {
    type: POPOVER_TYPE,
    create: create,
    get: get,
    remove: remove
  };
});
/////////////////////////
// END FILE js/tooltip/tooltip_factory.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/tooltip_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 *  Events and delegations from tooltip view
 *
 */

'use strict';

P.when('A', 'a-tooltip-factory').register('a-tooltip-handlers', function (A, factory) {
  var undefined,
    $ = A.$;

  /**
   * The delay between mouseleave and hiding the tooltip.
   * Add a slight delay to keep the tooltip open in case the user
   * accidentally moved the cursor outside the tooltip and back.
   *
   * @private
   * @constant
   * @type {number}
   */
  var MOUSE_LEAVE_DELAY = 125;

  /**
   * Open tooltip during click when activate attr === "onclick"
   */
  A.declarative("a-tooltip", "click", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover && popover.attrs("activate") === "onclick") {
      popover.show();
      event.$event.preventDefault();
    }
  });

  /**
   * Show tooltip during mouseover when activate attr === "onmouseover"
   */
  A.declarative("a-tooltip", "mouseenter", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover && popover.attrs("activate") === "onmouseover") {
      popover.show();
      if (popover.destroyTimer) {
        clearTimeout(popover.destroyTimer);
        popover.destroyTimer = null;
      }
    }
  });

  /**
   *  Hide tooltip when it is not hover for a duration
   *  There's a delay between the event which causes the tooltip to be hidden
   *  and actually hiding it.  This will set the timer necessary to do that.
   */
  A.declarative("a-tooltip", "mouseleave", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover && popover.attrs("activate") === "onmouseover") {
      popover.destroyTimer = A     }, MOUSE_LEAVE_DELAY);
    }
  });

  /**
   * Open tooltip during focus when activate attr === "onfocus"
   */
  A.declarative("a-tooltip", "focus focusin", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover) {
      popover.show();
    }
  });

  /**
   * Close tooltip when element focus is lost
   */
  A.declarative("a-tooltip", "blur focusout", function (event) {
    var popover = factory.get(event.$declarativeParent);

    if (popover) {
      popover.hide();
    }
  });

});
/////////////////////////
// END FILE js/tooltip/tooltip_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tooltip/tooltip.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
/**
 * API end point class for Tooltip
 *
 */

'use strict';

P.when('A', 'a-tooltip-factory', 'a-popover-base', 'a-tooltip-handlers').register('a-tooltip', function (A, factory) {

  /**
   * Returning tooltip factory
   */
  return factory;
});
/////////////////////////
// END FILE js/tooltip/tooltip.js
/////////////////////////

// END ASSET AmazonUIPopoverJS-3.1.1463.95
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIBottomSheet", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIBottomSheet-3.1.1469.91
/////////////////////////
// BEGIN FILE js/a_sheet.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_constants.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_constants.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_base.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_base.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_handlers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_handlers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_hybrid.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_hybrid.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_util.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_util.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_web.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_web.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_history_support.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_history_support.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_capabilities.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_capabilities.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_accessibility.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_accessibility.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/a_sheet_accessibility_templates.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/

/////////////////////////
// END FILE js/a_sheet_accessibility_templates.js
/////////////////////////

// END ASSET AmazonUIBottomSheet-3.1.1469.91
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIAdoptionQualityScripts", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIAdoptionQualityScripts-1.0.827.69
/////////////////////////
// BEGIN FILE a_acs.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
//Intentionally left blank
/////////////////////////
// END FILE a_acs.js
/////////////////////////
// END ASSET AmazonUIAdoptionQualityScripts-1.0.827.69
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIAccessibilityHighlightsSkin", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIAccessibilityHighlightsSkin-1.0.11.78
/////////////////////////
// BEGIN FILE skin.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
// This file is intentionally left blank. We only want the code under a weblab
/////////////////////////
// END FILE skin.js
/////////////////////////
// END ASSET AmazonUIAccessibilityHighlightsSkin-1.0.11.78
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUIDevbar", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUIDevbar-1.0.745.68
/////////////////////////
// BEGIN FILE js/constants.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.register('at-const
  }
});
/////////////////////////
// END FILE js/constants.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/helpers.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when('A', 'at-constants').register('at-helpers', function (A, constants) {
  var $ = A.$;

  function defaultProperty(properties, property, value) {
    if (!properties.hasOwnProperty(property)) {
      properties[property] = value;
    } else {
      properties[property] += ';' + value
    }
    return properties;
  }

  function appendSubmenu(container, submenu) {
    $('#at-submenu', container).append(submenu);
  }

  function appendContent(container, content) {
    $('#at-content', container).append(content);
  }

  function createLabel(properties) {
    return $('<label>', properties);
  }

  function createSpan(properties) {
    return $('<span>', properties);
  }

  function createButton(properties) {
    return $('<button>', properties).click(properties.callback);
);
  }

  function createDiv(properties) {
    return $('<div>', properties);
  }

  function createInput(properties) {
    return $('<input>', defaultProperty(properties, 'style', 'margin-bottom:3px;width:100%;'));
);
  }

  function createCheckbox(checkBoxProperties, labelProperties, clickFn) {
    return createLabel(defaultProperty(labelProperties, 'style', 'font-weight:normal;'))
      .prepend($('<input>', defaultProperty(defaultProperty(checkBoxProperties, 'style', 'margin-right:5px;'), 'type', 'checkbox')).click(clickFn));
  }

  function createPill(key, value, forcedClazz) {
    var clazz;
    if ($.type(value) === 'boolean' || $.type(value) === 'undefined' || $.type(value) === 'null') {
      clazz = value ? 'ab-feature-pill-green' : 'ab-feature-pill-red';
      value = value ? constants.char.checkmark : constants.char.cross;
    } else {
      clazz = 'ab-feature-pill-blue';
    }
    clazz = forcedClazz ? forcedClazz : clazz;

    return $('<div>', {'class':'ab-feature-pill ' + clazz, 'attr': key.toLowerCase()})
    .append($('<span>', {'class':'ab-feature-pill-key', 'html': key}))
    .append($('<span>', {'class':'ab-feature-pill-value', 'html': value}));
  }

  return {
    createSpan: createSpan,
    createButton: createButton,
    createMenuButton: createMenuButton,
    createDiv: createDiv,
    createInput: createInput,
    createTextarea: createTextarea,
    createCheckbox: createCheckbox,
    createLabel: createLabel,
    createPill: createPill,
    appendSubmenu: appendSubmenu,
    appendContent: appendContent
  }
});
/////////////////////////
// END FILE js/helpers.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_ACS.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when('A', 'at-constants', 'at-helpers', 'at-core', 'a-metrics-tasks')
      .register('at-acs', function (A, constants, helpers, core, metrics) {
  var $ = A.$;

  var taskRun;

  var $acsSubmenu = helpers.createDiv({'id':'at-submenu-acs-container','style':'display:none;'k;
  }

  function setupReload() {
    core.$content.children('div').hide();
    if ($('#at-reload-content').length === 0) {
      var $reloadContent = helpers.createDiv().addClass('at-subcontent')
        .append(helpers.createLabel({'html':'You must refresh the page to run this script'}))
        .append(helpers.createButton({'html':'Refresh Page'}).click(reloadPage));
      helpers.appendContent(core.$container, $reloadContent);
    }
    $('#at-reload-content').show();
);
  }

  function getAcsScore() {
    var task = 'a-metrics-aqs';
    if (!taskRun) {
      A.on(metrics.runTaskIds(task), function(results) {
        var report = results[task]["reportData"];
        var $scoreSubmenu = helpers.createDiv({'id': getContainerName(task)});

        var $nonAuiContent = helpers.createDiv().addClass('at-subcontent')
          .append(helpers.createLabel({'html': "% Non-AUI elements with an AUI CSS Class"}))
          .append(helpers.createSpan({'html': report["% non-aui with aui css class"]}));

        var $overridesContent = helpers.createDiv().addClass('at-subcontent')
          .append(helpers.createLabel({'html': "% AUI elements CSS Overrides"}))
          .append(helpers.createSpan({'html': report["% non-aui overriding aui css properties"]}));

        var $elementPercentContent = helpers.createDiv().addClass('at-subcontent')
          .append(helpers.createLabel({'html': "% Elements on Page from AUI"}))
          .append(helpers.createSpan({'html': report["% aui elements over total"]}));

        var $scoreContent = helpers.createDiv().addClass('at-subcontent')
          .append(helpers.createLabel({'html': "Overall ACS Score"}))
          .append(helpers.createSpan({'html': report["ACS"]}));

        $scoreSubmenu.append($nonAuiContent)
          .append($overridesContent)
          .append($elementPercentContent)
          .append($scoreContent);
          
        helpers.appendContent(core.$container, $scoreSubmenu);

        taskEnd(task);
      });
    } else if (taskRun !== task) {
      setupReload();
    } else {
      $('#' + getContainerName(task)).show();
    }
';
  }

  function getCssOverrides() {
    var task = 'a-css-overriding-analytics-fast';
    if (!taskRun) {
      A.on(metrics.runTaskIds(task), function(results) {
        var report = results[task]['reportData'];
        var $overridesSubmenu = helpers.createDiv({'id': getContainerName(task)}).addClass('at-scroll');

        var $percentContent = helpers.createDiv().addClass('at-subcontent')
          .append(helpers.createLabel({'html': "% Elements Overriding"}))
          .append(helpers.createSpan({'html': report['metrics: % Elements Overriding']}));

        var $overridesContent = helpers.createDiv()
          .append(helpers.createLabel({'html': "Overrides"})).addClass('at-overrides')
          .append(helpers.createSpan({'html': parseOverrides(report['metrics: # Overridden CSS classes'])}));

        $overridesSubmenu.append($percentContent).append($overridesContent);

        helpers.appendContent(core.$container, $overridesSubmenu);

        taskEnd(task);
      });
    } else if (taskRun !== task) {
      setupReload();
    } else {
      $('#' + getContainerName(task)).show();
    }

  }

  function parseOverrides(overrides) {
    var output = '';
    A.keys(overrides).forEach(function(sheet) {
      output += 'CSS Overrides Source: ' + sheet + '<ul>';
      A.keys(overrides[sheet]).forEach(function(rule) {
        output += '<li><a href="javascript:void(0);" class="a-declarative" data-action="override-click">Overriding rule: ' + rule + '</a><ol class="overrideDetails" style="display:none;">';
        A.keys(overrides[sheet][rule]).f     });
        output += '</ol></li>';
      });
      output += '</ul>';
    });
    return output;
  }

  A.declarative('override-click', 'click', function(event){
    var $target = event.$currentTarget;
    var $overrideDetails = $target.next();
    if ($overrideDetails.css('display') === "none") {
      $('.overrideDetails').hide();
      $overrideDetails.show();
    } else {
      $overrideDetails.hide();
    }
  });

  A.declarative('element-click', 'click', function(event){
    $('.overrideBox').removeClass('overrideBox');
    var $target = event.$currentTarget;
    var $targets = $($target.children()[0].innerText);
    var topPos = $target[0].offsetTop;
    $("#at-content-a-css-overriding-analytics-container").animate({ scrollTop: topPos }, "fast");
    $targets.addClass('overrideBox');
    $targets[0].scrollIntoView(false);
  });
  }

  $acsSubmenu.append(helpers.createMenuButton({'id':'at-submenu-acs-score', 'html': 'ACS Score'}).click(getAcsScore))
    .append(helpers.createMenuButton({'id':'at-submenu-acs-overrides', 'html': 'CSS Overrides'}).click(getCssOverrides));

  helpers.appendSubmenu(core.$container, $acsSubmenu);

});
/////////////////////////
// END FILE js/tool_ACS.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_Events.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * TODO: Move inline functions into declared functions.
 * TODO: Move logging to the bar.
 */
P.when('A', 'at-constants', 'at-helpers', 'at-core').register('at-events', function (A, constants, helpers, core) {
  var $ = A.$;

  var $eventSubmenu = helpers.createDiv({
    'id':'at-submenu-event-container',
    'style':'display:none'
  })
  .append(helpers.createInput({'id':'at-submenu-event-Name', 'placeholder':'Event Key'}))
  .append(helpers.createMenuButton({'id':'at-submenu-event-Listen', 'html': 'Listen', 'callback': function() {
    var val = $('#at-submenu-event-Name').val();
    A.oents)});
  }}))
  .append(helpers.createMenuButton({'id':'at-submenu-event-Trigger', 'html': 'Trigger', 'call);
  }}));

  helpers.appendSubmenu(core.$container, $eventSubmenu);

});
/////////////////////////
// END FILE js/tool_Events.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_Features.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

P.when('A', 'at-constants', 'at-helpers', 'at-core').register('at-features', function (A, constants, helpers, core) {
  var $ = A.$;

  function featureFilter (event) {
      var $pills = $featureContent.find('.ab-feature-pill');
      $pills.hide();
      $pills.filter('[attr*="'+event.target.value.toLowerCase()+'"]').show();
    }

  // TODO: Move to scss file
  var $featureContent = helpers.createDiv({
      'id':'at-content-feature-container',
      'style':'overflow-y:scroll;height:inherit;display:none;'
    });

  helpers.appendContent(core.$container, $featureContent);

  var featuresEnabled = 0, featuresDisabled = 0, featuresInformational = 0;
  $.each(A.capabilities, function(key, value) {
    $featureContent.append(helpers.createPill(key, value));
    if ($.type(value) === 'boolean' || $.type(value) === 'undefined' || $.type(value) === 'null') {
      value ? featuresEnabled++ : featuresDisabled++;
    } else {
      featuresInformational++;
    }
  });

  var $featureSubmenu = helpers.createDiv({'id':'at-submenu-feature-container','style':'display:none;'})
    .append(helpers.createInput({'id':'at-submenu-feature-filter', 'placeholder':'Filter'}).keyup(featureFilter))
    .append(helpers.createPill('Enabled', featuresEnabled, 'ab-feature-pill-green'))
    .append(helpers.createPill('Disabled', featuresDisabled, 'ab-feature-pill-red'))
    .append(helpers.createPill('Informational', featuresInformational, 'ab-feature-pill-blue'));

  helpers.appendSubmenu(core.$container, $featureSubmenu);

});
/////////////////////////
// END FILE js/tool_Features.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_Modules.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * TODO: Move CSS to file and classes.
 * TODO: Implement P._namespace("AmazonUI").when("prv:p-debug").execute(dbg => console.log(dbg))
 */
P.when('A', 'at-constants', 'at-helpers', 'at-core').register('at-modules', function (A, constants, helpers, core) {
  var $ = A.$;

  var registeredModules = [];

  function createModulePill() {
    var val = $('#at-submenu-module-input').val();
    if ($.inArray(val, registeredModules) > -1 || !val) { return; }
    registeredModules.push(val);
    var pill = helpers.createPill(val, constants.char.cross, 'ab-feature-pill-red');
    P.when(val).execute(function() {
      pill.removeClass('ab-feature-pill-red').addClass('ab-feature-pill-green');
      pill.find('.ab-feature-pill-value').html(constants.char.checkmark);
    });
    $moduleContent.append(pill);
  }

  function clearModulePills() {
    registeredModules = [];
    $('#at-submenu-module-input').val('');
    $moduleContent.empty();
  }

  function registerModule() {
    var val = $('#at-submenu-module-input').val();
    P.register(val, A.NOOP);
  }

  var $moduleSubmenu = helpers.createDiv({'id':'at-submenu-module-container','style':'display:none;'})
    .append(helpers.createInput({'id':'at-submenu-module-input', 'placeholder':'Module name'}))
    .append(helpers.createMenuButton({'id':'at-submenu-module-check', 'html': 'Check'}).click(createModulePill))
    .append(helpers.createMenuButton({'id':'at-submenu-module-clear', 'html': 'Clear'}).click(clearModulePills))
    .append(helpers.createMenuButton({'id':'at-submenu-module-register', 'html': 'Register'}).click(registerModule));

  helpers.appendSubmenu(core.$container, $moduleSubmenu);

  var $moduleContent = helpers.createDiv({
    'id':'at-content-module-container',
    'style':'overflow-y:scroll;height:inherit;display:none;'
  });

  helpers.appendContent(core.$container, $moduleContent);


});
/////////////////////////
// END FILE js/tool_Modules.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/tool_States.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

/**
 * TODO Implement Listener and lock
 */
P.when('A', 'at-constants', 'at-helpers', 'at-core').register('at-states', function (A, constants, helpers, core) {
  var $ = A.$;
  
  var stateListeners = {};

  function getState() {
    var val = $('#at-submenu-state-name', core.$container).val();
    var state = A.state(val);
    //console.log(state);
    $('#at-submenu-state-object', core.$container).val(JSON.stringify(state, undefined, 2));
  }

  function setState() {
    var key = $('#at-submenu-state-name', core.$container).val();
    var data = $('#at-submenu-state-object', core.$container).val();
    A.state.replace(key, JSON.parse(data));
  }

  function clearState() {
    $('#at-submenu-state-name', core.$container).val('');
    $('#at-submenu-state-object', core.$container).val('');
);
 {
  }

  function listenState() {
    var val = $('#at-submenu-state-name', core.$container).val();
    if (val) {
      var elements = $stateSubmenu.find('input:not([type="checkbox"]), button');
      var isChecked = $('#at-submenu-state-listen', core.$container).is(":checked");
      if(isChecked) {
        elements.prop('disabled', true);
        /*listenProp(val);
        A.state.bind(val, refreshState);*/
      } else {
        elements.prop('disabled', false);
      }
      
    }
  }

  var $stateSubmenu = helpers.createDiv({'id':'at-submenu-state-container','style':'display:none;'})
    .append(helpers.createInput({'id':'at-submenu-state-name', 'placeholder':'State Key'}))
    .append(helpers.createMenuButton({'id':'at-submenu-state-get', 'html': 'Get'}).click(getState))
    .append(helpers.createMenuButton({'id':'at-submenu-state-set', 'html': 'Set'}).click(setState))
    .append(helpers.createMenuButton({'id':'at-submenu-state-clear', 'html': 'Clear', }).click(clearState));
    //.append(helpers.createCheckbox({'id':'at-submenu-state-listen'}, {'html': 'Listen for Changes'}, listenState));

  helpers.appendSubmenu(core.$container, $stateSubmenu);

  var $stateContent = helpers.createDiv({
    'id':'at-content-state-container',
    'style':'height:100%;display:none;'
  }).append(helpers.createTextarea({
    'id':'at-submenu-state-object',
    'style':'box-sizing:border-box;width:100%;height:100%;'
  }));

  helpers.appendContent(core.$container, $stateContent);


});
/////////////////////////
// END FILE js/tool_States.js
/////////////////////////
/////////////////////////
// BEGIN FILE js/core.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
"use strict";

 P.when('A', 'a-analytics', 'at-constants', 'at-helpers').register('at-core', function (A, analytics, constants, helpers) {
  
  var $ = A.$;

  function incrementMetric(metricName) {
    if (window.ue) {
      window.ue.count(metricName, 1);
    }
  }

  // Only show devbar if the auiDevbar query parameter is true
  function showDevbar() {
    var devbarParam = getQueryParam('auiDevbar', window.location.href);
    return devbarParam === 'true' || devbarParam ==='1';
  }

  // from https://stackoverflow.com/questions/901115/how-can-i-get-query-string-values-in-javascript
  function getQueryParam(name, url) {
    name = name.replace(/[\[\]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
        results = regex.exec(url);
    if (!results) {
      return null;
    }
    if (!results[2]) {
      return '';
    }
    return decodeURIComponent(results[2].replace(/\+/g, " "));
  }

  // If the AUI_VERSION_INSTRUMENTATION:T1 weblab is not on, the ACS scripts will not run
  // If it is off, give the option to turn the webla);
  }

  function loadAcsWeblab() {
    var url = window.location.href;
    window.location.href = 'http://www.amazon.com/gp/private/weblab/cookie.html?url=' + url + '&wc=AUI_VERSION_INSTRUMENTATION:T1';
  }

  function menuClick(event) {
    var val = event.target.value;
    $submenu.children('div').hide();
    $submenu.find('#at-submenu-'+val+'-container').show();
    $content.children('div').hide();
    $content.find('#at-content-'+val+'-container').show();
    incrementMetric('at-menu-clck-' + val);
    if (val === 'acs' && !isAcsWeblabOn()) {
      setUpLoadWeblab();
    }
  }

  function setUpLoadWeblab() {
    var $addWeblabContent = helpers.createDiv().addClass('at-subcontent')
      .append(helpers.createLabel({'html':'ACS Scripts cannot run without the ACS weblab'}))
      .append(helpers.createMenuButton({'html':'Load ACS Weblab'}).click(loadAcsWeblab));
    helpers.appendContent($container, $addWeblabContent);
  }

  /* Setup Container */
  var $container;
  var $content;

  if (showDevbar()) {
    analytics.increment('acs:devbar');
    
    $container = helpers.createDiv({ 'id':'at-container' });

    /* Create Content Container */
    $content = helpers.createDiv({ 'id':'at-content' });

    /* Setup Main Menu */
    var $menu = helpers.createDiv({ 'id':'at-menu' });

    $menu
    .append(helpers.createMenuButton({'id':'at-menu-acs', 'html':'ACS', 'value':'acs'}).click(menuClick))
    .append(helpers.createMenuButton({'id':'at-menu-event', 'html':'Events', 'value':'event'}).click(menuClick))
    //.append(helpers.createMenuButton({'id':'at-menu-declarative', 'html':'Declaratives', 'value':'declarative'}).click(menuClick))
    .append(helpers.createMenuButton({'id':'at-menu-state', 'html':'States', 'value':'state'}).click(menuClick))
    .append(helpers.createMenuButton({'id':'at-menu-module', 'html':'Modules', 'value':'module'}).click(menuClick))
    .append(helpers.createMenuButton({'id':'at-menu-feature', 'html':'Features', 'value':'feature'}).click(menuClick));

    var $submenu = helpers.createDiv({ 'id':'at-submenu' });


    $container
      .append($menu)
      .append($submenu)
      .append($content);

    /* Create the Containers */
    $('body').prepend($container);
    $('body').addClass('at-body-padding');
  }
  
  return {
    $container: $container,
    $content: $content
  }
});
/////////////////////////
// END FILE js/core.js
/////////////////////////

// END ASSET AmazonUIDevbar-1.0.745.68
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////////
;(function (packageFunction) {
  var p = window.AmazonUIPageJS || window.P;
  var attribute = p._namespace || p.attributeErrors;
  var namespacedP = attribute ? attribute("AmazonUICompatJS", "AmazonUI") : p;

  if (namespacedP.guardFatal) {
    namespacedP.guardFatal(packageFunction)(namespacedP, window);
  } else {
    namespacedP.execute(function () {
      packageFunction(namespacedP, window);
    });.101
}));
////////////////////////////////////////////
/* ******** */
////////////////////////////////////////
  }
}(function(P, window, undefined){
// BEGIN ASSET AmazonUI-3.1.1612.95
/////////////////////////
// BEGIN FILE @version_injector.js
/////////////////////////
/*


Full source (including license, if applicable) included below.
*/
window.pcv = window.pcv || {};
window.pcv["AmazonUI"] = "13357cb22c2211fdd48f9e61c8413680b1494bf9";
/////////////////////////
// END FILE @version_injector.js
/////////////////////////
// END ASSET AmazonUI-3.1.1612.95
}));
////////////////////////////////////////////
/* ******** */
