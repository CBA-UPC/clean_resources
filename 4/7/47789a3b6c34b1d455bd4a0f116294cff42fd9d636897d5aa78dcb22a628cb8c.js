/*! For license information please see 130.64b6d9fdc0cc4f566b49.chunk.v7.js.LICENSE.txt */
(window.officehome_webpackJsonp=window.officehome_webpackJsonp||[]).push([[130],{"Zd4/":function(e,t,s){"use strict";s.r(t),s.d(t,"defaultClusterCapacity",(function(){return G})),s.d(t,"hasOngoingSession",(function(){return ee})),s.d(t,"IdCompressor",(function(){return Q})),s.d(t,"isFinalId",(function(){return W})),s.d(t,"isLocalId",(function(){return Z})),s.d(t,"getIds",(function(){return x})),s.d(t,"numericUuidEquals",(function(){return j})),s.d(t,"getPositiveDelta",(function(){return S})),s.d(t,"createSessionId",(function(){return A})),s.d(t,"numericUuidFromStableId",(function(){return U})),s.d(t,"stableIdFromNumericUuid",(function(){return z})),s.d(t,"incrementUuid",(function(){return R})),s.d(t,"ensureSessionUuid",(function(){return E})),s.d(t,"generateStableId",(function(){return m})),s.d(t,"assertIsStableId",(function(){return O})),s.d(t,"isStableId",(function(){return y})),s.d(t,"assertIsUuidString",(function(){return p})),s.d(t,"SessionIdNormalizer",(function(){return P})),s.d(t,"fail",(function(){return u})),s.d(t,"getOrCreate",(function(){return c})),s.d(t,"compareStrings",();var i=s("he5V"),n=s("QzZJ"),r=s.n(n);function o(e,t){return e-t}unction l(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Object.is;if(e.size!==t.size)return!1;for(const[i,n]of e){const e=t.get(i);if(void 0===e||!s(n,e))return!1}return!0}function c(e,t,s){let i=e.get(t);return void 0===i&&(i=s(t),e.set(t,i)),i}function d(e,t){return e>t?1:e===t?0:-1}r h=s("Lrhb"),v=s("A3AF");const g=Array.from("09afAF").map(();function I(e){return e>=g[0]&&e<=g[1]||e>=g[2]&&e<=g[3]||e>=g[4]&&e<=g[5]}function p(e){return Object(i.a)(function(e){for(let t=0;t<e.length;t++)switch(t){case 8:case 13:case 18:case 23:if("-"!==e.charAt(t))return!1;break;default:if(!I(e.charCodeAt(t)))return!1}return!0}(e),1186),e}unction O(e){return Object(i.a)(y(e),1187),e}function y(e){if(36!==e.length)return!1;for(let t=0;t<e.length;t++)switch(t){case 8:case 13:case 18:case 23:if("-"!==e.charAt(t))return!1;break;case 14:if("4"!==e.charAt(t))return!1;break;case 19:{const s=e.charAt(t);if("8"!==s&&"9"!==s&&"a"!==s&&"b"!==s)return!1;break}default:if(!I(e.charCodeAt(t)))return!1}return!0}p(h.a);class C{nKey(){return this.elements[0]}maxKey(){return this.elements[this.elements.length-2]}rst(){const{elements:e}=this,{length:t}=e;if(0!==t)return[e[0],e[1]]}last(){const{elements:e}=this,{length:t}=e;if(0===t)return;const s=t-2;return[e[s],e[s+1]]}getAtIndex(e){const t=2*e,{elements:s}=this;if(!(t<0||t>s.length-1))return[s[t],s[t+1]]}*entries(){const{elements:e}=this;for(let t=0;t<e.length;t+=2)yield[e[t],e[t+1]]}*keys(){const{elements:e}=this;for(let t=0;t<e.length;t+=2)yield e[t]}*values(){const{elements:e}=this;for(let t=0;t<e.length;t+=2)yield e[t+1]}*entriesReversed(){const{elements:e}=this;for(let t=e.length-2;t>=0;t-=2)yield[e[t],e[t+1]]}append(e,t){const{elements:s}=this,{length:i}=s;0!==i&&this.comparator(e,this.maxKey())<=0&&u("Inserted key must be > all others in the map."),s.push(e),s.push(t)}get(e){const t=C.keyIndexOf(this.elements,e,this.comparator);if(!(t<0))return this.elements[t+1]}getPairOrNextLower(e){return this.getPairOrNextLowerBy(e,this.comparator)}getPairOrNextHigher(e){return this.getPairOrNextHigherBy(e,this.comparator)}equals(e,t){if(e===this)return!0;if(this.elements.length!==e.elements.length)return!1;for(let s=this.elements.length-2;s>=0;s-=2){const i=this.elements[s+1],n=e.elements[s+1];if(0!==this.comparator(this.elements[s],e.elements[s]))return!1;if(!t(i,n))return!1}return!0}assertValid(){let e;for(const t of this.entries())void 0!==e&&Object(i.a)(this.comparator(t[0],e[0])>0,1151),e=t}*getRange(e,t){const s=this.getKeyIndexOfOrNextHigher(e,this.comparator);if(void 0===s)return;const i=this.getKeyIndexOfOrNextLower(t,this.comparator);if(void 0!==i)for(let e=s;e<=i;e+=2)yield[this.elements[e],this.elements[e+1]]}getPairOrNextLowerBy(e,t){const s=this.getKeyIndexOfOrNextLower(e,t);if(void 0!==s)return[this.elements[s],this.elements[s+1]]}getKeyIndexOfOrNextLower(e,t){const{elements:s}=this;if(0===s.length)return;let i=C.keyIndexOf(s,e,t);return i<0?(i^=C.failureXor,i>0?i-2:void 0):i}getPairOrNextHigherBy(e,t){const s=this.getKeyIndexOfOrNextHigher(e,t);if(void 0!==s)return[this.elements[s],this.elements[s+1]]}getKeyIndexOfOrNextHigher(e,t){const{elements:s}=this,{length:i}=s;if(0===i)return;let n=C.keyIndexOf(s,e,t);return n<0?(n^=C.failureXor,n<i?n:void 0):n}static keyIndexOf(e,t,s){let i=0,n=e.length/2,r=n>>1;for(;i<n;){const o=2*r,a=s(t,e[o],e[o+1]);if(a>0)i=r+1;else if(a<0)n=r;else{if(0===a)return o;u("Invalid comparator.")}r=i+n>>1}return 2*r^C.failureXor}}C.failureXor=-1;class b extends C{constructor(e,t,s){super(e),this.extractSearchValue=t,this.valueComparator=s,this.compareValues=(e,t,s)=>this.valueComparator(e,this.extractSearchValue(s))}append(e,t){0!==this.elements.length&&this.valueComparator(this.extractSearchValue(t),this.extractSearchValue(this.maxValue()))<=0&&u("Inserted value must be > all others in the map."),super.append(e,t)}getPairOrNextLowerByValue(e){return this.getPairOrNextLowerBy(e,this.compareValues)}ssertValid(){let e;super.assertValid();for(const t of this.entries())void 0!==e&&Object(i.a)(this.valueComparator(this.extractSearchValue(t[1]),this.extractSearchValue(e[1]))>0,1152),e=t}}function x(e){const{ids:t}=e;if(void 0===t)return;let s=t.first,n=t.last;const r=t;return void 0!==r.overrides&&(null!=s||(s=r.overrides[0][0]),null!=n||(n=r.overrides[r.overrides.length-1][0])),Object(i.a)(void 0!==s&&void 0!==n,1179),{first:s,last:n,overrides:r.overrides}}const F=2**52-1,L=2**52;function S(e,t,s){const[i,n]=e,[r,o]=t;if(i===r){const e=n-o;return e>=0&&e<=s?e:void 0}let a=Number.parseInt(k.Upper.parse(i),16)-Number.parseInt(k.Upper.parse(r),16);if(Math.abs(a)>1)return;let l=k.getNumericValue(k.Variant.parse(i));const c=k.getNumericValue(k.Variant.parse(r));let d=n-o;d<0&&(l-=1,d+=L);let u=l-c;if(u<0&&(a-=1,u+=k.twentyThirdBit),0===a&&!(u>1)){const e=L*u+d;return e>s?void 0:e}}const w=[];for(let e=0;e<13;e++)w.push("0".repeat(e));function N(e,t){return e.length===t?e:w[t-e.length]+e}function z(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=e[1]+t;if(s<=F){const t=N(s.toString(16),13);return`${e[0]+t.slice(0,1)}-${t.slice(1)}`}return z(R(e,t))}function U(e){const t=new Array(2);return t[0]=e.slice(0,22),t[1]=Number.parseInt(k.Lower.parse(e),16),t}nst B=2**48-1;function R(e,t){let s;const n=e[1]+t;if(n<=F)s=[e[0],n];else{const n=t-(F-e[1])-1,r=e[0],[o,a]=k.increment(r);if(a){const e=k.Upper.parse(r),t=Number.parseInt(e,16);Object(i.a)(t<=B,1180);const a=t+1;if(a>B)u("Exceeded maximum numeric UUID");else{const e=N(a.toString(16),12);s=[`${k.Upper.hyphenate(e)}-4${k.Variant.hyphenate(o)}`,n]}}else s=[`${k.Upper.slice(r)}-4${k.Variant.hyphenate(o)}`,n]}return s}var k;!function(e){const t=4194303;let s,n,r;function o(e){const t=Number.parseInt(e,16);return((16773120&t)>>2)+(768&t)+(255&t)}e.twentyThirdBit=2**22,function(e){e.parse=function(e){return e.slice(0,8)+e.slice(9,13)},e.hyphenate=function(e){return`${e.slice(0,8)}-${e.slice(8)}`},e.slice=(s=e.Upper||(e.Upper={})),function(e){e.parse=function(e){return e.slice(15,18)+e.slice(19,22)},e.hyphenate=function(e){return`${e.slice(0,3)}-${e.slice(3)}`}}(n=e.Variant||(e.Variant={})),function(e){e.parse=function(e){return e.slice(22,23)+e.slice(24)},e.hyphenate=function(e){return`${e.slice(0,1)}-${e.slice(1)}`}}(r=e.Lower||(e.Lower={})),e.getNumericValue=o,e.increment=function(e){const s=n.parse(e),r=o(s);Object(i.a)(r<=t,1181);const a=r+1;return[N((((4193280&a)<<2)+(768&a|2048)+(255&a)).toString(16),s.length),a>t]}}(k||(k={}));const T="ffffffff-ffff-4fff-bf",D=[...T].filter(().length,V=["7","b","d","e"];unction E(e){if(e.startsWith(T)){const t=Math.floor(Math.random()*D);let s=0;for(let e=0;e<t&&!M(s);s+=1)M(s)&&e++;const i=V[Math.floor(Math.random()*V.length)];return e.slice(0,s)+i+e.slice(s+1)}return e}class P{constructor(){this.expensiveAsserts=arguments.length>0&&void 0!==arguments[0]&&arguments[0],this.nextLocalId=-1,this.idRanges=new b(a,(e=>{let[t,s]=e;return void 0!==s?$(function(e){var t;return K(e)?e:(null!==(t=e.first())&&void 0!==t?t:u("Map must be non-empty"))[1]}(s)):Number.POSITIVE_INFINITY}),o)}getSessionSpaceId(e){const t=this.idRanges.getPairOrNextLowerByValue(e);if(void 0!==t){const[s,[i,n]]=t,r=H(s,n,e);if(void 0!==r){const[t,[s,n]]=r;if(e<=n){const n=e-s;return n<=t-i?t-n:e}}}}getFinalId(e){var t;const s=null!==(t=this.idRanges.getPairOrNextLower(e))&&void 0!==t?t:u("Local ID was never recorded with this normalizer."),[i,[n,r]]=s;e<n&&u("Local ID was never recorded with this normalizer.");const o=_(i,r,e);if(void 0!==o){const[t,[s,i,n]]=o,r=t-e;if(r<=i-s)return[s+r,n]}}getCreationIndex(e){const t=this.idRanges.getPairOrNextLowerByValue(e);if(void 0!==t){const[s,[i,n]]=t,r=H(s,n,e);if(void 0!==r){const[t,[s,i]]=r;if(e<=i)return-t-1+(e-s)}}}getIdByCreationIndex(e){var t;const s=-(e+1),i=this.idRanges.getPairOrNextLower(s);if(void 0===i)return;const[n,[r,o]]=i;if(s>=r)return s;const a=null!==(t=_(n,o,s))&&void 0!==t?t:u("Final ranges not aligned with owning local range."),[l,[c,d]]=a,f=c+(l-s);return f<=d?f:void 0}static makeFinalRangesMapetLastFinalId(){const e=this.idRanges.size-1,t=Math.max(0,e-1);for(let s=e;s>=t;s--){const e=this.idRanges.getAtIndex(s);if(void 0!==e){const t=e[1][1];if(void 0!==t)return q(t)[1]}}}addLocalId(){const e=this.nextLocalId--,t=this.idRanges.last();if(void 0!==t&&e===t[1][0]-1)return t[1][0]=e,e;if(this.expensiveAsserts)if(void 0===t)Object(i.a)(-1===e,1182);else{const[s,[n,r]]=t;let o=0;for(const[e,[t,i]]of X(s,r))o+=i-t+1;Object(i.a)(e===s-o,1183)}return this.idRanges.append(e,[e,void 0]),e}addFinalIds(e,t,s){var n;Object(i.a)(t>=e,1454);const[r,o]=null!==(n=this.idRanges.last())&&void 0!==n?n:u("Final IDs must be added to an existing local range."),[a,l]=o;let c;if(void 0===l)o[1]=[e,t,s],c=Math.min(this.nextLocalId,r-(t-e)-1);else{const[n,d,u,f]=this.getAlignmentOfLastRange(r,l);if(c=Math.min(this.nextLocalId,d-(t-e)-2),e===u+1)f[1]=t;else{const r=d-1;let c;K(l)?(c=P.makeFinalRangesMap(),c.append(n,f),o[1]=c):c=l,c.append(r,[e,t,s]),Object(i.a)(r>=a,1184)}this.expensiveAsserts&&this.idRanges.assertValid()}this.nextLocalId=c}registerFinalIdBlock(e,t,s){var n;Object(i.a)(t>=1,1455);const[r,[o,a]]=null!==(n=this.idRanges.last())&&void 0!==n?n:u("Final ID block should not be registered before any locals.");let l;if(void 0===a)l=r-o+1;else{const[e,t]=this.getAlignmentOfLastRange(r,a);l=t-o}Object(i.a)(l>0,1307);const c=e+Math.min(l,t)-1;this.addFinalIds(e,c,s)}getAlignmentOfLastRange(e,t){var s;let i,n;K(t)?(n=e,i=t):[n,i]=null!==(s=t.last())&&void 0!==s?s:u("Map should be non-empty.");const[r,o]=i;return[n,n-(o-r),o,i]}*[Symbol.iterator](){var e;for(const[t,[s,i]]of this.idRanges.entries()){for(let e=t;e>=s;e--)yield e;if(void 0!==i){let n,r;K(i)?(r=t,n=i):[r,n]=null!==(e=i.last())&&void 0!==e?e:u("Map should be non-empty.");const[o,a]=n;for(let e=o+(r-s)+1;e<=a;e++)yield e}}}serialize(){const e={localRanges:[],nextLocalId:this.nextLocalId},t=e.localRanges;for(const[e,s]of this.idRanges.entries()){const[i,n]=s;if(void 0!==n){const s=[];for(const[t,[i,r]]of X(e,n))s.push([t,i,r]);t.push([e,i,s])}else t.push([e,i])}return e}static deserialize(e,t){const s=new P,{idRanges:n}=s;for(const[s,r,o]of e.localRanges){let e;if(void 0!==o)if(Object(i.a)(0!==o.length,1185),1===o.length){const[s,i,n]=o[0];e=[i,n,t(i)]}else{e=P.makeFinalRangesMap();for(const[s,i,n]of o)e.append(s,[i,n,t(i)])}n.append(s,[r,e])}return s.nextLocalId=e.nextLocalId,s}equals(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(e,t)=>e===t;return this.nextLocalId===e.nextLocalId&&this.idRanges.equals(e.idRanges,((e,s)=>{const[i,n]=e,[r,o]=s;if(void 0===n||void 0===o)return n===o;const a=(e,s)=>{const[i,n,r]=e,[o,a,l]=s;return i===o&&n===a&&t(r,l)};return K(n)||K(o)?!(!K(n)||!K(o))&&a(n,o):i===r&&n.equals(o,a)}))}}unction q(e){var t;return K(e)?e:(null!==(t=e.last())&&void 0!==t?t:u("Map must be non-empty"))[1]}unction H(e,t,s){if(void 0!==t){if(K(t)){if(s<t[0])return;return[e,t]}return t.getPairOrNextLowerByValue(s)}}function _(e,t,s){if(void 0!==t){if(K(t)){if(s>e)return;return[e,t]}return t.getPairOrNextLower(s)}}function*X(e,t){if(void 0!==t)if(K(t))yield[e,t];else for(const e of t.entries())yield e}const G=512,J=E(O("decaf40b-3c1a-47f8-a7a1-e8461ddb69ce"));ass Q{constructor(e,t){this.localSessionId=e,this.logger=t,this.newClusterCapacity=G,this.sessions=new Map,this.nextClusterBaseFinalId=0,this.localIdCount=0,this.localOverrides=new C(a),this.sessionIdNormalizer=new P,this.clustersAndOverridesInversion=new r.a(void 0,d),this.finalIdToCluster=new C(o),this.localSession=this.createSession(e)}et clusterCapacity(e){Object(i.a)(e>0,1153),Object(i.a)(e<=Q.maxClusterSize,1154),this.newClusterCapacity=e}createSession(e){Object(i.a)(!this.clustersAndOverridesInversion.has(e),1156),void 0!==this.sessions.get(e)&&u("createSession must only be called once for each session ID.");const t={sessionUuid:U(e),currentClusterDetails:void 0,lastFinalizedLocalId:void 0};return this.sessions.set(e,t),t}takeNextCreationRange(){var e;const t=-this.localIdCount,s=null!==(e=this.lastTakenLocalId)&&void 0!==e?e:0;let n;if(Object(i.a)(t<=s,1157),t!==s){const e=s-1,r=[...this.localOverrides.getRange(s-1,t)];if(r)){Object(i.a)(r[0][0]<=e,1158),Object(i.a)(r[r.length-1][0]>=t,1159),n={overrides:r};const s=t===r[r.length-1][0]?void 0:t;f(e===r[0][0]?void 0:e,n,"first"),f(s,n,"last")}else n={first:e,last:t};this.lastTakenLocalId=t}const r={sessionId:this.localSessionId};return void 0===n||(Object(i.a)(this.lastTakenLocalId===-this.localIdCount&&this.lastTakenLocalId!==s,1160),r.ids=n),r}finalizeCreationRange(e){var t,s,n,r,o,a,l,c,d,h,v,g;const{sessionId:I}=e,p=I===this.localSessionId,m=null!==(t=this.sessions.get(I))&&void 0!==t?t:this.createSession(I),O=x(e);if(void 0===O)return;const{currentClusterDetails:y}=m,{cluster:C,clusterBase:b}=null!=y?y:{cluster:void 0,clusterBase:void 0},F=void 0!==C&&void 0!==b,L=null!==(s=m.lastFinalizedLocalId)&&void 0!==s?s:0,{first:S,last:w}=O;Object(i.a)(S===L-1,1161);const N=L-w;Object(i.a)(N>=1,1162);let U,A,j,B,k=0,T=0,D=N;if(F){if(p){const e=null!==(n=this.sessionIdNormalizer.getLastFinalId())&&void 0!==n?n:u("Cluster exists but normalizer does not have an entry for it."),t=b+Math.min(C.count+N,C.capacity)-1;t>e&&this.sessionIdNormalizer.addFinalIds(e+1,t,C)}T=C.count;const e=C.capacity-T,t=D-e,s=t<=0;if(s||b===this.finalIdToCluster.maxKey()){if(C.count+=D,k=D,D=0,!s){const e=this.newClusterCapacity+t,s=C.capacity;if(C.capacity+=e,this.nextClusterBaseFinalId=this.nextClusterBaseFinalId+e,Object(i.a)(this.nextClusterBaseFinalId<Number.MAX_SAFE_INTEGER,1163),this.checkClusterForCollision(C),p){const n=b+C.count-1;Object(i.a)(void 0!==m.lastFinalizedLocalId,1164),this.sessionIdNormalizer.registerFinalIdBlock(n-t+1,e,C),null===(r=this.logger)||void 0===r||r.sendTelemetryEvent({eventName:"RuntimeIdCompressor:ClusterExpansion",sessionId:this.localSessionId,previousCapacity:s,newCapacity:C.capacity,overflow:t})}}}else U=R(C.baseUuid,C.capacity),C.count+=e,D-=e,null===(o=this.logger)||void 0===o||o.sendTelemetryEvent({eventName:"RuntimeIdCompressor:OverfilledCluster",sessionId:this.localSessionId})}else U=m.sessionUuid,p&&(null===(a=this.logger)||void 0===a||a.sendTelemetryEvent({eventName:"RuntimeIdCompressor:FirstCluster",sessionId:this.localSessionId}));if(void 0!==U){D<=0&&u("Should not create an empty cluster."),void 0!==C&&C.capacity!==C.count&&u("Cluster must be filled before another is allocated."),j=this.nextClusterBaseFinalId;const e=Math.max(this.newClusterCapacity,D);A={baseUuid:U,capacity:e,count:D,session:m},B=S-(N-D),p&&(null===(l=this.logger)||void 0===l||l.sendTelemetryEvent({eventName:"RuntimeIdCompressor:NewCluster",sessionId:this.localSessionId,clusterCapacity:e,clusterCount:D}),this.sessionIdNormalizer.registerFinalIdBlock(j,A.capacity,A)),this.checkClusterForCollision(A),this.clustersAndOverridesInversion.set(z(A.baseUuid),{clusterBase:j,cluster:A}),m.currentClusterDetails={cluster:A,clusterBase:j},this.nextClusterBaseFinalId=this.nextClusterBaseFinalId+A.capacity,Object(i.a)(this.nextClusterBaseFinalId<Number.MAX_SAFE_INTEGER,1166),this.finalIdToCluster.append(j,A)}const V=O.overrides;if(void 0!==V)for(let e=0;e<V.length;e++){const[t,s]=V[e];let n,r;Object(i.a)(0===e||t<V[e-1][0],1167),Object(i.a)(t<L,1168),Object(i.a)(t>=w,1169),void 0!==B&&t<=B?(Object(i.a)(void 0!==A&&void 0!==j,1170),n=A,r=j+(B-t)):(Object(i.a)(void 0!==C&&void 0!==b,1171),n=C,r=b+T+(L-t)-1),null!==(c=n.overrides)&&void 0!==c||(n.overrides=new Map);const o=Q.createInversionKey(s),a=this.getExistingIdsForNewOverride(o,!0);let l,d;if(void 0!==a){let e;"number"==typeof a?(e=a,Z(e)&&(d=e)):[d,e]=a,W(e)?l=e:(Object(i.a)(!p||e===t,1172),l=s)}else l=s;if(Object(i.a)(!n.overrides.has(r),1173),"string"==typeof l)n.overrides.set(r,p||void 0===d?s:{override:s,originalOverridingFinal:r,associatedLocalId:d});else{const e={override:s,originalOverridingFinal:l};f(d,e,"associatedLocalId"),n.overrides.set(r,e)}const u={cluster:n,originalOverridingFinal:r};f(d,u,"associatedLocalId");const h=this.clustersAndOverridesInversion.get(o);(void 0===h||Q.isUnfinalizedOverride(h))&&this.clustersAndOverridesInversion.set(o,u)}p&&(null===(d=this.logger)||void 0===d||d.sendTelemetryEvent({eventName:"RuntimeIdCompressor:IdCompressorStatus",eagerFinalIdCount:k-(null!==(h=null==V?void 0:V.length)&&void 0!==h?h:0),localIdCount:D+(null!==(v=null==V?void 0:V.length)&&void 0!==v?v:0),overridesCount:null!==(g=null==V?void 0:V.length)&&void 0!==g?g:0,sessionId:this.localSessionId})),m.lastFinalizedLocalId=w}checkClusterForCollision(e){const t=R(e.baseUuid,e.capacity-1),s=z(t),i=this.clustersAndOverridesInversion.getPairOrNextLower(s);if(void 0!==i){const[n,r]=i;!Q.isClusterInfo(r)&&y(n)&&Q.uuidsMightCollide(n,s,e.capacity)&&void 0!==S(t,U(n),e.capacity-1)&&Q.failWithCollidingOverride(n)}}static failWithCollidingOverride(e){u(`Override '${e}' collides with another allocated UUID.`)}atic createInversionKey(e){return y(e)?e:`${e}0)}getExistingIdsForNewOverride(e,t){var s;const i=this.clustersAndOverridesInversion.getPairOrNextLower(e,se);let n,r;if(void 0!==i){const[s,o]=i;if(Q.isClusterInfo(o)){if(Q.isStableInversionKey(e)){r=e;const i=o.cluster;if(Q.uuidsMightCollide(e,s,i.capacity)){n=U(r);const e=S(n,i.baseUuid,i.capacity-1);if(void 0!==e&&!t){if(e>=i.count)return;return this.normalizeToSessionSpace(o.clusterBase+e)}}}}else if(s===e){if(Q.isUnfinalizedOverride(o))return o;const e=o;return void 0!==e.associatedLocalId?[e.associatedLocalId,e.originalOverridingFinal]:e.originalOverridingFinal}}const o=null!==(s=null!=n?n:r)&&void 0!==s?s:Q.isStableInversionKey(e)?e:void 0;if(void 0!==o){const e=this.getCompressedIdForStableId(o);if(void 0!==e)return e}}static uuidsMightCollide(e,t,s){const i=32-Math.ceil(Math.log2(s)/2);return!!e.startsWith(t.slice(0,i))}static tryGetOverride(e,t){var s;const i=null===(s=e.overrides)||void 0===s?void 0:s.get(t);if(void 0!==i)return"string"==typeof i?i:i.override}generateCompressedId(e){let t;if(void 0!==e){t=Q.createInversionKey(e);const s=this.getExistingIdsForNewOverride(t,!1);if(void 0!==s)return"number"==typeof s?s:s[0]}const s=-++this.localIdCount,{currentClusterDetails:n}=this.localSession,{sessionIdNormalizer:r}=this;let o,a;if(void 0!==n){a=n.cluster;const e=r.getLastFinalId();void 0!==e&&e-n.clusterBase+1<a.capacity&&(o=e+1)}if(void 0!==t){const n=r.addLocalId();Object(i.a)(n===s,1174),void 0!==o&&r.addFinalIds(o,o,null!=a?a:u("No cluster when generating compressed ID")),this.localOverrides.append(s,null!=e?e:u("Override must be defined")),this.clustersAndOverridesInversion.set(t,s)}else{if(void 0!==o)return r.addFinalIds(o,o,null!=a?a:u("No cluster when generating compressed ID")),o;{const e=r.addLocalId();Object(i.a)(e===s,1175)}}return s}decompress(e){var t;return null!==(t=this.tryDecompress(e))&&void 0!==t?t:u("Compressed ID was not generated by this compressor")}tryDecompress(e){var t;if(W(e)){const t=this.getClusterForFinalId(e);if(void 0===t){const t=this.sessionIdNormalizer.getCreationIndex(e);return void 0!==t?z(this.localSession.sessionUuid,t):void 0}{const[s,i]=t,n=Q.tryGetOverride(i,e);return void 0!==n?n:z(i.baseUuid,e-s)}}{const s=-e;if(s>this.localIdCount)return;const i=null===(t=this.localOverrides)||void 0===t?void 0:t.get(e);return void 0!==i?i:z(this.localSession.sessionUuid,s-1)}}recompress(e){var t;return null!==(t=this.tryRecompress(e))&&void 0!==t?t:u("No such string has ever been compressee)}recompressInternal(e,t){var s,i;let n=t;const r=Q.createInversionKey(e),o=Q.isStableInversionKey(r),a=this.clustersAndOverridesInversion.getPairOrNextLower(r,se);if(void 0!==a){const[e,t]=a;if(Q.isClusterInfo(t)){if(!o)return;const{clusterBase:e,cluster:s}=t;null!=n||(n=U(r));const a=S(n,s.baseUuid,s.count-1);if(void 0!==a){let t=e+a;const n=null===(i=s.overrides)||void 0===i?void 0:i.get(t);if("object"==typeof n){if(void 0!==n.associatedLocalId)return n.associatedLocalId;t=n.originalOverridingFinal}return this.normalizeToSessionSpace(t)}}else if(e===r)return Q.isUnfinalizedOverride(t)?t:null!==(s=t.associatedLocalId)&&void 0!==s?s:t.originalOverridingFinal}if(o){const e=this.getCompressedIdForStableId(null!=n?n:r);if(void 0!==e)return e}}normalizeToOpSpace(e){var t,s,i;if(W(e))return e;-e>this.localIdCount&&u("Supplied local ID was not created by this compressor.");const{lastFinalizedLocalId:n}=this.localSession;if(void 0===n||e<n){const i=this.localOverrides.get(e);if(void 0!==i){const s=Q.createInversionKey(i),n=null!==(t=this.clustersAndOverridesInversion.get(s))&&void 0!==t?t:u("Bimap is malformed.");return Q.isClusterInfo(n)||Q.isUnfinalizedOverride(n)||n.associatedLocalId!==e?e:n.originalOverridingFinal}const n=this.sessionIdNormalizer.getFinalId(e);return null!==(s=null==n?void 0:n[0])&&void 0!==s?s:e}const[r,o]=null!==(i=this.sessionIdNormalizer.getFinalId(e))&&void 0!==i?i:u("Locally created cluster should be added to the map when allocated");if(o.overrides){const e=o.overrides.get(r);if("object"==typeof e&&void 0!==e.originalOverridingFinal)return e.originalOverridingFinal}return r}normalizeToSessionSpace(e,t){var s,i,n,r;if(Z(e)){if(void 0===t||t===this.localSessionId)return-e>this.localIdCount&&u("Supplied local ID was not created by this compressor."),e;{const n=R((null!==(s=this.sessions.get(t))&&void 0!==s?s:u("No IDs have ever been finalized by the supplied session.")).sessionUuid,-e-1);return null!==(i=this.compressNumericUuid(n))&&void 0!==i?i:u("ID is not known to this compressor.")}}const o=this.sessionIdNormalizer.getSessionSpaceId(e);if(void 0!==o)return o;const[a,l]=null!==(n=this.getClusterForFinalId(e))&&void 0!==n?n:u("Supplied final ID was not finalized by this compressor."),c=null===(r=l.overrides)||void 0===r?void 0:r.get(e);return"object"==typeof c&&void 0!==c.associatedLocalId?c.associatedLocalId:e}compressNumericUuid(e){const t=z(e),s=this.recompressInternal(t,e);if(void 0!==s)return s}getCompressedIdForStableId(e){const t=S("string"==typeof e?U(e):e,this.localSession.sessionUuid,this.localIdCount-1);if(void 0!==t){const e=this.sessionIdNormalizer.getIdByCreationIndex(t);if(void 0!==e)return e}}getClusterForFinalId(e){const t=this.finalIdToCluster.getPairOrNextLower(e);if(void 0===t)return;const[s,i]=t;return e-s>=i.count?void 0:t}equals(e,t){if(t){if(this.localIdCount!==e.localIdCount||this.localSessionId!==e.localSessionId||this.lastTakenLocalId!==e.lastTakenLocalId)return!1;if(!this.localOverrides.equals(e.localOverrid==t)))return!1;if(!l(this.sessions,e.sessions,((e,s)=>Q.sessionDataEqual(e,s,!0,t))))return!1;if(!this.sessionIdNormalizer.equals(e.sessionIdNormalizer,((e,s)=>Q.idClustersEqual(e,s,!1,t))))return!1}else{for(const[s,i]of this.sessions){const n=e.sessions.get(s);if(void 0===n){if(void 0!==i.lastFinalizedLocalId)return!1}else if(!Q.sessionDataEqual(i,n,!0,t))return!1}for(const[t,s]of e.sessions)if(void 0===this.sessions.get(t)&&void 0!==s.lastFinalizedLocalId)return!1}if(this.nextClusterBaseFinalId!==e.nextClusterBaseFinalId||this.newClusterCapacity!==e.newClusterCapacity)return!1;if(!this.finalIdToCluster.equals(e.finalIdToCluster,((e,s)=>Q.idClustersEqual(e,s,!0,t))))return!1;const s=(e,s)=>{if(t||!Q.isUnfinalizedOverride(s))return{break:!0}};return void 0===this.clustersAndOverridesInversion.diffAgainst(e.clustersAndOverridesInversion,s,s,((e,s,i)=>{if(!((e,s)=>{const i=Q.isUnfinalizedOverride(e),n=Q.isUnfinalizedOverride(s);if(i)return!!n&&e===s;if(n)return!1;if(Q.isClusterInfo(e)){if(!Q.isClusterInfo(s)||e.clusterBase!==s.clusterBase)return!1}else if(Q.isClusterInfo(s)||t&&e.associatedLocalId!==s.associatedLocalId||e.originalOverridingFinal!==s.originalOverridingFinal)return!1;return!!Q.idClustersEqual(e.cluster,s.cluster,!0,t)})(s,i))return{break:!0}}))}static sessionDataEqual(e,t){let s=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];return!(!j(e.sessionUuid,t.sessionUuid)||e.lastFinalizedLocalId!==t.lastFinalizedLocalId||(void 0===e.currentClusterDetails||void 0===t.currentClusterDetails?e.currentClusterDetails!==t.currentClusterDetails:s&&!Q.idClustersEqual(e.currentClusterDetails.cluster,t.currentClusterDetails.cluster,!1,i)))}static idClustersEqual(e,t){let s=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];var n,r;return j(e.baseUuid,t.baseUuid)&&e.capacity===t.capacity&&e.count===t.count&&(!s||Q.sessionDataEqual(e.session,t.session,!1,i))&&void 0===e.overrides==(void 0===t.overrides)&&(void 0===e.overrides||l(null!==(n=e.overrides)&&void 0!==n?n:u("Overrides must be defined"),null!==(r=t.overrides)&&void 0!==r?r:u("Overrides must be defined"),((e,t)=>i?"string"==typeof e||"string"==typeof t?e===t:e.override===t.override&&e.originalOverridingFinal===t.originalOverridingFinal&&(!i||e.associatedLocalId===t.associatedLocalId):("string"==typeof e||"string"==typeof t||e.originalOverridingFinal===t.originalOverridingFinal)&&("string"==typeof e?e:e.override)===("string"==typeof t?t:t.override))))}serialize(e){var t,s;const n=[],r=new Map;for(const[t,s]of this.sessions){const i=t===this.localSessionId;if(t!==J&&(void 0!==s.lastFinalizedLocalId||i&&e)){const e=[t];r.set(t,n.length),n.push(e)}}const o=[];for(const[e,s]of this.finalIdToCluster.entries()){const i=z(s.session.sessionUuid);if(i!==J){const n=[null!==(t=r.get(i))&&void 0!==t?t:u("Session object contains wrong session numeric UUID"),s.capacity];if(s.count!==s.capacity&&n.push(s.count),void 0!==s.overrides){const t=[];for(const[i,n]of s.overrides){const s=i-e;t.push("string"==typeof n?[s,n]:n.originalOverridingFinal===i?[s,n.override]:[s,n.override,n.originalOverridingFinal])}n.push(t)}o.push(n)}}Object(i.a)(n.length-this.sessions.size<=2,1176);const a={version:Y,clusterCapacity:this.clusterCapacity,sessions:n,clusters:o};if(e){const e=a;return e.localSessionIndex=e.sessions.findIndex((e=>{let[t]=e;return t===this.localSessionId})),this.localIdCount>0&&(e.localState={localIdCount:this.localIdCount,overrides:[...this.localOverrides.entries()].m.e])),lastTakenLocalId:this.lastTakenLocalId,sessionNormalizer:this.sessionIdNormalizer.serialize()}),e}return null===(s=this.logger)||void 0===s||s.sendTelemetryEvent({eventName:"RuntimeIdCompressor:SerializedIdCompressorSize",size:JSON.stringify(a).length,clusterCount:a.clusters.length,sessionCount:a.sessions.length}),a}static deserialize(){for(var e=arguments.length,t=new Array(e),s=0;s<e;s++)t[s]=arguments[s];const[n,r]=t,{clusterCapacity:o,sessions:a,clusters:l}=n;let c,d;if(void 0===r){const[e]=t;c=a[e.localSessionIndex][0],d=e.localState}else c=r;const h=new Q(c);h.clusterCapacity=o;const v=new Map;if(void 0!==d&&(h.localIdCount=d.localIdCount,h.lastTakenLocalId=d.lastTakenLocalId,void 0!==d.overrides))for(const[e,t]of d.overrides)h.localOverrides.append(e,t),v.set(t,e),h.clustersAndOverridesInversion.set(Q.createInversionKey(t),e);const g=[];for(const e of a){const[t]=e;if(t===c)Object(i.a)(ee(n),1177),g.push({session:h.localSession,sessionId:t});else{const e=h.createSession(t);g.push({session:e,sessionId:t})}}for(const e of l){const{sessionIndex:t,capacity:s,count:i,overrides:n}=te(e),{session:r,sessionId:o}=g[t],{lastFinalizedLocalId:a,sessionUuid:l}=r,u={capacity:s,count:i,baseUuid:R(l,void 0===a?0:-a),session:r},I=h.nextClusterBaseFinalId;if(r.lastFinalizedLocalId=(null!=a?a:0)-i,r.currentClusterDetails={clusterBase:I,cluster:u},h.nextClusterBaseFinalId=h.nextClusterBaseFinalId+s,h.finalIdToCluster.append(I,u),h.clustersAndOverridesInversion.set(z(u.baseUuid),{clusterBase:I,cluster:u}),void 0!==n){u.overrides=new Map;for(const[e,t,s]of n){const i=I+e;if(void 0!==s){const e={override:t,originalOverridingFinal:s};void 0!==d&&f(v.get(t),e,"associatedLocalId"),u.overrides.set(i,e)}else{const e=v.get(t);u.overrides.set(i,void 0!==e&&o!==c?{override:t,originalOverridingFinal:i,associatedLocalId:e}:t);const s={cluster:u,originalOverridingFinal:i};void 0!==d&&f(e,s,"associatedLocalId"),h.clustersAndOverridesInversion.set(Q.createInversionKey(t),s)}}}}return void 0!==d&&(h.sessionIdNormalizer=P.deserialize(d.sessionNormalizer,(e=>{var t;const[s,i]=null!==(t=h.finalIdToCluster.getPairOrNextLower(e))&&void 0!==t?t:u("Final in serialized normalizer was never created.");return i}))),Object(i.a)(void 0===h.localSession.lastFinalizedLocalId||h.localIdCount>=-h.localSession.lastFinalizedLocalId,1178),h}static convertToCurrentVersion(e,t){e.version!==Y&&u("Unknown SerializedIdCompressor version number");const s=e;if(t===ee(s))return s}}Q.maxClusterSize=2**20;const Y="0.0ex}function te(e){const[t,s,i,n]=e,r="number"==typeof i;return{sessionIndex:t,capacity:s,count:r?i:s,overrides:r?n:i}}const se=[]}}]);
//# sourceMappingURL=130.64b6d9fdc0cc4f566b49.chunk.v7.js.map