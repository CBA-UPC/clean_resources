// Method not allowedation, see `http://go4.disney.go.com/adbe/lnch/1b439b897261/75f0a63cc128/75b74d03114c/RC7f498f4e9be64e3bbe2615cd307d41c5-source.js`.
_satellite.__registerScript('//go4.disney.go.com/adbe/lnch/1b439b897261/75f0a63cc128/75b74d03114c/RC7f498f4e9be64e3bbe2615cd307d41c5-source.min.js', "<iframe name=\"__bkframe\" height=\"0\" width=\"0\" frameborder=\"0\" style=\"display:none;position:absolute;clip:rect(0px 0px 0px 0px)\" src=\"about:blank\"></iframe>\n<script src=\"https://tags.bkrtx.com/js/bk-coretag.js\"></script>\n<script>\n/* global bk_addPageCtx, bk_allow_multiple_calls:true, bk_use_multiple_iframes:true, bk_doJSTag */\n(function () {\n    var cookies = {},\n        cookieString = '',\n        vars = {};\n\n    waitFor({\n        location: ['s_wdpro', 's_wdpro.pageName', 'jQuery'],\n        callback: process,\n        failCallback: noop,\n        timeout: 45000,\n        interval: 500\n    });\n\n    function process(s_wdpro, pn, $) {\n        var sam = unmap(s_wdpro);\n\n        fireBKTag(_set(vars, {\n            id: getSWID(),\n            pageId: sam.pageId,\n            siteSection: sam.siteSection,\n            contentLang: sam.configuration.contentLanguage,\n            contentLocale: sam.configuration.contentLocale\n        }));\n\n        $('#DP_Header_Vacationplanning_us_en_DisneyVacationAccount').one('click', function (e) {\n            fireBKTag({event: 'DisneyVacationAccount'});\n            setTimeout(this.click.bind(this), 580);\n            return false;\n        });\n    }\n\n    function unmap(s) {\n        var sam = {\n                configuration: {}\n            },\n            parts = s.pageName.trim().replace(/^\\/+|\\/+$/g, '').split('/'),\n            eventsMap = {\n                event1: 'assetStart',\n                event2: 'internalSearch',\n                event3: 'pageView',\n                event4: 'registration',\n                event5: 'internalSearchClick',\n                event7: 'internalAdClick',\n                event8: 'VPDOrder',\n                event9: 'purchaseWithPoints',\n                event10: 'cancellation',\n                event11: 'assetComplete',\n                event12: 'reviewQuote',\n                event13: 'bookingSearch',\n                scAdd: 'cartProductAdd',\n                event15: 'leadGenerated',\n                event16: 'ticketOrder',\n                event27: 'activityCancellation',\n                event28: 'activityModification',\n                event29: 'systemProductRemoval',\n                event30: 'quickQuoteSearch',\n                event31: 'checkoutDelivery',\n                event32: 'checkoutInsurance',\n                event33: 'checkoutApplyPayment',\n                event34: 'checkoutReviewQuote',\n                event35: 'benchListViewed',\n                event36: 'mapCustomization',\n                event37: 'recommendationSeen',\n                event38: 'recommendationSaved',\n                event39: 'activityBooking',\n                prodView: 'productView',\n                event46: 'checkoutGuestInfo',\n                event48: 'selfServiceInitiated',\n                event49: 'selfServiceCompleted',\n                event53: 'mediaDownloads',\n                event58: 'loggedIn',\n                event59: 'postCheckoutPayment',\n                event60: 'failedProduct',\n                event61: 'cartCreate',\n                event62: 'compareVacationModify',\n                event66: 'checkoutExpressCheckout',\n                event67: 'modificationEvent',\n                event68: 'posModRevenueEvent',\n                event69: 'negModRevenueEvent',\n                event70: 'posModNightsEvent',\n                event71: 'negModNightsEvent',\n                event72: 'personalizationClick',\n                scCheckout: 'scCheckout',\n                scView: 'cartView',\n                scRemove: 'cartProductRemove'\n            },\n            productTypeMap = {\n                prod: 'product',\n                res: 'resortVacation',\n                ins: 'insurance',\n                auto: 'groundTransportation',\n                air: 'airTransportation',\n                cruise: 'cruise',\n                gxa: 'greatFoodFast',\n                dine: 'dining',\n                tix: 'ticket',\n                med: 'media',\n                eexp: 'enhancedExperience',\n                ndt: 'nonDisneyTicket',\n                pre: 'preOrder',\n                evt: 'event'\n            },\n            val;\n\n        sam.configuration.contentLocale = parts.slice(2, 3)[0].toUpperCase();\n        sam.configuration.contentLanguage = parts.slice(3, 4)[0];\n        sam.siteSection = parts.slice(4, -1).join('/');\n        sam.pageId = parts[parts.length - 1];\n\n        sam.events = (s.events || '').split(',').map(function (v) {\n            v = v.trim();\n            return eventsMap[v] || v;\n        }).join(',');\n\n        if ((val = s.prop16 || s.eVar32) && (val = val.substr(6, 4) + '-' + val.substr(0, 2) + '-' + val.substr(3, 2))) {\n            sam.bookingSearchArrivalDate = val;\n        }\n\n        if ((val = s.prop17 || s.eVar33)) sam.bookingSearchLengthOfStayNights = +val;\n\n        if ((val = s.prop18 || s.eVar34) && (val = val.match(/(\\d+):(\\d+)A:(\\d+)C:(\\d+)I/))) {\n            sam.bookingSearchPartySize = +val[1];\n            sam.bookingSearchAdults = +val[2];\n            sam.bookingSearchChildren = +val[3];\n            sam.bookingSearchInfants = +val[4];\n        }\n\n        if ((val = s.eVar35)) sam.bookingSearchNumResults = +val;\n        if ((val = s.purchaseID)) sam.orderId = val;\n\n        if ((val = s.prop1 || s.eVar10)) sam.site = val;\n        if ((val = s.eVar7)) sam.store = val;\n        if ((val = s.prop29)) sam.registrationStatus = val;\n\n        if ((val = s.zip)) sam.homeZip = val;\n        if ((val = s.state)) sam.homeState = val;\n        if ((val = s.eVar29)) sam.homeCity = val;\n\n        if (s.products) {\n            sam.products = s.products.split(',').map(function (prodStr) {\n                var prod = {},\n                    parts = prodStr.split(';'),\n                    ids;\n\n                if (parts[0]) {\n                    prod.productType = productTypeMap[parts[0]] || parts[0];\n                }\n                if (parts[1]) {\n                    ids = parts[1].split(':');\n                    if (ids[0]) prod.productId = ids[0];\n                    if (ids[1]) prod.facilityId = ids[1];\n                    if (ids[2]) prod.roomTypeId = ids[2];\n                    if (ids[3]) prod.ticketId = ids[3];\n                }\n                if (parts[2]) {\n                    prod.quantity = +parts[2];\n                }\n                if (parts[3]) {\n                    prod.totalPrice = +parts[3];\n                }\n                return prod;\n            });\n        }\n\n        if ((val = s.eVar17)) {\n            sam.products.forEach(function (prod) {\n                prod.daysBetweenBookingAndArrival = +val;\n            });\n        }\n        if ((val = s.eVar18) && (val = val.substr(6, 4) + '-' + val.substr(0, 2) + '-' + val.substr(3, 2))) {\n            sam.products.forEach(function (prod) {\n                prod.bookedArrivalDate = val;\n            });\n        }\n        if ((val = s.eVar19)) {\n            sam.products.forEach(function (prod) {\n                prod.bookedLengthOfStayNights = +val;\n            });\n        }\n\n\n        return sam;\n    }\n\n    function getSWID() {\n        return cookieGet('SWID') ||\n            cookieGetObject('stateManager_jar', 'swid') ||\n            cookieGetObject('rememberme', 'swid');\n    }\n\n    function fireBKTag(vars) {\n        objForEach(vars, function (val, key) {\n            bk_addPageCtx(key, val);\n        });\n        bk_allow_multiple_calls = true;\n        bk_use_multiple_iframes = true;\n        bk_doJSTag(27175, 10);\n    }\n\n    function toType(o) {\n        return Object.prototype.toString.call(o).slice(8,-1).toLowerCase();\n    }\n\n    function cookieGetObject(name, key) {\n        var obj = _parse(cookieGet(name));\n        if (key) {\n            if (toType(obj) === 'object') {\n                obj = ref(key, obj);\n            } else {\n                obj = undefined;\n            }\n        }\n        return obj;\n    }\n\n    function cookieGet(key) {\n        return cookiesGetAll()[key];\n    }\n\n    function cookiesGetAll() {\n        var newCookieStr = document.cookie,\n            cookieArr,\n            i,\n            cookie,\n            index,\n            cookieName;\n\n        if (newCookieStr !== cookieString) {\n            cookieString = newCookieStr;\n            cookies = {};\n\n            cookieArr = cookieString.split('; ');\n            for (i = 0; i < cookieArr.length; i++) {\n                cookie = cookieArr[i];\n                index = cookie.indexOf('=');\n                if (index > 0) {\n                    cookieName = _decode(cookie.substring(0, index));\n                    if (!(cookieName in cookies)) {\n                        cookies[cookieName] = _decode(cookie.substring(index + 1));\n                    }\n                }\n            }\n        }\n        return cookies;\n    }\n\n    function _decode(str) {\n        try {\n            str = decodeURIComponent(str);\n        } catch (ignore) {\n            // str is not decodable using decodeURIComponent\n        }\n        return str;\n    }\n\n    function _parse(str) {\n        try {\n            str = JSON.parse(str);\n        } catch (ignore) {\n            // str is not parsable\n        }\n        return str;\n    }\n\n    function isNotNaN(val) {\n        return val === val;\n    }\n\n    function _set(targetObj, key, val) {\n        var srcObj = key;\n        if (typeof key === 'string') {\n            (srcObj = {})[key] = val;\n        }\n        objForEach(srcObj, function (val, key) {\n            if (toType(val) !== 'undefined' && isNotNaN(val)) {\n                targetObj[key] = val;\n            }\n        });\n        return targetObj;\n    }\n\n    function objForEach(r,n,o){var t;for(t in r)r.hasOwnProperty(t)&&n.call(o,r[t],t,r)} // jshint ignore:line\n\n    function ref(path, base) {\n        var i = path.indexOf('.');\n        base = base || this;\n        return (i === -1) ? base[path] : (base = base[path.substr(0, i)]) && ref(path.substr(i + 1), base);\n    }\n\n    function merge(destination, source) {\n        objForEach(source, function (val, key) { destination[key] = val; });\n        return destination;\n    }\n\n    function waitFor(config) {\n        if (!config._initialAttempt) {\n            config = waitForConfig(config);\n        }\n        config._attempt++;\n\n        var success = true,\n            refs = [];\n\n        config.location.forEach(function (loc) {\n            refs.push(success && (success = (typeof loc === 'function') ? loc.apply(null, refs) : ref(loc, config.base)));\n        });\n\n        if (success) {\n            config.callback.apply(null, refs);\n        } else if (config._attempt < config._maxAttempts) {\n            setTimeout(function () { waitFor(config); }, config.interval);\n        } else {\n            config.failCallback(config);\n        }\n\n        function waitForConfig(obj) {\n            var locationType,\n                config = {\n                    location: null,              // string reference to desired property on base object (e.g. 'WDPRO.Analytics.wdwQuery')\n                    base: window,                // base object on which to search\n                    callback: null,              // function to receive the property value once it's found\n                    failCallback: defaultFailFn, // function to call if propery is not found before the timeout\n                    timeout: 30000,              // how many milliseconds after which to give up and call the failCallback\n                    interval: 250                // how often during the timeout period to keep looking\n                };\n\n            merge(config, obj);\n\n            locationType = toType(config.location);\n            if (locationType !== 'string' && locationType !== 'array' && locationType !== 'function') {\n                throw new TypeError('waitFor: config.location is required and must be a string, a function, or an array');\n            }\n            if (toType(config.callback) !== 'function') {\n                throw new TypeError('waitFor: config.callback is required and must be a function');\n            }\n\n            if (locationType !== 'array') {\n                config.location = [config.location];\n            }\n            return merge(config, {\n                _initialAttempt: new Date().getTime(),\n                _attempt: 0,\n                _maxAttempts: config.timeout / config.interval\n            });\n        }\n\n        function defaultFailFn(config) {\n            if (toType(ref('console.log')) === 'function') {\n                console.log(\n                    '\"%s\" not found after %dms (%d attempts, delaying %dms)',\n                    config.location.join(','),\n                    new Date().getTime() - config._initialAttempt,\n                    config._attempt,\n                    config.interval\n                );\n            }\n        }\n    }\n\n    function noop() {}\n}());\n</script>");