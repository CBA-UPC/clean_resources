ar e,s,r,n,i;const o=(null===(e="undefined"!=typeof globalThis?globalThis:void 0)||void 0===e?void 0:e.crypto)||(null===(s="undefined"!=typeof global?global:void 0)||void 0===s?void 0:s.crypto)||(null===(r="undefined"!=typeof window?window:void 0)||void 0===r?void 0:r.crypto)||(null===(n="undefined"!=typeof self?self:void 0)||void 0===n?void 0:n.crypto)||(null===(i="undefined"!=typeof frames?frames:void 0)||void 0===i||null===(i=i[0])||void 0===i?void 0:i.crypto);let c;c=o?t=>{const e=[];for(let s=0;s<t;s+=4)e.push(o.getRandomValues(new Uint32Array(1))[0]);return new l(e,t)}:t=>{const e=[],s=for(let r,n=0;n<t;n+=4){const t=s(4294967296*(r||Math.random()));r=987654071*t(),e.push(4294967296*t()|0)}return new l(e,t)};lass l extends a{h,d,p;h=l,p=c,(d=t(d="random"))in h?Object.defineProperty(h,d,{value:p,enumerable:!0,configurable:!0,writable:!0}):h[d]=p;const u={stringifyparse,f={stringifyparse,y={stringifyparse:;st m={stringifyparse_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},v=[];for(let t=0;t<64;t+=1)v[t]=4294967296*Math.abs(Math.sin(t+1))|0;const k=B=S=z=nst M="function"!=typeof Object.assign?Object.assign;class O extends _{constructor(t,e,s){super(),this.cfg=M(new a,s),this._xformMode=t,this._key=e,this.reset()}static createEncryptor(t,e){return this.create(this._ENC_XFORM_MODE,t,e)}NC_XFORM_MODE=1,O._DEC_XFORM_MODE=2,O.keySize=4,O.ivSize=4;ncryptor=A.Decryptor=const C={padunpad;class D extends O{constructor(t,e,s){super(t,e,M({mode:A,padding:C},s)),this.blockSize=4}st F={stringifyparse;class P extends a{static encrypt(t,e,s,r){const n=M(new a,this.cfg,r),i=t.createEncryptor(s,n),o=i.finalize(e),c=i.cfg;return j.create({ciphertext:o,key:s,iv:c.iv,algorithm:t,mode:c.mode,padding:c.padding,blockSize:i.blockSize,formatter:n.format})}static decrypt(t,e,s,r){let n=e;const i=M(new a,this.cfg,r);n=this._parse(n,i.format);return t.createDecryptor(s,i).finalize(n.ciphertext)}P.cfg=M(new a,{format:F});const U={execute(t,e,s,r,n){let i,o=r;o||(o=l.random(8)),i=n?x.create({keySize:e+s,hasher:n}).compute(t,o):x.create({keySize:e+s}).compute(t,o);const c=l.create(i.words.slice(e),4*s);return i.sigBytes=4*e,j.create({key:i,iv:c,salt:o})}};class I extends P{static encrypt(t,e,s,r){const n=M(new a,this.cfg,r),i=n.kdf.execute(s,t.keySize,t.ivSize,n.salt,n.hasher);n.iv=i.iv;const o=P.encrypt.call(this,t,e,i.key,n);return o.mixIn(i),o}static decrypt(t,e,s,r){let n=e;const i=M(new a,this.cfg,r);n=this._parse(n,i.format);const o=i.kdf.execute(s,t.keySize,t.ivSize,n.salt,i.hasher);i.iv=o.iv;return P.decrypt.call(this,t,n,o.key,i)}}I.cfg=M(P.cfg,{kdf:U});const K=[],X=[],H=[],N=[],T=[],L=[],V=[],W=[],$=[],q=[],G=[];for(let t=0;t<256;t+=1)G[t]=t<128?t<<1:t<<1^283;let J=0,Q=0;for(let t=0;t<256;t+=1){let t=Q^Q<<1^Q<<2^Q<<3^Q<<4;t=t>>>8^255&t^99,K[J]=t,X[t]=J;const e=G[J],s=G[e],r=G[s];let n=257*G[t]^16843008*t;H[J]=n<<24|n>>>8,N[J]=n<<16|n>>>16,T[J]=n<<8|n>>>24,L[J]=n,n=16843009*r^65537*s^257*e^16843008*J,V[t]=n<<24|n>>>8,W[t]=n<<16|n>>>16,$[t]=n<<8|n>>>24,q[t]=n,J?(J=e^G[G[G[r^e]]],Q^=G[G[Q]]):(Q=1,J=Q)}const Y=[0,1,2,4,8,16,32,64,128,27,54];.keySize=8;const tt=D._createHelper(Z),et="RudderEncrypt:",st="Rudder",rt=t=>`${et}${tt.encrypt(t,st).toString()}`,nt=t=>t.startsWith(et)?tt.decrypt(t.substring(14),st).toString(y):t;export{nt as d,rt as e};
//# sourceMappingURL=rsa-plugins-legacyEncryptionUtils.min.js.map
