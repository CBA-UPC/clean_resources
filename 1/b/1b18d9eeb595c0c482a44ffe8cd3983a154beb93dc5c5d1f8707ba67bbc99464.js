/*!
 * nanoStream Webcaster API v.5.9.8
 * (c) 2017-2020, nanocosmos gmbh
 * https://www.nanocosmos.de
 * sales@nanocosmos.de
 * 
 * LEGAL NOTICE:
 * This material is subject to the terms and conditions defined in
 * separate license conditions ('LICENSE.txt' or nanocosmos.de/terms).
 * All information contained herein is, and remains the property
 * of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
 * contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
 * or copyright law. Dissemination of this information or reproduction of this material
 * is strictly forbidden unless prior written permission is obtained from nanocosmos.
 * All modifications will remain property of nanocosmos.
 */![function (e, t, r) { var n; void 0 === (n = function () { "use strict"; var e = Math.floor, t = Math.random, r = { browserInfo: void 0, debugLevel: 0, debugCount: 0, debugMax: 30, ELEMENT_DEBUG: "debug", ELEMENT_MESSAGES: "messages", ELEMENT_ERRORS: "errors", parseJSON: function (e, t, n) { if ("object" == typeof e) return e; try { return JSON.parse(e, t) } catch (t) { r.error("Error:" + t + " parsing from json: " + e, n) } }, stringifyJSON: function (e, t, n, i) { if (r.isString(e)) return e; try { return JSON.stringify(e, t, n) } catch (t) { r.error("Error:" + t + " stringifying to json: " + e, i) } }, encodeURIComponent: function (e, t) { if (r.isString(e)) return decodeURIComponent(e) === e ? encodeURIComponent(e) : e; r.error("Error: could not uri encode: " + e + "(must be of type string)", t) }, getElement: function (e) { var t = document.getElementById(e); return t || (r.debug("DOM element not found " + e), { value: void 0, checked: void 0, enabled: void 0, textContent: void 0, options: { length: 0 }, style: {}, innerHTML: "", src: "", classList: "", click: function () { return null }, show: function () { return null }, hide: function () { return null }, removeChild: }) }, print:  success: function (e) { r._log(e, "messages", "green") }, warning:  error: function (e, t) { t || (t = 1), r._log(e, r.ELEMENT_MESSAGES, "red"), r._log(e, r.ELEMENT_ERRORS, "red", t) }, debug:  _log: function (e, t, n, i) { switch (r.isObject(e) && (e = r.stringifyJSON(e, null, " ")), n) { case "green": e = "Success: " + e; break; case "orange": e = "Warning: " + e; break; case "red": e = "Error: " + e; break; default: n = "" }n ? console.log("%c" + e, "color:" + n) : console.log(e); var o = document.getElementById(t); if (o && (t === r.ELEMENT_DEBUG && r.debugCount > r.debugMax && (o.removeChild(o.firstChild), r.debugCount++), o.innerHTML += "<span" + (n ? ' style="color:' + n + ';">' : ">") + e + "</span><br>"), i > 1) throw new Error(e) }, isBool:  isIntString:  isNumber:  isIntInRange:  isInt: function (e) { return e === Number(e) && e % 1 == 0 }, isUint: function (e) { return e === Number(e) && e % 1 == 0 && e >= 0 }, isString:  isFunction:  isObject: function (e) { return !!e && e.constructor !== Array && ("object" == typeof e || e instanceof Object) }, isArray:  isEmpty:  getRandomUint: function (n) { return n = r.isUint(n) ? n : 10, e(t() * n) }, getRandomString: function (e, t) { var n; switch (e) { case 0: n = "0123456789"; break; case 1: n = "0123456789abcdefghijklmnopqrstuvwxyz"; break; case 2: n = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; break; default: n = "0123456789abcdefghijklmnopqrstuvwxyz" }for (var i = "", o = r.getRandomUint, s = r.isUint(t) ? t : 6, a = n.length, c = 0; c < s; c++)i += n[o(a)]; return i }, getTime:  getKeyByValue: function (e, t) { if (r.isObject(e)) return Object.keys(e).filter((function (r) { return e[r] === t }))[0] }, enumContainsValue: function (e, t) { for (var r in e) if (Object.prototype.hasOwnProperty.call(e, r) && e[r] === t) return !0; return !1 }, enumToString: function (e) { var t = []; for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n)) { var i = e[n]; r.isFunction(i) || t.push(e[n]) } return t.join() }, getVersionText: function (e, t, r) { var n = "Your browser: " + e + " v." + t; return r && (n += " (mobile)"), n }, getSupportText: function (e, t, n, i) { var o = r.getVersionText(e, t, n), s = ""; return i > 0 && (s = o + " is not supported.", i > 1 && (s = o + " is not fully supported. ", s += "You may try to use it, but it may show issues. Please report any issues to https://webrtc.live.")), s }, createBrowserInfo: function () { var e = ""; screen.width && (e += (screen.width ? screen.width : "") + " x " + (screen.height ? screen.height : "")); var t, n, i, o = navigator.appVersion, s = navigator.userAgent, a = navigator.appName, c = "" + parseFloat(o), d = parseInt(o, 10); -1 !== (n = s.indexOf("Opera")) && (a = "Opera", c = s.substring(n + 6), -1 !== (n = s.indexOf("Version")) && (c = s.substring(n + 8))), -1 !== (n = s.indexOf("OPR/")) ? (a = "Opera", c = s.substring(n + 4)) : -1 !== (n = s.indexOf("MSIE")) ? (a = "Microsoft Internet Explorer", c = s.substring(n + 5)) : "Netscape" === a && -1 !== (n = s.indexOf("Trident/")) ? (a = "Microsoft Internet Explorer", c = s.substring(n + 8), -1 !== (n = s.indexOf("rv:")) && (c = s.substring(n + 3))) : "Netscape" === a && -1 !== (n = s.indexOf("Edge/")) ? (a = "Microsoft Edge", c = s.substring(n + 5)) : -1 !== (n = s.indexOf("Edg/")) ? (a = "Microsoft Edge Chromium", c = s.substring(n + 4)) : -1 !== (n = s.indexOf("Chrome")) ? (a = "Chrome", c = s.substring(n + 7)) : -1 !== (n = s.indexOf("Safari")) ? (a = "Safari", c = s.substring(n + 7), -1 !== (n = s.indexOf("Version")) && (c = s.substring(n + 8)), -1 !== s.indexOf("CriOS") && (a = "Chrome")) : -1 !== (n = s.indexOf("Firefox")) ? (a = "Firefox", c = s.substring(n + 8)) : (t = s.lastIndexOf(" ") + 1) < (n = s.lastIndexOf("/")) && (a = s.substring(t, n), c = s.substring(n + 1), a.toLowerCase() === a.toUpperCase() && (a = navigator.appName)), -1 !== (i = c.indexOf(";")) && (c = c.substring(0, i)), -1 !== (i = c.indexOf(" ")) && (c = c.substring(0, i)), -1 !== (i = c.indexOf(")")) && (c = c.substring(0, i)), d = parseInt("" + c, 10), isNaN(d) && (c = "" + parseFloat(o), d = parseInt(o, 10)); var u = /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(o), l = navigator.cookieEnabled; void 0 !== navigator.cookieEnabled || l || (document.cookie = "testcookie", l = -1 !== document.cookie.indexOf("testcookie")); for (var p = "Unknown", f = [{ os: "Windows XP", regex: /(Windows NT 5.1|Windows XP)/ }, { os: "Windows Server 2003", regex: /Windows NT 5.2/ }, { os: "Windows Vista", regex: /Windows NT 6.0/ }, { os: "Windows 7", regex: /(Windows 7|Windows NT 6.1)/ }, { os: "Windows 8.1", regex: /(Windows 8.1|Windows NT 6.3)/ }, { os: "Windows 8", regex: /(Windows 8|Windows NT 6.2)/ }, { os: "Windows NT 4.0", regex: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/ }, { os: "Windows ME", regex: /Windows ME/ }, { os: "Android", regex: /Android/ }, { os: "Open BSD", regex: /OpenBSD/ }, { os: "Sun OS", regex: /SunOS/ }, { os: "Linux", regex: /(Linux|X11)/ }, { os: "iOS", regex: /(iPhone|iPad|iPod)/ }, { os: "Mac OS X", regex: /Mac OS X/ }, { os: "Mac OS", regex: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ }, { os: "QNX", regex: /QNX/ }, { os: "UNIX", regex: /UNIX/ }, { os: "BeOS", regex: /BeOS/ }, { os: "OS/2", regex: /OS\/2/ }, { os: "Search Bot", regex: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/ }], g = 0, h = f.length; g < h; ++g)if (f[g].regex.test(s)) { p = f[g].os; break } var v = "Unknown"; switch (/Windows/.test(p) && (v = (/Windows (.*)/.exec(p) || [])[1], p = "Windows"), p) { case "Mac OS X": v = (/Mac OS X (10[\.\_\d]+)/.exec(s) || [])[1]; break; case "Android": v = (/Android ([\.\_\d]+)/.exec(s) || [])[1]; break; case "iOS": v = (v = /OS (\d+)_(\d+)_?(\d+)?/.exec(o) || [])[1] + "." + v[2] + "." + (0 | v[3]) }r.browserInfo = { screenSize: e, browser: a, browserVersion: c, mobile: u, os: p, osVersion: v, cookiesEnabled: l } } }; return r.createBrowserInfo(), r }.apply(t, [])) || (e.exports = n) },  function (e, t, r) { var n, i; n = [r(0), r(6), r(3), r(46), r(87)], void 0 === (i = function (e, t, r, n, i) { "use strict"; var o = e.getTime, s = e.stringifyJSON, a = e.isObject, c = e.isNumber, d = e.isIntInRange, u = e.isString, l = e.isEmpty, p = 0, f = { _console: { loggers: [], level: t.LOG_LEVEL.INFO }, _graylog: { loggers: [], credentials: { accountId: "", accountKey: "" }, baseUrl: "https://glog1.nanocosmos.de/gelf/" }, _globalPrefix: "nanowebrtc", setConfig: function (e) { if (console.log(o() + ": [" + f._globalPrefix + "][LoggerController] - setConfig(" + s(e) + ")"), !a(e) || l(e)) throw r.TypeNotValidError("config", "Object"); if (a(e.console)) { if (c(e.console.level) && d(e.console.level, t.LOG_LEVEL.DISABLED, t.LOG_LEVEL.VERBOSE)) f._console.level = e.console.level; else { var n = r.ValueNotValidError("config.console.level", "0|1|2|3|4"); console.error(o() + ": [" + f._globalPrefix + "][LoggerController] - setConfig(): " + s(n)) } f._console.loggers.forEach(() } if (a(e.graylog)) { if (!a(e.graylog.credentials) || l(e.graylog.credentials)) throw r.TypeNotValidError("config.graylog.credentials", "Object"); if (!u(e.graylog.credentials.accountId)) throw r.TypeNotValidError("config.graylog.credentials.accountId", "String"); if (0 == e.graylog.credentials.accountId.length) throw r.ValueNotValidError("config.graylog.credentials.accountId", "1..n characters"); if (!u(e.graylog.credentials.accountKey)) throw r.TypeNotValidError("config.graylog.credentials.accountKey", "String"); if (0 == e.graylog.credentials.accountKey.length) throw r.TypeNotValidError("config.graylog.credentials.accountKey", "1..n characters"); f._graylog.credentials.accountId = "" + e.graylog.credentials.accountId, f._graylog.credentials.accountKey = "" + e.graylog.credentials.accountKey, f._graylog.loggers.forEach(() } }, create: function (a, c) { if (e.enumContainsValue(t.LOGGER_TYPE, c)) { var d = void 0; return p++, c === t.LOGGER_TYPE.GRAYLOG ? (d = new i(f._globalPrefix, f._console.level, f._graylog.baseUrl, f._graylog.credentials.accountId, f._graylog.credentials.accountKey, p), f._graylog.loggers.push(d)) : (d = new n(f._globalPrefix, a, f._console.level, p), f._console.loggers.push(d)), d } var u = r.EnumValueNotValidError(c, t.LOGGER_TYPE); console.log(o() + ": [" + f._globalPrefix + "][LoggerController] - create(): " + s(u)) }, delete: function (e) { for (var t, r, n = !1, i = 0; i < f._console.loggers.length; i++)if (t = f._console.loggers[i], e._id === t._id) { f._console.loggers.splice(i, 1), n = !0; break } if (n) return n; for (var o = 0; o < f._graylog.loggers.length; o++)if (r = f._graylog.loggers[o], e._id === r._id) { f._graylog.loggers.splice(o, 1), n = !0; break } return n } }; return f }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(0)], void 0 === (i = function (e) { "use strict"; var t = e.enumToString, r = e.isObject, n = function (e, t, r, n) { this.name = e, this.type = "NanoError", this.code = t, this.message = r, this.userinfo = n, this.toJSON = function () { return { name: this.name, type: this.type, code: this.code, message: this.message, userinfo: this.userinfo } } }, i = function () { }; return i.GeneralError = function (e) { return new n("GeneralError", 1e3, e = e).toJSON() }, i.TypeNotValidError = function (e, t) { return new n("TypeNotValidError", 1001, '"' + e + '" type not valid', { value: e, expected_type: t }).toJSON() }, i.ValueNotValidError = function (e, t) { return new n("ValueNotValidError", 1002, '"' + e + '" value not valid', { value: e, expected_value: t }).toJSON() }, i.EnumValueNotValidError = function (e, r) { return new n("EnumValueNotValidError", 1003, '"' + e + '" enum value not valid', { value: e, expected_values: t(r) }).toJSON() }, i.ObjectNotExistError = function (e, t) { return new n("ObjectNotExistError", 1004, '"' + e + '" object not exist', { value: e, expected_type: t }).toJSON() }, i.FunctionNotDefinedError = function (e) { return new n("FunctionNotDefinedError", 1005, '"' + e + '" function not defined', { func: e }).toJSON() }, i.OperationNotAllowedError = function (e, t) { return new n("OperationNotAllowedError", 1006, "Operation not allowed, reason: " + t, { operation: e, reason: t }).toJSON() }, i.RequestError = function (e, t) { return new n("RequestError", 2e3, "", { status: e, statusText: t }).toJSON() }, i.WebSocketError = function (e, t) { return new n("WebSocketError", 3e3, e, { server: t }).toJSON() }, i.WrongStateError = function (e) { return new n("WrongStateError", 3001, "Websocket is in a wrong state", { state: e }).toJSON() }, i.CreateWebSocketError = function (e, t) { return new n("CreateWebSocketError", 3002, e, { server: t }).toJSON() }, i.SignInError = function (e) { return new n("SignInError", 4e3, "Sign in failed", { reason: e }).toJSON() }, i.NotSignedInError =  i.StartBroadcastError = function (e) { return new n("StartBroadcastError", 5001, "Starting broadcast failed", { reason: e }).toJSON() }, i.BroadcastError = function (e) { return new n("BroadcastError", 5002, "Broadcast failed", { reason: e }).toJSON() }, i.StopBroadcastError = function (e) { return new n("StopBroadcastError", 5003, "Stopping broadcast failed", { reason: e }).toJSON() }, i.DeviceBlockedError = function (e, t) { return new n("DeviceBlockedError", 6e3, "Media stream received, but no " + (e ? e + " " : "") + "data from device" + (t ? ' "' + t + '". ' : ". ") + "Device could be in use from another application", { kind: e, label: t }).toJSON() }, i.MediaStreamTrackError = function () { return new n("MediaStreamTrackError", 6001, "Media stream received, but no tracks", {}).toJSON() }, i.MediaStreamNotFoundError = function () { return new n("MediaStreamNotFoundError", 6002, "Media stream not found", {}).toJSON() }, i.MediaStreamNotRemovedError = function () { return new n("MediaStreamNotRemovedError", 6003, "Media stream not removed", {}).toJSON() }, i.DevicesNotFoundError = function () { return new n("DevicesNotFoundError", 6004, 'Devices not set for "getUserMedia"', {}).toJSON() }, i.GetUserMediaError = function (e, t) { var r = e && e.constraint ? e.constraint : void 0, i = e && e.name && !r ? e.name : r ? "OverconstrainedError" : "GetUserMediaError", o = e && e.message ? e.message : "Failed to get user / display media."; return new n(i, 6005, o, { constraint: r, retry: t }).toJSON() }, i.EnumerateDevicesError = function (e) { var t = e && e.name ? e.name : "EnumerateDevicesError", r = e && e.message ? e.message : "Failed to enumerate devices."; return new n(t, 6006, r, {}).toJSON() }, i.GetDisplayMediaError = function (e, t) { return new n(e, 6008, t = t || 'Failed to call "getDisplayMedia".', {}).toJSON() }, i.ServerError = function (e) { return new n("ServerError", 7e3, "An error has occurred on server side", { reason: e }).toJSON() }, i.mapServerError = function (e) { var t, r; return e && e.error && "WebrtcServerError" === e.error.type ? ((r = e.error).code < 1e5 && (r.code = r.code + 1e5), r.type = "NanoError", (t = i.ServerError(r.message, r)).userinfo = r.userinfo ? r.userinfo : {}, r.message && (t.userinfo.reason = r.message), r.code && (t.code = r.code)) : t = e, t }, i.addMetaData = function (e, t) { e && r(e) && (e.userinfo && r(e.userinfo) || (e.userinfo = {}), e.userinfo.metadata = t) }, i.composeEvent = function (e, t) { var r = "", n = void 0, i = "", o = void 0; switch (e.name) { case "GeneralError": r = "GeneralError", i = e.message || "General error"; break; case "TypeNotValidError": r = "TypeNotValidError", i = e.message; break; case "ValueNotValidError": r = "ValueNotValidError", i = e.message; break; case "EnumValueNotValidError": r = "EnumValueNotValidError", i = e.message; break; case "ObjectNotExistError": r = "ObjectNotExistError", i = e.message; break; case "FunctionNotDefinedError": e.userinfo && e.userinfo.func && (-1 !== e.userinfo.func.indexOf("getUserMedia") ? r = "GetUserMediaError" : -1 !== e.userinfo.func.indexOf("getDisplayMedia") ? r = "GetDisplayMediaError" : -1 !== e.userinfo.func.indexOf("enumerateDevices") && (r = "EnumerateDevicesError"), i = e.userinfo.func + " not defined"); break; case "RequestError": r = "RequestError", i = e.message; break; case "WebSocketError": r = "RequestError"; break; case "WrongStateError": r = "WrongStateError", i = e.message; break; case "SignInError": r = "SignInError", i = e.message; break; case "NotSignedInError": r = "NotSignedInError", i = e.message; break; case "StartBroadcastError": r = "StartBroadcastError", i = e.message; break; case "BroadcastError": r = "BroadcastError", i = e.message; break; case "StopBroadcastError": r = "StopBroadcastError", i = e.message; break; case "DeviceBlockedError": case "MediaStreamTrackError": r = "MediaStreamError", i = e.message; break; case "MediaStreamNotFoundError": r = "NoStreamError", i = "No stream is available for the device."; break; case "MediaStreamNotRemovedError": r = "MediaStreamNotRemovedError", i = e.message; break; case "DevicesNotFoundError": r = "NoDeviceError", i = 'No device is available for "getUserMedia".'; break; case "GetUserMediaError": case "PermissionDenied": case "NotAllowedError": case "NotReadableError": case "NotFoundError": case "OverconstrainedError": case "AbortError": case "GetMediaError": case "NoDeviceError": case "NoStreamError": r = e.name, i = e.message, n = e.userinfo.constraint, o = e.userinfo.retry; break; case "EnumerateDevicesError": r = "EnumerateDevicesError", i = e.message; break; case "ServerError": r = "ServerError", i = e.message; break; case "WebrtcServerError": r = "WebrtcServerError", i = e.message; break; case "RTMPError": r = "RTMPError", i = e.message; break; default: r = e.name || "UnknownError", i = e.message || "Unknown error." }var s = {}; return s.name = t || e.name, s.data = { error: r + ": " + i, message: i, text: i, constraint: n, errorType: r, retry: o }, s.error = { name: e.name, type: e.type, code: e.code, message: e.message, text: e.message, userinfo: e.userinfo }, s }, i }.apply(t, n)) || (e.exports = i) },  function (e, t, r) {
     var n;
/*!
 * EventEmitter v4.2.11 - git.io/ee
 * Unlicense - http://unlicense.org/
 * Oliver Caldwell - http://oli.me.uk/
 * @preserve
 */(function () { "use strict"; function t() { } var i = t.prototype, o = this, s = o.EventEmitter; i.getListeners =  i.flattenListeners =  i.getListenersAsObject =  i.addListener =  i.on = c("addListener"), i.addOnceListener =  i.once = c("addOnceListener"), i.defineEvent =  i.defineEvents =  i.removeListener =  i.off = c("removeListener"), i.addListeners = function (e, t) { return this.manipulateListeners(!1, e, t) }, i.removeListeners =  i.manipulateListeners =  i.removeEvent =  i.removeAllListeners = c("removeEvent"), i.emitEvent =  i.trigger = c("emitEvent"), i.emit =  i.emitSimple = function (e, t, r) { return this.emitEvent(e, [{ name: e || "AnonymousEvent", data: t || {}, error: r || {} }]) }, i.setOnceReturnValue =  i._getOnceReturnValue =  i._getEvents =  t.noConflict =  void 0 === (n = function () { return t }.call(o, r, o, e)) || (e.exports = n) }).call(this)
 }, function (e, t, r) { var n; void 0 === (n = function () { "use strict"; return { STREAM_NOMEDIASTREAM: 1, STREAM_ACTIVE: 2, STREAM_INACTIVE: 3, STREAM_ENDED: 4, MEDIA_SOURCES: { CAMERA: "camera", SCREEN: "screen" }, ELEMENT_TYPES: { VIDEO: "video", AUDIO: "audio" }, LOGGER_TYPE: { CONSOLE: "console", GRAYLOG: "graylog" }, LOG_LEVEL: { DISABLED: 0, ERROR: 1, WARNING: 2, INFO: 3, VERBOSE: 4 }, BROADCAST_STATE: { IDLE: 1, INITIALIZED: 2, STARTED: 3, SIGNALING: 4, CONNECTED: 5, BROADCASTING: 6, RECONNECTING: 7, DISCONNECTED: 8, FAILED: 9, STOPPED: 10 }, CHATPEER_STATE: { IDLE: 1, INITIALIZED: 2, SIGNALING: 3, SIGNALLING_DONE: 4, CALLING: 5, NEGOTIATION_NEEDED: 7, DISCONNECTED: 8, FAILED: 9, STOPPED: 10 }, SCREEN_CAPTURE_BROWSER: { CHROME: "chrome", FIREFOX: "firefox", SAFARI: "safari" }, EVENT_NAMES: { webcast: ["SignInSuccess", "SignInError", "ServerError", "SignOutSuccess", "SignOutError", "SetConfigError", "ReceivedServerStats", "ReceivedWebRTCStats", "StartBroadcastSuccess", "StartBroadcastError", "BroadcastStatus", "BroadcastError", "StopBroadcastSuccess", "StopBroadcastError", "Error", "ReceivedDeviceList", "GetDevicesError", "SetVideoDeviceError", "SetAudioDeviceError", "GetSelectedVideoDeviceError", "GetSelectedAudioDeviceError", "GetSelectedDeviceError", "StartPreviewSuccess", "StartPreviewError", "StopPreviewSuccess", "StopPreviewError", "MuteDeviceError", "StreamTrackEnded"], chat: ["EnterRoomSuccess", "EnterRoomError", "LeaveRoomSuccess", "LeaveRoomError", "InvokeCall", "HangUpCall", "AnswerCall", "DeclineCall", "PeerListUpdated", "CallIncoming", "CallDeclined", "CallActive", "RemoteStreamError"] } } }.apply(t, [])) || (e.exports = n) },      function (e, t, r) { var n = r(7).Symbol; e.exports = n }, function (e, t, r) { var n = r(58), i = r(60), o = r(16); e.exports = function (e) { return o(e) ? n(e) : i(e) } },      function (e, t, r) { var n, i; n = [r(5), r(86), r(32), r(0), r(3), r(2)], void 0 === (i = function (e, t, r, n, i, o) { "use strict"; var s = n.stringifyJSON, a = n.isObject, c = n.isString, d = { IDLE: 1, SIGNED_IN: 2, SIGNED_OUT: 3, RECONNECTING: 4, FAILED: 5 }; function u() { e.call(this), this._sessionId = void 0, this._serverUrl = void 0, this._state = d.IDLE, this._logger = o.create("Session", "console"), this._websocketClient = new t } var l = u.prototype = Object.create(e.prototype); return l.isSignedIn =  l.signIn = function (e) { this._logger.verbose("signIn(" + s(e) + ")"); if (this.isSignedIn()) return Promise.reject(i.SignInError("Already signed in")); if (!a(e)) return Promise.reject(i.TypeNotValidError("data", "Object")); if (!e.server || !c(e.server)) return Promise.reject(i.TypeNotValidError("data.serverUrl", "String")); if (e.bintuApiKey && !c(e.bintuApiKey)) return Promise.reject(i.TypeNotValidError("data.bintuApiKey", "String")); if (e.token && !c(e.token)) return Promise.reject(i.TypeNotValidError("data.token", "String")); if (e.jwt && !c(e.jwt)) return Promise.reject(i.TypeNotValidError("data.jwt", "String")); this._serverUrl = e.server; var t = { user_name: "defaultUserName", room: "defaultRoom" }; e.bintuApiKey && (t.bintu_api_key = e.bintuApiKey), e.token && (t.token = e.token), e.jwt && (t.jwt = e.jwt), t.api_version = r.webrtc.release_version; var n = this; return this._websocketClient.connect(this._serverUrl, this._onMessage.bind(this)).then((function () { return n._websocketClient.sendMessage("sign_in", t) })).then((function (e) { return n._logger.verbose("signIn(): Signed in: " + s(e)), n._sessionId = e.session_id, n._setState(d.SIGNED_IN), { data: { server: n._serverUrl, userId: e.user_id, iceServers: e.ice_servers ? e.ice_servers : void 0 } } })).catch((function (e) { return n._logger.error("signIn(): " + s(e)), "CreateWebSocketError" !== e.name && n._websocketClient.close(), Promise.reject(e) })) }, l.signOut = function () { this._logger.verbose("signOut(), sessionId" + this._sessionId); if (!this.isSignedIn()) return Promise.reject(i.NotSignedInError()); var e = this; return this._websocketClient.sendMessage("sign_out", { session_id: this._sessionId }).then((function (t) { return e._logger.verbose("signOut(): " + t), e.removeAllListeners(), e._sessionId = void 0, e._setState(d.SIGNED_OUT), e._websocketClient.close(), t })).catch((function (t) { return e._logger.error("signOut(): " + t), e._websocketClient.close(), e._sessionId = void 0, Promise.reject(t) })) }, l.echo =  l.sendSignalingMessage = function (e) { this._logger.verbose("sendSignalingMessage(" + s(e) + ")"); if (!this.isSignedIn()) return Promise.reject(i.NotSignedInError()); var t = this; return this._checkPeerMessage(e).then(().catch((function (e) { return t._logger.error("sendSignalingMessage(): " + s(e)), Promise.reject(e) })) }, l.enterRoom = function (e) { return this._logger.verbose("enterRoom(" + s(e) + "), sessionId: " + this._sessionId), this.isSignedIn() ? a(e) ? c(e.roomName) ? c(e.userName) ? this._checkRoomName(e.roomName) ? this._websocketClient.sendMessage("enter_room", { session_id: this._sessionId, room_name: e.roomName, user_name: e.userName }) : Promise.reject(i.ValueNotValidError("data.room", "Alphanumeric characters / underscore (_) / dash (-) / dot (.)")) : Promise.reject(i.TypeNotValidError("data.userName", "String")) : Promise.reject(i.TypeNotValidError("data.roomName", "String")) : Promise.reject(i.TypeNotValidError("data", "Object")) : Promise.reject(i.NotSignedInError()) }, l.leaveRoom = function (e) { return this._logger.verbose("leaveRoom(" + s(e) + "), sessionId: " + this._sessionId), this.isSignedIn() ? a(e) ? c(e.roomName) ? this._websocketClient.sendMessage("leave_room", { session_id: this._sessionId, room_name: e.roomName }) : Promise.reject(i.TypeNotValidError("data.roomName", "String")) : Promise.reject(i.TypeNotValidError("data", "Object")) : Promise.reject(i.NotSignedInError()) }, l.callUser = function (e) { return this._logger.verbose("callUser(" + s(e) + ")"), this.isSignedIn() ? a(e) ? c(e.userId) ? c(e.roomName) ? this._websocketClient.sendMessage("call_user", { session_id: this._sessionId, user_id: e.userId, room_name: e.roomName }) : Promise.reject(i.TypeNotValidError("data.roomName", "String")) : Promise.reject(i.TypeNotValidError("data.userId", "String")) : Promise.reject(i.TypeNotValidError("data", "Object")) : Promise.reject(i.NotSignedInError()) }, l.answerCall = function (e) { return this._logger.verbose("answerCall(" + s(e) + ")"), this.isSignedIn() ? a(e) ? c(e.userId) ? c(e.roomName) ? this._websocketClient.sendMessage("answer_call", { session_id: this._sessionId, user_id: e.userId, room_name: e.roomName }) : Promise.reject(i.TypeNotValidError("data.roomName", "String")) : Promise.reject(i.TypeNotValidError("data.userId", "String")) : Promise.reject(i.TypeNotValidError("data", "Object")) : Promise.reject(i.NotSignedInError()) }, l.declineCall = function (e) { return this._logger.verbose("declineCall(" + s(e) + ")"), this.isSignedIn() ? a(e) ? c(e.userId) ? c(e.roomName) ? this._websocketClient.sendMessage("decline_call", { session_id: this._sessionId, user_id: e.userId, room_name: e.roomName }) : Promise.reject(i.TypeNotValidError("data.roomName", "String")) : Promise.reject(i.TypeNotValidError("data.userId", "String")) : Promise.reject(i.TypeNotValidError("data", "Object")) : Promise.reject(i.NotSignedInError()) }, l.hangUpCall = function (e) { return this._logger.verbose("hangUpCall(" + s(e) + ")"), this.isSignedIn() ? this._websocketClient.sendMessage("hangup_call", { session_id: this._sessionId, user_id: e.userId, room_name: e.roomName }) : Promise.reject(i.NotSignedInError()) }, l.startBroadcast = function (e) { this._logger.verbose("startBroadcast(" + s(e) + ")"); if (!this.isSignedIn()) return Promise.reject(i.NotSignedInError()); if (!a(e)) return Promise.reject(i.TypeNotValidError("broadcastParams", "Object")); e.session_id = this._sessionId; var t = this; return this._websocketClient.sendMessage("start_broadcast", e).catch((function (e) { return t._logger.error("startBroadcast(): " + s(e)), Promise.reject(e) })) }, l.stopBroadcast = function (e) { this._logger.verbose("stopBroadcast(" + s(e) + ")"); if (!this.isSignedIn()) return Promise.reject(i.NotSignedInError()); if (!a(e)) return Promise.reject(i.TypeNotValidError("data", "Object")); if (!c(e.sender_peer)) return Promise.reject(i.TypeNotValidError("data.sender_peer", "String")); if (!c(e.receiver_peer)) return Promise.reject(i.TypeNotValidError("data.receiver_peer", "String")); var t = this; return this._checkPeerMessage(e).then(t._websocketClient.sendMessage("stop_broadcast", { session_id: t._sessionId, sender_peer: e.sender_peer, receiver_peer: e.receiver_peer })).catch((function (e) { return t._logger.error("stopBroadcast(): " + s(e)), Promise.reject(e) })) }, l.sendMetaData = function (e) { this._logger.verbose("sendMetaData(" + s(e) + ")"); if (!this.isSignedIn()) return Promise.reject(i.NotSignedInError()); var t = this; return this._checkPeerMessage(e).then(t._websocketClient.sendMessage("send_metadata", e)).catch((function (e) { return t._logger.error("sendMetaData(): " + s(e)), Promise.reject(e) })) }, l.status = function () { this._logger.verbose("status()"); if (!this.isSignedIn()) return Promise.reject(i.NotSignedInError()); var e = this; return this._websocketClient.sendMessage("status", {}).catch((function (t) { return e._logger.error("status(): " + s(t)), Promise.reject(t) })) }, l.getInfo =  l._onMessage = function (e) { this._logger.verbose("_onMessage(" + JSON.stringify(e) + ")"); var t; if (e) { if ("transcoder_message" === e.type && "disconnected" === e.state && "transcoder_sign_out" === e.reason && (e.type = "close", this.emit("SessionMessage", e)), e.receiver_peer) return t = e.receiver_peer, void this.emit("receiver_peer_" + t, e); switch (e.type) { case "room_update": case "call_incoming": case "call_declined": case "start_as_caller": case "hang_up": return this.emit("RoomMessage", e); case "close": this._state !== d.SIGNED_OUT ? (this.emit("SessionMessage", { type: "close", reason: "websocket_disconnect" }), this._setState(d.IDLE)) : (this.emit("SessionMessage", { type: "close", reason: "disconnect" }), this._setState(d.IDLE)); break; default: this._logger.warning("_onMessage(): Unhandled message received: " + e) } } }, l._setState = function (e) { this._logger.verbose("_setState(" + e + ")"); if (e !== this._state) { var t = this._state; this._state = e; var r = "_setState(): State: " + n.getKeyByValue(d, t) + " -> " + n.getKeyByValue(d, this._state); this._logger.verbose(r) } }, l._checkPeerMessage = function (e) { return this._logger.verbose("_checkPeerMessage(" + s(e) + ")"), a(e) ? e.sender_peer ? e.receiver_peer ? Promise.resolve() : Promise.reject(i.TypeNotValidError("message.receiver_peer", "String")) : Promise.reject(i.TypeNotValidError("message.sender_peer", "String")) : Promise.reject(i.TypeNotValidError("message", "Object")) }, l._checkRoomName = function (e) { return /^([a-zA-Z0-9_\-.]{1,})$/gm.test(e) }, u }.apply(t, n)) || (e.exports = i) },  function (e, t, r) { var n = r(103), i = r(104), o = r(105), s = r(106), a = r(107); function c(e) { var t = -1, r = null == e ? 0 : e.length; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } c.prototype.clear = n, c.prototype.delete = i, c.prototype.get = o, c.prototype.has = s, c.prototype.set = a, e.exports = c },      function (e, t, r) { var n = r(136), i = r(14), o = r(15), s = o && o.isTypedArray, a = s ? i(s) : n; e.exports = a },     function (e, t, r) { var n; void 0 === (n = function () { "use strict"; return JSON.parse(JSON.stringify({ webrtc: { release_version: "5.9.6" } })) }.apply(t, [])) || (e.exports = n) }, function (e, t, r) { var n, i; n = [r(6), r(0), r(93), r(3), r(5), r(2)], void 0 === (i = function (e, t, r, n, i, o) { "use strict"; var s = t.stringifyJSON, a = t.isObject, c = t.isBool, d = t.isFunction; function u(e) { i.call(this), this._medias = { local: [], remote: [] }, this._constraints = {}, this._error = void 0, this._deviceController = e, this._logger = o.create("MediaController", "console") } var l = u.prototype = Object.create(i.prototype); return u.getSupportedConstraints = function () { var e; return (navigator.mediaDevices || navigator.mediaDevices.getSupportedConstraints) && (e = navigator.mediaDevices.getSupportedConstraints()), e }, l.getMediaForDevices = function (t, r) { this._logger.verbose("getMediaForDevices(" + s(t) + ", " + r + ")"); var i = "getMediaForDevices(): ", o = void 0, a = this; return new Promise((function (s, d) { return a._verifyDevicesExistence(t).then((function () { return o = t.videoinput.videoDeviceConfig ? t.videoinput.videoDeviceConfig.source : c(t.videoinput) ? e.MEDIA_SOURCES.CAMERA : void 0, a._verifySourceValidity(o) })).then(().then(().then((function (e) { var t = e.data.stream; a._error = void 0, a._reenumerateDevices(r).then((function (o) { if (t) return a._deviceController.updateSelected(t, r), s({ stream: e, devices: o }); var c = a._deviceController._selected.videoinput, u = a._deviceController._selected.audioinput; if (!1 !== c || !1 !== u) { var l = n.MediaStreamNotFoundError(), p = n.composeEvent(l); return a._logger.error(i + JSON.stringify(l)), d(p) } })) })).catch((function (e) { var t = n.composeEvent(e); return a._logger.error(i + JSON.stringify(e)), d(t) })) })) }, l._addLocalMedia = function (e) { this._logger.verbose("_addLocalMedia(): " + s(e)); try { var t = new r(e) } catch (e) { var i = n.composeEvent(e); return this._logger.error("_addLocalMedia(): " + JSON.stringify(e)), Promise.reject(i) } var o = t.kind; return this._medias[o].push(t), Promise.resolve(t) }, l.addRemoteMedia = function (e) { this._logger.verbose("addRemoteMedia(" + e + ")"); try { var t = new r(e) } catch (e) { var i = n.composeEvent(e); return this._logger.error("addRemoteMedia(): " + JSON.stringify(e)), Promise.reject(i) } var o = t.kind; return this._medias[o].push(t), this._setupMedia(t) }, l.removeMedia = function (e) { this._logger.verbose("removeMedia(" + e + ")"); for (var t = this.getLocalMedias(), r = 0; r < t.length; r++) { var n = t[r]; n.stream.id === e && (n.unbind(), t.splice(r, 1)) } var i = this.getRemoteMedias(); for (r = 0; r < i.length; r++) { var o = i[r]; o.stream.id === e && (o.unbind(), i.splice(r, 1)) } }, l.removeRemoteMedias = function () { this._logger.verbose("removeRemoteMedias()"); for (var e = this._medias.remote, t = 0; t < e.length; t++) { e[t].unbind(), e.splice(t, 1) } if (0 == e.length) return Promise.resolve({ data: {} }); var r = n.MediaStreamNotRemovedError(); return this._logger.error("removeRemoteMedias(): " + JSON.stringify(r)), Promise.reject(r) }, l.removeLocalMedias = function () { this._logger.verbose("removeLocalMedias()"); for (var e = this._medias.local, t = 0; t < e.length; t++) { e[t].unbind(), e.splice(t, 1) } if (0 == e.length) return Promise.resolve({ data: { stream: null } }); var r = n.MediaStreamNotRemovedError(), i = n.composeEvent(r); return this._logger.error("removeLocalMedias(): " + JSON.stringify(r)), Promise.reject(i) }, l.getLocalMedias = function () { return this._logger.verbose("getLocalMedias()"), this._medias.local }, l.applyAudioConstraints = function (e) { var t = "applyAudioConstraints(): "; this._logger.verbose(t + s(e)); var r = u.getSupportedConstraints(), n = this.getLocalMedias()[0], i = {}, o = []; return Object.getOwnPropertyNames(e).forEach((function (t) { r[t] && !0 === r[t] ? i[t] = e[t] : o.push(t) })), 0 !== o.length && this._logger.warning(t + "constraint(s) not supported: " + JSON.stringify(o)), n.applyAudioConstraints(i) }, l.getRemoteMedias = function () { return this._logger.verbose("getRemoteMedias()"), this._medias.remote }, l.muteVideoTracks = function (e) { this._logger.verbose("muteVideoTracks(" + e + ")"), this._muteTracks("videoinput", e) }, l.muteAudioTracks = function (e) { this._logger.verbose("muteAudioTracks(" + e + ")"), this._muteTracks("audioinput", e) }, l.muteTracks = function (e) { this._logger.verbose("muteTracks(" + s(e) + ")"); var t = "muteTracks(): "; if (!a(e)) { var r = n.TypeNotValidError("config", "Object"); return this._logger.error(t + JSON.stringify(r)), Promise.reject(r) } if (void 0 === e.kind || "videoinput" !== e.kind && "audioinput" !== e.kind) { r = n.ValueNotValidError("config.kind", "video/audio"); return this._logger.error(t + JSON.stringify(r)), Promise.reject(r) } if (void 0 === e.mute || !c(e.mute)) { r = n.TypeNotValidError("config.mute", "Boolean"); return this._logger.error(t + JSON.stringify(r)), Promise.reject(r) } return this._muteTracks(e.kind, e.mute), Promise.resolve({ data: {} }) }, l._getMedia = function (t, r) { this._logger.verbose("_getMedia(" + t + ", " + s(r) + ")"); var n = this; return this._verifySourceValidity(t).then((function () { return n._getReadyForMedia() })).then((function () { return t === e.MEDIA_SOURCES.CAMERA ? n._getUserMedia(r) : t === e.MEDIA_SOURCES.SCREEN ? n._getDisplayMedia(r) : void 0 })).then((function (e) { return n._addLocalMedia(e) })).then(().catch((function (e) { var t = "_getMedia(): " + JSON.stringify(e); return n._logger.error(t), Promise.reject(e) })) }, l._getUserMedia = function (e) { this._logger.verbose("_getUserMedia(" + s(e) + ")"); var t = "_getUserMedia(): ", r = this; return this._verifyGetUserMediaExistence().then((function (t) { return t.getUserMedia(e) })).then((function (e) { return Promise.resolve({ stream: e, kind: "local" }) })).catch((function (e) { if (!e) { var i = n.ObjectNotExistError("error", "Error"); return r._logger.error(t + JSON.stringify(i)), Promise.reject(i) } if ("NanoError" === e.type) return r._logger.error(t + JSON.stringify(e)), Promise.reject(e); var o = !r._error || r._error && "OverconstrainedError" !== r._error.name; i = n.GetUserMediaError(e, o); return r._error = i, r._logger.error(t + JSON.stringify(i)), Promise.reject(i) })) }, l._getDisplayMedia = function (e) { this._logger.verbose("_getDisplayMedia(" + s(e) + ")"); var r = "_getDisplayMedia(): ", i = "Chrome" === t.browserInfo.browser, o = this; return this._verifyGetDisplayMediaExistence().then((function (t) { return t.getDisplayMedia({ video: e.video, audio: !i && e.audio }) })).then((function (t) { return i && e.audio ? o._getUserMedia({ video: !1, audio: e.audio }).then((function (e) { return o._addAudioToStream(e, t) })) : t })).then(().catch((function (e) { if (!e) { var t = n.ObjectNotExistError("error", "Error"); return o._logger.error(r + JSON.stringify(t)), Promise.reject(t) } if ("NanoError" === e.type) return o._logger.error(r + JSON.stringify(e)), Promise.reject(e); t = n.GetUserMediaError(e); return o._logger.error(r + JSON.stringify(t)), Promise.reject(t) })) }, l._getReadyForMedia = function () { this._logger.verbose("_getReadyForMedia()"); var e = this.getLocalMedias()[0]; return e && this.removeMedia(e.stream.id), Promise.resolve() }, l._setupMedia = function (e) { this._logger.verbose("_setupMedia(" + s(e) + ")"); var t = "_setupMedia(): ", r = this; return new Promise((function (i, o) { var s = e.getVideoTracks(), a = e.getAudioTracks(); if (!s && !a) { p = n.MediaStreamTrackError(); return r._logger.error(t + JSON.stringify(p)), o(p) } for (var c = [].concat(s).concat(a), d = !0, u = 0; u < c.length; u++) { var l = c[u]; if (l.readyState && (!d || "live" !== l.readyState)) { d = !1; var p = n.DeviceBlockedError(l.kind, l.label); return r._logger.error(t + JSON.stringify(p)), o(p) } } r._composeMetadata(e).then(().catch((function (e) { return r._logger.error(t + JSON.stringify(e)), o(e) })) })) }, l._muteTracks = function (e, t) { this._logger.verbose("_muteTracks(" + e + ", " + t + ")"); var r = this.getLocalMedias()[0]; r && r.muteTracks(e, t) }, l._composeMetadata = function (e) { this._logger.verbose("_composeMetadata(" + s(e) + ")"); var t = "_composeMetadata(): "; if (!e) { var r = n.ObjectNotExistError("media", "Media"); return this._logger.error(t + JSON.stringify(r)), Promise.reject(r) } var i = e.metadata; if (!i) { r = n.ObjectNotExistError("metadata", "Metadata"); return this._logger.error(t + JSON.stringify(r)), Promise.reject(r) } var o = e.hasVideoTracks() || e.metadata.hasVideo, a = e.hasAudioTracks() || e.metadata.hasAudio, c = e.getVideoTracksSettings(), d = e.getAudioTracksSettings(), u = c ? c.width : e.metadata.width, l = c ? c.height : e.metadata.height, p = c ? Object.prototype.hasOwnProperty.call(c, "frameRate") ? c.frameRate : Object.prototype.hasOwnProperty.call(c, "framerate") ? c.framerate : e.metadata.framerate : e.metadata.framerate; i.hasVideo = o, i.hasAudio = a, i.width = u, i.height = l, i.framerate = Math.round(p); var f = { audio: d || {}, video: c || {} }; return Promise.resolve({ data: { stream: e.stream, metadata: i, constraints: this._constraints, settings: f } }) }, l._addAudioToStream = function (e, t) { this._logger.verbose("_addAudioToStream(" + s(e) + ", " + s(t) + ")"); var r = "_addAudioToStream(): "; if (!e) { var i = n.ObjectNotExistError("audio", "MediaStream"); return this._logger.error(r + JSON.stringify(i)), Promise.reject(i) } if (!t) { i = n.ObjectNotExistError("streamInfo", "MediaStream"); return this._logger.error(r + JSON.stringify(i)), Promise.reject(i) } var o = e.stream.getAudioTracks()[0]; return t.addTrack(o), Promise.resolve(t) }, l._reenumerateDevices = function (e) { return this._logger.verbose("_reenumerateDevices(" + e + ")"), this._deviceController.shouldReenumerate(e) ? this._deviceController.enumerateDevices() : Promise.resolve() }, l._verifyDevicesExistence = function (e) { this._logger.verbose("_verifyDevicesExistence(" + s(e) + ")"); var t = "_verifyDevicesExistence(): "; if (!e) { var r = n.ObjectNotExistError("devices", "Array"); return this._logger.error(t + JSON.stringify(r)), Promise.reject(r) } if (!e.videoinput && !e.audioinput) { r = n.DevicesNotFoundError(); return this._logger.error(t + JSON.stringify(r)), Promise.reject(r) } return Promise.resolve() }, l._verifySourceValidity = function (r) { this._logger.verbose("_verifySourceValidity(" + r + ")"); if (t.enumContainsValue(e.MEDIA_SOURCES, r)) return Promise.resolve(); var i = n.EnumValueNotValidError(r, e.MEDIA_SOURCES); return this._logger.error("_verifySourceValidity(): " + JSON.stringify(i)), Promise.reject(i) }, l._verifyGetUserMediaExistence = function () { this._logger.verbose("_verifyGetUserMediaExistence()"); var e = navigator.mediaDevices; if (!e || !d(e.getUserMedia)) { var t = n.FunctionNotDefinedError("getUserMedia"); return this._logger.error("_verifyGetUserMediaExistence(): " + JSON.stringify(t)), Promise.reject(t) } return Promise.resolve(e) }, l._verifyGetDisplayMediaExistence = function () { this._logger.verbose("_verifyGetDisplayMediaExistence()"); var e = navigator.mediaDevices; if (!e || !d(e.getDisplayMedia)) { var t = n.FunctionNotDefinedError("getDisplayMedia"); return this._logger.error("_verifyGetDisplayMediaExistence(): " + JSON.stringify(t)), Promise.reject(t) } return Promise.resolve(e) }, l._onTrackEnded = function (e) { this._logger.verbose("_onTrackEnded(" + s(e) + ")"), this._logger.info("StreamTrackEnded"), this.emit("StreamTrackEnded", { track: e.target.kind, type: e.type, device: e.target.label }) }, u }.apply(t, n)) || (e.exports = i) },  function (e, t, r) { var n = r(10)(r(7), "Map"); e.exports = n },     function (e, t, r) { var n = r(61)(Object.getPrototypeOf, Object); e.exports = n },   function (e, t, r) { var n = r(4), i = r(1); e.exports = function (e) { return "symbol" == typeof e || i(e) && "[object Symbol]" == n(e) } },   function (e, t, r) { var n, i; n = [r(0), r(6)], void 0 === (i = function (e, t) { "use strict"; var r = e.getTime; return function (n, i, o, s) { this._globalPrefix = n, this._label = i, this._level = o, this._id = s, this.error = function (e) { this._log(e, t.LOG_LEVEL.ERROR) }, this.warning = function (e) { this._log(e, t.LOG_LEVEL.WARNING) }, this.info = function (e) { this._log(e, t.LOG_LEVEL.INFO) }, this.debug = function (e) { this._log(e, t.LOG_LEVEL.DEBUG) }, this.verbose =  this._log = function (n, i) { if (this._level >= i) switch (e.isObject(n) && (n = JSON.stringify(n, null, " ")), n = r() + ": [" + this._globalPrefix + "][" + this._label + "] - " + n, i) { case t.LOG_LEVEL.ERROR: console.error(n); break; case t.LOG_LEVEL.WARNING: console.warn(n); break; case t.LOG_LEVEL.INFO: console.info(n); break; case t.LOG_LEVEL.VERBOSE: console.log(n) } } } }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(88), r(48), r(5), r(3), r(0), r(2), r(49)], void 0 === (i = function (e, t, r, n, i, o, s) { "use strict"; var a = i.parseJSON, c = i.stringifyJSON, d = i.isFunction, u = i.isArray, l = i.isString, p = i.isEmpty, f = { offerToReceiveAudio: !0, offerToReceiveVideo: !0 }; function g(e, t) { r.call(this), this._logger = o.create("PeerConnectionClient", "console"), this._logger.verbose("PeerConnectionClient(" + c(e) + ", " + t + ")"); if (!u(e.peerConnectionConfig.iceServers) || 0 === e.peerConnectionConfig.iceServers.length) { this._logger.warning("PeerConnectionClient(): params.peerConnectionConfig.iceServers parameter is malformed, must be an array with at least one entry") } this._params = e, this._startTime = t, this._pc = null, this._hasRemoteSdp = !1, this._messageQueue = [], this._isInitiator = !1, this._started = !1, this._closedIceConnectionStateSent = !1, this._sentEndOfRemoteCandidates = !1, this._create() } var h = g.prototype = Object.create(r.prototype); return h.isStarted = function () { return this._started }, h.isInitiator = function () { return this._isInitiator }, h._create = function () { this._logger.verbose("_create()"); this.close(); try { this._pc = new RTCPeerConnection(this._params.peerConnectionConfig, this._params.peerConnectionConstraints), this._bind(), this._logger.verbose("_create(): PeerConnectionCreated") } catch (e) { this._onError("CreatePeerConnection", e) } }, h.close = function () { this._logger.verbose("close()"); var e = this; this._pc ? (this._pc.close(), setTimeout((function () { e._closedIceConnectionStateSent || e.emitSimple("IceConnectionStateChange", { state: "closed" }), e._reset(), e._logger.verbose("close(): Peer connection closed"), o.delete(e._logger) }), 500)) : this._logger.verbose("close(): No PeerConnection") }, h.addStream = function (e, t) { if (this._logger.verbose("addStream(" + c(e) + ")"), l(t) && "" !== t) { var r = e.getVideoTracks(); p(r) || (r[0].contentHint = t) } this._pc && this._pc.addStream(e) }, h.updateEncodingSettings = function (t, r) { this._logger.verbose("updateEncodingSettings(" + t + ", " + r + ")"); var n = "updateEncoderOptions(): ", i = this; e.setSenderBitrates(this._pc, { video: r || 0, audio: t || 0 }).then((function (e) { e ? i._logger.info(n + "Sucessfully set bitrates") : i._logger.info(n + "Could not set bitrates") })).catch((function (e) { i._logger.warning(n + "Could not set bitrates " + e) })) }, h.updateSenderVideoDegradationPreference = function (t) { this._logger.verbose("updateSenderVideoDegradationPreference(" + t + ")"); var r = "updateSenderVideoDegradationPreference(): ", n = this; e.setSenderVideoDegradationPreference(n._pc, t).then((function (e) { e ? n._logger.info(r + "Sucessfully set video degradation preference") : n._logger.info(r + "Could not set video degradation preference") })).catch((function (e) { n._logger.warning(r + "Could not set video degradation preference " + e) })) }, h.removeStream = function (e) { var t, r, n; if (this._logger.verbose("removeStream(" + c(e) + ")"), this._pc) if (d(this._pc.removeTrack) && d(this._pc.getSenders)) { var i = e.getTracks(), o = this._pc.getSenders(); for (t = 0, n = o.length; t < n; ++t)for (r = 0, n = i.length; r < n; ++r)o[t].track === i[r] && this._pc.removeTrack(o[t]) } else d(this._pc.removeStream) && this._pc.removeStream(e) }, h.startAsCaller = function (e) { this._logger.verbose("startAsCaller(" + c(e) + ")"); if (this._pc && !this._started) { this._isInitiator = !0, this._started = !0; var t = this._buildConstraints(e); this._logger.verbose("startAsCaller(): Sending offer to peer with constraints: \n'" + c(t)); var r = this; this._pc.createOffer(t).then((function (e) { return r._setLocalDescription(e) })).then((function (e) { r.emitSimple("SignalingMessage", e) })).catch((function (e) { r._logger.error("startAsCaller(): " + c(e)), r._onError("createOffer", e) })) } }, h.startAsCallee = function (e) { var t, r; if (this._logger.verbose("startAsCallee(" + c(e) + ")"), this._pc && !this._started) { if (this._isInitiator = !1, this._started = !0, e && e.length > 0) for (t = 0, r = e.length; t < r; t++)this.queueSignalingMessage(e[t]); this._messageQueue.length > 0 && this._drainMessageQueue() } }, h.queueSignalingMessage = function (e) { this._logger.verbose("queueSignalingMessage(" + c(e) + ")"); var t = a(e); t && (this._isInitiator && "answer" === t.type || !this._isInitiator && "offer" === t.type ? (this._hasRemoteSdp = !0, this._messageQueue.unshift(t)) : t.candidate ? this._messageQueue.push(t) : this._logger.error("queueSignalingMessage(): Unknown message: " + c(e))) }, h.setRemoteDescription = function (e) { this._logger.verbose("setRemoteDescription(" + c(e) + ")"); var t = this, r = t._adjustRemoteDescription(e); return t._pc.setRemoteDescription(new RTCSessionDescription(r)).then((function () { t._hasRemoteSdp = !0 })).then((function () { for (var e = 0, r = t._messageQueue.length; e < r; e++) { t.addIceCandidate(t._messageQueue[e]), "Microsoft Edge" === i.browserInfo.browser && setTimeout((, 3e3) } t._messageQueue = [] })).catch((function (e) { return t._onError(t, "setRemoteDescription"), t._logger.error("setRemoteDescription(): " + c(e)), Promise.reject(e) })) }, h.doAnswer = function () { this._logger.verbose("doAnswer()"); var e = this, t = this._buildConstraints(); return this._logger.verbose("doAnswer(): Sending answer to peer with constraints: " + c(t, null, " ")), this._pc.createAnswer(t).then((function (t) { return e._setLocalDescription(t) })).catch(() }, h.addIceCandidate = function (e) { this._logger.verbose("addIceCandidate(" + c(e) + ")"); var t, r, n = "addIceCandidate(): ", i = this; return this._hasRemoteSdp ? (e && "" !== e ? (t = a(e), r = new RTCIceCandidate({ sdpMLineIndex: t.sdpMLineIndex, sdpMid: t.sdpMid, candidate: t.candidate }), this._logger.verbose(n + "Adding ice candidate:" + c(r.toJSON()))) : (r = e, this._logger.verbose(n + "(Microsoft Edge only) Adding the end of remote candidates")), this._recordIceCandidate("Remote", r), this._pc.addIceCandidate(r).then((function () { i._logger.verbose(n + "MSG: Remote candidate added successfully") })).catch((function (e) { i._logger.error(n + c(e)) }))) : (this._messageQueue.push(e), this._logger.verbose(n + "Queueing candidate, not reveiced remote sdp, yet"), Promise.resolve()) }, h.getStats = function (e) { var t, r, i, o; if (this._logger.verbose("getStats(" + e + ")"), !this._pc) return Promise.reject(new Error("No PeerConnection")); if (e && "video" !== e && "audio" !== e) return Promise.reject(n.ValueNotValidError("kind", "video / audio")); if (d(this._pc.getSenders)) { var s = this._pc.getSenders().filter((function (t) { return !!(i = t.track) && (i.kind && i.kind === e) })); s && s.length && (t = s[0].track) } else (o = this._pc.getRemoteStreams()) && o.length && (r = "video" === e ? o[0].getVideoTracks() : "audio" === e ? o[0].getAudioTracks() : void 0).length && (t = r[0]); return this._pc.getStats(t) }, h._reset = function () { this._logger.verbose("_reset()"), this._unbind(), this._pc = null, this._hasRemoteSdp = !1, this._messageQueue = [], this._isInitiator = !1, this._started = !1 }, h._bind = function () { this._logger.verbose("_bind()"); this._pc ? (this._pc.onicecandidate = this._onIceCandidate.bind(this), this._pc.ontrack = this._onRemoteStreamAdded.bind(this), this._pc.onremovestream = this._onRemoteStreamRemoved.bind(this), this._pc.onsignalingstatechange = this._onSignalingStateChanged.bind(this), this._pc.oniceconnectionstatechange = this._onIceConnectionStateChanged.bind(this), this._pc.onnegotiationneeded = this._onNegotiationNeeded.bind(this)) : this._logger.error("_bind(): No PeerConnection") }, h._unbind = function () { this._logger.verbose("_unbind()"); this._pc ? (this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.onremovestream = null, this._pc.onsignalingstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc.onnegotiationneeded = null) : this._logger.warning("_unbind(): No PeerConnection") }, h._setLocalDescription = function (e) { this._logger.verbose("_setLocalDescription(" + c(e) + ")"); var t, r = "_setLocalDescription(): ", n = this; try { this._params.sdpPatches && !this._params.sdpPatches.preventReplaceSendReceive && (e.sdp = this._replaceSendReceive(e.sdp, this._params.send, this._params.receive)), e.sdp = maybePreferVideoReceiveCodec(e.sdp, this._params) } catch (e) { return this._logger.verbose(r + e), Promise.reject(e) } return this._pc.setLocalDescription(e).then((function () { return n._logger.verbose(r + "setLocalDescription success"), t = { sdp: e.sdp, type: e.type }, n._logger.verbose("description after setting: " + c(t)), t })).catch((function (e) { n._onError("_setLocalDescription", e) })) }, h._buildConstraints = function (e) { return this._logger.verbose("_buildConstraints(" + c(e) + ")"), mergeConstraints(e, f) }, h._adjustRemoteDescription = function (e) { return this._logger.verbose("_adjustRemoteDescription() - before adjusting: " + c(e)), e.sdp = maybePreferVideoReceiveCodec(e.sdp, this._params), e.sdp = maybePreferVideoSendCodec(e.sdp, this._params), this._params.encoding && ("cbp" === this._params.encoding.h264Profile ? e.sdp = this._forceBaseline(e.sdp) : "high" === this._params.encoding.h264Profile && (e.sdp = this._forceHigh(e.sdp))), this._params.videoSendBitrate && (e.sdp = maybeSetVideoSendBitRate(e.sdp, this._params)), this._params.videoSendInitialBitrate && (e.sdp = maybeSetVideoSendInitialBitRate(e.sdp, this._params)), this._logger.verbose("_adjustRemoteDescription() - after adjusting: " + c(e) + ")"), e }, h._drainMessageQueue = function () { var e, t; if (this._logger.verbose("_drainMessageQueue()"), this._pc && this._started && this._hasRemoteSdp) { for (e = 0, t = this._messageQueue.length; e < t; e++)this._processSignalingMessage(this._messageQueue[e]); this._messageQueue = [] } }, h._processSignalingMessage = function (e) { this._logger.verbose("_processSignalingMessage(" + c(e) + ")"); var t = "_processSignalingMessage(): "; if ("offer" !== e.type || this._isInitiator) if ("answer" === e.type && this._isInitiator) { if (this._logger.verbose(t + "Received answer"), "have-local-offer" !== this._pc.signalingState) { e = "MSG: ERROR: remote answer received in unexpected state: " + this._pc.signalingState; return void this._logger.verbose(t + e) } this._setRemoteSdp(e) } else if (e.candidate || "candidate" === e.type) { this._logger.verbose(t + "New ice candidate"); var r = new RTCIceCandidate({ sdpMLineIndex: e.sdpMLineIndex, sdpMid: e.sdpMid, candidate: e.candidate }); this._recordIceCandidate("Remote", r); var n = this; this._pc.addIceCandidate(r).then(().catch(() } else this._logger.warning(t + "Unexpected message: " + c(e)); else { if (this._logger.verbose(t + "Received offer"), "stable" !== this._pc.signalingState) { var e = "ERROR: remote offer received in unexpected state: " + this._pc.signalingState; return void this._logger.verbose(t + e) } this._setRemoteSdp(e), this.doAnswer() } }, h._onIceCandidate = function (e) { this._logger.verbose("_onIceCandidate(" + c(e) + ")"); var t = e.candidate; if (!t) return this._logger.verbose("_onIceCandidate(): End of candidates"), void this.emitSimple("EndOfLocalCandidates", {}); this._isValidIceCandidate(t) && (this.emitSimple("SignalingMessage", { sdpMLineIndex: t.sdpMLineIndex, sdpMid: t.sdpMid, candidate: t.candidate }), this._recordIceCandidate("Local", t)) }, h._isValidIceCandidate = function (e) { this._logger.verbose("_isValidIceCandidate(" + c(e) + ")"); var t = e.candidate; return -1 === t.indexOf("tcp") && ("relay" !== this._params.peerConnectionConfig.iceTransports || "relay" === iceCandidateType(t)) }, h._onSignalingStateChanged = function () { this._logger.verbose("_onSignalingStateChanged()"); if (!this._pc) return !1; this._logger.verbose("_onSignalingStateChanged(): Signaling state changed to: " + this._pc.signalingState), this.emitSimple("SignalingStateChanged", { state: this._pc.signalingState }) }, h._onIceConnectionStateChanged = function () { this._logger.verbose("_onIceConnectionStateChanged()"); var e = "_onIceConnectionStateChanged(): "; if (!this._pc) return !1; if ("completed" === this._pc.iceConnectionState) { var t = e + "ICE complete time: " + (window.performance.now() - this._startTime).toFixed(0) + "ms"; this._logger.verbose(t) } this._logger.verbose(e + "ICE connection state changed to: " + this._pc.iceConnectionState), this.emitSimple("IceConnectionStateChange", { state: this._pc.iceConnectionState }), "closed" === this._pc.iceConnectionState && (this._closedIceConnectionStateSent = !0) }, h._onNegotiationNeeded = function (e) { this._logger.verbose("_onNegotiationNeeded(" + c(e) + ")"); if (!this._pc) return !1; this._logger.verbose("_onNegotiationNeeded(): NegotiationNeeded Event"), this.emitSimple("NegotiationNeeded", e) }, h._recordIceCandidate = function (e, t) { this._logger.verbose("_recordIceCandidate(" + c(e) + ", " + c(t) + ")"); this._logger.verbose("_recordIceCandidate(): New ICE candidate for " + e), this.emitSimple("NewIceCandidate", { location: e, candidate: t }) }, h._onRemoteStreamAdded = function (e) { this._logger.verbose("_onRemoteStreamAdded(" + c(e) + ")"); this._logger.verbose("_onRemoteStreamAdded(): Remote stream added to peer connection"), this.emitSimple("RemoteStreamAdded", { stream: e.streams[0] }) }, h._onRemoteStreamRemoved = function (e) { this._logger.verbose("_onRemoteStreamRemoved(" + c(e) + ")"); this._logger.verbose("_onRemoteStreamRemoved(): Remote stream removed from peer connection"), this.emitSimple("RemoteStreamRemoved", { stream: e.stream }) }, h._onError = function (e, t) { this._logger.error("_onError(" + e + ", " + t.toString()), this.emitSimple("PeerConnectionError", { tag: e, error: t.toString() }) }, h._replaceSendReceive = function (e, t, r) { this._logger.verbose("_replaceSendReceive(" + c(e) + ", " + c(t) + ", " + c(r) + ")"); var n, i, o = ""; t && r ? o = "a=sendrecv" : t ? o = "a=sendonly" : r && (o = "a=recvonly"); var s, a = e.split("\r\n"); for (n = 0, i = a.length; n < i; n++)-1 === (s = a[n]).indexOf("a=sendrecv") && -1 === s.indexOf("a=sendonly") && -1 === s.indexOf("a=recvonly") || (a[n] = o); return a.join("\r\n") }, h._forceProfile = function (e, t, r) { var n, i, o = e.split("\r\n"), s = this; return o.forEach((function (e, a) { e.indexOf(";profile-level-id=") > -1 && 2 === (i = e.split(";profile-level-id=")).length && (n = i[1], t.includes(n) ? (s._logger.verbose("_forceProfile() : replacing profile: " + n + " with " + r), o[a] = e.split(n).join(r)) : s._logger.verbose("_forceProfile() : not replacing profile: " + n)) })), o.join("\r\n") }, h._forceBaseline = function (e) { return this._forceProfile(e, ["640032", "640c1f", "42001f", "4d0032", "42001f"], "42e01f") }, h._forceHigh = function (e) { return this._forceProfile(e, ["640032", "640c1f", "42001f", "4d0032", "42001f", "42e01f"], "640c1f") }, g }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(89)], void 0 === (i = function (e) { window.trace = function (e) { if ("\n" === e[e.length - 1] && (e = e.substring(0, e.length - 1)), window.performance) { var t = (window.performance.now() / 1e3).toFixed(3); console.log(t + ": " + e) } else console.log(e) } }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { e.exports = { 1: [ { "./adapter_factory.js": 2 }], 2: [function (e, t, r) { "use strict"; function n(e) { return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } Object.defineProperty(r, "__esModule", { value: !0 }), r.adapterFactory = function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, t = e.window, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : { shimChrome: !0, shimFirefox: !0, shimSafari: !0 }, n = i.log, u = i.detectBrowser(t), l = { browserDetails: u, commonShim: c, extractVersion: i.extractVersion, disableLog: i.disableLog, disableWarnings: i.disableWarnings, sdp: d }; switch (u.browser) { case "chrome": if (!o || !o.shimPeerConnection || !r.shimChrome) return n("Chrome shim is not included in this adapter release."), l; if (null === u.version) return n("Chrome shim can not determine version, not shimming."), l; n("adapter.js shimming chrome."), l.browserShim = o, c.shimAddIceCandidateNullOrEmpty(t, u), c.shimParameterlessSetLocalDescription(t, u), o.shimGetUserMedia(t, u), o.shimMediaStream(t, u), o.shimPeerConnection(t, u), o.shimOnTrack(t, u), o.shimAddTrackRemoveTrack(t, u), o.shimGetSendersWithDtmf(t, u), o.shimGetStats(t, u), o.shimSenderReceiverGetStats(t, u), o.fixNegotiationNeeded(t, u), c.shimRTCIceCandidate(t, u), c.shimRTCIceCandidateRelayProtocol(t, u), c.shimConnectionState(t, u), c.shimMaxMessageSize(t, u), c.shimSendThrowTypeError(t, u), c.removeExtmapAllowMixed(t, u); break; case "firefox": if (!s || !s.shimPeerConnection || !r.shimFirefox) return n("Firefox shim is not included in this adapter release."), l; n("adapter.js shimming firefox."), l.browserShim = s, c.shimAddIceCandidateNullOrEmpty(t, u), c.shimParameterlessSetLocalDescription(t, u), s.shimGetUserMedia(t, u), s.shimPeerConnection(t, u), s.shimOnTrack(t, u), s.shimRemoveStream(t, u), s.shimSenderGetStats(t, u), s.shimReceiverGetStats(t, u), s.shimRTCDataChannel(t, u), s.shimAddTransceiver(t, u), s.shimGetParameters(t, u), s.shimCreateOffer(t, u), s.shimCreateAnswer(t, u), c.shimRTCIceCandidate(t, u), c.shimConnectionState(t, u), c.shimMaxMessageSize(t, u), c.shimSendThrowTypeError(t, u); break; case "safari": if (!a || !r.shimSafari) return n("Safari shim is not included in this adapter release."), l; n("adapter.js shimming safari."), l.browserShim = a, c.shimAddIceCandidateNullOrEmpty(t, u), c.shimParameterlessSetLocalDescription(t, u), a.shimRTCIceServerUrls(t, u), a.shimCreateOfferLegacy(t, u), a.shimCallbacksAPI(t, u), a.shimLocalStreamsAPI(t, u), a.shimRemoteStreamsAPI(t, u), a.shimTrackEventTransceiver(t, u), a.shimGetUserMedia(t, u), a.shimAudioContext(t, u), c.shimRTCIceCandidate(t, u), c.shimRTCIceCandidateRelayProtocol(t, u), c.shimMaxMessageSize(t, u), c.shimSendThrowTypeError(t, u), c.removeExtmapAllowMixed(t, u); break; default: n("Unsupported browser!") }return l }; var i = l(e("./utils")), o = l(e("./chrome/chrome_shim")), s = l(e("./firefox/firefox_shim")), a = l(e("./safari/safari_shim")), c = l(e("./common_shim")), d = l(e("sdp")); function u(e) { if ("function" != typeof WeakMap) return null; var t = new WeakMap, r = new WeakMap; return (u = function (e) { return e ? r : t })(e) } }, { "./chrome/chrome_shim": 3, "./common_shim": 6, "./firefox/firefox_shim": 7, "./safari/safari_shim": 10, "./utils": 11, sdp: 12 }], 3: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.fixNegotiationNeeded =  r.shimAddTrackRemoveTrack = function (e, t) { if (e.RTCPeerConnection) { if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return d(e); var r = e.RTCPeerConnection.prototype.getLocalStreams; e.RTCPeerConnection.prototype.getLocalStreams =  var n = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream =  var i = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream =  e.RTCPeerConnection.prototype.addTrack =  ["createOffer", "createAnswer"].forEach((); var o = e.RTCPeerConnection.prototype.setLocalDescription; e.RTCPeerConnection.prototype.setLocalDescription =  var s = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription"); Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", { get: }), e.RTCPeerConnection.prototype.removeTrack = function (e) { var t, r = this; if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError"); if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError"); if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError"); this._streams = this._streams || {}, Object.keys(this._streams).forEach((), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded"))) } } function c(e, t) { var r = t.sdp; return Object.keys(e._reverseStreams || []).forEach((function (t) { var n = e._reverseStreams[t], i = e._streams[n.id]; r = r.replace(new RegExp(i.id, "g"), n.id) })), new RTCSessionDescription({ type: t.type, sdp: r }) } }, r.shimAddTrackRemoveTrackWithNative = d, Object.defineProperty(r, "shimGetDisplayMedia", { enumerable: !0, get: function () { return o.shimGetDisplayMedia } }), r.shimGetSendersWithDtmf = function (e) { if ("object" === c(e) && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) { var t =  if (!e.RTCPeerConnection.prototype.getSenders) { e.RTCPeerConnection.prototype.getSenders =  var r = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addTrack =  var n = e.RTCPeerConnection.prototype.removeTrack; e.RTCPeerConnection.prototype.removeTrack = } var i = e.RTCPeerConnection.prototype.addStream; e.RTCPeerConnection.prototype.addStream =  var o = e.RTCPeerConnection.prototype.removeStream; e.RTCPeerConnection.prototype.removeStream = } else if ("object" === c(e) && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) { var s = e.RTCPeerConnection.prototype.getSenders; e.RTCPeerConnection.prototype.getSenders = function () { var e = this, t = s.apply(this, []); return t.forEach((function (t) { return t._pc = e })), t }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", { get: }) } }, r.shimGetStats =  Object.defineProperty(r, "shimGetUserMedia", { enumerable: !0, get: function () { return i.shimGetUserMedia } }), r.shimMediaStream =  r.shimOnTrack = function (e) { if ("object" === c(e) && e.RTCPeerConnection && !("ontrack" in e.RTCPeerConnection.prototype)) { Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", { get: function () { return this._ontrack }, set:  enumerable: !0, configurable: !0 }); var t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = } else n.wrapPeerConnectionEvent(e, "track", () }, r.shimPeerConnection = function (e, t) { !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(() }, r.shimSenderReceiverGetStats = function (e) { if ("object" === c(e) && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver) { if (!("getStats" in e.RTCRtpSender.prototype)) { var t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = function () { var e = this, r = t.apply(this, []); return r.forEach((function (t) { return t._pc = e })), r }); var r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = function () { var e = r.apply(this, arguments); return e._pc = this, e }), e.RTCRtpSender.prototype.getStats = function () { var e = this; return this._pc.getStats().then((function (t) { return n.filterStats(t, e.track, !0) })) } } if (!("getStats" in e.RTCRtpReceiver.prototype)) { var i = e.RTCPeerConnection.prototype.getReceivers; i && (e.RTCPeerConnection.prototype.getReceivers = function () { var e = this, t = i.apply(this, []); return t.forEach((function (t) { return t._pc = e })), t }), n.wrapPeerConnectionEvent(e, "track", (function (e) { return e.receiver._pc = e.srcElement, e })), e.RTCRtpReceiver.prototype.getStats = } if ("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype) { var o = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = } } }; var n = function (e, t) { if (!t && e && e.__esModule) return e; if (null === e || "object" !== c(e) && "function" != typeof e) return { default: e }; var r = s(t); if (r && r.has(e)) return r.get(e); var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e) if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) { var a = i ? Object.getOwnPropertyDescriptor(e, o) : null; a && (a.get || a.set) ? Object.defineProperty(n, o, a) : n[o] = e[o] } return n.default = e, r && r.set(e, n), n }(e("../utils.js")), i = e("./getusermedia"), o = e("./getdisplaymedia"); function s(e) { if ("function" != typeof WeakMap) return null; var t = new WeakMap, r = new WeakMap; return (s = function (e) { return e ? r : t })(e) } function c(e) { return (c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } }, { "../utils.js": 11, "./getdisplaymedia": 4, "./getusermedia": 5 }], 4: [ {}], 5: [function (e, t, r) { "use strict"; function n(e) { if ("function" != typeof WeakMap) return null; var t = new WeakMap, r = new WeakMap; return (n = function (e) { return e ? r : t })(e) } function i(e) { return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } Object.defineProperty(r, "__esModule", { value: !0 }), r.shimGetUserMedia = function (e, t) { var r = e && e.navigator; if (r.mediaDevices) { var n = function (e) { if ("object" !== i(e) || e.mandatory || e.optional) return e; var t = {}; return Object.keys(e).forEach((), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t }, s = function (e, s) { if (t.version >= 61) return s(e); if ((e = JSON.parse(JSON.stringify(e))) && "object" === i(e.audio)) { var a = function (e, t, r) { t in e && !(r in e) && (e[r] = e[t], delete e[t]) }; a((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), a(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = n(e.audio) } if (e && "object" === i(e.video)) { var c = e.video.facingMode; c = c && ("object" === i(c) ? c : { ideal: c }); var d, u = t.version < 66; if (c && ("user" === c.exact || "environment" === c.exact || "user" === c.ideal || "environment" === c.ideal) && (!r.mediaDevices.getSupportedConstraints || !r.mediaDevices.getSupportedConstraints().facingMode || u) && (delete e.video.facingMode, "environment" === c.exact || "environment" === c.ideal ? d = ["back", "rear"] : "user" !== c.exact && "user" !== c.ideal || (d = ["front"]), d)) return r.mediaDevices.enumerateDevices().then((); e.video = n(e.video) } return o("chrome: " + JSON.stringify(e)), s(e) }, a =  if (r.getUserMedia = bind(r), r.mediaDevices.getUserMedia) { var c = r.mediaDevices.getUserMedia.bind(r.mediaDevices); r.mediaDevices.getUserMedia = } } }; var o = function (e, t) { if (!t && e && e.__esModule) return e; if (null === e || "object" !== i(e) && "function" != typeof e) return { default: e }; var r = n(t); if (r && r.has(e)) return r.get(e); var o = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var a in e) if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) { var c = s ? Object.getOwnPropertyDescriptor(e, a) : null; c && (c.get || c.set) ? Object.defineProperty(o, a, c) : o[a] = e[a] } return o.default = e, r && r.set(e, o), o }(e("../utils.js")).log }, { "../utils.js": 11 }], 6: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.removeExtmapAllowMixed = function (e, t) { if (e.RTCPeerConnection && !("chrome" === t.browser && t.version >= 71 || "safari" === t.browser && t.version >= 605)) { var r = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = } }, r.shimAddIceCandidateNullOrEmpty = function (e, t) { if (e.RTCPeerConnection && e.RTCPeerConnection.prototype) { var r = e.RTCPeerConnection.prototype.addIceCandidate; r && 0 !== r.length && (e.RTCPeerConnection.prototype.addIceCandidate =  } }, r.shimConnectionState =  r.shimMaxMessageSize = function (e, t) { if (e.RTCPeerConnection) { "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", { get: function () { return void 0 === this._sctp ? null : this._sctp } }); var r =  n =  o =  s =  a = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = function () { if (this._sctp = null, "chrome" === t.browser && t.version >= 76) { var e = this.getConfiguration(), i = e.sdpSemantics; "plan-b" === i && Object.defineProperty(this, "sctp", { get:  enumerable: !0, configurable: !0 }) } if (r(arguments[0])) { var c, d = n(arguments[0]), u = o(d), l = s(arguments[0], d); c = 0 === u && 0 === l ? Number.POSITIVE_INFINITY : 0 === u || 0 === l ? Math.max(u, l) : Math.min(u, l); var p = {}; Object.defineProperty(p, "maxMessageSize", { get: }), this._sctp = p } return a.apply(this, arguments) } } }, r.shimParameterlessSetLocalDescription = function (e, t) { if (e.RTCPeerConnection && e.RTCPeerConnection.prototype) { var r = e.RTCPeerConnection.prototype.setLocalDescription; r && 0 !== r.length && (e.RTCPeerConnection.prototype.setLocalDescription = function () { var e = this, t = arguments[0] || {}; if ("object" !== a(t) || t.type && t.sdp) return r.apply(this, arguments); if (!(t = { type: t.type, sdp: t.sdp }).type) switch (this.signalingState) { case "stable": case "have-local-offer": case "have-remote-pranswer": t.type = "offer"; break; default: t.type = "answer" }if (t.sdp || "offer" !== t.type && "answer" !== t.type) return r.apply(this, [t]); var n = "offer" === t.type ? this.createOffer : this.createAnswer; return n.apply(this).then(() }) } }, r.shimRTCIceCandidate = function (e) { if (!(!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype)) { var t = e.RTCIceCandidate; e.RTCIceCandidate = function (e) { if ("object" === a(e) && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substring(2)), e.candidate && e.candidate.length) { var r = new t(e), n = i.default.parseCandidate(e.candidate); for (var o in n) o in r || Object.defineProperty(r, o, { value: n[o] }); return r.toJSON =  r } return new t(e) }, e.RTCIceCandidate.prototype = t.prototype, o.wrapPeerConnectionEvent(e, "icecandidate", () } }, r.shimRTCIceCandidateRelayProtocol = function (e) { !e.RTCIceCandidate || e.RTCIceCandidate && "relayProtocol" in e.RTCIceCandidate.prototype || o.wrapPeerConnectionEvent(e, "icecandidate", (function (e) { if (e.candidate) { var t = i.default.parseCandidate(e.candidate.candidate); "relay" === t.type && (e.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[t.priority >> 24]) } return e })) }, r.shimSendThrowTypeError =  var n, i = (n = e("sdp")) && n.__esModule ? n : { default: n }, o = function (e, t) { if (!t && e && e.__esModule) return e; if (null === e || "object" !== a(e) && "function" != typeof e) return { default: e }; var r = s(t); if (r && r.has(e)) return r.get(e); var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e) if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) { var c = i ? Object.getOwnPropertyDescriptor(e, o) : null; c && (c.get || c.set) ? Object.defineProperty(n, o, c) : n[o] = e[o] } return n.default = e, r && r.set(e, n), n }(e("./utils")); function s(e) { if ("function" != typeof WeakMap) return null; var t = new WeakMap, r = new WeakMap; return (s = function (e) { return e ? r : t })(e) } function a(e) { return (a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } }, { "./utils": 11, sdp: 12 }], 7: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.shimAddTransceiver = function (e) { if ("object" === d(e) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.addTransceiver; t && (e.RTCPeerConnection.prototype.addTransceiver = function () { this.setParametersPromises = []; var e = arguments[1] && arguments[1].sendEncodings; void 0 === e && (e = []); var r = (e = a(e)).length > 0; r && e.forEach((); var n = t.apply(this, arguments); if (r) { var i = n.sender, o = i.getParameters(); (!("encodings" in o) || 1 === o.encodings.length && 0 === Object.keys(o.encodings[0]).length) && (o.encodings = e, i.sendEncodings = e, this.setParametersPromises.push(i.setParameters(o).then((function () { delete i.sendEncodings })).catch(())) } return n }) } }, r.shimCreateAnswer = function (e) { if ("object" === d(e) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.createAnswer; e.RTCPeerConnection.prototype.createAnswer = function () { var e = arguments, r = this; return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then((function () { return t.apply(r, e) })).finally((function () { r.setParametersPromises = [] })) : t.apply(this, arguments) } } }, r.shimCreateOffer = function (e) { if ("object" === d(e) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = } }, Object.defineProperty(r, "shimGetDisplayMedia", { enumerable: !0, get: function () { return o.shimGetDisplayMedia } }), r.shimGetParameters = function (e) { if ("object" === d(e) && e.RTCRtpSender) { var t = e.RTCRtpSender.prototype.getParameters; t && (e.RTCRtpSender.prototype.getParameters =  } }, Object.defineProperty(r, "shimGetUserMedia", { enumerable: !0, get: function () { return i.shimGetUserMedia } }), r.shimOnTrack = function (e) { "object" === d(e) && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get: function () { return { receiver: this.receiver } } }) }, r.shimPeerConnection = function (e, t) { if ("object" === d(e) && (e.RTCPeerConnection || e.mozRTCPeerConnection)) { !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach((function (t) { var r, n, i, o = e.RTCPeerConnection.prototype[t], s = (r = {}, i =  (n = function (e) { var t = function (e, t) { if ("object" !== d(e) || null === e) return e; var r = e[Symbol.toPrimitive]; if (void 0 !== r) { var n = r.call(e, t || "default"); if ("object" !== d(n)) return n; throw new TypeError("@@toPrimitive must return a primitive value.") } return ("string" === t ? String : Number)(e) }(e, "string"); return "symbol" === d(t) ? t : String(t) }(n = t)) in r ? Object.defineProperty(r, n, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : r[n] = i, r); e.RTCPeerConnection.prototype[t] = s[t] })); var r = { inboundrtp: "inbound-rtp", outboundrtp: "outbound-rtp", candidatepair: "candidate-pair", localcandidate: "local-candidate", remotecandidate: "remote-candidate" }, n = e.RTCPeerConnection.prototype.getStats; e.RTCPeerConnection.prototype.getStats = } }, r.shimRTCDataChannel =  r.shimReceiverGetStats = function (e) { if ("object" === d(e) && e.RTCPeerConnection && e.RTCRtpSender && (!e.RTCRtpSender || !("getStats" in e.RTCRtpReceiver.prototype))) { var t = e.RTCPeerConnection.prototype.getReceivers; t && (e.RTCPeerConnection.prototype.getReceivers = function () { var e = this, r = t.apply(this, []); return r.forEach((function (t) { return t._pc = e })), r }), n.wrapPeerConnectionEvent(e, "track", (), e.RTCRtpReceiver.prototype.getStats = } }, r.shimRemoveStream =  r.shimSenderGetStats = function (e) { if ("object" === d(e) && e.RTCPeerConnection && e.RTCRtpSender && (!e.RTCRtpSender || !("getStats" in e.RTCRtpSender.prototype))) { var t = e.RTCPeerConnection.prototype.getSenders; t && (e.RTCPeerConnection.prototype.getSenders = ; var r = e.RTCPeerConnection.prototype.addTrack; r && (e.RTCPeerConnection.prototype.addTrack = , e.RTCRtpSender.prototype.getStats = } }; var n = function (e, t) { if (!t && e && e.__esModule) return e; if (null === e || "object" !== d(e) && "function" != typeof e) return { default: e }; var r = s(t); if (r && r.has(e)) return r.get(e); var n = {}, i = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var o in e) if ("default" !== o && Object.prototype.hasOwnProperty.call(e, o)) { var a = i ? Object.getOwnPropertyDescriptor(e, o) : null; a && (a.get || a.set) ? Object.defineProperty(n, o, a) : n[o] = e[o] } return n.default = e, r && r.set(e, n), n }(e("../utils")), i = e("./getusermedia"), o = e("./getdisplaymedia"); function s(e) { if ("function" != typeof WeakMap) return null; var t = new WeakMap, r = new WeakMap; return (s = function (e) { return e ? r : t })(e) } function d(e) { return (d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } }, { "../utils": 11, "./getdisplaymedia": 8, "./getusermedia": 9 }], 8: [ {}], 9: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.shimGetUserMedia = function (e, t) { var r = e && e.navigator, i = e && e.MediaStreamTrack; if (r.getUserMedia =  !(t.version > 55 && "autoGainControl" in r.mediaDevices.getSupportedConstraints())) { var s =  a = r.mediaDevices.getUserMedia.bind(r.mediaDevices); if (r.mediaDevices.getUserMedia = function (e) { return "object" === o(e) && "object" === o(e.audio) && (e = JSON.parse(JSON.stringify(e)), s(e.audio, "autoGainControl", "mozAutoGainControl"), s(e.audio, "noiseSuppression", "mozNoiseSuppression")), a(e) }, i && i.prototype.getSettings) { var c = i.prototype.getSettings; i.prototype.getSettings = } if (i && i.prototype.applyConstraints) { var d = i.prototype.applyConstraints; i.prototype.applyConstraints = function (e) { return "audio" === this.kind && "object" === o(e) && (e = JSON.parse(JSON.stringify(e)), s(e, "autoGainControl", "mozAutoGainControl"), s(e, "noiseSuppression", "mozNoiseSuppression")), d.apply(this, [e]) } } } }; var n = function (e, t) { if (!t && e && e.__esModule) return e; if (null === e || "object" !== o(e) && "function" != typeof e) return { default: e }; var r = i(t); if (r && r.has(e)) return r.get(e); var n = {}, s = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var a in e) if ("default" !== a && Object.prototype.hasOwnProperty.call(e, a)) { var c = s ? Object.getOwnPropertyDescriptor(e, a) : null; c && (c.get || c.set) ? Object.defineProperty(n, a, c) : n[a] = e[a] } return n.default = e, r && r.set(e, n), n }(e("../utils")); function i(e) { if ("function" != typeof WeakMap) return null; var t = new WeakMap, r = new WeakMap; return (i = function (e) { return e ? r : t })(e) } function o(e) { return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } }, { "../utils": 11 }], 10: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.shimAudioContext = function (e) { "object" !== o(e) || e.AudioContext || (e.AudioContext = e.webkitAudioContext) }, r.shimCallbacksAPI = function (e) { if ("object" === o(e) && e.RTCPeerConnection) { var t = e.RTCPeerConnection.prototype, r = t.createOffer, n = t.createAnswer, i = t.setLocalDescription, s = t.setRemoteDescription, a = t.addIceCandidate; t.createOffer = function (e, t) { var n = arguments.length >= 2 ? arguments[2] : arguments[0], i = r.apply(this, [n]); return t ? (i.then(e, t), Promise.resolve()) : i }, t.createAnswer =  var c = function (e, t, r) { var n = i.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n }; t.setLocalDescription = c, c = function (e, t, r) { var n = s.apply(this, [e]); return r ? (n.then(t, r), Promise.resolve()) : n }, t.setRemoteDescription = c, c =  t.addIceCandidate = c } }, r.shimConstraints = s, r.shimCreateOfferLegacy = function (e) { var t = e.RTCPeerConnection.prototype.createOffer; e.RTCPeerConnection.prototype.createOffer = function (e) { if (e) { void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio); var r = this.getTransceivers().find((function (e) { return "audio" === e.receiver.track.kind })); !1 === e.offerToReceiveAudio && r ? "sendrecv" === r.direction ? r.setDirection ? r.setDirection("sendonly") : r.direction = "sendonly" : "recvonly" === r.direction && (r.setDirection ? r.setDirection("inactive") : r.direction = "inactive") : !0 !== e.offerToReceiveAudio || r || this.addTransceiver("audio", { direction: "recvonly" }), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo); var n = this.getTransceivers().find((); !1 === e.offerToReceiveVideo && n ? "sendrecv" === n.direction ? n.setDirection ? n.setDirection("sendonly") : n.direction = "sendonly" : "recvonly" === n.direction && (n.setDirection ? n.setDirection("inactive") : n.direction = "inactive") : !0 !== e.offerToReceiveVideo || n || this.addTransceiver("video", { direction: "recvonly" }) } return t.apply(this, arguments) } }, r.shimGetUserMedia =  r.shimLocalStreamsAPI = function (e) { if ("object" === o(e) && e.RTCPeerConnection) { if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = , !("addStream" in e.RTCPeerConnection.prototype)) { var t = e.RTCPeerConnection.prototype.addTrack; e.RTCPeerConnection.prototype.addStream =  e.RTCPeerConnection.prototype.addTrack = } "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream =  } }, r.shimRTCIceServerUrls = function (e) { if (e.RTCPeerConnection) { var t = e.RTCPeerConnection; e.RTCPeerConnection = function (e, r) { if (e && e.iceServers) { for (var i = [], o = 0; o < e.iceServers.length; o++) { var s = e.iceServers[o]; void 0 === s.urls && s.url ? (n.deprecated("RTCIceServer.url", "RTCIceServer.urls"), (s = JSON.parse(JSON.stringify(s))).urls = s.url, delete s.url, i.push(s)) : i.push(e.iceServers[o]) } e.iceServers = i } return new t(e, r) }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", { get: }) } }, r.shimRemoteStreamsAPI = function (e) { if ("object" === o(e) && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = , !("onaddstream" in e.RTCPeerConnection.prototype))) { Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", { get:  set: }); var t = e.RTCPeerConnection.prototype.setRemoteDescription; e.RTCPeerConnection.prototype.setRemoteDescription = } }, r.shimTrackEventTransceiver = function (e) { "object" === o(e) && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", { get: }) }; var n = e("../utils")); function o(e) { return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e })(e) } }, { "../utils": 11 }], 11: [function (e, t, r) { "use strict"; Object.defineProperty(r, "__esModule", { value: !0 }), r.compactObject = function e(t) { return a(t) ? Object.keys(t).reduce((function (r, i) { var o = a(t[i]), s = o ? e(t[i]) : t[i], c = o && !Object.keys(s).length; return void 0 === s || c ? r : Object.assign(r, {}, i, s)) }), {}) : t }, r.deprecated =  r.detectBrowser = function (e) { var t = { browser: null, version: null }; if (void 0 === e || !e.navigator || !e.navigator.userAgent) return t.browser = "Not a browser.", t; var r = e.navigator; if (r.mozGetUserMedia) t.browser = "firefox", t.version = s(r.userAgent, /Firefox\/(\d+)\./, 1); else if (r.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection) t.browser = "chrome", t.version = s(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else { if (!e.RTCPeerConnection || !r.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t; t.browser = "safari", t.version = s(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype } return t }, r.disableLog = function (e) { return "boolean" != typeof e ? new Error("Argument type: " + n(e) + ". Please use a boolean.") : (i = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled") }, r.disableWarnings = function (e) { return "boolean" != typeof e ? new Error("Argument type: " + n(e) + ". Please use a boolean.") : (o = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled")) }, r.extractVersion = s, r.filterStats =  r.log =  r.walkStats = c, r.wrapPeerConnectionEvent = function (e, t, r) { if (e.RTCPeerConnection) { var n = e.RTCPeerConnection.prototype, i = n.addEventListener; n.addEventListener =  var o = n.removeEventListener; n.removeEventListener =  Object.defineProperty(n, "on" + t, { get:  set:  enumerable: !0, configurable: !0 }) } }; var i = !0, o = !0; }, {}], 12: [function (e, t, r) { "use strict"; var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? :  i = { generateIdentifier: }; i.localCName = i.generateIdentifier(), i.splitLines =  i.splitSections =  i.getDescription =  i.getMediaSections =  i.matchPrefix =  i.parseCandidate = function (e) { for (var t = void 0, r = { foundation: (t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "))[0], component: { 1: "rtp", 2: "rtcp" }[t[1]] || t[1], protocol: t[2].toLowerCase(), priority: parseInt(t[3], 10), ip: t[4], address: t[4], port: parseInt(t[5], 10), type: t[7] }, n = 8; n < t.length; n += 2)switch (t[n]) { case "raddr": r.relatedAddress = t[n + 1]; break; case "rport": r.relatedPort = parseInt(t[n + 1], 10); break; case "tcptype": r.tcpType = t[n + 1]; break; case "ufrag": r.ufrag = t[n + 1], r.usernameFragment = t[n + 1]; break; default: void 0 === r[t[n]] && (r[t[n]] = t[n + 1]) }return r }, i.writeCandidate =  i.parseIceOptions =  i.parseRtpMap =  i.writeRtpMap =  i.parseExtmap =  i.writeExtmap =  i.parseFmtp = function (e) { for (var t = {}, r = void 0, n = e.substring(e.indexOf(" ") + 1).split(";"), i = 0; i < n.length; i++)t[(r = n[i].trim().split("="))[0].trim()] = r[1]; return t }, i.writeFmtp = function (e) { var t = "", r = e.payloadType; if (void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) { var n = []; Object.keys(e.parameters).forEach((), t += "a=fmtp:" + r + " " + n.join(";") + "\r\n" } return t }, i.parseRtcpFb =  i.writeRtcpFb =  i.parseSsrcMedia =  i.parseSsrcGroup =  i.getMid =  i.parseFingerprint =  i.getDtlsParameters =  i.writeDtlsParameters =  i.parseCryptoLine =  i.writeCryptoLine =  i.parseCryptoKeyParams =  i.writeCryptoKeyParams =  i.getCryptoParameters =  i.getIceParameters =  i.writeIceParameters =  i.parseRtpParameters = function (e) { var t = { codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: [] }, r = i.splitLines(e)[0].split(" "); t.profile = r[2]; for (var n = 3; n < r.length; n++) { var o = r[n], s = i.matchPrefix(e, "a=rtpmap:" + o + " ")[0]; if (s) { var a = i.parseRtpMap(s), c = i.matchPrefix(e, "a=fmtp:" + o + " "); switch (a.parameters = c.length ? i.parseFmtp(c[0]) : {}, a.rtcpFeedback = i.matchPrefix(e, "a=rtcp-fb:" + o + " ").map(i.parseRtcpFb), t.codecs.push(a), a.name.toUpperCase()) { case "RED": case "ULPFEC": t.fecMechanisms.push(a.name.toUpperCase()) } } } i.matchPrefix(e, "a=extmap:").forEach((); var d = i.matchPrefix(e, "a=rtcp-fb:* ").map(i.parseRtcpFb); return t.codecs.forEach((function (e) { d.forEach((function (t) { e.rtcpFeedback.find(() || e.rtcpFeedback.push(t) })) })), t }, i.writeRtpDescription = function (e, t) { var r = ""; r += "m=" + e + " ", r += t.codecs.length > 0 ? "9" : "0", r += " " + (t.profile || "UDP/TLS/RTP/SAVPF") + " ", r += t.codecs.map(().join(" ") + "\r\n", r += "c=IN IP4 0.0.0.0\r\n", r += "a=rtcp:9 IN IP4 0.0.0.0\r\n", t.codecs.forEach((); var n = 0; return t.codecs.forEach((), n > 0 && (r += "a=maxptime:" + n + "\r\n"), t.headerExtensions && t.headerExtensions.forEach((), r }, i.parseRtpEncodingParameters = function (e) { var t = [], r = i.parseRtpParameters(e), n = -1 !== r.fecMechanisms.indexOf("RED"), o = -1 !== r.fecMechanisms.indexOf("ULPFEC"), s = i.matchPrefix(e, "a=ssrc:").map((function (e) { return i.parseSsrcMedia(e) })).filter((function (e) { return "cname" === e.attribute })), a = s.length > 0 && s[0].ssrc, c = void 0, d = i.matchPrefix(e, "a=ssrc-group:FID").map((); d.length > 0 && d[0].length > 1 && d[0][0] === a && (c = d[0][1]), r.codecs.forEach((), 0 === t.length && a && t.push({ ssrc: a }); var u = i.matchPrefix(e, "b="); return u.length && (u = 0 === u[0].indexOf("b=TIAS:") ? parseInt(u[0].substring(7), 10) : 0 === u[0].indexOf("b=AS:") ? 1e3 * parseInt(u[0].substring(5), 10) * .95 - 16e3 : void 0, t.forEach(()), t }, i.parseRtcpParameters =  i.writeRtcpParameters =  i.parseMsid = function (e) { var t = void 0, r = i.matchPrefix(e, "a=msid:"); if (1 === r.length) return { stream: (t = r[0].substring(7).split(" "))[0], track: t[1] }; var n = i.matchPrefix(e, "a=ssrc:").map(().filter((); return n.length > 0 ? { stream: (t = n[0].value.split(" "))[0], track: t[1] } : void 0 }, i.parseSctpDescription = function (e) { var t = i.parseMLine(e), r = i.matchPrefix(e, "a=max-message-size:"), n = void 0; r.length > 0 && (n = parseInt(r[0].substring(19), 10)), isNaN(n) && (n = 65536); var o = i.matchPrefix(e, "a=sctp-port:"); if (o.length > 0) return { port: parseInt(o[0].substring(12), 10), protocol: t.fmt, maxMessageSize: n }; var s = i.matchPrefix(e, "a=sctpmap:"); if (s.length > 0) { var a = s[0].substring(10).split(" "); return { port: parseInt(a[0], 10), protocol: a[1], maxMessageSize: n } } }, i.writeSctpDescription =  i.generateSessionId =  i.writeSessionBoilerplate =  i.getDirection =  i.getKind =  i.isRejected =  i.parseMLine =  i.parseOLine =  i.isValidSDP =  "object" === (void 0 === t ? "undefined" : n(t)) && (t.exports = i) }, {}] }, {}, [1])(1) }, function (e, t, r) { var n, i; n = [r(0), r(5), r(2)], void 0 === (i = function (e, t, r) { "use strict"; var n = e.stringifyJSON, i = e.isObject, o = e.isNumber, s = e.isBool; function a() { t.call(this), this._logger = r.create("RtcStats", "console"), this._logger.verbose("RtcStats()"), this.videoTimestampPrev = null, this.videoFramesPrev = null, this.videoBytesPrev = 0, this.audioTimestampPrev = null, this.audioBytesPrev = 0, this.firstReportTimestamp = 0, this.videoSsrcPrev = 0, this.frameWidthPrev = void 0, this.frameHeightPrev = void 0, this.resolutionChanged = void 0 } var c = a.prototype = Object.create(t.prototype); return a.logger = r.create("RtcStats", "console"), c.putReport = function (e, t, r) { this._logger.verbose("putReport(" + n(e) + ", " + t + ", " + r + ")"); var i = this._filterStats(e, t, r); this.emitSimple("ReceivedWebRTCStats", { results: i }) }, c._filterStats = function (e, t, r) { if (this._logger.verbose("_filterStats(" + n(e) + ", " + t + ")"), i(e)) { var a = this, c = {}; return e.forEach((function (n) { if ((!t || "video" === t) && ("track" === n.type && ("video" === n.kind || n.id && -1 !== n.id.indexOf("RTCMediaStreamTrack_sender") || s(n.remoteSource) && !1 === n.remoteSource) && (n.framesPerSecond && (c.framerate = Math.round(10 * n.framesPerSecond) / 10), n.frameWidth && (c.frameWidth = n.frameWidth, c.frameHeight = n.frameHeight, o(a.frameWidthPrev) && o(a.frameHeightPrev) ? a.frameWidthPrev !== n.frameWidth || a.frameHeightPrev !== n.frameHeight ? (a.resolutionChanged = 1, a.frameWidthPrev = n.frameWidth, a.frameHeightPrev = n.frameHeight) : a.resolutionChanged = 0 : (a.frameWidthPrev = n.frameWidth, a.frameHeightPrev = n.frameHeight, a.resolutionChanged = 0))), "outbound-rtp" === n.type && "video" === n.mediaType)) { if (n.codecId) if (m = e.get(n.codecId)) { var i = m.mimeType; c.videoCodec = i } else c.videoCodec = n.codecId; var d = n.timestamp; if (n.bytesSent) { var u = n.bytesSent; if (a.videoBytesPrev && a.videoTimestampPrev) { var l = 8 * (u - a.videoBytesPrev) / (d - a.videoTimestampPrev); c.videoBitrate = Math.round(l) } a.videoBytesPrev = u } if (n.framesEncoded && a.videoTimestampPrev) { if (a.videoFramesPrev) { var p = 1e3 * (n.framesEncoded - a.videoFramesPrev) / (d - a.videoTimestampPrev); c.framerate = Math.round(10 * p) / 10 } a.videoFramesPrev = n.framesEncoded } if (r) { if (c.extended = { nackCount: void 0, framesEncoded: void 0, keyFramesEncoded: void 0, totalEncodeTime: void 0, averageEncodeTime: void 0, encodeTimePercentage: void 0, idleTimePercentage: void 0, firCount: void 0, pliCount: void 0, resolutionChanged: void 0, priority: 0 }, c.extended.nackCount = n.nackCount, c.extended.framesEncoded = n.framesEncoded, c.extended.keyFramesEncoded = n.keyFramesEncoded, c.extended.totalEncodeTime = n.totalEncodeTime, o(n.totalEncodeTime) && o(n.framesEncoded)) { var f = n.totalEncodeTime / n.framesEncoded; c.extended.averageEncodeTime = Math.round(1e3 * f) / 1e3 } if (a.firstReportTimestamp && o(n.totalEncodeTime)) { var g = (d - a.firstReportTimestamp) / 1e3, h = 100 * n.totalEncodeTime / g, v = 100 - h; c.extended.encodeTimePercentage = Math.round(1e3 * h) / 1e3, c.extended.idleTimePercentage = Math.round(1e3 * v) / 1e3 } n.ssrc && a.videoSsrcPrev !== n.ssrc && (a.videoSsrcPrev = n.ssrc, a.firstReportTimestamp = n.timestamp), c.extended.firCount = n.firCount, c.extended.pliCount = n.pliCount, c.extended.resolutionChanged = a.resolutionChanged, 1 === a.resolutionChanged && (c.extended.priority = 1) } a.videoTimestampPrev = d } if ((!t || "audio" === t) && "outbound-rtp" === n.type && "audio" === n.mediaType) { var m; if (n.codecId) if (m = e.get(n.codecId)) { i = m.mimeType; c.audioCodec = i } else c.audioCodec = n.codecId; d = n.timestamp; if (n.bytesSent) { u = n.bytesSent; if (a.audioBytesPrev && a.audioTimestampPrev) { l = 8 * (u - a.audioBytesPrev) / (d - a.audioTimestampPrev); c.audioBitrate = Math.round(l) } a.audioBytesPrev = u } a.audioTimestampPrev = d } })), c } }, a }.apply(t, n)) || (e.exports = i) },                   function (e, t, r) { var n = r(158), i = r(14), o = r(15), s = o && o.isMap, a = s ? i(s) : n; e.exports = a },             function (e, t, r) { var n, i; n = [r(83), r(84), r(6), r(0), r(220), r(32)], void 0 === (i = function (e, t, r, n, i, o) { "use strict"; window.nanowebrtc = { user: e, userinternal: t, tools: n, const: r, audioprocess: i, version: o.webrtc.release_version, release_description: o.webrtc.release_description } }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(5), r(0), r(6)], void 0 === (i = function (e, t, r) { "use strict"; var n = t.parseJSON, i = t.stringifyJSON; function o() { e.call(this); var t = window.nanowebrtc.userinternal; this._rtcUser = new t; var n = this; r.EVENT_NAMES.webcast.forEach((function (e) { n._rtcUser.on(e, () })), r.EVENT_NAMES.chat.forEach((function (e) { n._rtcUser.on(e, () })), o.browserSupport = t.browserSupport } var s = o.prototype = Object.create(e.prototype); return o.browserSupport = { supportLevel: -1, supportText: "" }, o.checkSupport = function () { var e = window.nanowebrtc.userinternal; return o.browserSupport = e.checkSupport(), n(i(o.browserSupport)) }, s.signIn = function (e) { return this._rtcUser.signIn(e) }, s.signOut = function () { return this._rtcUser.signOut() }, s.isSignedIn = function () { return this._rtcUser.isSignedIn() }, s.setConfig = function (e) { return this._rtcUser.setConfig(e) }, s.setIceServers = function (e) { return this._rtcUser.setIceServers(e) }, s.checkServer = function (e) { return this._rtcUser.checkServer(e) }, s.enableStats = function (e, t) { return this._rtcUser.enableStats(e, t) }, s.startBroadcast = function (e) { return this._rtcUser.startBroadcast(e) }, s.stopBroadcast = function () { return this._rtcUser.stopBroadcast() }, s.sendMetaData =  s.enterRoom = function (e) { return this._rtcUser.enterRoom(e) }, s.leaveRoom = function () { return this._rtcUser.leaveRoom() }, s.invokeCall = function (e) { return this._rtcUser.invokeCall(e) }, s.hangUpCall = function (e) { return this._rtcUser.hangUpCall(e) }, s.answerCall = function (e) { return this._rtcUser.answerCall(e) }, s.declineCall = function (e) { return this._rtcUser.declineCall(e) }, s.addScreenCaptureExtension = function (e) { return this._rtcUser.addScreenCaptureExtension(e) }, s.isScreenCaptureAvailable = function () { return this._rtcUser.isScreenCaptureAvailable() }, s.getDevices = function () { return this._rtcUser.getDevices() }, s.setVideoDevice = function (e) { return this._rtcUser.setVideoDevice(e) }, s.setAudioDevice = function (e) { return this._rtcUser.setAudioDevice(e) }, s.getSelectedVideoDevice = function () { return this._rtcUser.getSelectedVideoDevice() }, s.getSelectedAudioDevice = function () { return this._rtcUser.getSelectedAudioDevice() }, s.getSelectedDevice = function (e) { return this._rtcUser.getSelectedDevice(e) }, s.startPreview = function (e) { return this._rtcUser.startPreview(e) }, s.stopPreview =  s.muteVideo = function (e) { return this._rtcUser.muteVideo(e) }, s.muteAudio = function (e) { return this._rtcUser.muteAudio(e) }, s.muteDevice = function (e) { return this._rtcUser.muteDevice(e) }, s.injectExternalMediaStream =  o }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(85), r(6), r(0), r(5), r(90), r(91), r(33), r(94), r(19), r(95), r(3), r(97), r(2), r(98)], void 0 === (i = function (e, t, n, i, o, s, a, c, d, u, l, p, f, g) { "use strict"; var h = r(100), v = n.getElement, m = n.stringifyJSON, _ = n.parseJSON, S = n.isObject, b = n.isArray, y = n.isString, C = n.isBool, E = n.isInt, P = n.isEmpty, w = { Chrome: { versions: { current: 86, minimal: 50 }, mobile: !0 }, Firefox: { versions: { current: 82, minimal: 42 }, mobile: !0 }, Opera: { versions: { current: 71, minimal: 40 }, mobile: !0 }, "Microsoft Edge": { versions: void 0, mobile: void 0 }, "Microsoft Edge Chromium": { versions: { current: 86, minimal: 80 }, mobile: !1 }, Safari: { versions: { current: 13, minimal: 11 }, mobile: !1 } }; function T() { i.call(this), this._logger = f.create("RtcUser", "console"), this._logger.verbose("RtcUser()"), this._userId = void 0, this._iceServers = [{ urls: ["stun:stun.l.google.com:19302"] }, { urls: ["stun:stun.nanocosmos.net:80"], username: "nano", credential: "nano" }], this._iceServersOverride = void 0, this._config = { codecs: { videoCodec: "H264" }, bitrates: { videoSendInitialBitrate: 0, videoSendBitrate: 0 }, sdpPatches: { preventReplaceSendReceive: !1 } }, this._streamProtected = !1, this._statsEnabled = !1, this._statsIntervalTime = 1e3, this._metricsEnabled = !1, this._broadcaster = void 0, this._isBroadcasting = !1, this._audioMixer = new o, this._session = void 0, this._deviceController = new s, this._mediaController = new a(this._deviceController), this._mediaController.on("StreamTrackEnded", this._onStreamTrackEnded.bind(this)), this._screenCaptureExtension = new c; var e = this._screenCaptureExtension.getScreenCaptureName(), t = this._deviceController.addScreenCaptureDevice(e); t.length > 0 && (t.updated = !0, this.emitSimple("ReceivedDeviceList", t)), T.checkSupport() } var R = T.prototype = Object.create(i.prototype); return T.browserSupport = { supportLevel: -1, supportText: "" }, T.logger = f.create("RtcUser", "console"), T.checkSupport = function () { T.logger.verbose("checkSupport()"); var e = n.browserInfo.browser, t = parseInt(n.browserInfo.browserVersion.split(".")[0], 10), r = n.browserInfo.mobile, i = n.getVersionText(e, t, r); T.logger.verbose("checkSupport(): " + i); var o = 1, s = w[e]; void 0 !== s && (void 0 !== s.versions && void 0 !== s.mobile ? (o = 0, t < s.versions.current && t >= s.versions.minimal && (o = 2), (t < s.versions.minimal || r && !1 === s.mobile) && (o = 3)) : o = 3); var a = n.getSupportText(e, t, r, o); return 1 === o && T.logger.error("checkSupport(): " + a), T.browserSupport.supportLevel = o, T.browserSupport.supportText = a, T.browserSupport }, R.signIn = function (e) { var t = "signIn(): ", r = h.cloneDeep(e); this._logger.verbose(t + m(r)); var n, i = this; if (S(r) || (n = l.TypeNotValidError("options", "Object")), this.isSignedIn() && (n = l.SignInError("Already signed in")), n) { l.addMetaData(n, this._getMetaData()), this._logger.error(t + m(n)); var o = l.composeEvent(n, "SignInError"); return this.emitSimple(o.name, o.data, n), this._sendMetrics(o), Promise.reject(n) } return r.userName && this._logger.warning(t + '"options.userName" parameter is deprecated and will be removed in the WebRTC-Client v.6'), r.room && (this._logger.warning(t + '"options.room" parameter is deprecated and will be removed in the WebRTC-Client v.6'), /_/.test(r.room) && (r.room = r.room.replace(/_/g, ""), this._logger.warning(t + '"options.room" parameter should not contain underscores (_)'))), r.serverUserName && this._logger.warning(t + '"options.serverUserName" parameter is deprecated and will be removed in the WebRTC-Client v.6'), r.serverPassword && this._logger.warning(t + '"options.serverPassword" parameter is deprecated and will be removed in the WebRTC-Client v.6'), p.isWebSocketUrl(r.server) || this._logger.warning(t + '"options.server" parameter is expected to be a String of format: "ws(s)://host[:port]/path[?query]". An error will be thrown on incorrect type/format starting from the WebRTC-Client v.6'), r.jwt && (p.isJWT(r.jwt) || this._logger.warning(t + '"options.jwt" parameter is expected to be a String of format: "Base64-encoded part.Base64-encoded part.Base64-encoded part". An error will be thrown on incorrect type/format starting from the WebRTC-Client v.6')), this._session = new d, this._session.on("SessionMessage", i._onSessionMessage.bind(i)), this._session.signIn(r).then((function (e) { if (e.data) { e.data.iceServers && (i._iceServers = e.data.iceServers), i._userId = e.data.userId; var r = JSON.parse(JSON.stringify(e)); return r.name = "SignInSuccess", delete r.data.iceServers, i._logger.info(t + r.name + ": " + m(r)), i.emitSimple(r.name, r.data), i._sendMetrics(r), r.data } })).catch((function (e) { i._session.removeAllListeners(), "NanoError" !== e.type && (e = e.error && e.error && "WebrtcServerError" === e.error.type ? l.mapServerError(e) : l.SignInError(e && (e.message || e.text))), l.addMetaData(e, i._getMetaData()), i._logger.error(t + m(e)); var r = l.composeEvent(e, "SignInError"); return i.emitSimple(r.name, r.data, r.error), i._sendMetrics(r), Promise.reject(e) })) }, R.signOut = function () { this._logger.verbose("signOut(): "); var e = this; if (!this.isSignedIn()) { var t = l.NotSignedInError(); l.addMetaData(t, this._getMetaData()), this._logger.error("signOut(): " + m(t)); var r = l.composeEvent(t, "SignOutError"); return this.emitSimple(r.name, r.data, t), void this._sendMetrics(r) } return this._session.signOut().then(().then((function () { e._session.removeAllListeners(), e._session = void 0; var t = { name: "SignOutSuccess", data: {} }; e.emitSimple(t.name, t.data), e._sendMetrics(t) })).catch((function (t) { "NanoError" !== t.type && (t = l.GeneralError("Failed to sign out")), l.addMetaData(t, e._getMetaData()), e._logger.error("signOut(): " + m(t)); var r = l.composeEvent(t, "SignOutError"); e.emitSimple(r.name, r.data, r.error), e._sendMetrics(r) })) }, R.isSignedIn = function () { return this._logger.verbose("isSignedIn()"), !!this._session && this._session.isSignedIn() }, R.setConfig = function (e) { var r, n = "setConfig(): ", i = h.cloneDeep(e); if (this._logger.verbose(n + m(i)), S(i)) { var o = {}; if (!r && S(i.metrics)) { var s = "" + i.metrics.accountId, a = "" + i.metrics.accountKey; if (s.length > 0 && a.length > 0) { o.graylog = { credentials: { accountId: s, accountKey: a } }; var c = JSON.parse(JSON.stringify(i.metrics)); delete c.accountId, delete c.accountKey; try { this._metricsController = new g(this, c), this._metricsEnabled = !0 } catch (r) { this._logger.error(n + m(r)), this._metricsEnabled = !1 } } } if (!r && p.isIntInRange(i.logLevel, t.LOG_LEVEL.DISABLED, t.LOG_LEVEL.VERBOSE) && (o.console = { level: i.logLevel }), r || P(o) || f.setConfig(o), !r && i.codecs && (y(i.codecs.videoCodec) ? this._config.codecs.videoCodec = i.codecs.videoCodec : void 0 !== i.codecs.videoCodec && (r = l.TypeNotValidError("config.bitrates.videoCodec", "String"))), !r && i.bitrates && (E(i.bitrates.videoSendInitialBitrate) ? (p.isIntInRange(i.bitrates.videoSendInitialBitrate, 0, 34e3) || this._logger.warning(n + '"config.bitrates.videoSendInitialBitrate" parameter is expected to be an Integer in range 0 - 34000 kbps. An error will be thrown on incorrect type/range starting from the WebRTC-Client v.6'), this._config.bitrates.videoSendInitialBitrate = i.bitrates.videoSendInitialBitrate) : void 0 !== i.bitrates.videoSendInitialBitrate && (r = l.TypeNotValidError("config.bitrates.videoSendInitialBitrate", "Number")), !r && E(i.bitrates.videoSendBitrate) ? (p.isIntInRange(i.bitrates.videoSendBitrate, 0, 34e3) || this._logger.warning(n + '"config.bitrates.videoSendBitrate" parameter is expected to be an Integer in range 0 - 34000 kbps. An error will be thrown on incorrect type/range starting from the WebRTC-Client v.6'), this._config.bitrates.videoSendBitrate = i.bitrates.videoSendBitrate) : r || void 0 === i.bitrates.videoSendBitrate || (r = l.TypeNotValidError("config.bitrates.videoSendBitrate", "Number")), !r && E(i.bitrates.audioSendBitrate) ? (p.isIntInRange(i.bitrates.audioSendBitrate, 0, 512) || this._logger.warning(n + '"config.bitrates.audioSendBitrate" parameter is expected to be an Integer in range 0 - 512 kbps. An error will be thrown on incorrect type/range starting from the WebRTC-Client v.6'), this._config.bitrates.audioSendBitrate = i.bitrates.audioSendBitrate) : r || void 0 === i.bitrates.audioSendBitrate || (r = l.TypeNotValidError("config.bitrates.audioSendBitrate", "Number"))), !r && i.sdpPatches && (C(i.sdpPatches.preventReplaceSendReceive) ? this._config.sdpPatches.preventReplaceSendReceive = i.sdpPatches.preventReplaceSendReceive : r = l.TypeNotValidError("config.sdpPatches.preventReplaceSendReceive", "Bool")), !r && i.iceServers && b(i.iceServers) && (this._config.iceServers = i.iceServers), r) { l.addMetaData(r, this._getMetaData()), this._logger.error(n + m(r)); d = l.composeEvent(r, "SetConfigError"); return this.emitSimple(d.name, d.data, d.error), void this._sendMetrics(d) } return Promise.resolve() } r = l.TypeNotValidError("config", "Object"), l.addMetaData(r, this._getMetaData()), this._logger.error(n + m(r)); var d = l.composeEvent(r, "SetConfigError"); this.emitSimple(d.name, d.data, d.error) }, R.setIceServers = function (e) { var t = h.cloneDeep(e); this._logger.verbose("setIceServers(" + m(t) + ")"), this._logger.warning('"setIceServers()" function is deprecated and will be removed in the WebRTC-Client v.6'), this._iceServersOverride = t }, R.checkServer = function (e) { var t = "checkServer(): "; this._logger.verbose(t); var r = this; return this.isSignedIn() ? this._session.status().then((function (e) { var t = _(e.data); r.emitSimple("ReceivedServerStats", { stats: t || { error: { message: "Could not parse response from server", code: -1, userinfo: null } } }) })).catch((function (e) { return "NanoError" !== e.type && (e = e.error && e.error && "WebrtcServerError" === e.error.type ? l.mapServerError(e) : l.GeneralError(t + "failed, error: " + e)), r._logger.error(t + m(e)), Promise.reject(e) })) : Promise.reject(l.NotSignedInError()) }, R.enableStats = function (e, t) { this._logger.verbose("enableStats(" + e + ", " + t + ")"); t < 1e3 && this._logger.warning('enableStats(): "interval" parameter is expected to be an Integer higher than or equal to 1 second. An error will be thrown on incorrect type/format starting from the WebRTC-Client v.6'), this._statsEnabled = void 0 === e || e, this._statsIntervalTime = t || 1e3 }, R.startBroadcast = function (t) { var r = "startBroadcast(): ", i = h.cloneDeep(t); this._logger.debug(r + m(i)); var o, s, a = this; a.isSignedIn() || (o = l.NotSignedInError()), S(i) || (o = l.TypeNotValidError("config", "Object")), this._broadcaster && (o = l.OperationNotAllowedError("startBroadcast()", "Already broadcasting.")); var c = this._mediaController.getLocalMedias()[0]; if (c || (o = l.OperationNotAllowedError("startBroadcast()", "No Local Media. No preview was started.")), o) return l.addMetaData(o, this._getMetaData()), this._logger.error(r + m(o)), s = l.composeEvent(o, "StartBroadcastError"), this.emitSimple(s.name, s.data, s.error), void this._sendMetrics(s); i.encoding && !P(i.encoding) && (p.isH264Profile(i.encoding.h264Profile) ? (("Chrome" !== n.browserInfo.browser || "Windows" !== n.browserInfo.os || "Chrome" === n.browserInfo.browser && n.browserInfo.mobile) && (delete i.encoding.h264Profile, this._logger.warning(r + '"config.encoding.h264Profile" parameter should be set in Chrome desktop for Windows only.')), this._config.encoding = i.encoding) : this._logger.warning(r + '"config.encoding.h264Profile" parameter is not a valid H264 codec profile.')), this._broadcaster = new e(this._userId, this._session), this._config.jwt = i.jwt, this._config.extended = this._metricsEnabled, this._broadcaster.setConfig(this._config); var d = this._iceServersOverride || this._config.iceServers || this._iceServers; this._broadcaster.setIceServers(d), this._broadcaster.enableStats(this._statsEnabled, this._statsIntervalTime), this._listenToBroadcaster(this._broadcaster); var u = c.stream; this._broadcaster.addStream(u), S(i.transcodingTargets) || (i.transcodingTargets = {}), P(i.transcodingTargets) || (p.isRtmpUrl(i.transcodingTargets.output) || this._logger.warning(r + '"config.transcodingTargets.output" parameter is expected to be a String of format: "rtmp(s)://host[:port]/application/[path]". An error will be thrown on incorrect type/format starting from the WebRTC-Client v.6'), i.transcodingTargets.audiobitrate && (p.isIntInRange(i.transcodingTargets.audiobitrate, 0, 512) || this._logger.warning(r + 'Starting from the WebRTC-Client v.6, the "config.transcodingTargets.audiobitrate" parameter will be expected to be an Integer in range 0 - 510 kbps.')), i.transcodingTargets.rtmpconnectinfo && (p.isObjectOfMaxDepth(i.transcodingTargets.rtmpconnectinfo, 1) || this._logger.warning(r + '"config.transcodingTargets.rtmpconnectinfo" parameter is expected to be a flat object (of max depth 1). An error will be thrown on incorrect type/format starting from the WebRTC-Client v.6'))), i.jwt && (p.isJWT(i.jwt) || this._logger.warning(r + '"options.jwt" parameter is expected to be a String of format: "Base64-encoded part.Base64-encoded part.Base64-encoded part". An error will be thrown on incorrect type/format starting from the WebRTC-Client v.6')); var f = c.metadata; i.transcodingTargets.videowidth = f.width, i.transcodingTargets.videoheight = f.height, this._deviceController.getDevice("videoinput").then((function (e) { return (!C(e) || C(e) && !0 === e) && (i.transcodingTargets.targetvideowidth = e.videoDeviceConfig.width && e.videoDeviceConfig.width.ideal || 0, i.transcodingTargets.targetvideoheight = e.videoDeviceConfig.height && e.videoDeviceConfig.height.ideal || 0, i.transcodingTargets.source = e.videoDeviceConfig.source || "", i.transcodingTargets.ismobile = n.browserInfo.mobile ? 1 : 0), a._broadcaster.setTranscodingSettings(i.transcodingTargets), a._broadcaster.start() })).then((function (e) { a._streamProtected = !0, a._logger.info(r + "StartBroadcastSuccess: stream name: " + u), e.name = "StartBroadcastSuccess", a.emitSimple(e.name, e.data), a._sendMetrics(e) })).catch((function (e) { a._isBroadcasting = !1, a._broadcaster.destroy(), a._broadcaster = void 0, a._streamProtected = a._chatRoom && !!a._chatRoom.getUsersCount() || !1, "NanoError" !== e.type && (e = e.error && e.error && "WebrtcServerError" === e.error.type ? l.mapServerError(e) : l.StartBroadcastError(e && (e.message || e.text))), l.addMetaData(e, a._getMetaData()), a._logger.error(r + m(e)), s = l.composeEvent(e, "StartBroadcastError"), a.emitSimple(s.name, s.data, s.error), a._sendMetrics(s) })) }, R.stopBroadcast = function () { this._logger.verbose("stopBroadcast()"); var e = "stopBroadcast(): ", t = this, r = t._broadcaster; if (this._broadcaster = void 0, r) r.stop().catch((function (r) { "NanoError" !== r.type && (r = r.error && r.error && "WebrtcServerError" === r.error.type ? l.mapServerError(r) : l.GeneralError("Failed to stop broadcast")), l.addMetaData(r, t._getMetaData()), t._logger.warning(e + m(r)); var n = l.composeEvent(r, "StopBroadcastError"); t._sendMetrics(n) })).then((function (r) { t._isBroadcasting = !1, t._streamProtected = t._chatRoom && !!t._chatRoom.getUsersCount() || !1, t._logger.info(e + "StopBroadcastSuccess"), r.name = "StopBroadcastSuccess", t.emitSimple(r.name, r.data), t._sendMetrics(r) })); else { var n = l.StopBroadcastError("No broadcast is running"); this._logger.error(e + m(n)); var i = l.composeEvent(n); this.emitSimple(i.name, i.data, i.error), this._sendMetrics(i) } }, R.sendMetaData = function (e, t) { var r = h.cloneDeep(t); this._logger.verbose("sendMetaData(" + e + ", " + m(r) + ")"); var n = "sendMetaData(): ", i = this; if (!y(e)) { var o = l.TypeNotValidError("handlerName", "String"); l.addMetaData(o, this._getMetaData()), this._logger.error(n + m(o)); var s = l.composeEvent(o, "Error"); return this.emitSimple(s.name, s.data, s.error), void this._sendMetrics(s) } if (p.isMetadataHandler(e) || this._logger.warning(n + '"handlerName" parameter is expected to be a String containg one of the following values: "onMetaData" or "onCuePoint". An error will be thrown on incorrect type/value starting from the WebRTC-Client v.6'), !S(r)) { o = l.TypeNotValidError("jsonValues", "Object"); l.addMetaData(o, this._getMetaData()), this._logger.error(n + m(o)); s = l.composeEvent(o, "Error"); return this.emitSimple(s.name, s.data, s.error), void this._sendMetrics(s) } if (p.isObjectOfMaxDepth(r, 6) || this._logger.warning(n + '"jsonValues" parameter is expected to be an Object of max depth 6. An error will be thrown on incorrect type/format starting from the WebRTC-Client v.6'), this._isBroadcasting) { this._channels.getBroadcaster().sendMetaData(e, r).catch((function (e) { "NanoError" !== e.type && (e = e.error && e.error && "WebrtcServerError" === e.error.type ? l.mapServerError(e) : l.GeneralError("Failed to send metadata")), l.addMetaData(e, i._getMetaData()), i._logger.error(n + m(e)); var t = l.composeEvent(e, "Error"); i.emitSimple(t.name, t.data, t.error), i._sendMetrics(t) })) } else { o = l.OperationNotAllowedError("sendMetaData()", "Not broadcasting"); l.addMetaData(o, i._getMetaData()), this._logger.error(n + m(o)); s = l.composeEvent(o, "Error"); this.emitSimple(s.name, s.data, s.error), this._sendMetrics(s) } }, R.enterRoom = function (e) { var t = h.cloneDeep(e); this._logger.verbose("enterRoom(" + m(t) + ")"); var r, n, i = this; if (!i.isSignedIn()) return r = l.NotSignedInError(), n = l.composeEvent(r, "EnterRoomError"), void this.emitSimple(n.name, n.data, n.error); if (i._chatRoom) return r = l.OperationNotAllowedError("enterRoom", "Already in room"), n = l.composeEvent(r, "EnterRoomError"), void this.emitSimple(n.name, n.data, n.error); if (!S(t)) return r = l.TypeNotValidError("roomOptions", "Object"), n = l.composeEvent(r, "EnterRoomError"), void i.emitSimple(n.name, n.data, n.error); if (!y(t.userName)) return r = l.TypeNotValidError("roomOptions.userName", "String"), n = l.composeEvent(r, "EnterRoomError"), void i.emitSimple(n.name, n.data, n.error); if (!y(t.room)) return r = l.TypeNotValidError("roomOptions.room", "String"), n = l.composeEvent(r, "EnterRoomError"), void i.emitSimple(n.name, n.data, n.error); t.userId = i._userId, i._chatRoom = new u(t, i._session, i._mediaController), i._chatRoom.setConfig(i._config); var o = i._iceServersOverride || i._iceServers; i._chatRoom.setIceServers(o), i._chatRoom.on("RoomUpdate", i._onRoomUpdate.bind(i)), i._chatRoom.on("RemoteStreamAdded", i._onRemoteStreamAdded.bind(this)), i._chatRoom.enter().then((function () { i._logger.info("enterRoom(): EnterRoomSuccess: user name: " + t.userName + ", room name: " + t.room), i.emitSimple("EnterRoomSuccess", {}) })).catch((function (e) { "NanoError" !== e.type && (e = l.GeneralError("Failed to enter room")); var t = l.composeEvent(e, "EnterRoomError"); i.emitSimple(t.name, t.data, t.error), i._chatRoom.removeEvent("RoomUpdate"), i._chatRoom = void 0 })) }, R.leaveRoom = function () { this._logger.verbose("leaveRoom()"); var e = this; if (e._chatRoom) e._chatRoom.removeEvent("RoomUpdate"), e._chatRoom.removeEvent("RemoteStreamAdded"), e._chatRoom.leave().then((function () { e._logger.info("leaveRoom(): LeaveRoomSuccess: user name:" + e._chatRoom._userName + ", room name: " + e._chatRoom._roomName), e.emitSimple("LeaveRoomSuccess", {}) })).catch((function (t) { "NanoError" !== t.type && (t = l.GeneralError("Failed to leave room")); var r = l.composeEvent(t, "LeaveRoomError"); e.emitSimple(r.name, r.data, r.error) })).then((function () { e._chatRoom = void 0 })); else { var t = l.ObjectNotExistError("_chatRoom", "String"), r = l.composeEvent(t, "LeaveRoomError"); e.emitSimple(r.name, r.data, r.error) } }, R.invokeCall = function (e) { this._logger.verbose("invokeCall(" + e + ")"); var t = this; if (t._chatRoom) if (y(e)) t._chatRoom.callUser(e).then((function () { t._logger.info("invokeCall(): Invoke call: remote user id: " + e), t._streamProtected = !0 })).catch((function (e) { t._streamProtected = !!t._chatRoom.getUsersCount() || t._isBroadcasting, "NanoError" !== e.type && (e = l.GeneralError("Failed to invoke call")); var r = l.composeEvent(e, "InvokeCall"); t.emitSimple(r.name, r.data, r.error) })); else { r = l.TypeNotValidError("remoteUserId", "String"), n = l.composeEvent(r, "InvokeCall"); t.emitSimple(n.name, n.data, n.error) } else { var r = l.ObjectNotExistError("_chatRoom", "String"), n = l.composeEvent(r, "InvokeCall"); t.emitSimple(n.name, n.data, n.error) } }, R.hangUpCall = function (e) { this._logger.verbose("hangUpCall(" + e + ")"); var t = this; if (t._chatRoom) if (y(e)) t._chatRoom.hangUpCall(e).then((function () { t._logger.info("hangUpCall(): Hang up call: remote user id: " + e), t._streamProtected = !!t._chatRoom.getUsersCount() || t._isBroadcasting })).catch((function (e) { t._streamProtected = !!t._chatRoom.getUsersCount() || t._isBroadcasting, "NanoError" !== e.type && (e = l.GeneralError("Failed to hang up call")); var r = l.composeEvent(e, "HangUpCall"); t.emitSimple(r.name, r.data, r.error) })); else { r = l.TypeNotValidError("remoteUserId", "String"), n = l.composeEvent(r, "HangUpCall"); t.emitSimple(n.name, n.data, n.error) } else { var r = l.ObjectNotExistError("_chatRoom", "String"), n = l.composeEvent(r, "HangUpCall"); t.emitSimple(n.name, n.data, n.error) } }, R.answerCall = function (e) { this._logger.verbose("answerCall(" + e + ")"); var t = this; if (t._chatRoom) if (y(e)) t._chatRoom.answerCall(e).then((function () { t._logger.info("answerCall(): Answer call: remote user id: " + e), t._streamProtected = !0 })).catch((function (e) { t._streamProtected = !!t._chatRoom.getUsersCount() || t._isBroadcasting, "NanoError" !== e.type && (e = l.GeneralError("Failed to answer call")), t._logger.error("answerCall(): " + m(e)); var r = l.composeEvent(e, "AnswerCall"); t.emitSimple(r.name, r.data, r.error) })); else { r = l.TypeNotValidError("remoteUserId", "String"), n = l.composeEvent(r, "AnswerCall"); t.emitSimple(n.name, n.data, n.error) } else { var r = l.ObjectNotExistError("_chatRoom", "String"), n = l.composeEvent(r, "AnswerCall"); t.emitSimple(n.name, n.data, n.error) } }, R.declineCall = function (e) { this._logger.verbose("declineCall(" + e + ")"); var t = this; if (t._chatRoom) if (y(e)) t._chatRoom.declineCall(e).then(().catch((function (e) { "NanoError" !== e.type && (e = l.GeneralError("Failed to decline call")), t._logger.error("declineCall(): " + m(e)); var r = l.composeEvent(e, "DeclineCall"); t.emitSimple(r.name, r.data, r.error) })); else { r = l.TypeNotValidError("remoteUserId", "String"), n = l.composeEvent(r, "DeclineCall"); t.emitSimple(n.name, n.data, n.error) } else { var r = l.ObjectNotExistError("_chatRoom", "String"), n = l.composeEvent(r, "DeclineCall"); t.emitSimple(n.name, n.data, n.error) } }, R.addScreenCaptureExtension = function (e) { this._logger.verbose("addScreenCaptureExtension(" + e + ")"); var t = n.browserInfo.browser, r = parseInt(n.browserInfo.browserVersion.split(".")[0], 10); if ("Chrome" === t && r < 72) { e = y(e) ? e : "nanoScreenCapture", this._screenCaptureExtension.addChromeExtension(e); var i = this._deviceController.addScreenCaptureDevice(e); i.length > 0 && (i.updated = !0, this.emitSimple("ReceivedDeviceList", i)) } else this._logger.warning("addScreenCaptureExtension(): Screen capture extension is only required for Chrome versions < 72") }, R.isScreenCaptureAvailable = function () { return this._logger.verbose("isScreenCaptureAvailable()"), !!this._screenCaptureExtension && this._screenCaptureExtension.isScreenCaptureAvailable() }, R.getDevices = function () { this._logger.verbose("getDevices()"), this._deviceController.enumerateDevices().then(this._getDevicesSuccess.bind(this)).catch(this._getDevicesError.bind(this)) }, R.setVideoDevice = function (e) { var t = h.cloneDeep(e); if (this._logger.verbose("setVideoDevice(" + m(t) + ")"), this._logger.warning('"setVideoDevice()" function is deprecated and will be removed in the WebRTC-Client v.6'), this._streamProtected) { var r = l.OperationNotAllowedError("setVideoDevice()", "Stream is already in use"), n = l.composeEvent(r, "SetVideoDeviceError"); this.emitSimple(n.name, n.data, n.error) } else t.kind = "videoinput", this._deviceController.setDevice(t) }, R.setAudioDevice = function (e) { var t = h.cloneDeep(e); if (this._logger.verbose("setAudioDevice(" + m(t) + ")"), this._logger.warning('"setAudioDevice()" function is deprecated and will be removed in the WebRTC-Client v.6'), this._streamProtected) { var r = l.OperationNotAllowedError("setAudioDevice()", "Stream is already in use"), n = l.composeEvent(r, "SetAudioDeviceError"); this.emitSimple(n.name, n.data, n.error) } else t.kind = "audioinput", this._deviceController.setDevice(t) }, R.getSelectedVideoDevice = function () { if (this._logger.verbose("getSelectedVideoDevice()"), this._logger.warning('"getSelectedVideoDevice()" function is deprecated and will be removed in the WebRTC-Client v.6'), this._streamProtected) { var e = l.OperationNotAllowedError("getSelectedVideoDevice()", "Stream is already in use"), t = l.composeEvent(e, "GetSelectedVideoDeviceError"); this.emitSimple(t.name, t.data, t.error) } else this._deviceController.getDevice("videoinput").then((function (e) { return e })).catch((function (e) { "NanoError" !== e.type && (e = l.GeneralError("Failed to get device")); var t = l.composeEvent(e, "GetSelectedVideoDeviceError"); self.emitSimple(t.name, t.data, t.error) })) }, R.getSelectedAudioDevice = function () { if (this._logger.verbose("getSelectedAudioDevice()"), this._logger.warning('"getSelectedAudioDevice()" function is deprecated and will be removed in the WebRTC-Client v.6'), this._streamProtected) { var e = l.OperationNotAllowedError("getSelectedAudioDevice()", "Stream is already in use"), t = l.composeEvent(e, "GetSelectedAudioDeviceError"); this.emitSimple(t.name, t.data, t.error) } else this._deviceController.getDevice("audioinput").then(().catch((function (e) { "NanoError" !== e.type && (e = l.GeneralError("Failed to get device")); var t = l.composeEvent(e, "GetSelectedAudioDeviceError"); self.emitSimple(t.name, t.data, t.error) })) }, R.getSelectedDevice = function (e) { var t = h.cloneDeep(e); this._logger.verbose("getSelectedDevice(" + m(t) + ")"); var r = "getSelectedDevice(): ", n = this; if (this._streamProtected) { var i = l.OperationNotAllowedError("getSelectedDevice()", "Stream is already in use"); this._logger.error(r + m(i)); var o = l.composeEvent(i, "GetSelectedDeviceError"); return this.emitSimple(o.name, o.data, o.error), void this._sendMetrics(o) } p.isDeviceKind(t.kind) || this._logger.warning(r + '"config.kind" parameter is expected to be a String containg one of the following values: "videoinput" or "audioinput". An error will be thrown on incorrect type/value starting from the WebRTC-Client v.6'), this._deviceController.getDevice(t.kind).then((function (e) { return n._logger.info(r + "Selected " + ("videoinput" === t.kind ? "video" : "audio") + " device: " + m(e)), e })).catch((function (e) { "NanoError" !== e.type && (e = l.GeneralError("Failed to get device")), n._logger.error(r + m(e)); var t = l.composeEvent(e, "GetSelectedDeviceError"); n.emitSimple(t.name, t.data, t.error), n._sendMetrics(t) })) }, R.startPreview = function (e) { var t = h.cloneDeep(e); this._logger.verbose("startPreview(" + m(t) + ")"); var r, n = "startPreview(): ", i = this; if (this._streamProtected && (r = l.OperationNotAllowedError("startPreview()", "Stream is already in use")), r || S(t) || (r = l.TypeNotValidError("config", "Object")), r || S(t.videoDeviceConfig) || (r = l.TypeNotValidError("config.videoDeviceConfig", "Object")), r || S(t.audioDeviceConfig) || (r = l.TypeNotValidError("config.audioDeviceConfig", "Object")), r || !t.audioDeviceConfig.autoGainControl || C(t.audioDeviceConfig.autoGainControl) || (r = l.TypeNotValidError("config.audioDeviceConfig.autoGainControl", "Bool")), r || !t.audioDeviceConfig.echoCancellation || C(t.audioDeviceConfig.echoCancellation) || (r = l.TypeNotValidError("config.audioDeviceConfig.echoCancellation", "Bool")), r || !t.audioDeviceConfig.noiseSuppression || C(t.audioDeviceConfig.noiseSuppression) || (r = l.TypeNotValidError("config.audioDeviceConfig.noiseSuppression", "Bool")), r) { l.addMetaData(r, this._getMetaData()), this._logger.error(n + m(r)); var o = l.composeEvent(r, "StartPreviewError"); return this.emitSimple(o.name, o.data, o.error), void this._sendMetrics(o) } p.isVideoSource(t.videoDeviceConfig.source) || this._logger.warning(n + '"config.videoDeviceConfig.source" parameter is expected to be a String containg one of the following values: "camera" or "screen". An error will be thrown on incorrect type/value starting from the WebRTC-Client v.6'), t.videoDeviceConfig.width && (p.isVideoWidth(t.videoDeviceConfig.width) || this._logger.warning(n + '"config.videoDeviceConfig.width" parameter is expected to be an Integer in range 320 - 3840(4K). An error will be thrown on incorrect type/range starting from the WebRTC-Client v.6')), t.videoDeviceConfig.height && (p.isVideoHeight(t.videoDeviceConfig.height) || this._logger.warning(n + '"config.videoDeviceConfig.height" parameter is expected to be an Integer in range 240 - 2160(4K). An error will be thrown on incorrect type/range starting from the WebRTC-Client v.6')), t.videoDeviceConfig.framerate && (p.isFramerate(t.videoDeviceConfig.framerate) || this._logger.warning(n + '"config.videoDeviceConfig.framerate" parameter is expected to be an Integer in range 0 - 60 fps. An error will be thrown on incorrect type/range starting from the WebRTC-Client v.6')), p.isDevice(t.videoDeviceConfig.device) || this._logger.warning(n + '"config.videoDeviceConfig.device" parameter is expected to be a Boolean or an Integer. An error will be thrown on incorrect type/value starting from the WebRTC-Client v.6'); var s = t.videoDeviceConfig; s.kind = "videoinput"; var a = t.audioDeviceConfig; a.kind = "audioinput"; var c = t.elementId, d = !!t.useWebView; this._deviceController.setDevice(s).then((function (e) { return i._logger.verbose(n + "Selected video device: " + m(e)), i._deviceController.setDevice(a) })).then((function (e) { return i._logger.verbose(n + "Selected audio device: " + m(e)), i._getStream(d, !1) })).then((function (e) { if (e && e.stream && e.stream.data && e.stream.data.stream) { var t = e.stream.data.stream; if (c) v(c).srcObject = t; i._logger.info(n + "StartPreviewSuccess: stream: " + m(e.stream)), e.name = "StartPreviewSuccess", e.data = e.stream.data, delete e.stream, i.emitSimple(e.name, e.data), i._sendMetrics(e), e.devices && (e.name = "ReceivedDeviceList", i.emitSimple(e.name, e.devices.data)) } })).catch((function (e) { "NanoError" !== e.type && (e = l.GeneralError("Failed to start preview")), i._logger.error(n + m(e)); var t = l.composeEvent(e, "StartPreviewError"); l.addMetaData(e, i._getMetaData()), i.emitSimple(t.name, t.data, t.error), i._sendMetrics(t) })) }, R.stopPreview = function () { this._logger.verbose("stopPreview()"); var e = this; if (this._streamProtected) { var t = l.OperationNotAllowedError("stopPreview()", "Stream is already in use"); l.addMetaData(t, this._getMetaData()); var r = l.composeEvent(t, "StopPreviewError"); return this.emitSimple(r.name, r.data, r.error), void this._sendMetrics(r) } this._mediaController.removeLocalMedias().then((function (t) { null === t.data.stream && (t.name = "StopPreviewSuccess", e.emitSimple(t.name, t.data), e._sendMetrics(t)) })).catch((function (t) { "NanoError" !== t.type && (t = l.GeneralError("Failed to stop preview")), l.addMetaData(t, e._getMetaData()), e._logger.error("stopPreview(): " + m(t)); var r = l.composeEvent(t, "StopPreviewError"); e.emitSimple(r.name, r.data, r.error), e._sendMetrics(r) })) }, R.muteVideo = function (e) { this._logger.verbose("muteVideo(" + e + ")"), this._logger.warning('"muteVideo()" function is deprecated and will be removed in the WebRTC-Client v.6'), this._mediaController.muteVideoTracks(e) }, R.muteAudio = function (e) { this._logger.verbose("muteAudio(" + e + ")"), this._logger.warning('"muteAudio()" function is deprecated and will be removed in the WebRTC-Client v.6'), this._mediaController.muteAudioTracks(e) }, R.muteDevice = function (e) { var t = h.cloneDeep(e); this._logger.verbose("muteDevice(" + m(t) + ")"); var r = this; this._mediaController.muteTracks(t).catch((function (e) { "NanoError" !== e.type && (e = l.GeneralError("Failed to mute")), l.addMetaData(e, r._getMetaData()), r._logger.error("muteDevice(): " + m(e)); var t = l.composeEvent(e, "MuteDeviceError"); r.emitSimple(t.name, t.data, t.error), r._sendMetrics(t) })) }, R.injectExternalMediaStream = function (e) { var t = h.cloneDeep(e); return this._logger.verbose("injectExternalMediaStream(" + m(t) + ")"), t && t.stream ? n.isArray(t.tracks) && t.tracks.length ? this._streamProtected ? Promise.reject(new Error("Cant inject, stream is already beeing used")) : -1 !== t.tracks.indexOf("audio") ? this._mixExternalAudio(t.stream) : Promise.reject(new Error('Mixing in tracks other than "audio" is not supported at the moment')) : Promise.reject(new Error("Parameter config.tracks must contain an array with track types to be replaced")) : Promise.reject(new Error("You need to provide a stream config object")) }, R._getMetaData = function () { var e = { isSignedIn: void 0, sessionId: void 0, server: void 0, streamname: void 0, output: void 0, hasAudio: !1, hasVideo: !1, isMobile: n.browserInfo.mobile, browser: n.browserInfo.browser, browserVersion: n.browserInfo.browserVersion, os: n.browserInfo.os }, t = this._session ? this._session.getInfo() : {}; e.isSignedIn = t && t.isSignedIn, e.sessionId = t && t.sessionId, e.server = t && t.server; var r = this._broadcaster ? this._broadcaster.getInfo() : {}; return e.streamname = r && r.streamname, e.output = r && r.output, e.hasAudio = r && r.hasAudio, e.hasVideo = r && r.hasVideo, Object.keys(e).forEach((), e }, R._listenToBroadcaster = function (e) { this._logger.verbose("_listenToBroadcaster()"), e.on("BroadcastStatus", this._onBroadcastStatus.bind(this)), e.on("ReceivedWebRTCStats", this._onReceivedWebRTCStats.bind(this)) }, R._getStream = function (e, t, r) { this._logger.verbose("_getStream(" + e + ", " + t + ", " + m(r) + ")"); var n = this, i = {}; return Promise.resolve().then(().then((function (e) { if (e && e.data) { if (!e.data.updated) return Promise.reject(r); n._getDevicesSuccess(e) } return n._deviceController.getDevice("videoinput") })).then((function (e) { return i.videoinput = e, n._deviceController.getDevice("audioinput") })).then((function (t) { return i.audioinput = t, n._mediaController.getMediaForDevices(i, e) })).catch((function (r) { return "OverconstrainedError" === r.name && r.userinfo && "deviceId" === r.userinfo.constraint && r.userinfo.retry && !t ? n._getStream(e, !0, r) : Promise.reject(r) })) }, R._mixExternalAudio = function (e) { if (this._logger.verbose("_mixExternalAudio(" + m(e) + ")"), !e) return Promise.reject(new Error("No external stream passed")); var t, r, n = this; return Promise.resolve(this._mediaController.getLocalMedias()[0]).then((function (e) { if (e && e[0]) return e[0]; throw new Error("No local stream") })).then((function (e) { if ((r = (t = e).getAudioTracks()).length > 0) return n._audioMixer.connect(t, 0); throw new Error("Local stream has no audio") })).then(().then(().then((function (e) { var n = r[0], i = e.getAudioTracks()[0]; t.removeTrack(n), t.addTrack(i) })).catch(() }, R._sendMetrics =  R._destroy = function () { this._logger.verbose("destroy()"); var e = this; e._broadcaster && (e._isBroadcasting = !1, e._broadcaster.stop().catch(().then((function () { e._broadcaster = void 0 }))), e._chatRoom && e._chatRoom.destroy().catch(().then(() }, R._onBroadcastStatus = function (e) { this._logger.verbose("_onBroadcastStatus(" + m(e) + ")"); var r, n = { name: "BroadcastStatus" }, i = e.failedReason; switch (e.data.state) { case t.BROADCAST_STATE.INITIALIZED: case t.BROADCAST_STATE.STARTED: case t.BROADCAST_STATE.SIGNALING: case t.BROADCAST_STATE.CONNECTED: case t.BROADCAST_STATE.RECONNECTING: case t.BROADCAST_STATE.STOPPED: n.data = e.data; break; case t.BROADCAST_STATE.BROADCASTING: n.data = e.data, this._isBroadcasting = !0; break; case t.BROADCAST_STATE.DISCONNECTED: n.name = "BroadcastError", r = i || "Broadcast disconnected for unknown reason", n.error = l.BroadcastError(r), this._isBroadcasting = !1, this._broadcaster.destroy(), this._broadcaster = void 0; break; case t.BROADCAST_STATE.FAILED: this._isBroadcasting ? (n.name = "BroadcastError", r = i || "Broadcast disconnected for unknown reason", n.error = l.BroadcastError(r)) : (n.name = "StartBroadcastError", r = i || "Broadcast could not start for unknown reason.", n.error = l.StartBroadcastError(r)), this._isBroadcasting = !1, this._broadcaster.destroy(), this._broadcaster = void 0 }n.error && l.addMetaData(n.error, this._getMetaData()), this.emitSimple(n.name, n.data, n.error), this._sendMetrics(n) }, R._onRemoteStreamAdded = function (e) { this._logger.verbose("_onRemoteStreamAdded(" + m(e) + ")"), e.data.stream && e.data.stream.id; for (var t = this._mediaController.getRemoteMedias(), r = 0; r < t.length; r++) { var n = t[r]; if (n.stream.id === e.data.stream) return void this.emitSimple("CallActive", { data: n }) } e.name = "RemoteStreamError", this.emitSimple(e.name, e) }, R._onReceivedWebRTCStats = function (e) { if (this._logger.verbose("_onReceivedWebRTCStats(" + m(e) + ")"), this._metricsController) { var t = JSON.parse(JSON.stringify(e)); this._metricsController.onEvent(t) } e.data && e.data.results && e.data.results.extended && !P(e.data.results.extended) && delete e.data.results.extended, this.emitSimple(e.name, e.data, e.error) }, R._onSessionMessage = function (e) { this._logger.verbose("_onSessionMessage(" + m(e) + ")"); var t, r; switch (e.type) { case "close": switch (e.error && e.error && "WebrtcServerError" === e.error.type && (t = l.mapServerError(e.error)), e.reason) { case "websocket_disconnect": this._isBroadcasting ? (t = l.BroadcastError("Broadcast disconnected, websocket connection closed"), r = l.composeEvent(t, "BroadcastError")) : (t = l.WebSocketError("Websocket connection closed"), r = l.composeEvent(t, "SignInError")); break; case "disconnect": t = t || l.BroadcastError("Broadcast disconnected for unknown reason"), r = l.composeEvent(t, "BroadcastError"); break; case "transcoder_sign_out": var n = "Broadcast disconnected, the transcoder has closed"; this._isBroadcasting ? (t = t || l.BroadcastError(n), r = l.composeEvent(t, "BroadcastError")) : (t = t || l.StartBroadcastError(n), r = l.composeEvent(t, "StartBroadcastError")) } }r && (this._destroy(), l.addMetaData(r.error, this._getMetaData()), this._logger.error("_onSessionMessage(): " + m(r.error)), this.emitSimple(r.name, r.data, r.error), this._sendMetrics(r)) }, R._onRoomUpdate = function (e) { switch (this._logger.verbose("_onRoomUpdate(" + m(e) + ")"), e.type) { case "room_update": this._streamProtected = !!this._chatRoom.getUsersCount() || this._isBroadcasting, this.emitSimple("PeerListUpdated", { data: e.data }); break; case "call_incoming": this.emitSimple("CallIncoming", { data: e.data }); break; case "call_declined": this._streamProtected = !!this._chatRoom.getUsersCount() || this._isBroadcasting, this.emitSimple("CallDeclined", { data: e.data }) } }, R._onStreamTrackEnded = function (e) { this._logger.verbose("_onStreamTrackEnded(" + m(e) + ")"), this.emitSimple("StreamTrackEnded", { data: e }) }, R._getDevicesSuccess = function (e) { this._logger.info("_getDevicesSuccess(" + m(e) + ")"), this.emitSimple("ReceivedDeviceList", e.data) }, R._getDevicesError = function (e) { this._logger.error("_getDevicesError(" + m(e) + ")"), this.emitSimple("GetDevicesError", e.data, e.error), this._sendMetrics(e) }, T }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(19), r(47), r(6), r(5), r(0), r(50), r(3), r(2)], void 0 === (i = function (e, t, r, n, i, o, s, a) { "use strict"; var c = i.isString, d = i.isIntString, u = i.stringifyJSON, l = i.isObject, p = i.isArray, f = i.isFunction, g = r.BROADCAST_STATE; function h(e, t) { if (n.call(this), this._logger = a.create("Broadcaster", "console"), this._logger.verbose("Broadcaster(" + e + ")"), d(e) || this._logger.error("Param userId must be an integer"), !t || !t || !f(t.signIn)) throw s.TypeNotValidError("session", "Session"); this._userId = e, this._remoteUserId = e, this._peerId = void 0, this._remotePeerId = void 0, this._remoteUserName = "webrtc2H264", this._pcClient = void 0, this._streams = [], this._transcodingSettings = { output: null, streamname: null, videobitrate: null, videowidth: null, videoheight: null, targetvideowidth: null, targetvideoheight: null, source: null, ismobile: null, audiobitrate: null, framerate: null, dropframes: null, h264passthrough: 1, icecast_audio: null, icecast_event_id: null, rtmpconnectinfo: null }, this._startTime = null, this._iceServers = [], this._config = {}, this._state = g.IDLE, this._disconnectStateTimeout = void 0, this._disconnectRecoverWaitMs = 5e3, this._sdpAnswerSent = !1, this._messageQueueRemote = [], this._messageQueueLocal = [], this._remoteStream = null, this._statsEnabled = !1, this._statsIntervalTime = 1e3, this._statsInterval = 0, this._rtcStats = null, this._session = t } var v = h.prototype = Object.create(n.prototype); return v.setIceServers =  v.setConfig = function (e) { this._config = e }, v.getState = function () { return this._state }, v.getPeerId = function () { return this._peerId }, v.setTranscodingSettings = function (e) { var t; for (t in e) Object.prototype.hasOwnProperty.call(this._transcodingSettings, t) && (this._transcodingSettings[t] = e[t]) }, v.start = function () { this._logger.verbose("start()"); var e, t = this; return this._session.startBroadcast(this._getBroadcastParameters()).then((function (r) { return t._peerId = r.peer_id, t._setState(g.INITIALIZED), e = "receiver_peer_" + t._peerId, t._session.on(e, t._onServerMessage.bind(t)), t._transcodingSettings.output || (t._transcodingSettings.output = r.output), t._transcodingSettings.streamname || (t._transcodingSettings.streamname = r.stream_name), Promise.resolve({ data: { output: t._transcodingSettings.output, streamname: t._transcodingSettings.streamname } }) })).catch(() }, v.stop = function () { this._logger.verbose("stop()"); var e = this; return e._stopCollectRtcStats(), e._peerId && e._remotePeerId ? e._session.isSignedIn() ? this._session.stopBroadcast({ sender_peer: this._peerId, receiver_peer: this._remotePeerId }).then((function () { var t = "receiver_peer_" + e._peerId; return e._session.removeEvent(t), t = "receiver_peer_" + e._remotePeerId, e._session.removeEvent(t), e.destroy(), e._logger.verbose("stop(): Broadcast stopped"), Promise.resolve({ data: { output: e._transcodingSettings.output, streamname: e._transcodingSettings.streamname } }) })).catch((function (t) { return e._logger.error("stop(): " + t), e._logger.verbose("stop(): Broadcast stopped"), e.destroy(), Promise.reject(t) })) : (e.destroy(), Promise.resolve()) : Promise.reject(s.StopBroadcastError("Not connected to any peer")) }, v.addStream = function (e) { this._logger.verbose("addStream()"); e ? 2 !== this._streams.length ? p(e) ? this._streams = e : this._streams.push(e) : this._logger.warning("addStream(): [_peerId: r " + this._peerId + "] Stream count is already = 2, we only support 2 streams/Broadcaster") : this._logger.error("addStream(): [_peerId: " + this._peerId + '] Parameter "stream" must not be undefined') }, v.sendMetaData = function (e, t) { this._logger.verbose("sendMetaData()"); if (this.getState() === g.BROADCASTING) { this._logger.verbose("sendMetaData(): [_peerId: " + this._peerId + "] Sending metaData: " + e + " - " + u(t)); var r = { eventType: "metaData", eventName: e, strLabel: this._streams[0].id, payload: t }, n = { sender_peer: this._peerId, receiver_peer: this._remotePeerId, data: r }; return this._session.sendMetaData(n) } var i = "[_peerId: " + this._peerId + "] Tried to send metaData but Broadcaster is not in active state"; return this._logger.error(i), Promise.reject(i) }, v.enableStats = function (e, t) { this._logger.verbose("enableStats()"), this._statsEnabled = void 0 === e || e, this._statsIntervalTime = t || 1e3, this._rtcStats = null, this._statsEnabled && (this._rtcStats = new o, this._rtcStats.on("ReceivedWebRTCStats", this._reemit.bind(this))) }, v.destroy = function () { this._logger.verbose("destroy()"), this._unbind(), this._closePCClient(), this._messageQueueRemote = [], this._messageQueueLocal = [], this._sdpAnswerSent = !1, this._setState(g.STOPPED), a.delete(this._logger) }, v.getInfo = function () { return { output: this._transcodingSettings.output || void 0, streamname: this._transcodingSettings.streamname || void 0, hasAudio: this._streams[0] && this._streams[0].getAudioTracks().length > 0, hasVideo: this._streams[0] && this._streams[0].getVideoTracks().length > 0 } }, v._getBroadcastParameters = function () { this._logger.verbose("_getBroadcastParameters()"); var e, t = {}; for (e in t.peer = this._peerId, this._transcodingSettings) { var r = this._transcodingSettings[e]; null !== r && ((l(r) || c(r)) && (r = u(r)), t[e.toString()] = r.toString()) } return t.jwt = this._config.jwt, t.stream_label = this._streams[0] && this._streams[0].id ? this._streams[0].id : "", t.stream_label2 = this._streams[1] && this._streams[1].id ? this._streams[1].id : "", t.videocodec = this._config.codecs.videoCodec ? this._config.codecs.videoCodec : "H264", t.audio = this._streams[0].getAudioTracks().length > 0 ? "1" : "0", t.video = this._streams[0].getVideoTracks().length > 0 ? "1" : "0", t }, v._onServerMessage = function (e) { this._logger.verbose("_onServerMessage()"); var t = "_onServerMessage(): ", r = this; switch (e.type) { case "transcoder_message": if ("started" === e.state) r._pcClient ? r._logger.error(t + "We should not have a pcClient at this moment") : (r._createPCClient(), r._pcClient.startAsCallee(r._messageQueueRemote), r._setState(g.STARTED)); else if ("disconnected" === e.state) { r._setState(g.DISCONNECTED), r._logger.verbose(t + "Disconnected"); var n = r._addEventPayload({}, "The transcoder has disconnected."); return void r.emit("BroadcastStatus", n) } break; case "sdp_message": if (!e.sender_peer) return void r._logger.error(t + "Received sdp_message, but message has no sender_peer"); r._remotePeerId = e.sender_peer, r._pcClient && r._pcClient.isStarted() ? r._pcClient.setRemoteDescription(e.data.sdp).catch((function (e) { return r._logger.error(t + "setRemoteDescription failed: " + e), Promise.reject(e) })).then(().catch((function (e) { return r._logger.error(t + "doAnswer failed:" + e), Promise.reject(e) })).then((function (e) { r._logger.verbose(t + "doAnswer succeded: " + u(e)); var n = {}; return n.sender_peer = r._peerId, n.receiver_peer = r._remotePeerId, n.data = e, r.emitSimple("SDPAnswer", n), r._session.sendSignalingMessage(n).then(().catch((function (e) { r._logger.error(t + "sendSignalingMessage (answer) failed: " + e) })) })).catch((function (e) { r._logger.error(t + "sendSignalingMessage failed: " + e) })) : r._messageQueueRemote.push(e.data.sdp); break; case "ice_candidate": r._pcClient && r._pcClient.isStarted() ? r._pcClient.addIceCandidate(e.data.candidate) : r._messageQueueRemote.push(e.data.candidate); break; case "rtmp_status": var i = void 0; r._logger.verbose(t + "Received rtmp status: " + u(e.data)), e.data && "status" === e.data.status && ("connected" === e.data.message ? r._setState(g.BROADCASTING) : "reconnecting" === e.data.message && r._setState(g.RECONNECTING)), e.data && "error" === e.data.status && 4711 === e.data.number && (i = "RTMP connect failed on server side", r._setState(g.FAILED)); n = r._addEventPayload({ data: e.data }, i); r.emit("BroadcastStatus", n); break; case "server_error": r._setState(g.FAILED), r._logger.error(t + "Server error: " + e.error); break; default: r._logger.warning(t + "received unknown message:" + e) } }, v._addEventPayload = function (e, t) { return (e = e || {}).data = e.data || {}, e.data.streamname = this._transcodingSettings.streamname, e.data.state = this._state, t && (e.failedReason = t), e.data.message = i.getKeyByValue(g, this._state).toLowerCase(), e.data.text = e.data.message, e }, v._reemit = function (e) { e = this._addEventPayload(e), this.emit(e.name, e) }, v._collectRtcStats = function () { this._logger.verbose("_collectRtcStats()"); var e = this, t = e._config.extended; clearInterval(e._statsInterval), this._statsInterval = setInterval((function () { if (e._pcClient) { var r = void 0, n = e._getBroadcastParameters(); if ("1" === n.video && "0" === n.audio) r = "video"; else if ("0" === n.video && "1" === n.audio) r = "audio"; else if ("0" === n.video && "0" === n.audio) return void e._logger.error('_collectRtcStatsAttempts to show stats for "no video" and "no audio" stream'); e._pcClient.getStats(r).then((function (n) { e._rtcStats || (e._rtcStats = new o), e._rtcStats.putReport(n, r, t) })).catch((function (t) { e._logger.error("_collectRtcStats[_peerId: " + e._peerId + "] " + t) })) } else clearInterval(e._statsInterval) }), this._statsIntervalTime) }, v._stopCollectRtcStats = function () { this._logger.verbose("_stopCollectRtcStats()"); this._statsInterval && (this._logger.verbose("_stopCollectRtcStats(): Stopping rtc stats collection"), this._rtcStats.removeEvent("ReceivedWebRTCStats"), clearInterval(this._statsInterval), this._rtcStats = null) }, v._getPeerConnectionConfig = function () { this._logger.verbose("_getPeerConnectionConfig()"); var e = { iceServers: this._iceServers, iceTransports: "all" }, t = { optional: [], mandatory: [] }; return t.optional.push({ googCpuOveruseDetection: !1 }), t.optional.push({ RtpDataChannels: !1 }), { mediaConstraints: { audio: !0, video: !0 }, sdpPatches: this._config.sdpPatches, encoding: this._config.encoding, peerConnectionConfig: e, peerConnectionConstraints: t, send: 0 !== this._streams.length, receive: !1, audioSendBitrate: this._config.bitrates.audioSendBitrate || 0, videoSendCodec: this._config.codecs.videoCodec || "H264", videoRecvCodec: this._config.codecs.videoCodec || "H264", videoSendBitrate: this._config.bitrates.videoSendBitrate || 0, videoSendInitialBitrate: this._config.bitrates.videoSendInitialBitrate || 0 } }, v._createPCClient = function () { this._logger.verbose("_createPCClient()"); var e = "_createPCClient(): "; if (this._pcClient) this._logger.verbose(e + "[_peerId:  " + this._peerId + "] PeerConnection still alive, do not create!"); else try { if (this._pcClient = new t(this._getPeerConnectionConfig(), this._startTime), "object" == typeof callstats && callstats && callstats.fabricUsage) { try { var r = callstats.fabricUsage.multiplex, n = this._remoteUserName, i = this._remoteUserName + "_" + this._peerId + "_" + this._userId + "__" + this._remotePeerId + "_" + this._remoteUserId; callstats.addNewFabric(this._pcClient._pc, n, r, i, (function (t, r) { this._logger.verbose(e + "Callstats Monitoring status: " + t + " msg: " + r) })) } catch (t) { this._logger.warning(e + "Error in callstats") } } this._bind(); for (var o = 0; o < this._streams.length; o++)this._pcClient.addStream(this._streams[o], "detail"); this._logger.verbose(e + "Created PeerConnectionClient") } catch (t) { this._logger.error(e + "[_peerId: " + this._peerId + "] Create PeerConnection exception: " + t.message), this.emitSimple("CreatePeerConnectionClientError") } }, v._bind = function () { this._logger.verbose("_bind()"), this._pcClient.on("SignalingMessage", this._onSignalingMessage.bind(this)), this._pcClient.on("RemoteStreamRemoved", this._onRemoteStreamRemoved.bind(this)), this._pcClient.on("RemoteStreamAdded", this._onRemoteStreamAdded.bind(this)), this._pcClient.on("IceConnectionStateChange", this._onIceConnectionStateChange.bind(this)), this._pcClient.on("EndOfLocalCandidates", this._onEndOfLocalCandidates.bind(this)), this._pcClient.on("NegotiationNeeded", this._onNegotiationNeeded.bind(this)) }, v._unbind = function () { this._logger.verbose("_unbind()"), this._pcClient && (this._pcClient.off("SignalingMessage", this._onSignalingMessage.bind(this)), this._pcClient.off("RemoteStreamRemoved", this._onRemoteStreamRemoved.bind(this)), this._pcClient.off("RemoteStreamAdded", this._onRemoteStreamAdded.bind(this)), this._pcClient.off("IceConnectionStateChange", this._onIceConnectionStateChange.bind(this)), this._pcClient.off("EndOfLocalCandidates", this._onEndOfLocalCandidates.bind(this)), this._pcClient.off("NegotiationNeeded", this._onNegotiationNeeded.bind(this))) }, v._setState = function (e) { if (e !== this._state) { var t = this._state; this._state = e, this._logger.verbose("_setState(): State: " + i.getKeyByValue(g, t) + " -> " + i.getKeyByValue(g, this._state)) } }, v._onIceConnectionStateChange = function (e) { this._logger.verbose("_onIceConnectionStateChange(" + u(e) + ")"); var t = void 0; switch (e.data.state) { case "new": case "checking": this._setState(g.SIGNALING); break; case "connected": if (clearTimeout(this._disconnectStateTimeout), this.getState() === g.BROADCASTING) return; case "completed": if (this.getState() === g.CONNECTED) return; if (this._setState(g.CONNECTED), this._statsEnabled && this._pcClient && this._collectRtcStats(), this._config && this._config.bitrates) "Microsoft Edge" !== i.browserInfo.browser ? this._pcClient.updateEncodingSettings(this._config.bitrates.audioSendBitrate || 0, this._config.bitrates.videoSendBitrate || 0) : this._logger.warning("Setting bitrate is not supported in Microsoft Edge"); this._pcClient.updateSenderVideoDegradationPreference("maintain-resolution"); break; case "failed": this._setState(g.FAILED), t = "IceConnectionState changed to failed", this._statsEnabled && this._pcClient && this._stopCollectRtcStats(); break; case "disconnected": return this._logger.warning("_onIceConnectionStateChange(): Ice connection disconnected"), void (this._disconnectStateTimeout = setTimeout(bind(this), this._disconnectRecoverWaitMs)); case "closed": this._setState(g.STOPPED) }e = this._addEventPayload(e, t), this.emit("BroadcastStatus", e) }, v._disconnectTimeoutHandler = function () { this._setState(g.DISCONNECTED); var e = this._addEventPayload({}, "broadcast ice connection disconnected and did not recover"); this.emit("BroadcastStatus", e) }, v._onNegotiationNeeded = function (e) { this._logger.verbose("NegotiationNeeded event has been fired") }, v._onEndOfLocalCandidates =  v._onRemoteStreamAdded = function (e) { this._logger.verbose("_onRemoteStreamAdded()"), this._remoteStream = e.data.stream }, v._onRemoteStreamRemoved =  v._closePCClient = function () { this._logger.verbose("_closePCClient()"); if (this._pcClient) { var e, t, r = this._streams; for (e = 0, t = r.length; e < t; ++e)try { this._pcClient.removeStream(r[e]) } catch (e) { this._logger.error("_closePCClient(): [_peerId: " + this._peerId + "] Could not remove stream from peerconnectionclient") } this._pcClient.close(), this._pcClient = null } }, v._sendMessageToPeer = function (e) { this._logger.verbose("_sendMessageToPeer()"); var t = "_sendMessageToPeer(): ", r = this, n = {}, i = void 0; return this._remotePeerId && c(this._remotePeerId) || (i = this._remotePeerId ? s.TypeNotValidError("_remotePeerId", "String") : s.ObjectNotExistError("_remotePeerId", "String")), this._peerId && c(this._peerId) || (i = this._peerId ? s.TypeNotValidError("_peerId", "String") : s.ObjectNotExistError("_peerId", "String")), l(e) || (i = s.TypeNotValidError("message", "Object")), i ? (this._logger.error(t + u(i)), Promise.reject(i)) : (n.sender_peer = this._peerId, n.receiver_peer = this._remotePeerId, n.data = e, n.data && "" === n.data.candidate ? Promise.resolve() : this._session.sendSignalingMessage(n).catch((function (e) { return r._logger.error(t + u(e)), Promise.reject(e) }))) }, v._onSignalingMessage = function (e) { this._logger.verbose("_onSignalingMessage - " + u(e.data)); var t = "_onSignalingMessage(): ", r = this; if (this._remotePeerId) { if (this._sdpAnswerSent && this._messageQueueLocal.length > 0) for (this._logger.debug(t + "answer sent, sending enqueued messages, count: " + this._messageQueueLocal.length); this._messageQueueLocal.length > 0;) { var n = this._messageQueueLocal.shift(); n && this._sendMessageToPeer(n).catch((function (e) { r._logger.error(t + u(e)) })) } if (!this._sdpAnswerSent) return this._logger.debug(t + "answer not sent yet, enqueueing message."), void this._messageQueueLocal.push(e.data); this._sendMessageToPeer(e.data).then((function () { })).catch((function (e) { r._logger.error(t + u(e)) })) } else this._logger.error(t + "Trying to send message, but no remote peer set! This should not happen!") }, h }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(5), r(0), r(3), r(2)], void 0 === (i = function (e, t, r, n) { "use strict"; var i = t.isString, o = t.stringifyJSON, s = t.isObject, a = t.isInt, c = t.isFunction, d = 0, u = { IDLE: 1, CONNECTED: 2, CLOSED: 3 }; function l() { this._websocket = void 0, this._url = void 0, this._callback = void 0, this._state = u.IDLE, this._resolvers = {}, this._logger = n.create("WebsocketClient", "console") } var p = l.prototype; return p.connect = function (e, t) { if (this._logger.verbose("connect()"), !i(e)) return Promise.reject(r.TypeNotValidError("url", "String")); if (!c(t)) return Promise.reject(r.TypeNotValidError("callback", "Function")); if (this._state !== u.IDLE && this._state !== u.CLOSED) return Promise.reject(r.WrongStateError("Can not connect websocket, already connected.")); this._url = e, this._callback = t; var n = this; try { this._websocket = new WebSocket(this._url) } catch (e) { return Promise.reject(r.CreateWebSocketError("Creating websocket failed", this._url)) } return this._websocket.onclose = function (e) { n._onClose(e) }, this._websocket.onmessage = function (e) { n._onMessage(e) }, this._websocket.onerror = function (e) { n._onError(e) }, this._websocket.onopen =  this._createResolver("connect") }, p.close = function () { var e; return this._logger.verbose("close()"), this._websocket ? (e = this._createResolver("close"), this._websocket.close(), this._setState(u.CLOSED), this._websocket = void 0) : e = Promise.reject(r.WebSocketError("No websocket", this._url)), e }, p.sendMessage = function (e, t) { if (this._logger.verbose("sendMessage(" + e + ", " + o(t) + ")"), !i(e)) return Promise.reject(r.TypeNotValidError("type", "String")); if (!s(t)) return Promise.reject(r.TypeNotValidError("message", "Object")); if (!this._websocket || this._websocket.readyState > 1) return Promise.reject(r.WebSocketError("Sending message failed", this._url)); var n = d++, a = this._createResolver(n); return this._websocket.send(o({ type: e, message: t, message_id: n })), a }, p._setState = function (e) { this._logger.verbose("_setState(" + e + ")"); if (e !== this._state) { var r = this._state; this._state = e; var n = "_setState(): State: " + t.getKeyByValue(u, r) + " -> " + t.getKeyByValue(u, this._state); this._logger.verbose(n) } }, p._onOpen = function (e) { this._logger.verbose("_onOpen(" + o(e) + ")"), this._setState(u.CONNECTED), this._resolve("connect", { event: e }) }, p._onClose = function (e) { this._logger.verbose("_onClose(" + o(e) + ")"), this._setState(u.CLOSED), this._resolve("close", { type: e.type, code: e.code }) }, p._onMessage = function (e) { this._logger.verbose("_onMessage(" + o(e.data) + ")"); var t, r; if (e && e.data) { try { t = JSON.parse(e.data) } catch (e) { return void this._logger.error("_onMessage(): " + o(e)) } r = t.message_id, this._resolve(r, t) } else this._logger.error('_onMessage(): event has no "data" property') }, p._onError = function (e) { this._logger.error("_onError(" + o(e) + ")"), this._resolve("connect", { event: e }) }, p._createResolver = function (e) { if (this._logger.verbose("_createResolver(" + e + ")"), !a(e) && !i(e)) return Promise.reject("resolver error" + e); var t, r, n = new Promise((); return this._resolvers[e] = { resolve: t, reject: r }, n }, p._resolve = function (e, t) { this._logger.verbose("_resolve(" + e + ", " + o(t) + ")"); var n = "_resolve(): ", i = this._resolvers[e]; if (i) { if (this._logger.verbose(n + "Message id: " + e), delete this._resolvers[e], t && t.event && "error" === t.event.type && "connect" === e) return i.reject(r.WebSocketError("Could not connect to server, please check server url", this._url)); t.error ? (this._logger.verbose(n + "Rejecting id: " + e), i.reject(t.error)) : (this._logger.verbose(n + "Resolving id: " + e), i.resolve(t)) } else this._logger.verbose(n + "Passive message"), this._callback(t) }, l }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(0), r(46)], void 0 === (i = function (e, t) { "use strict"; var r = e.stringifyJSON, n = e.isString; return function (e, i, o, s, a, c) { this._globalPrefix = e, this._level = i, this._url = o, this._credentials = { accountId: s, accountKey: a }, this._id = c, this._logger = new t(e, "GrayLogger", i), this._logger.verbose("GrayLogger(" + e + ", " + i + ", " + o + ")"); var d = 0, u = {}; this.send = function (e, t) { this._logger.verbose("send(" + e + ", " + r(t) + ")"); var i = "send(): ", o = this; if (n(this._credentials.accountId) && ("" !== this._credentials.accountId || n(this._credentials.accountKey)) && "" !== this._credentials.accountKey) try { d += 1; var s = new XMLHttpRequest; if (u[d] = s, s.open("POST", o._url + o._credentials.accountKey, !0), s.onreadystatechange = function (e, t) { if (this && 4 === this.readyState) { var r = this.status >= 400 ? "fail" : this.status >= 200 ? "success" : "unknown"; o._done.call(o, e, t, r) } }.bind(s, d, e), void 0 !== t) { if ("string" == typeof t) try { t = JSON.parse(t) } catch (e) { this._logger.error(i + r(e)), t = null } if ("object" == typeof t) try { t = JSON.stringify(t), setTimeout(o._done.bind(o, d, e, "suspend"), 5e3), s.send(t) } catch (e) { this._logger.error(i + r(e)), o._done.call(o, d, "catch " + e.message) } } else this._logger.verbose(i + '"data" is undefined and will not be sent') } catch (e) { this._logger.error(i + r(e)), o._done.call(o, d, "catch " + e.message) } else o._logger.verbose(i + "No credentials is set; graylogger is disabled. Returning") }, this.destroy = function () { for (var e in this._logger.verbose("destroy()"), u) if (Object.prototype.hasOwnProperty.call(u, e)) { var t = u[e]; "function" == typeof t.onreadystatechange && (t.onreadystatechange = null), delete u[e] } }, this._done = function (e, t, r) { if (this._logger.verbose("_done(" + e + ", " + t + ", " + r + ")"), void 0 !== u[e]) { var n = u[e]; "function" == typeof n.onreadystatechange && (n.onreadystatechange = null), delete u[e] } } } }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(6), r(48), r(0), r(2), r(3)], void 0 === (i = function (e, t, r, n, i) { "use strict"; var o = r.isInt, s = r.isObject, a = r.isString, c = r.stringifyJSON, d = r.browserInfo, u = { _logger: n.create("EncodingUtils", "console"), setSenderBitrates: function (e, t) { u._logger.verbose("setSenderBitrates(" + c(e) + ", " + c(t) + ")"); var r = "setSenderBitrates(): "; if (!(e && e instanceof window.RTCPeerConnection)) { var n = i.TypeNotValidError("peerConnection", "RTCPeerConnection"); return u._logger.error(r + JSON.stringify(n)), Promise.reject(n) } if (!s(t)) { n = i.TypeNotValidError("bitrates", "Object"); return u._logger.error(r + JSON.stringify(n)), Promise.reject(n) } var a = parseInt(d.browserVersion, 10); if (("Chrome" === d.browser || "Firefox" === d.browser && a >= 64 || "Safari" === d.browser && a >= 13 || "Microsoft Edge Chromium" === d.browser) && "RTCRtpSender" in window && "setParameters" in window.RTCRtpSender.prototype) return Promise.resolve().then((function () { if (o(t.video)) { var n = u.getVideoSenders(e)[0]; if (n) return u.setVideoSenderMaxBitrate(n, t.video); u._logger.verbose(r + 'No sender of type "video" in peerconnection, skipping') } })).catch((function (e) { u._logger.warning(r + e) })).then((function () { if (o(t.audio)) { var n = u.getAudioSenders(e)[0]; if (n) return u.setAudioSenderMaxBitrate(n, t.audio); u._logger.verbose(r + 'No sender of type "audio" in peerconnection, skipping') } })).catch((function (e) { u._logger.warning(r + e) })).then((function () { return Promise.resolve(!0) })); return this._logger.warning("setSenderBitrates(): Can not set bitrates on RTCRtpSender, browser not supported"), Promise.resolve(!1) }, setSenderVideoDegradationPreference: function (e, t) { u._logger.verbose("setSenderVideoDegradationPreference(" + c(e) + ", " + c(t) + ")"); var r = "setSenderVideoDegradationPreference(): "; if (!(e && e instanceof window.RTCPeerConnection)) { var n = i.TypeNotValidError("peerConnection", "RTCPeerConnection"); return u._logger.error(r + JSON.stringify(n)), Promise.reject(n) } if (!a(t)) { n = i.TypeNotValidError("preference", "String"); return u._logger.error(r + JSON.stringify(n)), Promise.reject(n) } var o = parseInt(d.browserVersion, 10); if (("Chrome" === d.browser || "Firefox" === d.browser && o >= 64 || "Safari" === d.browser && o >= 13 || "Microsoft Edge Chromium" === d.browser) && "RTCRtpSender" in window && "setParameters" in window.RTCRtpSender.prototype) return Promise.resolve().then((function () { var n = u.getVideoSenders(e)[0]; if (n) return u.setVideoDegradationPreference(n, t); u._logger.verbose(r + 'No sender of type "video" in peerconnection, skipping') })).catch((function (e) { u._logger.warning(r + e) })).then((); return this._logger.warning("setSenderVideoDegradationPreference(): Can not set video degradation preference on RTCRtpSender, browser not supported"), Promise.resolve(!1) }, setAudioSenderMaxBitrate: function (e, t) { u._logger.verbose("setAudioSenderMaxBitrate(" + e + ", " + t + ")"); var r = e.getParameters(); return (!r.encodings || r.encodings.length <= 0) && (r.encodings = [{}]), 0 === t ? delete r.encodings[0].maxBitrate : r.encodings[0].maxBitrate = 1e3 * t, e.setParameters(r) }, setVideoSenderMaxBitrate: function (e, t) { u._logger.verbose("setVideoSenderMaxBitrate(" + e + ", " + t + ")"); var r = e.getParameters(); return (!r.encodings || r.encodings.length <= 0) && (r.encodings = [{}]), 0 === t ? delete r.encodings[0].maxBitrate : r.encodings[0].maxBitrate = 1e3 * t, e.setParameters(r) }, getAudioSenders: function (e) { return e.getSenders().filter((function (e) { return e.track && "audio" === e.track.kind })) }, getVideoSenders: function (e) { return e.getSenders().filter(() }, setVideoDegradationPreference: function (e, t) { var r = e.getParameters(); return "maintain-framerate" !== t && "maintain-resolution" !== t && "balanced" !== t || (r.degradationPreference = t), e.setParameters(r) }, setSDPAudioOptions: function (e, t) { parseInt(d.browserVersion, 10); return t && (t.bitrate && (e.sdp = setCodecParam(sdp, "opus/48000", "maxaveragebitrate", t.bitrate)), !0 === t.cbr && (e.sdp = setCodecParam(sdp, "opus/48000", "cbr", 1)), !0 === t.stereo && (e.sdp = maybeSetOpusOptions(e.sdp, { opusStereo: "true" }))), e } }; return u }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { "use strict"; window.mergeConstraints = function (e, t) { if (!e || !t) return e || t; var r = e; for (var n in t) r[n] = t[n]; return r }, window.iceCandidateType =  window.maybeSetOpusOptions = function (e, t) { return "true" === t.opusStereo ? e = setCodecParam(e, "opus/48000", "stereo", "1") : "false" === t.opusStereo && (e = removeCodecParam(e, "opus/48000", "stereo")), "true" === t.opusFec ? e = setCodecParam(e, "opus/48000", "useinbandfec", "1") : "false" === t.opusFec && (e = removeCodecParam(e, "opus/48000", "useinbandfec")), "true" === t.opusDtx ? e = setCodecParam(e, "opus/48000", "usedtx", "1") : "false" === t.opusDtx && (e = removeCodecParam(e, "opus/48000", "usedtx")), t.opusMaxPbr && (e = setCodecParam(e, "opus/48000", "maxplaybackrate", t.opusMaxPbr)), e }, window.maybeSetAudioSendBitRate = function (e, t) { return t.audioSendBitrate ? (trace("Prefer audio send bitrate: " + t.audioSendBitrate), preferBitRate(e, t.audioSendBitrate, "audio")) : e }, window.maybeSetAudioReceiveBitRate = function (e, t) { return t.audioRecvBitrate ? (trace("Prefer audio receive bitrate: " + t.audioRecvBitrate), preferBitRate(e, t.audioRecvBitrate, "audio")) : e }, window.maybeSetVideoSendBitRate = function (e, t) { return t.videoSendBitrate ? (trace("Prefer video send bitrate: " + t.videoSendBitrate), preferBitRate(e, t.videoSendBitrate, "video")) : e }, window.maybeSetVideoReceiveBitRate = function (e, t) { return t.videoRecvBitrate ? (trace("Prefer video receive bitrate: " + t.videoRecvBitrate), preferBitRate(e, t.videoRecvBitrate, "video")) : e }, window.preferBitRate = function (e, t, r) { var n = e.split("\r\n"), i = findLine(n, "m=", r); if (null === i) return trace("Failed to add bandwidth line to sdp, as no m-line found"), e; var o = findLineInRange(n, i + 1, -1, "m="); null === o && (o = n.length); var s = findLineInRange(n, i + 1, o, "c="); if (null === s) return trace("Failed to add bandwidth line to sdp, as no c-line found"), e; var a = findLineInRange(n, s + 1, o, "b=AS"); a && n.splice(a, 1); var c = "b=AS:" + t; return n.splice(s + 1, 0, c), e = n.join("\r\n") }, window.maybeSetVideoSendInitialBitRate = function (e, t) { var r = parseInt(t.videoSendInitialBitrate); if (!r) return e; var n = parseInt(r), i = parseInt(t.videoSendBitrate); i && (r > i && (trace("Clamping initial bitrate to max bitrate of " + i + " kbps."), r = i, t.videoSendInitialBitrate = r), n = i); var o = e.split("\r\n"), s = findLine(o, "m=", "video"); if (null === s) return trace("Failed to find video m-line"), e; var a = o[s], c = new RegExp("m=video\\s\\d+\\s[A-Z/]+\\s"), d = a.split(c)[1].split(" ")[0], u = o[findLine(o, "a=rtpmap", d)].split("a=rtpmap:" + d)[1].split("/")[0], l = t.videoSendCodec || u; return e = setCodecParam(e, l, "x-google-min-bitrate", t.videoSendInitialBitrate.toString()), e = setCodecParam(e, l, "x-google-max-bitrate", n.toString()) }, window.removePayloadTypeFromMline = function (e, t) { e = e.split(" "); for (var r = 0; r < e.length; ++r)e[r] === t.toString() && e.splice(r, 1); return e.join(" ") }, window.removeCodecByName = function (e, t) { var r = findLine(e, "a=rtpmap", t); if (null === r) return e; var n = getCodecPayloadTypeFromLine(e[r]); e.splice(r, 1); var i = findLine(e, "m=", "video"); return null === i || (e[i] = removePayloadTypeFromMline(e[i], n)), e }, window.removeCodecByPayloadType = function (e, t) { var r = findLine(e, "a=rtpmap", t.toString()); if (null === r) return e; e.splice(r, 1); var n = findLine(e, "m=", "video"); return null === n || (e[n] = removePayloadTypeFromMline(e[n], t)), e }, window.maybeRemoveVideoFec = function (e, t) { if ("false" !== t.videoFec) return e; var r = e.split("\r\n"), n = findLine(r, "a=rtpmap", "red"); if (null === n) return e; var i = getCodecPayloadTypeFromLine(r[n]); if (r = removeCodecByPayloadType(r, i), r = removeCodecByName(r, "ulpfec"), null === (n = findLine(r, "a=fmtp", i.toString()))) return e; var o = parseFmtpLine(r[n]).pt; return null === o ? e : (r.splice(n, 1), (r = removeCodecByPayloadType(r, o)).join("\r\n")) }, window.maybePreferAudioSendCodec = function (e, t) { return maybePreferCodec(e, "audio", "send", t.audioSendCodec) }, window.maybePreferAudioReceiveCodec = function (e, t) { return maybePreferCodec(e, "audio", "receive", t.audioRecvCodec) }, window.maybePreferVideoSendCodec = function (e, t) { return maybePreferCodec(e, "video", "send", t.videoSendCodec) }, window.maybePreferVideoReceiveCodec =  window.maybePreferCodec = function (e, t, r, n) { var i = t + " " + r + " codec"; if (!n) return trace("No preference on " + i + "."), e; trace("Prefer " + i + ": " + n); var o = e.split("\r\n"), s = findLine(o, "m=", t); if (null === s) return e; for (var a = null, c = o.length - 1; c >= 0; --c) { var d = findLineInRange(o, c, 0, "a=rtpmap", n, "desc"); if (null === d) break; c = d, (a = getCodecPayloadTypeFromLine(o[d])) && (o[s] = setDefaultCodec(o[s], a)) } return e = o.join("\r\n") }, window.setCodecParam = function (e, t, r, n) { var i = e.split("\r\n"), o = findFmtpLine(i, t), s = {}; if (null === o) { var a = findLine(i, "a=rtpmap", t); if (null === a) return e; var c = getCodecPayloadTypeFromLine(i[a]); s.pt = c.toString(), s.params = {}, s.params[r] = n, i.splice(a + 1, 0, writeFmtpLine(s)) } else (s = parseFmtpLine(i[o])).params[r] = n, i[o] = writeFmtpLine(s); return e = i.join("\r\n") }, window.removeCodecParam = function (e, t, r) { var n = e.split("\r\n"), i = findFmtpLine(n, t); if (null === i) return e; var o = parseFmtpLine(n[i]); delete o.params[r]; var s = writeFmtpLine(o); return null === s ? n.splice(i, 1) : n[i] = s, e = n.join("\r\n") }, window.parseFmtpLine = function (e) { var t = {}, r = e.indexOf(" "), n = e.substring(r + 1).split(";"), i = new RegExp("a=fmtp:(\\d+)"), o = e.match(i); if (!o || 2 !== o.length) return null; t.pt = o[1]; for (var s = {}, a = 0; a < n.length; ++a) { var c = n[a].split("="); 2 === c.length && (s[c[0]] = c[1]) } return t.params = s, t }, window.writeFmtpLine = function (e) { if (!e.hasOwnProperty("pt") || !e.hasOwnProperty("params")) return null; var t = e.pt, r = e.params, n = [], i = 0; for (var o in r) n[i] = o + "=" + r[o], ++i; return 0 === i ? null : "a=fmtp:" + t.toString() + " " + n.join(";") }, window.findFmtpLine = function (e, t) { var r = getCodecPayloadType(e, t); return r ? findLine(e, "a=fmtp:" + r.toString()) : null }, window.findLine = function (e, t, r) { return findLineInRange(e, 0, -1, t, r) }, window.findLineInRange = function (e, t, r, n, i, o) { if (void 0 === o && (o = "asc"), "asc" === (o = o || "asc")) { for (var s = -1 !== r ? r : e.length, a = t; a < s; ++a)if (0 === e[a].indexOf(n) && (!i || -1 !== e[a].toLowerCase().indexOf(i.toLowerCase()))) return a } else for (var c = -1 !== t ? t : e.length - 1; c >= 0; --c)if (0 === e[c].indexOf(n) && (!i || -1 !== e[c].toLowerCase().indexOf(i.toLowerCase()))) return c; return null }, window.getCodecPayloadType = function (e, t) { var r = findLine(e, "a=rtpmap", t); return r ? getCodecPayloadTypeFromLine(e[r]) : null }, window.getCodecPayloadTypeFromLine =  window.setDefaultCodec = }, function (e, t, r) { var n, i; n = [r(5), r(0), r(2)], void 0 === (i = function (e, t, r) { "use strict"; var n = t.stringifyJSON, i = t.isNumber; function o() { e.call(this), this._logger = r.create("AudioMixer", "console"), this._logger.verbose("AudioMixer()"), this._name = "AudioMixer", this._audioContext, this._streams = [], this._output } var s = o.prototype = Object.create(e.prototype); return s.connect = function (e, t) { if (this._logger.verbose("connect(" + n(e) + ", " + t + ")"), !e || 0 === e.getAudioTracks().length) return Promise.reject(new Error(this._name + '.connect parameter "stream" must contain a AudioStreamTrack')); if (!i(t) || t > 1) return Promise.reject(new Error(this._name + '.connect parameter "input" must be 0 or 1')); var r = e.clone(); return this._streams[t] = r, this._listenToStream(r) }, s.disconnect = function (e) { this._logger.verbose("disconnect(" + e + ")"), r.delete(this._logger) }, s.getOutputStream = function () { return this._logger.verbose("getOutputStream()"), this._streams.length < 2 ? Promise.reject(new Error(this._name + " needs exactly 2 input streams")) : this._getMixedStream() }, s._listenToStream = function (e) { return this._logger.verbose("_listenToStream(" + n(e) + ")"), e.onactive = this._onactive.bind(this), e.oninactive = this._oninactive.bind(this), e.onaddtrack = this._onaddtrack.bind(this), e.onended = this._onended.bind(this), Promise.resolve() }, s._unregisterAudioTrackListeners =  s._onactive = function (e) { this._logger.verbose("_onactive(" + n(e) + ")") }, s._oninactive = function (e) { this._logger.verbose("_oninactive(" + n(e) + ")") }, s._onaddtrack = function (e) { this._logger.verbose("_onaddtrack(" + n(e) + ")") }, s._onended = function (e) { this._logger.verbose("_onended(" + n(e) + ")") }, s._getMixedStream = function () { this._logger.verbose("_getMixedStream()"), this._audioContext || (this._audioContext = new AudioContext); var e = this._audioContext.createMediaStreamSource(this._streams[0]), t = this._audioContext.createMediaStreamSource(this._streams[1]), r = this._audioContext.createChannelSplitter(2), n = this._audioContext.createChannelSplitter(2); e.connect(r), t.connect(n); var i = this._audioContext.createChannelMerger(4); r.connect(i, 0, 0), r.connect(i, 1, 1), n.connect(i, 0, 2), n.connect(i, 1, 3); var o = this._createDownMixerNode(); return i.connect(o), this._output = this._audioContext.createMediaStreamDestination(), o.connect(this._output), Promise.resolve(this._output.stream) }, s._createDownMixerNode = function () { this._logger.verbose("_createDownMixerNode()"); var e = this._audioContext.createScriptProcessor(4096, 4, 2); return e.onaudioprocess = function (e) { for (var t, r = e.inputBuffer.getChannelData(0), n = e.inputBuffer.getChannelData(1), i = e.inputBuffer.getChannelData(2), o = e.inputBuffer.getChannelData(3), s = e.outputBuffer.getChannelData(0), a = e.outputBuffer.getChannelData(1), c = 0; c < r.length; c++)t = .25 * (r[c] + n[c]) + .25 * (i[c] + o[c]), s[c] = t, a[c] = t }, e }, o }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(6), r(0), r(92), r(3), r(2)], void 0 === (i = function (e, t, r, n, i) { "use strict"; var o = t.stringifyJSON, s = t.isObject, a = t.isBool, c = t.isInt, d = t.isFunction; function u() { this._devices = { videoinput: [], audioinput: [] }, this._selected = { videoinput: new r({ deviceId: !1 }), audioinput: new r({ deviceId: !1 }) }, this._tempDevice = void 0, this._reenumeratedOnce = !1, this._logger = i.create("DeviceController", "console") } var l = u.prototype; return l.enumerateDevices = function () { this._logger.verbose("enumerateDevices()"); var e = "enumerateDevices(): ", t = this; return t._verifyEnumerateDevicesExistence().then((function (e) { return e.enumerateDevices() })).then((function (e) { var r, n = t._createDevices(e); r = t._updateDevices(n); var i = t._tempDevice; if (i && !t._hasSCD()) { var o = t._devices.videoinput.length; i.displayIndex = o, t._devices[i.kind].push(i) } return Promise.resolve({ data: { devices: { videodevices: t._listed().videoinput, audiodevices: t._listed().audioinput }, updated: r } }) })).catch((function (r) { if (!r) { var i = n.ObjectNotExistError("error", "Error"); return t._logger.error(e + JSON.stringify(i)), Promise.reject(i) } if ("NanoError" === r.type) { var o = n.composeEvent(r); return t._logger.error(e + JSON.stringify(r)), Promise.reject(o) } i = n.EnumerateDevicesError(r), o = n.composeEvent(i); return t._logger.error(e + JSON.stringify(i)), Promise.reject(o) })) }, l.addScreenCaptureDevice = function (n) { this._logger.verbose("addScreenCaptureDevice(" + n + ")"); var i = t.browserInfo.browser, o = t.browserInfo.mobile; if (!t.enumContainsValue(e.SCREEN_CAPTURE_BROWSER, i.toLowerCase()) || o) return {}; var s = new r({ deviceId: "screen", kind: "videoinput", label: n + " (" + i + ")", displayLabel: n + " (" + i + ")" }); if ("Chrome" !== i || this._hasDevices()) return this._tempDevice = s, {}; var a = this._devices.videoinput.length; return s.displayIndex = a, this._devices.videoinput.push(s), { data: { devices: { videodevices: this._listed().videoinput, audiodevices: this._listed().audioinput }, updated: !0 } } }, l.setDevice = function (e) { this._logger.verbose("setDevice(" + o(e) + ")"); var t = "setDevice(): "; if (!s(e)) { var i = n.TypeNotValidError("config", "Object"); return this._logger.error(t + JSON.stringify(i)), Promise.reject(i) } if ("videoinput" !== e.kind && "audioinput" !== e.kind) { i = n.ValueNotValidError("config.kind", "video/audio"); return this._logger.error(t + JSON.stringify(i)), Promise.reject(i) } if ("camera" === e.source && !a(e.device) && !c(e.device)) { i = n.TypeNotValidError("config.device", "Boolean/Int"); return this._logger.error(t + JSON.stringify(i)), Promise.reject(i) } var d = e.device, u = this._devices[e.kind], l = void 0; if (a(d)) d = new r({ deviceId: d }), "videoinput" === e.kind && d.setVideoDeviceConfig(e), "audioinput" === e.kind && d.setAudioDeviceConfig(e), l = d; else if (void 0 !== (d = "screen" === e.source ? "screen" === u[u.length - 1].deviceId ? u[u.length - 1] : void 0 : u[d])) for (var p = 0; p < u.length; p++)if (d.deviceId === u[p].deviceId) { "videoinput" === e.kind && d.setVideoDeviceConfig(e), "audioinput" === e.kind && d.setAudioDeviceConfig(e), l = d; break } if (void 0 === l) { this._selected[e.kind] = new r({ deviceId: !1 }); i = n.DevicesNotFoundError(); return this._logger.error(t + JSON.stringify(i)), Promise.reject(i) } return this._selected[e.kind] = l, Promise.resolve({ device: l }) }, l.getDevice = function (e) { this._logger.verbose("getDevice(" + e + ")"); if ("videoinput" !== e && "audioinput" !== e) { var t = n.ValueNotValidError("config.kind", "video/audio"); return this._logger.error("getDevice(): " + JSON.stringify(t)), Promise.reject(t) } var r = this._selected; return Promise.resolve(r[e]) }, l.updateSelected = function (e, t) { this._logger.verbose("updateSelected(" + e + ", " + t + ")"); var r = e.getVideoTracks(), n = e.getAudioTracks(), i = this; r && r.length > 0 && this.getDevice("videoinput").then((function (e) { if (t || "screen" !== !e.deviceId) { if (!a(e)) { s = e.videoDeviceConfig || {}; e.setVideoDeviceConfig(s) } i._selected.videoinput = e } else { var n = r[0].label, o = i._getDeviceForLabel(n); if (!0 === e || o.label !== e.label) { var s = e.videoDeviceConfig || {}; o.setVideoDeviceConfig(s), i._selected.videoinput = o } } })).catch((function (e) { i._logger.error("updateSelected(): " + JSON.stringify(e)) })), n && n.length > 0 && i.getDevice("audioinput").then((function (e) { if (t) i._selected.audioinput = e; else { var r = n[0].label, o = i._getDeviceForLabel(r); !0 !== e && o.label === e.label || (i._selected.audioinput = o) } })).catch(() }, l.shouldReenumerate = function (e) { if (this._logger.verbose("shouldReenumerate(" + e + ")"), e && this._reenumeratedOnce) return !1; this._reenumeratedOnce = !0; for (var t = 0, r = this._getAllDevices(), n = 0; n < r.length; n++) { "" === (r[n].label || "") && (t += 1) } return t == (this._hasSCD() ? r.length - 1 : r.length) }, l.composeConstraints = function (e) { this._logger.verbose("composeConstraints(" + o(e) + ")"); var t = "composeConstraints(): ", r = this; return this._getConstraintTypes(e).then((function (n) { for (var i = { audio: !1, video: !1 }, o = 0; o < n.length; o++)switch (n[o]) { case "video": a(e.videoinput.deviceId) ? i.video = e.videoinput.deviceId : (i.video = e.videoinput.videoDeviceConfig, "" !== e.videoinput.deviceId && (i.video.deviceId = { exact: e.videoinput.deviceId })); break; case "audio": a(e.audioinput.deviceId) ? i.audio = e.audioinput.deviceId : (i.audio = e.audioinput.getAudioDeviceConfig(), "" !== e.audioinput.deviceId && (i.audio.deviceId = { exact: e.audioinput.deviceId })); break; case "screen": var s = e.videoinput.videoDeviceConfig; i.video = { width: s.width.ideal, height: s.height.ideal, frameRate: s.frameRate.ideal }, a(e.audioinput) ? i.audio = e.audioinput : (i.audio = {}, i.audio.deviceId = { exact: e.audioinput.deviceId }) }var c = t + JSON.stringify(i); return r._logger.verbose(c), Promise.resolve(i) })).catch((function (e) { var n = t + JSON.stringify(e); return r._logger.error(n), Promise.reject(e) })) }, l._getAllDevices = function () { return [].concat(this._devices.videoinput).concat(this._devices.audioinput) }, l._hasDevices = function () { return !(this._getAllDevices().length > 0) }, l._hasSCD = function () { var t = this._devices.videoinput.length - 1, r = this._devices.videoinput[t]; return r && r.deviceId === e.MEDIA_SOURCES.SCREEN }, l._listed =  l._createDevices = function (e) { this._logger.verbose("_createDevices(" + o(i) + ")"); for (var t = { videoinput: [], audioinput: [] }, n = 0; n < e.length; n++) { var i = e[n], s = i.kind; if ("videoinput" === s || "audioinput" === s) { var a = t[s].length; i.displayIndex = a; var c = new r(i); t[s].push(c) } } return t }, l._addDevices = function (e) { for (this._logger.verbose("_addDevices(" + o(e) + ")"); this._devices.videoinput.length;)this._devices.videoinput.pop(); for (; this._devices.audioinput.length;)this._devices.audioinput.pop(); this._devices.videoinput = e.videoinput, this._devices.audioinput = e.audioinput }, l._updateDevices = function (e) { this._logger.verbose("_updateDevices(" + o(a) + ")"); var t = [].concat(e.videoinput).concat(e.audioinput), r = this._getAllDevices().filter((), n = !1; if (r.length !== t.length) n = !0; else for (var i = 0; i < r.length; i++) { var s = r[i], a = t[i], c = ["constraints", "setVideoDeviceConfig", "videoDeviceConfig"]; for (var d in s) if (Object.prototype.hasOwnProperty.call(s, d) && Object.prototype.hasOwnProperty.call(a, d) && -1 === c.indexOf(d) && -1 === c.indexOf(d) && s[d] !== a[d]) { n = !0; break } } return this._addDevices(e), n }, l._getDeviceForLabel = function (e) { this._logger.verbose("_getDeviceForLabel(" + e + ")"); var t = this._getAllDevices(); if (-1 !== e.indexOf("screen")) for (var r = 0; r < t.length; r++) { if ("screen" === (n = t[r]).deviceId) return n } else for (r = 0; r < t.length; r++) { var n; if ((n = t[r]).label === e) return n } }, l._getListedFromDevices = function (e) { this._logger.verbose("_getListedFromDevices(" + o(e) + ")"); for (var t = { videoinput: [], audioinput: [] }, r = 0; r < e.length; r++) { var n = e[r]; t[n.kind].push({ index: n.displayIndex, id: n.label || n.displayId }) } return t }, l._getConstraintTypes = function (r) { this._logger.verbose("_getConstraintTypes(" + o(r) + ")"); var i = "_getConstraintTypes(): "; if (!r) { var s = n.ObjectNotExistError("devices", "Array"); return this._logger.error(i + JSON.stringify(s)), Promise.reject(s) } var c = []; if (r.videoinput) { var d = r.videoinput.videoDeviceConfig ? r.videoinput.videoDeviceConfig.source : a(r.videoinput) ? e.MEDIA_SOURCES.CAMERA : void 0; if (!t.enumContainsValue(e.MEDIA_SOURCES, d)) { s = n.EnumValueNotValidError(d, e.MEDIA_SOURCES); return this._logger.error(i + JSON.stringify(s)), Promise.reject(s) } c.push(d === e.MEDIA_SOURCES.SCREEN ? "screen" : "video") } return r.audioinput && (r.videoinput && "screen" !== r.videoinput.deviceId || !r.videoinput) && c.push("audio"), Promise.resolve(c) }, l._verifyEnumerateDevicesExistence = function () { this._logger.verbose("_verifyEnumerateDevicesExistence()"); var e = navigator.mediaDevices; if (!e || !d(e.enumerateDevices)) { var t = n.FunctionNotDefinedError("enumerateDevices"); return this._logger.error("_verifyEnumerateDevicesExistence(): " + JSON.stringify(t)), Promise.reject(t) } return Promise.resolve(e) }, l._verifyGetUserMediaExistence = function () { this._logger.verbose("_verifyGetUserMediaExistence()"); var e = navigator.mediaDevices; if (!e || !d(e.getUserMedia)) { var t = n.FunctionNotDefinedError("getUserMedia"); return this._logger.error("_verifyGetUserMediaExistence(): " + JSON.stringify(t)), Promise.reject(t) } return Promise.resolve(e) }, u }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(6), r(0)], void 0 === (i = function (e, t) { "use strict"; var r = t.isBool; return function (t) { this.deviceId = t.deviceId, r(this.deviceId) || (this.kind = t.kind, this.label = t.label, this.groupId = t.groupId, this.displayIndex = t.displayIndex, this.displayId = t.kind + "device ID: " + t.deviceId.substr(0, 10)), this.videoDeviceConfig = {}, this.audioDeviceConfig = {}, this.setVideoDeviceConfig = function (t) { var r = (t = t || {}).source || e.MEDIA_SOURCES.CAMERA, n = t.width || 0, i = t.height || 0, o = t.framerate || 0, s = t.minFramerate || 0; r !== e.MEDIA_SOURCES.CAMERA && r !== e.MEDIA_SOURCES.SCREEN || (this.videoDeviceConfig.source = r), o < s && (o = s), n > 0 && i > 0 && (this.videoDeviceConfig.width = { ideal: n }, this.videoDeviceConfig.height = { ideal: i }), o > 0 && (this.videoDeviceConfig.frameRate = { ideal: o }) }, this.getVideoDeviceConfig = function () { return this.videoDeviceConfig }, this.setAudioDeviceConfig =  this.getAudioDeviceConfig = function () { return this.audioDeviceConfig } } }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(0), r(3), r(2)], void 0 === (i = function (e, t, r) { "use strict"; var n = e.stringifyJSON, i = e.isObject, o = e.isEmpty, s = e.isString; return function (e) { this._logger = r.create("Media", "console"); if (!i(e) || o(e)) { var a = t.TypeNotValidError("config", "Object"); throw this._logger.error("Media(): " + n(a)), a } if (!i(e.stream)) { a = t.TypeNotValidError("config.stream", "Object"); throw this._consoleLogger.error("Media(): " + n(a)), a } if (!s(e.kind) || "local" !== e.kind && "remote" !== e.kind) { a = t.ValueNotValidError("config.kind", "local/remote"); throw this._consoleLogger.error("Media(): " + n(a)), a } this.stream = e.stream, this.kind = e.kind, this.metadata = { hasVideo: 0, hasAudio: 0, width: 0, height: 0, framerate: 0 }, this.remoteUserName = e.remoteUserName, this.remoteUserId = e.remoteUserId, this.getTracks =  this.getVideoTracks = function () { return this.stream.getVideoTracks() }, this.getAudioTracks = function () { return this.stream.getAudioTracks() }, this.hasVideoTracks = function () { return this.stream.getVideoTracks().length > 0 ? 1 : 0 }, this.hasAudioTracks =  this.getVideoTracksSettings = function () { var e = this.stream.getVideoTracks(); return e && e.length > 0 ? this.stream.getVideoTracks()[0].getSettings() : void 0 }, this.getVideoTracksConstraints = function () { var e = this.stream.getVideoTracks(); return e && e.length > 0 ? this.stream.getVideoTracks()[0].geConstraints() : void 0 }, this.getAudioTracksSettings = function () { var e = this.stream.getAudioTracks(); return e && e.length > 0 ? this.stream.getAudioTracks()[0].getSettings() : void 0 }, this.getAudioTrackConstraints = function () { var e = this.stream.getAudioTracks(); return e && e.length > 0 ? this.stream.getAudioTracks()[0].getConstraints() : void 0 }, this.applyAudioConstraints = function (e) { var r, s, a = "applyAudioConstraints(): ", c = this; return c._logger.verbose(a + n(e)), !i(e) || o(e) ? (r = t.TypeNotValidError("constraints", "Object"), c._logger.error(a + n(r)), Promise.reject(r)) : c.hasAudioTracks() ? (s = c.getAudioTracks()[0], c._logger.verbose(a + "constraints before applying: " + n(c.getAudioTrackConstraints())), s.applyConstraints(e).then((function () { c._logger.verbose(a + "constraints after applying: " + n(c.getAudioTrackConstraints())) })).catch((function (e) { return c._logger.error(a + n(e)), Promise.reject(e) }))) : (r = t.OperationNotAllowedError("Media.applyAudioConstraints()", "Media has no audio tracks."), c._logger.error(a + n(r)), Promise.reject(r)) }, this.muteTracks = function (e, t) { var r = "videoinput" === e ? this.getVideoTracks() : "audioinput" === e ? this.getAudioTracks() : void 0; if (r) for (var n = 0; n < r.length; n++)r[n].enabled = !t }, this.bind = function (e) { for (var t = this.getTracks(), r = 0; r < t.length; r++)t[r].onended = e._onTrackEnded.bind(e) }, this.unbind = function () { if (this.stream) { for (var e = this.getTracks(), t = 0; t < e.length; t++)e[t].onended = void 0; this._stopTracks(e), this.stream = void 0 } this.metadata = { hasAudio: 0, hasVideo: 0, width: 0, height: 0, framerate: 0 } }, this._stopTracks = } }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(6), r(0), r(5), r(2), r(3), r(49)], void 0 === (i = function (e, t, r, n, i, o) { "use strict"; var s = t.isObject, a = t.isString, c = t.isFunction, d = t.stringifyJSON; function u() { r.call(this), this._logger = n.create("ScreenCapture", "console"), this._logger.verbose("ScreenCapture()"); this._screenCaptureName = void 0, this._isScreenCaptureAvailable = !1, this._isChromeScreenCaptureExtensionInstalled = !1, this._sourceId = null, this._onGetSourceId = null; var e = this; window.addEventListener("message", (function (t) { e._logger.verbose("window.addEventListener(" + d(t) + ")"); var r = "addEventListener(): ", n = t.origin; if (a(n) && e._isValidOrigin(n) && s(t.data)) { var o = t.data.type; if (a(o) && e._isValidType(o)) { var c = t.data.command; if (a(c)) { var u = t.data.value; if (a(u)) { if ("message" === c) { if ("isReady" === u || "isLoaded" === u) { e._isChromeScreenCaptureExtensionInstalled = !0; var l = r + e._screenCaptureName + " event: " + u; e._logger.verbose(l) } } else if ("error" === c) { l = r + e._screenCaptureName + " error: " + u; if (e._logger.verbose(l), "PermissionDeniedError" === u) { var p = i.GetDisplayMediaError("PermissionDenied", l); e.emit(p.name, p) } } else if ("setSourceId" === c) { var f = u; l = r + e._screenCaptureName + "event: " + c; e._logger.verbose(l), e._setSourceId(f) } e._isScreenCaptureAvailable = !(!("getDisplayMedia" in navigator.mediaDevices) || !e._isChromeScreenCaptureExtensionInstalled) } } } } })), "chrome" === o.browserDetails.browser && o.browserDetails.version < 72 ? this._logger.warning('ScreenCapture(): Chrome screen capture extension is required for Chrome < v.72; use RTCUser\'s "addScreenCaptureExtension()" call to enable an extension') : this._initWithNativeAPISupport() } var l = u.prototype = Object.create(r.prototype); return l.addChromeExtension = function (e) { this._logger.verbose("addChromeExtension(" + e + ")"); if (!a(e)) { var t = i.TypeNotValidError("name", "String"); throw self._logger.error("addChromeExtension(): " + d(t)), t } this._screenCaptureName = e, this._checkChromeExtensionAliveness(), this._initWithChromeExtensionSupport() }, l.getScreenCaptureName = function () { return this._logger.verbose("getScreenCaptureName()"), this._screenCaptureName }, l.isScreenCaptureAvailable =  l._initWithNativeAPISupport = function () { this._logger.verbose("_initWithNativeAPISupport()"); var r = t.browserInfo.mobile; t.enumContainsValue(e.SCREEN_CAPTURE_BROWSER, o.browserDetails.browser.toLowerCase()) && !r ? (this._screenCaptureName = "nanoScreenCapture", "firefox" == o.browserDetails.browser && o.browserShim.shimGetDisplayMedia(window, "screen"), this._isScreenCaptureAvailable = "getDisplayMedia" in navigator.mediaDevices) : this._isScreenCaptureAvailable = !1 }, l._initWithChromeExtensionSupport = function () { this._logger.verbose("_initWithChromeExtensionSupport()"); var e = "_initWithChromeExtensionSupport(): ", t = this; o.browserShim.shimGetDisplayMedia(window, (function () { return new Promise((function (r, n) { t.once("PermissionDenied", (function () { var r = i.GetDisplayMediaError("PermissionDenied"); t._logger.error(e + d(r)), n(r) })), t._getSourceId((function () { if (t._sourceId) r(t._sourceId); else { var o = i.GetDisplayMediaError("NotAllowedError"); t._logger.error(e + d(o)), n(o) } })) })) })) }, l._checkChromeExtensionAliveness = function () { this._logger.verbose("_checkChromeExtensionAliveness()"); var e = this; setTimeout((, 500), this._logger.verbose("_checkChromeExtensionAliveness(): " + this._screenCaptureName + "alive?"), this._toWindow(this._screenCaptureName, "isAlive", "") }, l._isValidOrigin = function (e) { return this._logger.verbose("_isValidOrigin(" + e + ")"), e === window.location.origin }, l._isValidType = function (e) { return this._logger.verbose("_isValidType(" + e + ")"), e === this._screenCaptureName }, l._getSourceId = function (e) { this._logger.verbose("_getSourceId()"); c(e) && (this._onGetSourceId = e, this._logger.verbose("_getSourceId(): " + this._screenCaptureName), this._toWindow(this._screenCaptureName, "getSourceId", "")) }, l._setSourceId = function (e) { this._logger.verbose("_setSourceId(" + e + ")"), this._sourceId = void 0 !== e ? e : null, this._onGetSourceId && this._onGetSourceId() }, l._toWindow = function (e, t, r) { this._logger.verbose("_toWindow(" + this._screenCaptureName + e + ", " + t + ", " + r + ")"), window.postMessage({ type: e, command: t, value: r }, "*") }, u }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(19), r(6), r(5), r(0), r(96), r(33), r(3), r(2)], void 0 === (i = function (e, t, r, n, i, o, s, a) { "use strict"; var c = n.stringifyJSON, d = 1, u = 2, l = 3, p = t.CHATPEER_STATE; function f(e, t, n) { r.call(this), this._logger = a.create("ChatRoom", "console"), this._logger.verbose("ChatRoom(" + c(e) + ")"), this._roomName = e.room, this._userName = e.userName, this._userId = e.userId, this._peers = [], this._serverUserList = [], this._state = d, this._iceServers = [], this._config = {}, this._session = t, this._mediaController = n } var g = f.prototype = Object.create(r.prototype); return g.setConfig = function (e) { this._logger.verbose("setConfig(" + c(e) + ")"), this._config = e }, g.setIceServers = function (e) { this._iceServers = e }, g.enter = function () { this._logger.verbose("enter()"); var e = this; return e._state == u ? Promise.reject(s.OperationNotAllowedError("ChatRoom.enter()", "Already in room")) : (this._session.on("RoomMessage", e._onRoomMessage.bind(e)), this._session.enterRoom({ roomName: this._roomName, userName: this._userName }).then((function (t) { e._state = u }))) }, g.leave = function () { this._logger.verbose("leave()"); var e = this; return this._session.removeEvent("RoomMessage"), this._session.leaveRoom({ roomName: this._roomName }).then(().catch((function (t) { return e.destroy(), e._state = l, e._logger.error("leave(): " + c(t)), Promise.reject(t) })) }, g.callUser = function (e) { this._logger.verbose("callUser(" + e + ")"); var t = this; return this._session.callUser({ userId: e, roomName: this._roomName }).catch((function (e) { return t._logger.error("callUser(): " + c(e)), Promise.reject(e) })) }, g.answerCall = function (e) { this._logger.verbose("answerCall(" + e + ")"); var t = this; return this._session.answerCall({ userId: e, roomName: this._roomName }).then((function (r) { t._createChatPeer(!1, e, r.user_name, r.caller_peer_id, r.callee_peer_id) })).catch((function (e) { return t._logger.error("answerCall(): " + c(e)), Promise.reject(e) })) }, g.declineCall = function (e) { this._logger.verbose("declineCall(" + e + ")"); var t = this; return this._session.declineCall({ userId: e, roomName: this._roomName }).catch((function (e) { return t._logger.error("declineCall(): " + c(e)), Promise.reject(e) })) }, g.hangUpCall = function (e) { this._logger.verbose("hangUpCall(" + e + ")"); var t = this; return this._session.hangUpCall({ userId: e, roomName: this._roomName }).then(().catch((function (e) { return t._logger.error("hangUpCall(): " + c(e)), Promise.reject(e) })) }, g.getUsersCount =  g.destroy = function () { this._logger.verbose("destroy()"), this._session.removeEvent("RoomMessage"); for (var e = 0; e < this._peers.length; e++)this._peers[e].destroy(); return this._peers = [], a.delete(this._logger), Promise.resolve() }, g._addEventPayload = function (e) { return (e = e || {}).data = e.data || {}, e.data.state = this._state, e }, g._reemit = function (e) { e = this._addEventPayload(e), this.emit(e.name, e) }, g._createChatPeer = function (e, t, r, n, o) { this._logger.verbose("_createChatPeer(" + e + ", " + t + ", " + r + ", " + n + ", " + o + ")"); var s = new i(this._userName, this._userId, t, r, this._roomName, this._session, this._mediaController); s.setIceServers(this._iceServers), s.addStream(this._mediaController.getLocalMedias()[0].stream), s.setConfig(this._config), s.start(e, n, o), this._peers.push(s), this._bind(s) }, g._destroyPeer = function (e) { this._logger.verbose("_destroyPeer(" + e + ")"); var t = this._removePeerFromPeerList(e); this._unbind(t), t.destroy() }, g._bind = function (e) { this._logger.verbose("_bind(" + c(e) + ")"), e.on("RemoteStreamAdded", this._reemit.bind(this)), e.on("StateChanged", this._handlePeerState.bind(this)) }, g._unbind = function (e) { this._logger.verbose("_unbind(" + c(e) + ")"), e.removeEvent("RemoteStreamAdded"), e.removeEvent("StateChanged") }, g._handlePeerState = function (e) { switch (this._logger.verbose("_handlePeerState( " + c(e) + ")"), e.data.state) { case t.CHATPEER_STATE.INITIALIZED: case t.CHATPEER_STATE.SIGNALING: case t.CHATPEER_STATE.SIGNALLING_DONE: case t.CHATPEER_STATE.CALLING: case t.CHATPEER_STATE.NEGOTIATION_NEEDED: break; case t.CHATPEER_STATE.DISCONNECTED: case t.CHATPEER_STATE.FAILED: this._destroyPeer(e.target.getRemoteUserId()); break; case t.CHATPEER_STATE.STOPPED: }this._createPublicUserList() }, g._createPublicUserList = function () { this._logger.verbose("_createPublicUserList()"); for (var e, t, r, i, o = "_createPublicUserList(): ", s = [], a = 0; a < this._peers.length; a++)i = {}, t = (e = this._peers[a]).getState(), r = n.getKeyByValue(p, t).toLowerCase(), i.state = r, i.remoteUserName = e.getRemoteUserName(), i.remoteUserId = e.getRemoteUserId(), s.push(i); var d = this._serverUserList.filter((), u = d.concat(s).sort((); return this._logger.verbose(o + "publicList: " + c(d)), this._logger.verbose(o + "peerList: " + c(s)), this._logger.verbose(o + "sortedList: " + c(u)), this.emit("RoomUpdate", { type: "room_update", data: { userlist: u } }), u }, g._getPeerByRemoteUserId = function (e) { var t; this._logger.verbose("_getPeerByRemoteUserId(" + e + ")"); for (var r = 0; r < this._peers.length; r++)if ((t = this._peers[r]).getRemoteUserId() === e) return t }, g._removePeerFromPeerList = function (e) { var t; this._logger.verbose("_removePeerFromPeerList(" + e + ")"); for (var r = 0; r < this._peers.length; r++)if ((t = this._peers[r]).getRemoteUserId() === e) return this._peers.splice(r, 1), t }, g._onRoomMessage = function (e) { this._logger.verbose("_onRoomMessage(" + c(e) + ")"); var t = {}; switch (e.type) { case "room_update": this._logger.verbose("_onRoomMessage(): room_update: " + c(e)), this._serverUserList = e.data.userlist, this._createPublicUserList(); break; case "call_incoming": t.remoteUserId = e.user_id, t.remoteUserName = e.user_name, this.emit("RoomUpdate", { type: "call_incoming", data: t }); break; case "call_declined": t.remoteUserName = e.data.user_name, t.remoteUserId = e.data.user_id, this.emit("RoomUpdate", { type: "call_declined", data: t }); break; case "hang_up": this._destroyPeer(e.data.user_id), this._createPublicUserList(); break; case "start_as_caller": this._createChatPeer(!0, e.user_id, e.user_name, e.caller_peer_id, e.callee_peer_id) } }, f }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(19), r(47), r(6), r(5), r(0), r(50), r(33), r(2)], void 0 === (i = function (e, t, r, n, i, o, s, a) { "use strict"; var c = i.isString, d = i.isIntString, u = i.stringifyJSON, l = i.isArray, p = r.CHATPEER_STATE; function f(e, t, r, i, o, s, u) { n.call(this), this._logger = a.create("ChatPeer", "console"), this._logger.verbose("ChatPeer(" + e + ", " + t + ", " + r + ", " + i + ", " + o + ")"); var l = "ChatPeer(): "; c(e) || this._logger.error(l + "Param userName must be a string"), c(o) || this._logger.error(l + "Param room must be a string"), d(t) || this._logger.error(l + "Param userId must be an integer"), this._userName = e, this._userId = t, this._peerId = void 0, this._remoteUserName = i, this._remoteUserId = r, this._remotePeerId = void 0, this._room = o, this._pcClient = void 0, this._streams = [], this._startTime = null, this._iceServers = [], this._config = {}, this._state = p.IDLE, this._messageQueue = [], this._isCaller = !1, this._remoteStream = null, this._statsEnabled = !1, this._statsIntervalTime = 1e3, this._statsInterval = 0, this._rtcStats = null, this._session = s, this._mediaController = u } var g = f.prototype = Object.create(n.prototype); return g.setIceServers = function (e) { this._iceServers = e }, g.setConfig = function (e) { this._config = e }, g.getState = function () { return this._state }, g.getPeerId = function () { return this._peerId }, g.getRemoteUserId = function () { return this._remoteUserId }, g.getRemoteUserName = function () { return this._remoteUserName }, g.start = function (e, t, r) { var n; this._logger.verbose("start(" + e + ", " + t + ", " + r + ")"), this._isCaller = e, this._createPCClient(), this._isCaller ? (this._peerId = t, this._remotePeerId = r) : (this._peerId = r, this._remotePeerId = t), n = "receiver_peer_" + this._peerId, this._session.on(n, this._onServerMessage.bind(this)), this._isCaller ? this._pcClient.startAsCaller(null) : this._pcClient.startAsCallee(this._messageQueue), this._setState(p.INITIALIZED) }, g.addStream = function (e) { this._logger.verbose("addStream(" + u(e) + ")"); e ? 2 !== this._streams.length ? l(e) ? this._streams = e : this._streams.push(e) : this._logger.__warning("addStream(): [peer id: " + this._peerId + "] stream count is already=2, we only support 2 streams/Chatpeer") : this._logger.error("addStream(): [peer id: " + this._peerId + '] parameter "stream" must not be undefined') }, g.enableStats = function (e, t) { this._logger.verbose("enableStats(" + e + ", " + t + ")"), this._statsEnabled = void 0 === e || e, this._statsIntervalTime = t || 1e3, this._rtcStats = null, this._statsEnabled && (this._rtcStats = new o, this._rtcStats.on("ReceivedWebRTCStats", this._reemit.bind(this))) }, g.destroy = function () { this._logger.verbose("destroy()"), this._unbind(), this._closePCClient(), this._setState(p.STOPPED), this._remoteStream && (this._mediaController.removeMedia(this._remoteStream.id), this._remoteStream = null), a.delete(this._logger) }, g._onServerMessage = function (e) { this._logger.verbose("_onServerMessage(" + u(e) + ")"); var t = "_onServerMessage(): ", r = this; switch (e.type) { case "sdp_message": r._pcClient && r._pcClient.isStarted() ? r._pcClient.setRemoteDescription(e.data).catch((function (e) { return r._logger.error(t + "setRemoteDescription failed:" + e), Promise.reject(e) })).then((function () { if (r._logger.verbose(t + "setRemoteDescription succeded"), !r._isCaller) return r._pcClient.doAnswer() })).catch((function (e) { return r._logger.error(t + "doAnswer failed:" + e), Promise.reject(e) })).then((function (e) { if (!r._isCaller) { r._logger.verbose(t + "doAnswer succeded " + e); var n = {}; return n.sender_peer = r._peerId, n.receiver_peer = r._remotePeerId, n.data = e, r._session.sendSignalingMessage(n).catch(() } })).catch(() : r._messageQueue.push(e.data.sdp); break; case "ice_candidate": r._pcClient && r._pcClient.isStarted() ? r._pcClient.addIceCandidate(e.data.candidate) : r._messageQueue.push(e.data.candidate); break; case "server_error": r._setState(p.FAILED), r._logger.error(t + "Server error: " + e.error); break; default: r._logger.verbose(t + "Unknown message:" + e) } }, g._addEventPayload = function (e) { return (e = e || {}).target = this, e.data = e.data || {}, e.data.state = this._state, e.data.message = i.getKeyByValue(p, this._state).toLowerCase(), e.data.text = e.data.message, e }, g._reemit = function (e) { e = this._addEventPayload(e), this.emit(e.name, e) }, g._collectRtcStats = function () { this._logger.verbose("_collectRtcStats()"); var e = this; clearInterval(e._statsInterval), this._statsInterval = setInterval((function () { e._pcClient ? e._pcClient.getStats().then(().catch(() : clearInterval(e._statsInterval) }), this._statsIntervalTime) }, g._stopCollectRtcStats = function () { this._logger.verbose("_stopCollectRtcStats()"); this._statsInterval && (this._logger.verbose("_stopCollectRtcStats(): Stopping rtc stats collection"), clearInterval(this._statsInterval)) }, g._getPeerConnectionConfig = function () { this._logger.verbose("_getPeerConnectionConfig()"); var e = { iceServers: this._iceServers, iceTransports: "all" }, t = { optional: [], mandatory: [] }; return t.optional.push({ googCpuOveruseDetection: !1 }), t.optional.push({ RtpDataChannels: !1 }), { mediaConstraints: { audio: !0, video: !0 }, sdpPatches: this._config.sdpPatches, peerConnectionConfig: e, peerConnectionConstraints: t, send: !0, receive: !0, videoSendCodec: this._config.codecs.videoCodec || "H264", videoRecvCodec: this._config.codecs.videoCodec || "H264", videoSendBitrate: this._config.bitrates.videoSendBitrate || 0, videoSendInitialBitrate: this._config.bitrates.videoSendInitialBitrate || 0 } }, g._createPCClient = function () { this._logger.verbose("_createPCClient()"); var e = "_createPCClient(): "; if (this._pcClient) this._logger.verbose(e + "[peer id:  " + this._peerId + "] PeerConnection still alive, do not create!"); else try { this._pcClient = new t(this._getPeerConnectionConfig(), this._startTime), this._bind(); for (var r = 0; r < this._streams.length; r++)this._pcClient.addStream(this._streams[r]); this._logger.verbose(e + "Created PeerConnectionClient") } catch (t) { this._logger.error(e + "[peer id: " + this._peerId + "] Create PeerConnection exception: " + t.message), this.emitSimple("CreatePeerConnectionClientError") } }, g._bind = function () { this._logger.verbose("_bind()"), this._pcClient.on("SignalingMessage", this._onSignalingMessage.bind(this)), this._pcClient.on("RemoteStreamRemoved", this._onRemoteStreamRemoved.bind(this)), this._pcClient.on("RemoteStreamAdded", this._onRemoteStreamAdded.bind(this)), this._pcClient.on("IceConnectionStateChange", this._onIceConnectionStateChange.bind(this)), this._pcClient.on("EndOfLocalCandidates", this._onEndOfLocalCandidates.bind(this)), this._pcClient.on("NegotiationNeeded", this._onNegotiationNeeded.bind(this)) }, g._unbind = function () { this._logger.verbose("_unbind()"), this._pcClient.off("SignalingMessage", this._onSignalingMessage.bind(this)), this._pcClient.off("RemoteStreamRemoved", this._onRemoteStreamRemoved.bind(this)), this._pcClient.off("RemoteStreamAdded", this._onRemoteStreamAdded.bind(this)), this._pcClient.off("IceConnectionStateChange", this._onIceConnectionStateChange.bind(this)), this._pcClient.off("EndOfLocalCandidates", this._onEndOfLocalCandidates.bind(this)), this._pcClient.off("NegotiationNeeded", this._onNegotiationNeeded.bind(this)) }, g._setState = function (e) { this._logger.verbose("_setState(" + e + ")"); if (e !== this._state) { if (this._state !== p.CALLING || e !== p.SIGNALING && e !== p.SIGNALLING_DONE) { var t, r = this._state; this._state = e, this._logger.verbose("_setState(): State: " + i.getKeyByValue(p, r) + " -> " + i.getKeyByValue(p, this._state)), t = this._addEventPayload({}), this.emit("StateChanged", t) } } else this._logger.verbose("_setState(): No state change") }, g._onIceConnectionStateChange = function (e) { switch (this._logger.verbose("_onIceConnectionStateChange(" + u(e) + ")"), e.data.state) { case "new": case "checking": this._setState(p.SIGNALING); break; case "connected": case "completed": this._setState(p.SIGNALLING_DONE), this._statsEnabled && this._pcClient && this._collectRtcStats(); break; case "failed": this._setState(p.FAILED), this._statsEnabled && this._pcClient && this._stopCollectRtcStats(); break; case "disconnected": this._setState(p.DISCONNECTED) } }, g._onNegotiationNeeded = function (e) { this._logger.verbose("_onNegotiationNeeded(" + u(e) + ")"); this._logger.warning("_onNegotiationNeeded(): NegotiationNeeded event has been fired") }, g._onEndOfLocalCandidates = function (e) { this._logger.verbose("_onEndOfLocalCandidates(" + u(e) + ")") }, g._onRemoteStreamAdded = function (e) { this._logger.verbose("_onRemoteStreamAdded(" + u(e) + ")"); var t = this; if (!this._remoteStream) { this._remoteStream = e.data.stream; var r = { stream: this._remoteStream, kind: "remote", remoteUserId: this._remoteUserId, remoteUserName: this._remoteUserName }; this._mediaController.addRemoteMedia(r).then((function () { t._setState(p.CALLING), t.emitSimple(e.name, { stream: t._remoteStream.id }) })).catch(() } }, g._onRemoteStreamRemoved = function (e) { this._logger.verbose("_onRemoteStreamRemoved(" + u(e) + ")"), this._remoteStream && (this._mediaController.removeMedia(this._remoteStream.id), this._remoteStream = null) }, g._closePCClient = function () { this._logger.verbose("_closePCClient()"); if (this._pcClient) { var e, t, r = this._streams; for (e = 0, t = r.length; e < t; ++e)try { this._pcClient.removeStream(r[e]) } catch (e) { this._logger.error("_closePCClient(): [peer id: " + this._peerId + "] Could not remove stream from peerconnectionclient") } this._pcClient.close(), this._streams = null, this._pcClient = null } else this._logger.warning("_closePCClient(): No PeerConenctionClient") }, g._sendMessageToPeer = function (e) { this._logger.verbose("_sendMessageToPeer(" + u(e) + ")"); var t = "_sendMessageToPeer(): ", r = this, n = {}; if (!this._remotePeerId) { var i = t + "Trying to send message, but no remote peer id set! This should not happen!"; return this._logger.error(i), Promise.reject(i) } if (!this._peerId) { i = t + "Trying to send message, but no peer id set! This should not happen!"; return this._logger.error(i), Promise.reject(i) } return n.sender_peer = this._peerId, n.receiver_peer = this._remotePeerId, n.data = e, this._session.sendSignalingMessage(n).catch((function (e) { return r._logger.error(t + e), Promise.reject(e) })) }, g._onSignalingMessage = function (e) { this._logger.verbose("_onSignalingMessage(" + u(e) + ")"); var t = "_onSignalingMessage(): ", r = this; this._remotePeerId ? this._sendMessageToPeer(e.data).then(().catch(() : this._logger.error(t + "Trying to send message, but no remote peer set! This should not happen!") }, f }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(2), r(0)], void 0 === (i = function (e, t) { "use strict"; var r = { _logger: e.create("ParamUtils", "console"), isRtmpUrl: function (e) { if (!t.isString(e)) return !1; if (!/^([rR][tT][mM][pP][sS]?):\/\/([a-zA-Z0-9.\-:]{4,})\/\b([a-zA-Z0-9()@:%_\+.~#?&\/=-]*)$/gm.test(e)) return !1; var n = e.split("//")[1].split("/")[0]; if (!n) return !1; var i = n.split(":")[0], o = n.split(":")[1]; return !(!r.isValidDomainName(i) && !r.isValidIp(i)) && !(o && (o.length > 5 || !/^\d+$/.test(o))) }, isWebSocketUrl: function (e) { if (!t.isString(e)) return !1; if (!/^([wW][sS][sS]?):\/\/([a-zA-Z0-9.\-:]{4,})\/\b([a-zA-Z0-9()@:%_\+.~#?&\/=-]*)$/gm.test(e)) return !1; var n = e.split("//")[1].split("/")[0], i = n.split(":")[0], o = n.split(":")[1]; return !(!r.isValidDomainName(i) && !r.isValidIp(i)) && !(o && (o.length > 5 || !/^\d+$/.test(o))) }, isIceServerUrl: function (e) { if (!t.isString(e)) return !1; if (!/^([sS][tT][uU][nN]|[tT][uU][rR][nN]):([a-zA-Z0-9.\-:]{4,})\??\b([a-zA-Z0-9()@:%_\+.~#?&\/=-]*)$/gm.test(e)) return !1; var n = e.split(":")[1].split("?")[0], i = n.split(":")[0], o = n.split(":")[1]; return !(!r.isValidDomainName(i) && !r.isValidIp(i)) && !(o && (o.length > 5 || !/^\d+$/.test(o))) }, isJWT:  isObjectOfMaxDepth: function (e, n) { return t.isObject(e) && r.getObjectDepth(e) <= n }, isIntInRange:  isMetadataHandler: function (e) { return !!t.isString(e) && ("onMetaData" === e || "onCuePoint" === e) }, isDeviceKind: function (e) { return !!t.isString(e) && ("videoinput" === e || "audioinput" === e) }, isVideoSource: function (e) { return !!t.isString(e) && ("camera" === e || "screen" === e) }, isVideoWidth: function (e) { return !!t.isInt(e) && (e >= 320 && e <= 3840) }, isVideoHeight: function (e) { return !!t.isInt(e) && (e >= 240 && e <= 2160) }, isFramerate: function (e) { return !!t.isInt(e) && (e >= 0 && e <= 60) }, isDevice:  isH264Profile: function (e) { return !!t.isString(e) && ("cbp" === e || "high" === e) }, isValidDomainName: function (e) { var t = e, r = "." === t.charAt(t.length - 1); if (t = r ? t.slice(0, -1) : t, !/^[a-zA-Z0-9.\-]*$/.test(t)) return !1; if (t.length < 1 || t.length > 253) return !1; var n = t.split("."); if (n.length < 2) return !1; for (var i = 0; i < n.length; i++) { var o = n[i], s = i === n.length - 1; if (o.length < 1 || o.length > 63) return !1; if ("-" === o.charAt(0) || "-" === o.charAt(o.length - 1)) return !1; if (s) { if (!isNaN(Number(o))) return !1; if (o.length < 2) return !1 } } return !0 }, isValidIp:  getObjectDepth: function (e) { var t = 1; for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n) && "object" == typeof e[n]) { var i = r.getObjectDepth(e[n]) + 1; t = Math.max(i, t) } return t } }; return r }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(0), r(32), r(2), r(99), r(3)], void 0 === (i = function (e, t, r, n, i) { "use strict"; var o = e.isObject, s = e.isBool, a = e.isInt, c = e.isEmpty, d = e.stringifyJSON; function u(e, t) { this._consoleLogger = r.create("MetricsController", "console"), this._grayLogger = r.create("MetricsController", "graylog"), this._consoleLogger.verbose("MetricsController(" + d(t) + ")"); var s = "MetricsController(): "; if (this._statsInterval = 10, this._lastStatsUpdate = void 0, this._broadcastSignallingTime = void 0, this._broadcastStartingTime = void 0, this._lastPLICount = void 0, this._lastPLICountUpdate = void 0, !o(e) || c(e)) { var u = i.TypeNotValidError("rtcUser", "Object"); throw this._consoleLogger.error(s + d(u)), u } if (this._rtcUser = e, this._metrics = new n(t), t && a(t.statsInterval)) { if (t.statsInterval < 1 || t.statsInterval > 10) { u = i.ValueNotValidError("config.statsInterval", "1...10"); throw this._consoleLogger.error(s + d(u)), u } this._statsInterval = t.statsInterval } this._rtcUser._statsEnabled || this._rtcUser.enableStats(!0, 1e3 * this._statsInterval) } var l = u.prototype; return l.onEvent = function (e) { this._consoleLogger.verbose("onEvent(" + d(e) + ")"); var t = this; return Promise.resolve().then((function () { switch (e.name) { case "SignInSuccess": return t._metrics.session.serverUrl = t._rtcUser._session._serverUrl, t._metrics.session.sessionId = t._rtcUser._session._sessionId, t._rtcUser._session.status().then((function (r) { var n = r && r.data ? r.data.hostname : ""; return t._metrics.session.hostName = n, t._getPayload(e) })); case "SignOutSuccess": t._metrics.cleanUpSession(); break; case "StartPreviewSuccess": return t._rtcUser._deviceController.getDevice("videoinput").then((function (e) { return t._metrics.devices.videoinput = e, t._rtcUser._deviceController.getDevice("audioinput") })).then((function (r) { return t._metrics.devices.audioinput = r, t._getPayload(e) })); case "StopPreviewSuccess": t._metrics.cleanUpDevices(); break; case "StartBroadcastSuccess": var r = e && e.data ? e.data.output : "", n = e && e.data ? e.data.streamname : ""; t._metrics.rtmp.url = r, t._metrics.rtmp.streamname = n, t._broadcastStartingTime = (new Date).getTime(); break; case "StopBroadcastSuccess": if (void 0 !== t._broadcastStartingTime) { var i = (new Date).getTime() - t._broadcastStartingTime; t._metrics.broadcast.totalTime = i / 1e3 } t._metrics.broadcast.status = "stopped", t._metrics.cleanUpStats(); break; case "BroadcastStatus": var o = e && e.data ? e.data.message : ""; if (t._metrics.broadcast.status = o, "signaling" === o) t._broadcastSignallingTime = (new Date).getTime(); else if ("broadcasting" === o && void 0 !== t._broadcastSignallingTime) { var s = (new Date).getTime() - t._broadcastSignallingTime; t._metrics.broadcast.startupTime = s / 1e3 } break; case "ReceivedWebRTCStats": e.name = "ReceivedWebRtcStats"; var a = (new Date).getTime(), c = t._lastStatsUpdate; if (void 0 !== c) if ((a - c) / 1e3 < t._statsInterval && e.data && e.data.results && e.data.results.extended && 1 !== e.data.results.extended.priority) return; if (t._lastStatsUpdate = a, e && e.data && e.data.results) { var d = e.data.results, u = {}; for (var l in d) Object.prototype.hasOwnProperty.call(d, l) && "extended" !== l && (u[l] = d[l]); if (d.extended) { var p = d.extended; for (var l in p) Object.prototype.hasOwnProperty.call(p, l) && (u[l] = p[l]); var f = t._metrics.devices; f.videoinput && f.videoinput.videoDeviceConfig && (u.contentType = "" + f.videoinput.videoDeviceConfig.source); a = (new Date).getTime(); var g = e.data.results.extended.pliCount, h = t._lastPLICount, v = t._lastPLICountUpdate; if (void 0 !== h && void 0 !== v) { var m = g - h; if (m > 0) { var _ = (a - v) / 1e3 / m; u.pliFrequency = _, t._lastPLICount = g, t._lastPLICountUpdate = a } else t._consoleLogger.verbose("Connection issue: PLI is not increasing") } else t._lastPLICount = g, t._lastPLICountUpdate = a } t._metrics.stats = u } if (void 0 !== t._broadcastStartingTime) { var S = a - t._broadcastStartingTime; t._metrics.broadcast.totalTime = S / 1e3 } break; default: if (e.name && -1 !== e.name.indexOf("Error")) { var b = {}; b.code = e.error.code, b.message = e.error.message, t._metrics.error = b, t._metrics.broadcast.status = "error" } }return t._getPayload(e) })).then((function (r) { o(r) && !c(r) && t._grayLogger.send(e.name, r) })).then((function () { ("StopBroadcastSuccess" === e.name || e.name && -1 !== e.name.indexOf("Error")) && (t._metrics.cleanUpRtmp(), t._metrics.cleanUpBroadcast(), t._metrics.cleanUpStats()), t._metrics.cleanUpError() })).catch((function (r) { "NanoError" !== r.type && (r = i.GeneralError("Failed to handle an event: " + e.name)), t._consoleLogger.error("onEvent(): " + d(r)), t._metrics.cleanUpRtmp(), t._metrics.cleanUpBroadcast(), t._metrics.cleanUpStats(), t._metrics.cleanUpError() })) }, l._getPayload = function (n) { var i = e.browserInfo, o = r._graylog.credentials, a = this._metrics; return Promise.resolve().then((function () { var e = { application_name: "webrtc-client", application_event_id: a.eventId, application_account_id: o.accountId, application_account_key: o.accountKey, message: n.name.replace(/\b\w/g, (function (e) { return e.toLowerCase() })).replace(/([A-Z])/g, "_$1").toUpperCase(), origin: document.location.origin, path_name: document.location.pathname, referrer: document.location.href, search: document.location.search, os: i.os, os_version: i.osVersion, browser: i.browser, browser_version: i.browserVersion, webrtc_client_version: t.webrtc.release_version, server_url: a.session.serverUrl, server_hostname: a.session.hostName, session_id: a.session.sessionId, rtmp_url: a.rtmp.url, rtmp_streamname: a.rtmp.streamname, broadcast_status: a.broadcast.status, broadcast_startup_time: a.broadcast.startupTime, broadcast_total_time: a.broadcast.totalTime, bintu_orga_hash: -1 !== a.rtmp.url.indexOf("bintu") ? a.rtmp.streamname.split("-")[0] : "", video_device: a.devices.videoinput.label || (s(a.devices.videoinput) ? a.devices.videoinput + "" : a.devices.videoinput.label), audio_device: a.devices.audioinput.label || (s(a.devices.audioinput) ? a.devices.audioinput + "" : a.devices.audioinput.label), stats_content_type: a.stats.contentType, stats_audio_codec: a.stats.audioCodec, stats_audio_bitrate: a.stats.audioBitrate, stats_video_codec: a.stats.videoCodec, stats_frame_height: a.stats.frameHeight, stats_frame_width: a.stats.frameWidth, stats_framerate: a.stats.framerate, stats_video_bitrate: a.stats.videoBitrate, stats_nack_count: a.stats.nackCount, stats_frames_encoded: a.stats.framesEncoded, stats_key_frames_encoded: a.stats.keyFramesEncoded, stats_total_encode_time: a.stats.totalEncodeTime, stats_average_encode_time: a.stats.averageEncodeTime, stats_encode_time_percentage: a.stats.encodeTimePercentage, stats_idle_time_percentage: a.stats.idleTimePercentage, stats_fir_count: a.stats.firCount, stats_pli_count: a.stats.pliCount, stats_pli_frequency: a.stats.pliFrequency, stats_resolution_changed: a.stats.resolutionChanged, error_code: a.error.code, error_message: a.error.message }; for (var r in a.customFields) Object.prototype.hasOwnProperty.call(a, r) && (e[r] = "" + a.customFields[r]); return Promise.resolve(e) })).catch((function (e) { return Promise.reject(e) })) }, u }.apply(t, n)) || (e.exports = i) }, function (e, t, r) { var n, i; n = [r(0), r(2), r(3)], void 0 === (i = function (e, t, r) { "use strict"; var n = e.isObject, i = e.isEmpty, o = e.stringifyJSON; return function (e) { if (this.logger = t.create("Metrics", "console"), this.logger.verbose("Metrics(" + o(e) + ")"), this.eventId = "", this.customFields = {}, this.session = {}, this.devices = { videoinput: {}, audioinput: {} }, this.rtmp = { url: "", streamname: "" }, this.broadcast = { status: "", startupTime: void 0, totalTime: void 0 }, this.stats = {}, this.error = {}, n(e) && !i(e)) for (var s in this.eventId = "" + e.eventId, e) if (0 === s.indexOf("customField")) { var a = s.split("customField"); if (!(a.length > 1 && 0 === a[0].length)) { d = r.GeneralError("Custom field property is invalid"); throw this.logger.error(o(d)), d } var c = parseInt(a[1]); if (isNaN(c) || c.toString() != a[1]) { var d = r.GeneralError("Invalid or incorrect custom field index"); throw this.logger.error(o(d)), d } if (c < 1 || c > 10) { var d = r.GeneralError("Custom field index exceeds the range 1 to 10"); throw this.logger.error(o(d)), d } this.customFields["application_custom_field_" + a[1]] = e[s] } this.cleanUpSession = function () { this.session = {} }, this.cleanUpDevices =  this.cleanUpRtmp =  this.cleanUpBroadcast =  this.cleanUpStats = function () { this.stats = {} }, this.cleanUpError = } }.apply(t, n)) || (e.exports = i) },   function (e, t, r) { var n = r(20); e.exports = function (e) { return n(e, 4) } },        function (e, t) { e.exports = function (e) { return this.__data__.get(e) } }, function (e, t) { e.exports = function (e) { return this.__data__.has(e) } },        function (e, t, r) { var n = r(120), i = r(121), o = r(122), s = r(123), a = r(124); function c(e) { var t = -1, r = null == e ? 0 : e.length; for (this.clear(); ++t < r;) { var n = e[t]; this.set(n[0], n[1]) } } c.prototype.clear = n, c.prototype.delete = i, c.prototype.get = o, c.prototype.has = s, c.prototype.set = a, e.exports = c },        function (e, t, r) { var n = r(26); e.exports = function (e) { return n(this, e).get(e) } },     function (e, t, r) { var n = r(17), i = r(13); e.exports = function (e, t) { return e && n(t, i(t), e) } },  function (e, t, r) { var n = r(4), i = r(1); e.exports = function (e) { return i(e) && "[object Arguments]" == n(e) } },        function (e, t, r) { var n = r(17), i = r(39); e.exports = function (e, t) { return n(e, i(e), t) } },   function (e, t, r) { var n = r(67), i = r(64), o = r(29); e.exports = function (e) { return n(e, o, i) } }, function (e, t, r) { var n = r(10)(r(7), "DataView"); e.exports = n }, function (e, t, r) { var n = r(10)(r(7), "Promise"); e.exports = n }, function (e, t, r) { var n = r(10)(r(7), "Set"); e.exports = n },    function (e, t, r) { var n = r(41); e.exports = function (e, t) { var r = t ? n(e.buffer) : e.buffer; return new e.constructor(r, e.byteOffset, e.byteLength) } },      function (e, t, r) { var n = r(11), i = r(1); e.exports = function (e) { return i(e) && "[object Map]" == n(e) } }, function (e, t, r) { var n = r(11), i = r(1); e.exports = function (e) { return i(e) && "[object Set]" == n(e) } },  function (e, t, r) { var n = r(20); e.exports = function (e, t) { return n(e, 5, t = "function" == typeof t ? t : void 0) } },    function (e, t, r) { var n = r(166), i = r(30)(n); e.exports = i },     function (e, t, r) { var n = r(171), i = r(14), o = r(15), s = o && o.isArrayBuffer, a = s ? i(s) : n; e.exports = a }, function (e, t, r) { var n = r(4), i = r(1); e.exports = function (e) { return i(e) && "[object ArrayBuffer]" == n(e) } },   function (e, t, r) { var n = r(175), i = r(14), o = r(15), s = o && o.isDate, a = s ? i(s) : n; e.exports = a }, function (e, t, r) { var n = r(4), i = r(1); e.exports = function (e) { return i(e) && "[object Date]" == n(e) } },                       function (e, t, r) { var n = r(199), i = r(14), o = r(15), s = o && o.isRegExp, a = s ? i(s) : n; e.exports = a }, function (e, t, r) { var n = r(4), i = r(1); e.exports = function (e) { return i(e) && "[object RegExp]" == n(e) } },   function (e, t, r) { var n = r(11), i = r(1); e.exports = function (e) { return i(e) && "[object WeakMap]" == n(e) } },                  function (e, t, r) { var n, i; n = [r(5), r(0), r(2)], void 0 === (i = function (e, t, r) { "use strict"; var n = Math.max, i = Math.sqrt, o = t.stringifyJSON, s = t.isObject, a = t.isFunction; function c() { e.call(this), this._logger = r.create("AudioProcess", "console"), this._logger.verbose("AudioProcess()"); this._bufferSize = 1024, this._numInputChannels = 2, this._numOutputChannels = 2, this._channels = [], this._microphone = null, this._scriptProcessorNode = null, this.active = !1; var t = window.AudioContext || window.webkitAudioContext; a(t) ? this._audioContext = new t : (this._logger.error("AudioProcess(): No browser audio context found"), this._audioContext = null) } var d = c.prototype = Object.create(e.prototype); function u(e, t) { this._logger = r.create("AudioChannel", "console"), this._logger.verbose("AudioChannel(" + o(e) + ", " + t + ")"); e = e || {}, s(t) || this._logger.error("AudioChannel(): Param audioProcess must be of type object", 2), this._audioProcess = t, this._level = 0, this._maxLevel = 0, this._oldLevel = 0, this._id = e.id, this._name = e.name, this._channelData = void 0 } return d.connect = function (e, t) { var r, n; for (this._logger.verbose("connect(" + o(e) + ", " + o(t) + ")"), t = t || { bufferSize: 1024, numInputChannels: 2, numOutputChannels: 2, channels: [{ name: "left", id: 0 }, { name: "right", id: 1 }] }, this._bufferSize = t.bufferSize || 1024, this._numInputChannels = t.numInputChannels || 2, this._numOutputChannels = t.numOutputChannels || 2, this._channels = [], r = 0, n = t.channels.length; r < n; r++)this._channels.push(new u(t.channels[r], this)); if (e) { var i = e.getAudioTracks(); if (i && i.length > 0) { var s = this._scriptProcessorNode = this._audioContext.createScriptProcessor(this._bufferSize, this._numInputChannels, this._numOutputChannels); this._microphone = this._audioContext.createMediaStreamSource(e), this._microphone.connect(s), s.connect(this._audioContext.destination), s.onaudioprocess = this._onAudioProcess.bind(this), this.active = !0 } else this.emitSimple("AudioNoTrack", { stream: e }) } else this.emitSimple("AudioNoStream", { stream: e }) }, d.resume =  d.reset =  d._onAudioProcess = function (e) { if (this.active) { var t, r, n = e.inputBuffer, i = this._channels, o = this; setTimeout((function () { var e = []; for (t = 0, r = i.length; t < r; t++)i[t].update(n.getChannelData(t)), e.push(i[t].getChannelData()); o.emitSimple("AudioProcess", { channels: e }) }), 0) } }, u.prototype.update = function (e) { this._channelData = e; var t, r = 0, o = e.length; for (t = 0; t < o; t++)r += e[t] * e[t]; this._level = i(r / (o || 1)), this._maxLevel = n(this._level, this._maxLevel), this._oldLevel = n(this._level, this._oldLevel - .008) }, u.prototype.getChannelData =  c }.apply(t, n)) || (e.exports = i) }]);