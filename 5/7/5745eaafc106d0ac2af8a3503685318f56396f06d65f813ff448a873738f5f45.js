import{isDirective as u}from"./directive.js";import{removeNodes as i}from"./dom.js";import{noChange as m,nothing as o}from"./part.js";import{TemplateInstance as l}from"./template-instance.js";import{TemplateResult as h}from"./template-result.js";import{createMarker as p}from"./template.js";export const isPrimitive=value=>{return value===null||!(typeof value==="object"||typeof value==="function")};export const isIterable=value=>{return Array.isArray(value)||!!(value&&value[Symbol.iterator])};export class AttributeCommitter{constructor(element,name,t){this.dirty=true;this.element=element;this.name=name;this.strings=t;this.parts=[];for(let i=0;i<t.length-1;i++){this.parts[i]=this._createPart()}}_createPart(){return new AttributePart(this)}_getValue(){const t=this.strings;const i=t.length-1;const o=this.parts;if(i===1&&t[0]===""&&t[1]===""){const l=o[0].value;if(typeof l==="symbol"){return String(l)}if(typeof l==="string"||!isIterable(l)){return l}}let text="";for(let h=0;h<i;h++){text+=t[h];const part=o[h];if(part!==undefined){const l=part.value;if(isPrimitive(l)||!isIterable(l)){text+=typeof l==="string"?l:String(l)}else{for(const u of l){text+=typeof u==="string"?u:String(u)}}}}text+=t[i];return text}commit(){if(this.dirty){this.dirty=false;this.element.setAttribute(this.name,this._getValue())}}}export class AttributePart{etValue(value){if(value!==m&&(!isPrimitive(value)||value!==this.value)){this.value=value;if(!u(value)){this.committer.dirty=true}}}commit(){while(u(this.value)){const t=this.value;this.value=m;t(this)}if(this.value===m){return}this.committer.commit()}}export class NodePart{ppendInto(t){this.startNode=t.appendChild(p());this.endNode=t.appendChild(p())}ppendIntoPart(part){part.__insert(this.startNode=p());part.__insert(this.endNode=p())}insertAfterPart(t){t.__insert(this.startNode=p());this.endNode=t.endNode;t.endNode=this.startNode}setValue(value){this.__pendingValue=value}commit(){if(this.startNode.parentNode===null){return}while(u(this.__pendingValue)){const t=this.__pendingValue;this.__pendingValue=m;t(this)}const value=this.__pendingValue;if(value===m){return}if(isPrimitive(value)){if(value!==this.value){this.__commitText(value)}}else if(value instanceof h){this.__commitTemplateResult(value)}else if(value instanceof Node){this.__commitNode(value)}else if(isIterable(value)){this.__commitIterable(value)}else if(value===o){this.value=o;this.clear()}else{this.__commitText(value)}}_commitNode(value){if(this.value===value){return}this.clear();this.__insert(value);this.value=value}__commitText(value){const node=this.startNode.nextSibling;value=value==null?"":value;const valueAsString=typeof value==="string"?value:String(value);if(node===this.endNode.previousSibling&&node.nodeType===3){node.data=valueAsString}else{this.__commitNode(document.createTextNode(valueAsString))}this.value=value}__commitTemplateResult(value){const t=this.options.templateFactory(value);if(this.value instanceof l&&this.value.template===t){this.value.update(value.values)}else{const i=new l(t,value.processor,this.options);const o=i._clone();i.update(value.values);this.__commitNode(o);this.value=i}}__commitIterable(value){if(!Array.isArray(this.value)){this.value=[];this.clear()}const t=this.value;let i=0;let o;for(const item of value){o=t[i];if(o===undefined){o=new NodePart(this.options);t.push(o);if(i===0){o.appendIntoPart(this)}else{o.insertAfterPart(t[i-1])}}o.setValue(item);o.commit();i++}if(i<t.length){t.length=i;this.clear(o&&o.endNode)}}export class BooleanAttributePart{constructor(element,name,t){this.value=undefined;this.__pendingValue=undefined;if(t.length!==2||t[0]!==""||t[1]!==""){throw new Error("Boolean attributes can only contain a single expression")}this.element=element;this.name=name;this.strings=t}setValue(value){this.__pendingValue=value}commit(){while(u(this.__pendingValue)){const t=this.__pendingValue;this.__pendingValue=m;t(this)}if(this.__pendingValue===m){return}const value=!!this.__pendingValue;if(this.value!==value){if(value){this.element.setAttribute(this.name,"")}else{this.element.removeAttribute(this.name)}this.value=value}this.__pendingValue=m}}export class PropertyCommitter extends AttributeCommitter{constructor(element,name,t){super(element,name,t);this.single=t.length===2&&t[0]===""&&t[1]===""}getValue(){if(this.single){return this.parts[0].value}return super._getValue()}commit(){if(this.dirty){this.dirty=false;this.element[this.name]=this._getValue()}}}export et _=false;(()=>{try{const options={get capture;window.addEventListener("test",options,options);window.removeEventListener("test",options,options)}catch(t){}})();export class EventPart{constructor(element,t,i){this.value=undefined;this.__pendingValue=undefined;this.element=element;this.eventName=t;this.eventContext=i;this.__boundHandleEvent=ommit(){while(u(this.__pendingValue)){const h=this.__pendingValue;this.__pendingValue=m;h(this)}if(this.__pendingValue===m){return}const t=this.__pendingValue;const i=this.value;const o=t==null||i!=null&&(t.capture!==i.capture||t.once!==i.once||t.passive!==i.passive);const l=t!=null&&(i==null||o);if(o){this.element.removeEventListener(this.eventName,this.__boundHandleEvent,this.__options)}if(l){this.__options=v(t);this.element.addEventListener(this.eventName,this.__boundHandleEvent,this.__options)}this.value=t;this.__pendingValue=m}handleEvent(event){if(typeof this.value==="function"){this.value.call(this.eventContext||this.element,event)}else{this.value.handleEvent(event)}}}const v=