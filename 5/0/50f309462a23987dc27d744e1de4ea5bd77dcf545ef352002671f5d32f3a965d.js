export const marker=`{{lit-${String(Math.random()).slice(2)}}}`;export const nodeMarker=`<!--${marker}-->`;export const markerRegex=new RegExp(`${marker}|${nodeMarker}`);export const boundAttributeSuffix="$lit$";export class Template{constructor(result,element){this.parts=[];this.element=element;const t=[];const stack=[];const o=document.createTreeWalker(element.content,133,null,false);let i=0;let index=-1;let l=0;const{strings:u,values:{length}}=result;while(l<length){const node=o.nextNode();if(node===null){o.currentNode=stack.pop();continue}index++;if(node.nodeType===1){if(node.hasAttributes()){const attributes=node.attributes;const{length}=attributes;let count=0;for(let t=0;t<length;t++){if(endsWith(attributes[t].name,boundAttributeSuffix)){count++}}while(count-- >0){const p=u[l];const name=lastAttributeNameRegex.exec(p)[2];const h=name.toLowerCase()+boundAttributeSuffix;const m=node.getAttribute(h);node.removeAttribute(h);const g=m.split(markerRegex);this.parts.push({type:"attribute",index:index,name:name,strings:g});l+=g.length-1}}if(node.tagName==="TEMPLATE"){stack.push(node);o.currentNode=node.content}}else if(node.nodeType===3){const data=node.data;if(data.indexOf(marker)>=0){const parent=node.parentNode;const u=data.split(markerRegex);const lastIndex=u.length-1;for(let o=0;o<lastIndex;o++){let t;let s=u[o];if(s===""){t=createMarker()}else{const match=lastAttributeNameRegex.exec(s);if(match!==null&&endsWith(match[2],boundAttributeSuffix)){s=s.slice(0,match.index)+match[1]+match[2].slice(0,-boundAttributeSuffix.length)+match[3]}t=document.createTextNode(s)}parent.insertBefore(t,node);this.parts.push({type:"node",index:++index})}if(u[lastIndex]===""){parent.insertBefore(createMarker(),node);t.push(node)}else{node.data=u[lastIndex]}l+=lastIndex}}else if(node.nodeType===8){if(node.data===marker){const parent=node.parentNode;if(node.previousSibling===null||index===i){index++;parent.insertBefore(createMarker(),node)}i=index;this.parts.push({type:"node",index:index});if(node.nextSibling===null){node.data=""}else{t.push(node);index--}l++}else{let t=-1;while((t=node.data.indexOf(marker,t+1))!==-1){this.parts.push({type:"node",index:-1});l++}}}}for(const n of t){n.parentNode.removeChild(n)}}}const endsWith=export const isTemplatePartActive=part=>part.index!==-1;export const createMarker=export const lastAttributeNameRegex=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F "'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;