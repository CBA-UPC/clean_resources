this.workbox=this.workbox||{},this.workbox.backgroundSync=function(t,e,s,n){"use strict";et a,i;const c=new WeakMap,o=new WeakMap,u=new WeakMap,h=new WeakMap,y=new WeakMap;let w={getset:has:;st m=const p=["get","getKey","getAll","getAllKeys","count"],g=["put","add","delete","clear"],D=new Map;=((w);try{self["workbox:background-sync:6.5.0"]&&_()}catch(t){}const B="requests",I="queueName";class q{sync addEntry(t){const e=(await this.getDb()).transaction(B,"readwrite",{durability:"relaxed"});await e.store.add(t),await e.done}async getFirstEntryId(){const t=await this.getDb(),e=await t.transaction(B).store.openCursor();return null==e?void 0:e.value.id}async getAllEntriesByQueueName(t){const e=await this.getDb(),s=await e.getAllFromIndex(B,I,IDBKeyRange.only(t));return s||new Array}async getEntryCountByQueueName(t){return(await this.getDb()).countFromIndex(B,I,IDBKeyRange.only(t))}async deleteEntry(t){const e=await this.getDb();await e.delete(B,t)}async getFirstEntryByQueueName(t){return await this.getEndEntryFromIndex(IDBKeyRange.only(t),"next")}sync getEndEntryFromIndex(t,e){const s=await this.getDb(),n=await s.transaction(B).store.index(I).openCursor(t,e);return null==n?void 0:n.value}(t,e){e>0&&e<3&&t.objectStoreNames.contains(B)&&t.deleteObjectStore(B);t.createObjectStore(B,{autoIncrement:!0,keyPath:"id"}).createIndex(I,I,{unique:!1})}}onst E=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];onst x="workbox-background-sync",v=new Set,j=class S{constructor(t,{forceSyncFallback:s,onSync:n,maxRetentionTime:r}={}){if(this.m=!1,this.p=!1,v.has(t))throw new e.WorkboxError("duplicate-queue-name",{name:t});v.add(t),this.g=t,this.D=n||this.replayRequests,this.B=r||10080,this.I=Boolean(s),this.q=new k(this.g),this.k()}sync pushRequest(t){await this.R(t,"push")}sync popRequest(){return this.v("pop")}nc R({request:t,metadata:e,timestamp:s=Date.now()},n){const r={requestData:(await R.fromRequest(t.clone())).toObject(),timestamp:s};switch(e&&(r.metadata=e),n){case"push":await this.q.pushEntry(r);break;case"unshift":await this.q.unshiftEntry(r)}this.m?this.p=!0:await this.registerSync()}async v(t){const e=Date.now();let s;switch(t){case"pop":s=await this.q.popEntry();break;case"shift":s=await this.q.shiftEntry()}if(s){const n=60*this.B*1e3;return e-s.timestamp>n?this.v(t):j(s)}}sync registerSync(){if("sync"in self.registration&&!this.I)try{await self.registration.sync.register(`${x}:${this.g}`)}catch(t){}}k(){"sync"in self.registration&&!this.I?self.addEventListener("sync",(t=>{if(t.tag===`${x}:${this.g}`){const e=t.waitUntil(e())}})):this.D({queue:this})}return t.BackgroundSyncPlugin=t.Queue=S,t.QueueStore=k,t.StorableRequest=R,t}({},workbox.core._private,workbox.core._private,workbox.core._private);
//# sourceMappingURL=workbox-background-sync.prod.js.map
